/*!
 * 
 *   red5pro-sdk - Red5 Pro HTML Publisher and Subscriber SDK.
 *   Author: Infrared5 Inc.
 *   Version: 3.1.1
 *   Url: https://github.com/red5pro/red5pro-html-sdk#readme
 *   License(s): MIT
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["red5prosdk"] = factory();
	else
		root["red5prosdk"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(298);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	__webpack_require__(2);
	
	__webpack_require__(293);
	
	__webpack_require__(295);
	
	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	global._babelPolyfill = true;
	
	var DEFINE_PROPERTY = "defineProperty";
	function define(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}
	
	define(String.prototype, "padLeft", "".padStart);
	define(String.prototype, "padRight", "".padEnd);
	
	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define(Array, key, Function.call.bind([][key]));
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(3);
	__webpack_require__(52);
	__webpack_require__(53);
	__webpack_require__(54);
	__webpack_require__(55);
	__webpack_require__(57);
	__webpack_require__(60);
	__webpack_require__(61);
	__webpack_require__(62);
	__webpack_require__(63);
	__webpack_require__(64);
	__webpack_require__(65);
	__webpack_require__(66);
	__webpack_require__(67);
	__webpack_require__(68);
	__webpack_require__(70);
	__webpack_require__(72);
	__webpack_require__(74);
	__webpack_require__(76);
	__webpack_require__(79);
	__webpack_require__(80);
	__webpack_require__(81);
	__webpack_require__(85);
	__webpack_require__(87);
	__webpack_require__(89);
	__webpack_require__(92);
	__webpack_require__(93);
	__webpack_require__(94);
	__webpack_require__(95);
	__webpack_require__(97);
	__webpack_require__(98);
	__webpack_require__(99);
	__webpack_require__(100);
	__webpack_require__(101);
	__webpack_require__(102);
	__webpack_require__(103);
	__webpack_require__(105);
	__webpack_require__(106);
	__webpack_require__(107);
	__webpack_require__(109);
	__webpack_require__(110);
	__webpack_require__(111);
	__webpack_require__(113);
	__webpack_require__(114);
	__webpack_require__(115);
	__webpack_require__(116);
	__webpack_require__(117);
	__webpack_require__(118);
	__webpack_require__(119);
	__webpack_require__(120);
	__webpack_require__(121);
	__webpack_require__(122);
	__webpack_require__(123);
	__webpack_require__(124);
	__webpack_require__(125);
	__webpack_require__(126);
	__webpack_require__(131);
	__webpack_require__(132);
	__webpack_require__(136);
	__webpack_require__(137);
	__webpack_require__(138);
	__webpack_require__(139);
	__webpack_require__(141);
	__webpack_require__(142);
	__webpack_require__(143);
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(146);
	__webpack_require__(147);
	__webpack_require__(148);
	__webpack_require__(149);
	__webpack_require__(150);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(153);
	__webpack_require__(154);
	__webpack_require__(155);
	__webpack_require__(156);
	__webpack_require__(157);
	__webpack_require__(159);
	__webpack_require__(160);
	__webpack_require__(166);
	__webpack_require__(167);
	__webpack_require__(169);
	__webpack_require__(170);
	__webpack_require__(171);
	__webpack_require__(175);
	__webpack_require__(176);
	__webpack_require__(177);
	__webpack_require__(178);
	__webpack_require__(179);
	__webpack_require__(181);
	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(184);
	__webpack_require__(187);
	__webpack_require__(189);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(193);
	__webpack_require__(195);
	__webpack_require__(197);
	__webpack_require__(198);
	__webpack_require__(199);
	__webpack_require__(201);
	__webpack_require__(202);
	__webpack_require__(203);
	__webpack_require__(204);
	__webpack_require__(211);
	__webpack_require__(214);
	__webpack_require__(215);
	__webpack_require__(217);
	__webpack_require__(218);
	__webpack_require__(221);
	__webpack_require__(222);
	__webpack_require__(224);
	__webpack_require__(225);
	__webpack_require__(226);
	__webpack_require__(227);
	__webpack_require__(228);
	__webpack_require__(229);
	__webpack_require__(230);
	__webpack_require__(231);
	__webpack_require__(232);
	__webpack_require__(233);
	__webpack_require__(234);
	__webpack_require__(235);
	__webpack_require__(236);
	__webpack_require__(237);
	__webpack_require__(238);
	__webpack_require__(239);
	__webpack_require__(240);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(244);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(247);
	__webpack_require__(248);
	__webpack_require__(249);
	__webpack_require__(251);
	__webpack_require__(252);
	__webpack_require__(253);
	__webpack_require__(254);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(257);
	__webpack_require__(258);
	__webpack_require__(260);
	__webpack_require__(261);
	__webpack_require__(263);
	__webpack_require__(264);
	__webpack_require__(265);
	__webpack_require__(266);
	__webpack_require__(269);
	__webpack_require__(270);
	__webpack_require__(271);
	__webpack_require__(272);
	__webpack_require__(273);
	__webpack_require__(274);
	__webpack_require__(275);
	__webpack_require__(276);
	__webpack_require__(278);
	__webpack_require__(279);
	__webpack_require__(280);
	__webpack_require__(281);
	__webpack_require__(282);
	__webpack_require__(283);
	__webpack_require__(284);
	__webpack_require__(285);
	__webpack_require__(286);
	__webpack_require__(287);
	__webpack_require__(288);
	__webpack_require__(291);
	__webpack_require__(292);
	module.exports = __webpack_require__(9);

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(4)
	  , has            = __webpack_require__(5)
	  , DESCRIPTORS    = __webpack_require__(6)
	  , $export        = __webpack_require__(8)
	  , redefine       = __webpack_require__(18)
	  , META           = __webpack_require__(22).KEY
	  , $fails         = __webpack_require__(7)
	  , shared         = __webpack_require__(23)
	  , setToStringTag = __webpack_require__(24)
	  , uid            = __webpack_require__(19)
	  , wks            = __webpack_require__(25)
	  , wksExt         = __webpack_require__(26)
	  , wksDefine      = __webpack_require__(27)
	  , keyOf          = __webpack_require__(29)
	  , enumKeys       = __webpack_require__(42)
	  , isArray        = __webpack_require__(45)
	  , anObject       = __webpack_require__(12)
	  , toIObject      = __webpack_require__(32)
	  , toPrimitive    = __webpack_require__(16)
	  , createDesc     = __webpack_require__(17)
	  , _create        = __webpack_require__(46)
	  , gOPNExt        = __webpack_require__(49)
	  , $GOPD          = __webpack_require__(51)
	  , $DP            = __webpack_require__(11)
	  , $keys          = __webpack_require__(30)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(50).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(44).f  = $propertyIsEnumerable;
	  __webpack_require__(43).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(28)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(10)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 4 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 5 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(7)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , core      = __webpack_require__(9)
	  , hide      = __webpack_require__(10)
	  , redefine  = __webpack_require__(18)
	  , ctx       = __webpack_require__(20)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target)redefine(target, key, out, type & $export.U);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 9 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(11)
	  , createDesc = __webpack_require__(17);
	module.exports = __webpack_require__(6) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(12)
	  , IE8_DOM_DEFINE = __webpack_require__(14)
	  , toPrimitive    = __webpack_require__(16)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(6) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(6) && !__webpack_require__(7)(function(){
	  return Object.defineProperty(__webpack_require__(15)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13)
	  , document = __webpack_require__(4).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(13);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , hide      = __webpack_require__(10)
	  , has       = __webpack_require__(5)
	  , SRC       = __webpack_require__(19)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);
	
	__webpack_require__(9).inspectSource = function(it){
	  return $toString.call(it);
	};
	
	(module.exports = function(O, key, val, safe){
	  var isFunction = typeof val == 'function';
	  if(isFunction)has(val, 'name') || hide(val, 'name', key);
	  if(O[key] === val)return;
	  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe){
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if(O[key])O[key] = val;
	      else hide(O, key, val);
	    }
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 19 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(21);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(19)('meta')
	  , isObject = __webpack_require__(13)
	  , has      = __webpack_require__(5)
	  , setDesc  = __webpack_require__(11).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(7)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(11).f
	  , has = __webpack_require__(5)
	  , TAG = __webpack_require__(25)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(23)('wks')
	  , uid        = __webpack_require__(19)
	  , Symbol     = __webpack_require__(4).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(25);

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(4)
	  , core           = __webpack_require__(9)
	  , LIBRARY        = __webpack_require__(28)
	  , wksExt         = __webpack_require__(26)
	  , defineProperty = __webpack_require__(11).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(30)
	  , toIObject = __webpack_require__(32);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(31)
	  , enumBugKeys = __webpack_require__(41);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(5)
	  , toIObject    = __webpack_require__(32)
	  , arrayIndexOf = __webpack_require__(36)(false)
	  , IE_PROTO     = __webpack_require__(40)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(33)
	  , defined = __webpack_require__(35);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(34);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 34 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(32)
	  , toLength  = __webpack_require__(37)
	  , toIndex   = __webpack_require__(39);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(38)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 38 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(38)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(23)('keys')
	  , uid    = __webpack_require__(19);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(30)
	  , gOPS    = __webpack_require__(43)
	  , pIE     = __webpack_require__(44);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 44 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(34);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(12)
	  , dPs         = __webpack_require__(47)
	  , enumBugKeys = __webpack_require__(41)
	  , IE_PROTO    = __webpack_require__(40)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(15)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(48).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(11)
	  , anObject = __webpack_require__(12)
	  , getKeys  = __webpack_require__(30);
	
	module.exports = __webpack_require__(6) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(4).document && document.documentElement;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(32)
	  , gOPN      = __webpack_require__(50).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(31)
	  , hiddenKeys = __webpack_require__(41).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(44)
	  , createDesc     = __webpack_require__(17)
	  , toIObject      = __webpack_require__(32)
	  , toPrimitive    = __webpack_require__(16)
	  , has            = __webpack_require__(5)
	  , IE8_DOM_DEFINE = __webpack_require__(14)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(6) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(46)});

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(6), 'Object', {defineProperty: __webpack_require__(11).f});

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(6), 'Object', {defineProperties: __webpack_require__(47)});

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(32)
	  , $getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	__webpack_require__(56)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(8)
	  , core    = __webpack_require__(9)
	  , fails   = __webpack_require__(7);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(58)
	  , $getPrototypeOf = __webpack_require__(59);
	
	__webpack_require__(56)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(35);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(5)
	  , toObject    = __webpack_require__(58)
	  , IE_PROTO    = __webpack_require__(40)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(58)
	  , $keys    = __webpack_require__(30);
	
	__webpack_require__(56)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(56)('getOwnPropertyNames', function(){
	  return __webpack_require__(49).f;
	});

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('preventExtensions', function($preventExtensions){
	  return function preventExtensions(it){
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isFrozen', function($isFrozen){
	  return function isFrozen(it){
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isSealed', function($isSealed){
	  return function isSealed(it){
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isExtensible', function($isExtensible){
	  return function isExtensible(it){
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(8);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(69)});

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(30)
	  , gOPS     = __webpack_require__(43)
	  , pIE      = __webpack_require__(44)
	  , toObject = __webpack_require__(58)
	  , IObject  = __webpack_require__(33)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(7)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(8);
	$export($export.S, 'Object', {is: __webpack_require__(71)});

/***/ },
/* 71 */
/***/ function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(8);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(73).set});

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(13)
	  , anObject = __webpack_require__(12);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(20)(Function.call, __webpack_require__(51).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(75)
	  , test    = {};
	test[__webpack_require__(25)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(18)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(34)
	  , TAG = __webpack_require__(25)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Function', {bind: __webpack_require__(77)});

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var aFunction  = __webpack_require__(21)
	  , isObject   = __webpack_require__(13)
	  , invoke     = __webpack_require__(78)
	  , arraySlice = [].slice
	  , factories  = {};
	
	var construct = function(F, len, args){
	  if(!(len in factories)){
	    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};
	
	module.exports = Function.bind || function bind(that /*, args... */){
	  var fn       = aFunction(this)
	    , partArgs = arraySlice.call(arguments, 1);
	  var bound = function(/* args... */){
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if(isObject(fn.prototype))bound.prototype = fn.prototype;
	  return bound;
	};

/***/ },
/* 78 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(11).f
	  , createDesc = __webpack_require__(17)
	  , has        = __webpack_require__(5)
	  , FProto     = Function.prototype
	  , nameRE     = /^\s*function ([^ (]*)/
	  , NAME       = 'name';
	
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	
	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(6) && dP(FProto, NAME, {
	  configurable: true,
	  get: function(){
	    try {
	      var that = this
	        , name = ('' + that).match(nameRE)[1];
	      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
	      return name;
	    } catch(e){
	      return '';
	    }
	  }
	});

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isObject       = __webpack_require__(13)
	  , getPrototypeOf = __webpack_require__(59)
	  , HAS_INSTANCE   = __webpack_require__(25)('hasInstance')
	  , FunctionProto  = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if(!(HAS_INSTANCE in FunctionProto))__webpack_require__(11).f(FunctionProto, HAS_INSTANCE, {value: function(O){
	  if(typeof this != 'function' || !isObject(O))return false;
	  if(!isObject(this.prototype))return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
	  return false;
	}});

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , $parseInt = __webpack_require__(82);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var $parseInt = __webpack_require__(4).parseInt
	  , $trim     = __webpack_require__(83).trim
	  , ws        = __webpack_require__(84)
	  , hex       = /^[\-+]?0[xX]/;
	
	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , defined = __webpack_require__(35)
	  , fails   = __webpack_require__(7)
	  , spaces  = __webpack_require__(84)
	  , space   = '[' + spaces + ']'
	  , non     = '\u200b\u0085'
	  , ltrim   = RegExp('^' + space + space + '*')
	  , rtrim   = RegExp(space + space + '*$');
	
	var exporter = function(KEY, exec, ALIAS){
	  var exp   = {};
	  var FORCE = fails(function(){
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if(ALIAS)exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};
	
	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function(string, TYPE){
	  string = String(defined(string));
	  if(TYPE & 1)string = string.replace(ltrim, '');
	  if(TYPE & 2)string = string.replace(rtrim, '');
	  return string;
	};
	
	module.exports = exporter;

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(8)
	  , $parseFloat = __webpack_require__(86);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var $parseFloat = __webpack_require__(4).parseFloat
	  , $trim       = __webpack_require__(83).trim;
	
	module.exports = 1 / $parseFloat(__webpack_require__(84) + '-0') !== -Infinity ? function parseFloat(str){
	  var string = $trim(String(str), 3)
	    , result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(4)
	  , has               = __webpack_require__(5)
	  , cof               = __webpack_require__(34)
	  , inheritIfRequired = __webpack_require__(88)
	  , toPrimitive       = __webpack_require__(16)
	  , fails             = __webpack_require__(7)
	  , gOPN              = __webpack_require__(50).f
	  , gOPD              = __webpack_require__(51).f
	  , dP                = __webpack_require__(11).f
	  , $trim             = __webpack_require__(83).trim
	  , NUMBER            = 'Number'
	  , $Number           = global[NUMBER]
	  , Base              = $Number
	  , proto             = $Number.prototype
	  // Opera ~12 has broken Object#toString
	  , BROKEN_COF        = cof(__webpack_require__(46)(proto)) == NUMBER
	  , TRIM              = 'trim' in String.prototype;
	
	// 7.1.3 ToNumber(argument)
	var toNumber = function(argument){
	  var it = toPrimitive(argument, false);
	  if(typeof it == 'string' && it.length > 2){
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0)
	      , third, radix, maxCode;
	    if(first === 43 || first === 45){
	      third = it.charCodeAt(2);
	      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if(first === 48){
	      switch(it.charCodeAt(1)){
	        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default : return +it;
	      }
	      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if(code < 48 || code > maxCode)return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};
	
	if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
	  $Number = function Number(value){
	    var it = arguments.length < 1 ? 0 : value
	      , that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for(var keys = __webpack_require__(6) ? gOPN(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys.length > j; j++){
	    if(has(Base, key = keys[j]) && !has($Number, key)){
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(18)(global, NUMBER, $Number);
	}

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var isObject       = __webpack_require__(13)
	  , setPrototypeOf = __webpack_require__(73).set;
	module.exports = function(that, target, C){
	  var P, S = target.constructor;
	  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
	    setPrototypeOf(that, P);
	  } return that;
	};

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , toInteger    = __webpack_require__(38)
	  , aNumberValue = __webpack_require__(90)
	  , repeat       = __webpack_require__(91)
	  , $toFixed     = 1..toFixed
	  , floor        = Math.floor
	  , data         = [0, 0, 0, 0, 0, 0]
	  , ERROR        = 'Number.toFixed: incorrect invocation!'
	  , ZERO         = '0';
	
	var multiply = function(n, c){
	  var i  = -1
	    , c2 = c;
	  while(++i < 6){
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function(n){
	  var i = 6
	    , c = 0;
	  while(--i >= 0){
	    c += data[i];
	    data[i] = floor(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function(){
	  var i = 6
	    , s = '';
	  while(--i >= 0){
	    if(s !== '' || i === 0 || data[i] !== 0){
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function(x, n, acc){
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function(x){
	  var n  = 0
	    , x2 = x;
	  while(x2 >= 4096){
	    n += 12;
	    x2 /= 4096;
	  }
	  while(x2 >= 2){
	    n  += 1;
	    x2 /= 2;
	  } return n;
	};
	
	$export($export.P + $export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128..toFixed(0) !== '1000000000000000128'
	) || !__webpack_require__(7)(function(){
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits){
	    var x = aNumberValue(this, ERROR)
	      , f = toInteger(fractionDigits)
	      , s = ''
	      , m = ZERO
	      , e, z, j, k;
	    if(f < 0 || f > 20)throw RangeError(ERROR);
	    if(x != x)return 'NaN';
	    if(x <= -1e21 || x >= 1e21)return String(x);
	    if(x < 0){
	      s = '-';
	      x = -x;
	    }
	    if(x > 1e-21){
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if(e > 0){
	        multiply(0, z);
	        j = f;
	        while(j >= 7){
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while(j >= 23){
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if(f > 0){
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var cof = __webpack_require__(34);
	module.exports = function(it, msg){
	  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
	  return +it;
	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(38)
	  , defined   = __webpack_require__(35);
	
	module.exports = function repeat(count){
	  var str = String(defined(this))
	    , res = ''
	    , n   = toInteger(count);
	  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
	  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
	  return res;
	};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , $fails       = __webpack_require__(7)
	  , aNumberValue = __webpack_require__(90)
	  , $toPrecision = 1..toPrecision;
	
	$export($export.P + $export.F * ($fails(function(){
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function(){
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision){
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
	  }
	});

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export   = __webpack_require__(8)
	  , _isFinite = __webpack_require__(4).isFinite;
	
	$export($export.S, 'Number', {
	  isFinite: function isFinite(it){
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {isInteger: __webpack_require__(96)});

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(13)
	  , floor    = Math.floor;
	module.exports = function isInteger(it){
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {
	  isNaN: function isNaN(number){
	    return number != number;
	  }
	});

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export   = __webpack_require__(8)
	  , isInteger = __webpack_require__(96)
	  , abs       = Math.abs;
	
	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number){
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(8)
	  , $parseFloat = __webpack_require__(86);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , $parseInt = __webpack_require__(82);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(8)
	  , log1p   = __webpack_require__(104)
	  , sqrt    = Math.sqrt
	  , $acosh  = Math.acosh;
	
	$export($export.S + $export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x){
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

/***/ },
/* 104 */
/***/ function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x){
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(8)
	  , $asinh  = Math.asinh;
	
	function asinh(x){
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}
	
	// Tor Browser bug: Math.asinh(0) -> -0 
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(8)
	  , $atanh  = Math.atanh;
	
	// Tor Browser bug: Math.atanh(-0) -> 0 
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x){
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(8)
	  , sign    = __webpack_require__(108);
	
	$export($export.S, 'Math', {
	  cbrt: function cbrt(x){
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

/***/ },
/* 108 */
/***/ function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x){
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  clz32: function clz32(x){
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(8)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  cosh: function cosh(x){
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(8)
	  , $expm1  = __webpack_require__(112);
	
	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});

/***/ },
/* 112 */
/***/ function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x){
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export   = __webpack_require__(8)
	  , sign      = __webpack_require__(108)
	  , pow       = Math.pow
	  , EPSILON   = pow(2, -52)
	  , EPSILON32 = pow(2, -23)
	  , MAX32     = pow(2, 127) * (2 - EPSILON32)
	  , MIN32     = pow(2, -126);
	
	var roundTiesToEven = function(n){
	  return n + 1 / EPSILON - 1 / EPSILON;
	};
	
	
	$export($export.S, 'Math', {
	  fround: function fround(x){
	    var $abs  = Math.abs(x)
	      , $sign = sign(x)
	      , a, result;
	    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	    a = (1 + EPSILON32 / EPSILON) * $abs;
	    result = a - (a - $abs);
	    if(result > MAX32 || result != result)return $sign * Infinity;
	    return $sign * result;
	  }
	});

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
	var $export = __webpack_require__(8)
	  , abs     = Math.abs;
	
	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
	    var sum  = 0
	      , i    = 0
	      , aLen = arguments.length
	      , larg = 0
	      , arg, div;
	    while(i < aLen){
	      arg = abs(arguments[i++]);
	      if(larg < arg){
	        div  = larg / arg;
	        sum  = sum * div * div + 1;
	        larg = arg;
	      } else if(arg > 0){
	        div  = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(8)
	  , $imul   = Math.imul;
	
	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y){
	    var UINT16 = 0xffff
	      , xn = +x
	      , yn = +y
	      , xl = UINT16 & xn
	      , yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  log10: function log10(x){
	    return Math.log(x) / Math.LN10;
	  }
	});

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {log1p: __webpack_require__(104)});

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  log2: function log2(x){
	    return Math.log(x) / Math.LN2;
	  }
	});

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {sign: __webpack_require__(108)});

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(8)
	  , expm1   = __webpack_require__(112)
	  , exp     = Math.exp;
	
	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x){
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(8)
	  , expm1   = __webpack_require__(112)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  tanh: function tanh(x){
	    var a = expm1(x = +x)
	      , b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  trunc: function trunc(it){
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var $export        = __webpack_require__(8)
	  , toIndex        = __webpack_require__(39)
	  , fromCharCode   = String.fromCharCode
	  , $fromCodePoint = String.fromCodePoint;
	
	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
	    var res  = []
	      , aLen = arguments.length
	      , i    = 0
	      , code;
	    while(aLen > i){
	      code = +arguments[i++];
	      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , toIObject = __webpack_require__(32)
	  , toLength  = __webpack_require__(37);
	
	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite){
	    var tpl  = toIObject(callSite.raw)
	      , len  = toLength(tpl.length)
	      , aLen = arguments.length
	      , res  = []
	      , i    = 0;
	    while(len > i){
	      res.push(String(tpl[i++]));
	      if(i < aLen)res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(83)('trim', function($trim){
	  return function trim(){
	    return $trim(this, 3);
	  };
	});

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(127)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(128)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(38)
	  , defined   = __webpack_require__(35);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(28)
	  , $export        = __webpack_require__(8)
	  , redefine       = __webpack_require__(18)
	  , hide           = __webpack_require__(10)
	  , has            = __webpack_require__(5)
	  , Iterators      = __webpack_require__(129)
	  , $iterCreate    = __webpack_require__(130)
	  , setToStringTag = __webpack_require__(24)
	  , getPrototypeOf = __webpack_require__(59)
	  , ITERATOR       = __webpack_require__(25)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 129 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(46)
	  , descriptor     = __webpack_require__(17)
	  , setToStringTag = __webpack_require__(24)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(10)(IteratorPrototype, __webpack_require__(25)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $at     = __webpack_require__(127)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $export   = __webpack_require__(8)
	  , toLength  = __webpack_require__(37)
	  , context   = __webpack_require__(133)
	  , ENDS_WITH = 'endsWith'
	  , $endsWith = ''[ENDS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(135)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /*, endPosition = @length */){
	    var that = context(this, searchString, ENDS_WITH)
	      , endPosition = arguments.length > 1 ? arguments[1] : undefined
	      , len    = toLength(that.length)
	      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
	      , search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(134)
	  , defined  = __webpack_require__(35);
	
	module.exports = function(that, searchString, NAME){
	  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(13)
	  , cof      = __webpack_require__(34)
	  , MATCH    = __webpack_require__(25)('match');
	module.exports = function(it){
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(25)('match');
	module.exports = function(KEY){
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch(e){
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch(f){ /* empty */ }
	  } return true;
	};

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $export  = __webpack_require__(8)
	  , context  = __webpack_require__(133)
	  , INCLUDES = 'includes';
	
	$export($export.P + $export.F * __webpack_require__(135)(INCLUDES), 'String', {
	  includes: function includes(searchString /*, position = 0 */){
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	
	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(91)
	});

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $export     = __webpack_require__(8)
	  , toLength    = __webpack_require__(37)
	  , context     = __webpack_require__(133)
	  , STARTS_WITH = 'startsWith'
	  , $startsWith = ''[STARTS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(135)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /*, position = 0 */){
	    var that   = context(this, searchString, STARTS_WITH)
	      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
	      , search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.2 String.prototype.anchor(name)
	__webpack_require__(140)('anchor', function(createHTML){
	  return function anchor(name){
	    return createHTML(this, 'a', 'name', name);
	  }
	});

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , fails   = __webpack_require__(7)
	  , defined = __webpack_require__(35)
	  , quot    = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function(string, tag, attribute, value) {
	  var S  = String(defined(string))
	    , p1 = '<' + tag;
	  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function(NAME, exec){
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function(){
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.3 String.prototype.big()
	__webpack_require__(140)('big', function(createHTML){
	  return function big(){
	    return createHTML(this, 'big', '', '');
	  }
	});

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.4 String.prototype.blink()
	__webpack_require__(140)('blink', function(createHTML){
	  return function blink(){
	    return createHTML(this, 'blink', '', '');
	  }
	});

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.5 String.prototype.bold()
	__webpack_require__(140)('bold', function(createHTML){
	  return function bold(){
	    return createHTML(this, 'b', '', '');
	  }
	});

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.6 String.prototype.fixed()
	__webpack_require__(140)('fixed', function(createHTML){
	  return function fixed(){
	    return createHTML(this, 'tt', '', '');
	  }
	});

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.7 String.prototype.fontcolor(color)
	__webpack_require__(140)('fontcolor', function(createHTML){
	  return function fontcolor(color){
	    return createHTML(this, 'font', 'color', color);
	  }
	});

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.8 String.prototype.fontsize(size)
	__webpack_require__(140)('fontsize', function(createHTML){
	  return function fontsize(size){
	    return createHTML(this, 'font', 'size', size);
	  }
	});

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.9 String.prototype.italics()
	__webpack_require__(140)('italics', function(createHTML){
	  return function italics(){
	    return createHTML(this, 'i', '', '');
	  }
	});

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.10 String.prototype.link(url)
	__webpack_require__(140)('link', function(createHTML){
	  return function link(url){
	    return createHTML(this, 'a', 'href', url);
	  }
	});

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.11 String.prototype.small()
	__webpack_require__(140)('small', function(createHTML){
	  return function small(){
	    return createHTML(this, 'small', '', '');
	  }
	});

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.12 String.prototype.strike()
	__webpack_require__(140)('strike', function(createHTML){
	  return function strike(){
	    return createHTML(this, 'strike', '', '');
	  }
	});

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.13 String.prototype.sub()
	__webpack_require__(140)('sub', function(createHTML){
	  return function sub(){
	    return createHTML(this, 'sub', '', '');
	  }
	});

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.14 String.prototype.sup()
	__webpack_require__(140)('sup', function(createHTML){
	  return function sup(){
	    return createHTML(this, 'sup', '', '');
	  }
	});

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);
	
	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var $export = __webpack_require__(8)
	  , fails   = __webpack_require__(7)
	  , getTime = Date.prototype.getTime;
	
	var lz = function(num){
	  return num > 9 ? num : '0' + num;
	};
	
	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (fails(function(){
	  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
	}) || !fails(function(){
	  new Date(NaN).toISOString();
	})), 'Date', {
	  toISOString: function toISOString(){
	    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
	    var d = this
	      , y = d.getUTCFullYear()
	      , m = d.getUTCMilliseconds()
	      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
	    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	  }
	});

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var DateProto    = Date.prototype
	  , INVALID_DATE = 'Invalid Date'
	  , TO_STRING    = 'toString'
	  , $toString    = DateProto[TO_STRING]
	  , getTime      = DateProto.getTime;
	if(new Date(NaN) + '' != INVALID_DATE){
	  __webpack_require__(18)(DateProto, TO_STRING, function toString(){
	    var value = getTime.call(this);
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var TO_PRIMITIVE = __webpack_require__(25)('toPrimitive')
	  , proto        = Date.prototype;
	
	if(!(TO_PRIMITIVE in proto))__webpack_require__(10)(proto, TO_PRIMITIVE, __webpack_require__(158));

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var anObject    = __webpack_require__(12)
	  , toPrimitive = __webpack_require__(16)
	  , NUMBER      = 'number';
	
	module.exports = function(hint){
	  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Array', {isArray: __webpack_require__(45)});

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(20)
	  , $export        = __webpack_require__(8)
	  , toObject       = __webpack_require__(58)
	  , call           = __webpack_require__(161)
	  , isArrayIter    = __webpack_require__(162)
	  , toLength       = __webpack_require__(37)
	  , createProperty = __webpack_require__(163)
	  , getIterFn      = __webpack_require__(164);
	
	$export($export.S + $export.F * !__webpack_require__(165)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(12);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(129)
	  , ITERATOR   = __webpack_require__(25)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(11)
	  , createDesc      = __webpack_require__(17);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(75)
	  , ITERATOR  = __webpack_require__(25)('iterator')
	  , Iterators = __webpack_require__(129);
	module.exports = __webpack_require__(9).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(25)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export        = __webpack_require__(8)
	  , createProperty = __webpack_require__(163);
	
	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  function F(){}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */){
	    var index  = 0
	      , aLen   = arguments.length
	      , result = new (typeof this == 'function' ? this : Array)(aLen);
	    while(aLen > index)createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.13 Array.prototype.join(separator)
	var $export   = __webpack_require__(8)
	  , toIObject = __webpack_require__(32)
	  , arrayJoin = [].join;
	
	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(33) != Object || !__webpack_require__(168)(arrayJoin)), 'Array', {
	  join: function join(separator){
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	var fails = __webpack_require__(7);
	
	module.exports = function(method, arg){
	  return !!method && fails(function(){
	    arg ? method.call(null, function(){}, 1) : method.call(null);
	  });
	};

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export    = __webpack_require__(8)
	  , html       = __webpack_require__(48)
	  , cof        = __webpack_require__(34)
	  , toIndex    = __webpack_require__(39)
	  , toLength   = __webpack_require__(37)
	  , arraySlice = [].slice;
	
	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  if(html)arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end){
	    var len   = toLength(this.length)
	      , klass = cof(this);
	    end = end === undefined ? len : end;
	    if(klass == 'Array')return arraySlice.call(this, begin, end);
	    var start  = toIndex(begin, len)
	      , upTo   = toIndex(end, len)
	      , size   = toLength(upTo - start)
	      , cloned = Array(size)
	      , i      = 0;
	    for(; i < size; i++)cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export   = __webpack_require__(8)
	  , aFunction = __webpack_require__(21)
	  , toObject  = __webpack_require__(58)
	  , fails     = __webpack_require__(7)
	  , $sort     = [].sort
	  , test      = [1, 2, 3];
	
	$export($export.P + $export.F * (fails(function(){
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function(){
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(168)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn){
	    return comparefn === undefined
	      ? $sort.call(toObject(this))
	      : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export  = __webpack_require__(8)
	  , $forEach = __webpack_require__(172)(0)
	  , STRICT   = __webpack_require__(168)([].forEach, true);
	
	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */){
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(20)
	  , IObject  = __webpack_require__(33)
	  , toObject = __webpack_require__(58)
	  , toLength = __webpack_require__(37)
	  , asc      = __webpack_require__(173);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(174);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13)
	  , isArray  = __webpack_require__(45)
	  , SPECIES  = __webpack_require__(25)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $map    = __webpack_require__(172)(1);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */){
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $filter = __webpack_require__(172)(2);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */){
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $some   = __webpack_require__(172)(3);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */){
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $every  = __webpack_require__(172)(4);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */){
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $reduce = __webpack_require__(180);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(21)
	  , toObject  = __webpack_require__(58)
	  , IObject   = __webpack_require__(33)
	  , toLength  = __webpack_require__(37);
	
	module.exports = function(that, callbackfn, aLen, memo, isRight){
	  aFunction(callbackfn);
	  var O      = toObject(that)
	    , self   = IObject(O)
	    , length = toLength(O.length)
	    , index  = isRight ? length - 1 : 0
	    , i      = isRight ? -1 : 1;
	  if(aLen < 2)for(;;){
	    if(index in self){
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if(isRight ? index < 0 : length <= index){
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $reduce = __webpack_require__(180);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(8)
	  , $indexOf      = __webpack_require__(36)(false)
	  , $native       = [].indexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(168)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(8)
	  , toIObject     = __webpack_require__(32)
	  , toInteger     = __webpack_require__(38)
	  , toLength      = __webpack_require__(37)
	  , $native       = [].lastIndexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(168)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
	    // convert -0 to +0
	    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
	    var O      = toIObject(this)
	      , length = toLength(O.length)
	      , index  = length - 1;
	    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
	    if(index < 0)index = length + index;
	    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
	    return -1;
	  }
	});

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Array', {copyWithin: __webpack_require__(185)});
	
	__webpack_require__(186)('copyWithin');

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(58)
	  , toIndex  = __webpack_require__(39)
	  , toLength = __webpack_require__(37);
	
	module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
	  var O     = toObject(this)
	    , len   = toLength(O.length)
	    , to    = toIndex(target, len)
	    , from  = toIndex(start, len)
	    , end   = arguments.length > 2 ? arguments[2] : undefined
	    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
	    , inc   = 1;
	  if(from < to && to < from + count){
	    inc  = -1;
	    from += count - 1;
	    to   += count - 1;
	  }
	  while(count-- > 0){
	    if(from in O)O[to] = O[from];
	    else delete O[to];
	    to   += inc;
	    from += inc;
	  } return O;
	};

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(25)('unscopables')
	  , ArrayProto  = Array.prototype;
	if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(10)(ArrayProto, UNSCOPABLES, {});
	module.exports = function(key){
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Array', {fill: __webpack_require__(188)});
	
	__webpack_require__(186)('fill');

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(58)
	  , toIndex  = __webpack_require__(39)
	  , toLength = __webpack_require__(37);
	module.exports = function fill(value /*, start = 0, end = @length */){
	  var O      = toObject(this)
	    , length = toLength(O.length)
	    , aLen   = arguments.length
	    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
	    , end    = aLen > 2 ? arguments[2] : undefined
	    , endPos = end === undefined ? length : toIndex(end, length);
	  while(endPos > index)O[index++] = value;
	  return O;
	};

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(8)
	  , $find   = __webpack_require__(172)(5)
	  , KEY     = 'find'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(186)(KEY);

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(8)
	  , $find   = __webpack_require__(172)(6)
	  , KEY     = 'findIndex'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(186)(KEY);

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(192)('Array');

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(4)
	  , dP          = __webpack_require__(11)
	  , DESCRIPTORS = __webpack_require__(6)
	  , SPECIES     = __webpack_require__(25)('species');
	
	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(186)
	  , step             = __webpack_require__(194)
	  , Iterators        = __webpack_require__(129)
	  , toIObject        = __webpack_require__(32);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(128)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 194 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var global            = __webpack_require__(4)
	  , inheritIfRequired = __webpack_require__(88)
	  , dP                = __webpack_require__(11).f
	  , gOPN              = __webpack_require__(50).f
	  , isRegExp          = __webpack_require__(134)
	  , $flags            = __webpack_require__(196)
	  , $RegExp           = global.RegExp
	  , Base              = $RegExp
	  , proto             = $RegExp.prototype
	  , re1               = /a/g
	  , re2               = /a/g
	  // "new" creates a new object, old webkit buggy here
	  , CORRECT_NEW       = new $RegExp(re1) !== re1;
	
	if(__webpack_require__(6) && (!CORRECT_NEW || __webpack_require__(7)(function(){
	  re2[__webpack_require__(25)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))){
	  $RegExp = function RegExp(p, f){
	    var tiRE = this instanceof $RegExp
	      , piRE = isRegExp(p)
	      , fiU  = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function(key){
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function(){ return Base[key]; },
	      set: function(it){ Base[key] = it; }
	    });
	  };
	  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(18)(global, 'RegExp', $RegExp);
	}
	
	__webpack_require__(192)('RegExp');

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(12);
	module.exports = function(){
	  var that   = anObject(this)
	    , result = '';
	  if(that.global)     result += 'g';
	  if(that.ignoreCase) result += 'i';
	  if(that.multiline)  result += 'm';
	  if(that.unicode)    result += 'u';
	  if(that.sticky)     result += 'y';
	  return result;
	};

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(198);
	var anObject    = __webpack_require__(12)
	  , $flags      = __webpack_require__(196)
	  , DESCRIPTORS = __webpack_require__(6)
	  , TO_STRING   = 'toString'
	  , $toString   = /./[TO_STRING];
	
	var define = function(fn){
	  __webpack_require__(18)(RegExp.prototype, TO_STRING, fn, true);
	};
	
	// 21.2.5.14 RegExp.prototype.toString()
	if(__webpack_require__(7)(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
	  define(function toString(){
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if($toString.name != TO_STRING){
	  define(function toString(){
	    return $toString.call(this);
	  });
	}

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	if(__webpack_require__(6) && /./g.flags != 'g')__webpack_require__(11).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(196)
	});

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	// @@match logic
	__webpack_require__(200)('match', 1, function(defined, MATCH, $match){
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide     = __webpack_require__(10)
	  , redefine = __webpack_require__(18)
	  , fails    = __webpack_require__(7)
	  , defined  = __webpack_require__(35)
	  , wks      = __webpack_require__(25);
	
	module.exports = function(KEY, length, exec){
	  var SYMBOL   = wks(KEY)
	    , fns      = exec(defined, SYMBOL, ''[KEY])
	    , strfn    = fns[0]
	    , rxfn     = fns[1];
	  if(fails(function(){
	    var O = {};
	    O[SYMBOL] = function(){ return 7; };
	    return ''[KEY](O) != 7;
	  })){
	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function(string, arg){ return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function(string){ return rxfn.call(string, this); }
	    );
	  }
	};

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	// @@replace logic
	__webpack_require__(200)('replace', 2, function(defined, REPLACE, $replace){
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue){
	    'use strict';
	    var O  = defined(this)
	      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	// @@search logic
	__webpack_require__(200)('search', 1, function(defined, SEARCH, $search){
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	// @@split logic
	__webpack_require__(200)('split', 2, function(defined, SPLIT, $split){
	  'use strict';
	  var isRegExp   = __webpack_require__(134)
	    , _split     = $split
	    , $push      = [].push
	    , $SPLIT     = 'split'
	    , LENGTH     = 'length'
	    , LAST_INDEX = 'lastIndex';
	  if(
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ){
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function(separator, limit){
	      var string = String(this);
	      if(separator === undefined && limit === 0)return [];
	      // If `separator` is not a regex, use native split
	      if(!isRegExp(separator))return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while(match = separatorCopy.exec(string)){
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if(lastIndex > lastLastIndex){
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
	            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
	          });
	          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if(output[LENGTH] >= splitLimit)break;
	        }
	        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if(lastLastIndex === string[LENGTH]){
	        if(lastLength || !separatorCopy.test(''))output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
	    $split = function(separator, limit){
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit){
	    var O  = defined(this)
	      , fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(28)
	  , global             = __webpack_require__(4)
	  , ctx                = __webpack_require__(20)
	  , classof            = __webpack_require__(75)
	  , $export            = __webpack_require__(8)
	  , isObject           = __webpack_require__(13)
	  , aFunction          = __webpack_require__(21)
	  , anInstance         = __webpack_require__(205)
	  , forOf              = __webpack_require__(206)
	  , speciesConstructor = __webpack_require__(207)
	  , task               = __webpack_require__(208).set
	  , microtask          = __webpack_require__(209)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(25)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(210)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(24)($Promise, PROMISE);
	__webpack_require__(192)(PROMISE);
	Wrapper = __webpack_require__(9)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(165)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 205 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(20)
	  , call        = __webpack_require__(161)
	  , isArrayIter = __webpack_require__(162)
	  , anObject    = __webpack_require__(12)
	  , toLength    = __webpack_require__(37)
	  , getIterFn   = __webpack_require__(164)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(12)
	  , aFunction = __webpack_require__(21)
	  , SPECIES   = __webpack_require__(25)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(20)
	  , invoke             = __webpack_require__(78)
	  , html               = __webpack_require__(48)
	  , cel                = __webpack_require__(15)
	  , global             = __webpack_require__(4)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(34)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , macrotask = __webpack_require__(208).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(34)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(18);
	module.exports = function(target, src, safe){
	  for(var key in src)redefine(target, key, src[key], safe);
	  return target;
	};

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(212);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(213)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(11).f
	  , create      = __webpack_require__(46)
	  , redefineAll = __webpack_require__(210)
	  , ctx         = __webpack_require__(20)
	  , anInstance  = __webpack_require__(205)
	  , defined     = __webpack_require__(35)
	  , forOf       = __webpack_require__(206)
	  , $iterDefine = __webpack_require__(128)
	  , step        = __webpack_require__(194)
	  , setSpecies  = __webpack_require__(192)
	  , DESCRIPTORS = __webpack_require__(6)
	  , fastKey     = __webpack_require__(22).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(4)
	  , $export           = __webpack_require__(8)
	  , redefine          = __webpack_require__(18)
	  , redefineAll       = __webpack_require__(210)
	  , meta              = __webpack_require__(22)
	  , forOf             = __webpack_require__(206)
	  , anInstance        = __webpack_require__(205)
	  , isObject          = __webpack_require__(13)
	  , fails             = __webpack_require__(7)
	  , $iterDetect       = __webpack_require__(165)
	  , setToStringTag    = __webpack_require__(24)
	  , inheritIfRequired = __webpack_require__(88);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  var fixMethod = function(KEY){
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a){
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance             = new C
	      // early implementations not supports chaining
	      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
	      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
	      // most early implementations doesn't supports iterables, most modern - not close it correctly
	      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
	      // for early implementations -0 and +0 not the same
	      , BUGGY_ZERO = !IS_WEAK && fails(function(){
	        // V8 ~ Chromium 42- fails only with 5+ elements
	        var $instance = new C()
	          , index     = 5;
	        while(index--)$instance[ADDER](index, index);
	        return !$instance.has(-0);
	      });
	    if(!ACCEPT_ITERABLES){ 
	      C = wrapper(function(target, iterable){
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base, target, C);
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if(IS_WEAK && proto.clear)delete proto.clear;
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(212);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(213)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var each         = __webpack_require__(172)(0)
	  , redefine     = __webpack_require__(18)
	  , meta         = __webpack_require__(22)
	  , assign       = __webpack_require__(69)
	  , weak         = __webpack_require__(216)
	  , isObject     = __webpack_require__(13)
	  , getWeak      = meta.getWeak
	  , isExtensible = Object.isExtensible
	  , uncaughtFrozenStore = weak.ufstore
	  , tmp          = {}
	  , InternalMap;
	
	var wrapper = function(get){
	  return function WeakMap(){
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};
	
	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      var data = getWeak(key);
	      if(data === true)return uncaughtFrozenStore(this).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	};
	
	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(213)('WeakMap', wrapper, methods, weak, true, true);
	
	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  InternalMap = weak.getConstructor(wrapper);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    redefine(proto, key, function(a, b){
	      // store frozen objects on internal weakmap shim
	      if(isObject(a) && !isExtensible(a)){
	        if(!this._f)this._f = new InternalMap;
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var redefineAll       = __webpack_require__(210)
	  , getWeak           = __webpack_require__(22).getWeak
	  , anObject          = __webpack_require__(12)
	  , isObject          = __webpack_require__(13)
	  , anInstance        = __webpack_require__(205)
	  , forOf             = __webpack_require__(206)
	  , createArrayMethod = __webpack_require__(172)
	  , $has              = __webpack_require__(5)
	  , arrayFind         = createArrayMethod(5)
	  , arrayFindIndex    = createArrayMethod(6)
	  , id                = 0;
	
	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function(that){
	  return that._l || (that._l = new UncaughtFrozenStore);
	};
	var UncaughtFrozenStore = function(){
	  this.a = [];
	};
	var findUncaughtFrozen = function(store, key){
	  return arrayFind(store.a, function(it){
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function(key){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = arrayFindIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var data = getWeak(anObject(key), true);
	    if(data === true)uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(216);
	
	// 23.4 WeakSet Objects
	__webpack_require__(213)('WeakSet', function(get){
	  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value){
	    return weak.def(this, value, true);
	  }
	}, weak, false, true);

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , $typed       = __webpack_require__(219)
	  , buffer       = __webpack_require__(220)
	  , anObject     = __webpack_require__(12)
	  , toIndex      = __webpack_require__(39)
	  , toLength     = __webpack_require__(37)
	  , isObject     = __webpack_require__(13)
	  , ArrayBuffer  = __webpack_require__(4).ArrayBuffer
	  , speciesConstructor = __webpack_require__(207)
	  , $ArrayBuffer = buffer.ArrayBuffer
	  , $DataView    = buffer.DataView
	  , $isView      = $typed.ABV && ArrayBuffer.isView
	  , $slice       = $ArrayBuffer.prototype.slice
	  , VIEW         = $typed.VIEW
	  , ARRAY_BUFFER = 'ArrayBuffer';
	
	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});
	
	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it){
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});
	
	$export($export.P + $export.U + $export.F * __webpack_require__(7)(function(){
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end){
	    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
	    var len    = anObject(this).byteLength
	      , first  = toIndex(start, len)
	      , final  = toIndex(end === undefined ? len : end, len)
	      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
	      , viewS  = new $DataView(this)
	      , viewT  = new $DataView(result)
	      , index  = 0;
	    while(first < final){
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});
	
	__webpack_require__(192)(ARRAY_BUFFER);

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4)
	  , hide   = __webpack_require__(10)
	  , uid    = __webpack_require__(19)
	  , TYPED  = uid('typed_array')
	  , VIEW   = uid('view')
	  , ABV    = !!(global.ArrayBuffer && global.DataView)
	  , CONSTR = ABV
	  , i = 0, l = 9, Typed;
	
	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');
	
	while(i < l){
	  if(Typed = global[TypedArrayConstructors[i++]]){
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}
	
	module.exports = {
	  ABV:    ABV,
	  CONSTR: CONSTR,
	  TYPED:  TYPED,
	  VIEW:   VIEW
	};

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(4)
	  , DESCRIPTORS    = __webpack_require__(6)
	  , LIBRARY        = __webpack_require__(28)
	  , $typed         = __webpack_require__(219)
	  , hide           = __webpack_require__(10)
	  , redefineAll    = __webpack_require__(210)
	  , fails          = __webpack_require__(7)
	  , anInstance     = __webpack_require__(205)
	  , toInteger      = __webpack_require__(38)
	  , toLength       = __webpack_require__(37)
	  , gOPN           = __webpack_require__(50).f
	  , dP             = __webpack_require__(11).f
	  , arrayFill      = __webpack_require__(188)
	  , setToStringTag = __webpack_require__(24)
	  , ARRAY_BUFFER   = 'ArrayBuffer'
	  , DATA_VIEW      = 'DataView'
	  , PROTOTYPE      = 'prototype'
	  , WRONG_LENGTH   = 'Wrong length!'
	  , WRONG_INDEX    = 'Wrong index!'
	  , $ArrayBuffer   = global[ARRAY_BUFFER]
	  , $DataView      = global[DATA_VIEW]
	  , Math           = global.Math
	  , RangeError     = global.RangeError
	  , Infinity       = global.Infinity
	  , BaseBuffer     = $ArrayBuffer
	  , abs            = Math.abs
	  , pow            = Math.pow
	  , floor          = Math.floor
	  , log            = Math.log
	  , LN2            = Math.LN2
	  , BUFFER         = 'buffer'
	  , BYTE_LENGTH    = 'byteLength'
	  , BYTE_OFFSET    = 'byteOffset'
	  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
	  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
	  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;
	
	// IEEE754 conversions based on https://github.com/feross/ieee754
	var packIEEE754 = function(value, mLen, nBytes){
	  var buffer = Array(nBytes)
	    , eLen   = nBytes * 8 - mLen - 1
	    , eMax   = (1 << eLen) - 1
	    , eBias  = eMax >> 1
	    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
	    , i      = 0
	    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
	    , e, m, c;
	  value = abs(value)
	  if(value != value || value === Infinity){
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if(value * (c = pow(2, -e)) < 1){
	      e--;
	      c *= 2;
	    }
	    if(e + eBias >= 1){
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if(value * c >= 2){
	      e++;
	      c /= 2;
	    }
	    if(e + eBias >= eMax){
	      m = 0;
	      e = eMax;
	    } else if(e + eBias >= 1){
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	};
	var unpackIEEE754 = function(buffer, mLen, nBytes){
	  var eLen  = nBytes * 8 - mLen - 1
	    , eMax  = (1 << eLen) - 1
	    , eBias = eMax >> 1
	    , nBits = eLen - 7
	    , i     = nBytes - 1
	    , s     = buffer[i--]
	    , e     = s & 127
	    , m;
	  s >>= 7;
	  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if(e === 0){
	    e = 1 - eBias;
	  } else if(e === eMax){
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	};
	
	var unpackI32 = function(bytes){
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	};
	var packI8 = function(it){
	  return [it & 0xff];
	};
	var packI16 = function(it){
	  return [it & 0xff, it >> 8 & 0xff];
	};
	var packI32 = function(it){
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	};
	var packF64 = function(it){
	  return packIEEE754(it, 52, 8);
	};
	var packF32 = function(it){
	  return packIEEE754(it, 23, 4);
	};
	
	var addGetter = function(C, key, internal){
	  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
	};
	
	var get = function(view, bytes, index, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	};
	var set = function(view, bytes, index, conversion, value, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = conversion(+value);
	  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	};
	
	var validateArrayBufferArguments = function(that, length){
	  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
	  var numberLength = +length
	    , byteLength   = toLength(numberLength);
	  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
	  return byteLength;
	};
	
	if(!$typed.ABV){
	  $ArrayBuffer = function ArrayBuffer(length){
	    var byteLength = validateArrayBufferArguments(this, length);
	    this._b       = arrayFill.call(Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };
	
	  $DataView = function DataView(buffer, byteOffset, byteLength){
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH]
	      , offset       = toInteger(byteOffset);
	    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };
	
	  if(DESCRIPTORS){
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }
	
	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset){
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset){
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if(!fails(function(){
	    new $ArrayBuffer;     // eslint-disable-line no-new
	  }) || !fails(function(){
	    new $ArrayBuffer(.5); // eslint-disable-line no-new
	  })){
	    $ArrayBuffer = function ArrayBuffer(length){
	      return new BaseBuffer(validateArrayBufferArguments(this, length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
	      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
	    };
	    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2))
	    , $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	$export($export.G + $export.W + $export.F * !__webpack_require__(219).ABV, {
	  DataView: __webpack_require__(220).DataView
	});

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int8', 1, function(init){
	  return function Int8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	if(__webpack_require__(6)){
	  var LIBRARY             = __webpack_require__(28)
	    , global              = __webpack_require__(4)
	    , fails               = __webpack_require__(7)
	    , $export             = __webpack_require__(8)
	    , $typed              = __webpack_require__(219)
	    , $buffer             = __webpack_require__(220)
	    , ctx                 = __webpack_require__(20)
	    , anInstance          = __webpack_require__(205)
	    , propertyDesc        = __webpack_require__(17)
	    , hide                = __webpack_require__(10)
	    , redefineAll         = __webpack_require__(210)
	    , toInteger           = __webpack_require__(38)
	    , toLength            = __webpack_require__(37)
	    , toIndex             = __webpack_require__(39)
	    , toPrimitive         = __webpack_require__(16)
	    , has                 = __webpack_require__(5)
	    , same                = __webpack_require__(71)
	    , classof             = __webpack_require__(75)
	    , isObject            = __webpack_require__(13)
	    , toObject            = __webpack_require__(58)
	    , isArrayIter         = __webpack_require__(162)
	    , create              = __webpack_require__(46)
	    , getPrototypeOf      = __webpack_require__(59)
	    , gOPN                = __webpack_require__(50).f
	    , getIterFn           = __webpack_require__(164)
	    , uid                 = __webpack_require__(19)
	    , wks                 = __webpack_require__(25)
	    , createArrayMethod   = __webpack_require__(172)
	    , createArrayIncludes = __webpack_require__(36)
	    , speciesConstructor  = __webpack_require__(207)
	    , ArrayIterators      = __webpack_require__(193)
	    , Iterators           = __webpack_require__(129)
	    , $iterDetect         = __webpack_require__(165)
	    , setSpecies          = __webpack_require__(192)
	    , arrayFill           = __webpack_require__(188)
	    , arrayCopyWithin     = __webpack_require__(185)
	    , $DP                 = __webpack_require__(11)
	    , $GOPD               = __webpack_require__(51)
	    , dP                  = $DP.f
	    , gOPD                = $GOPD.f
	    , RangeError          = global.RangeError
	    , TypeError           = global.TypeError
	    , Uint8Array          = global.Uint8Array
	    , ARRAY_BUFFER        = 'ArrayBuffer'
	    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
	    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
	    , PROTOTYPE           = 'prototype'
	    , ArrayProto          = Array[PROTOTYPE]
	    , $ArrayBuffer        = $buffer.ArrayBuffer
	    , $DataView           = $buffer.DataView
	    , arrayForEach        = createArrayMethod(0)
	    , arrayFilter         = createArrayMethod(2)
	    , arraySome           = createArrayMethod(3)
	    , arrayEvery          = createArrayMethod(4)
	    , arrayFind           = createArrayMethod(5)
	    , arrayFindIndex      = createArrayMethod(6)
	    , arrayIncludes       = createArrayIncludes(true)
	    , arrayIndexOf        = createArrayIncludes(false)
	    , arrayValues         = ArrayIterators.values
	    , arrayKeys           = ArrayIterators.keys
	    , arrayEntries        = ArrayIterators.entries
	    , arrayLastIndexOf    = ArrayProto.lastIndexOf
	    , arrayReduce         = ArrayProto.reduce
	    , arrayReduceRight    = ArrayProto.reduceRight
	    , arrayJoin           = ArrayProto.join
	    , arraySort           = ArrayProto.sort
	    , arraySlice          = ArrayProto.slice
	    , arrayToString       = ArrayProto.toString
	    , arrayToLocaleString = ArrayProto.toLocaleString
	    , ITERATOR            = wks('iterator')
	    , TAG                 = wks('toStringTag')
	    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
	    , DEF_CONSTRUCTOR     = uid('def_constructor')
	    , ALL_CONSTRUCTORS    = $typed.CONSTR
	    , TYPED_ARRAY         = $typed.TYPED
	    , VIEW                = $typed.VIEW
	    , WRONG_LENGTH        = 'Wrong length!';
	
	  var $map = createArrayMethod(1, function(O, length){
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });
	
	  var LITTLE_ENDIAN = fails(function(){
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });
	
	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
	    new Uint8Array(1).set({});
	  });
	
	  var strictToLength = function(it, SAME){
	    if(it === undefined)throw TypeError(WRONG_LENGTH);
	    var number = +it
	      , length = toLength(it);
	    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
	    return length;
	  };
	
	  var toOffset = function(it, BYTES){
	    var offset = toInteger(it);
	    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
	    return offset;
	  };
	
	  var validate = function(it){
	    if(isObject(it) && TYPED_ARRAY in it)return it;
	    throw TypeError(it + ' is not a typed array!');
	  };
	
	  var allocate = function(C, length){
	    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };
	
	  var speciesFromList = function(O, list){
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };
	
	  var fromList = function(C, list){
	    var index  = 0
	      , length = list.length
	      , result = allocate(C, length);
	    while(length > index)result[index] = list[index++];
	    return result;
	  };
	
	  var addGetter = function(it, key, internal){
	    dP(it, key, {get: function(){ return this._d[internal]; }});
	  };
	
	  var $from = function from(source /*, mapfn, thisArg */){
	    var O       = toObject(source)
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , iterFn  = getIterFn(O)
	      , i, length, values, result, step, iterator;
	    if(iterFn != undefined && !isArrayIter(iterFn)){
	      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
	        values.push(step.value);
	      } O = values;
	    }
	    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
	    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };
	
	  var $of = function of(/*...items*/){
	    var index  = 0
	      , length = arguments.length
	      , result = allocate(this, length);
	    while(length > index)result[index] = arguments[index++];
	    return result;
	  };
	
	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });
	
	  var $toLocaleString = function toLocaleString(){
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };
	
	  var proto = {
	    copyWithin: function copyWithin(target, start /*, end */){
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /*, thisArg */){
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /*, thisArg */){
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /*, thisArg */){
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /*, thisArg */){
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /*, thisArg */){
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /*, fromIndex */){
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /*, fromIndex */){
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator){ // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /*, thisArg */){
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse(){
	      var that   = this
	        , length = validate(that).length
	        , middle = Math.floor(length / 2)
	        , index  = 0
	        , value;
	      while(index < middle){
	        value         = that[index];
	        that[index++] = that[--length];
	        that[length]  = value;
	      } return that;
	    },
	    some: function some(callbackfn /*, thisArg */){
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn){
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end){
	      var O      = validate(this)
	        , length = O.length
	        , $begin = toIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
	      );
	    }
	  };
	
	  var $slice = function slice(start, end){
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };
	
	  var $set = function set(arrayLike /*, offset */){
	    validate(this);
	    var offset = toOffset(arguments[1], 1)
	      , length = this.length
	      , src    = toObject(arrayLike)
	      , len    = toLength(src.length)
	      , index  = 0;
	    if(len + offset > length)throw RangeError(WRONG_LENGTH);
	    while(index < len)this[offset + index] = src[index++];
	  };
	
	  var $iterators = {
	    entries: function entries(){
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys(){
	      return arrayKeys.call(validate(this));
	    },
	    values: function values(){
	      return arrayValues.call(validate(this));
	    }
	  };
	
	  var isTAIndex = function(target, key){
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key){
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc){
	    if(isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ){
	      target[key] = desc.value;
	      return target;
	    } else return dP(target, key, desc);
	  };
	
	  if(!ALL_CONSTRUCTORS){
	    $GOPD.f = $getDesc;
	    $DP.f   = $setDesc;
	  }
	
	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty:           $setDesc
	  });
	
	  if(fails(function(){ arrayToString.call({}); })){
	    arrayToString = arrayToLocaleString = function toString(){
	      return arrayJoin.call(this);
	    }
	  }
	
	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice:          $slice,
	    set:            $set,
	    constructor:    function(){ /* noop */ },
	    toString:       arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function(){ return this[TYPED_ARRAY]; }
	  });
	
	  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
	    CLAMPED = !!CLAMPED;
	    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
	      , ISNT_UINT8 = NAME != 'Uint8Array'
	      , GETTER     = 'get' + KEY
	      , SETTER     = 'set' + KEY
	      , TypedArray = global[NAME]
	      , Base       = TypedArray || {}
	      , TAC        = TypedArray && getPrototypeOf(TypedArray)
	      , FORCED     = !TypedArray || !$typed.ABV
	      , O          = {}
	      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function(that, index){
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function(that, index, value){
	      var data = that._d;
	      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function(that, index){
	      dP(that, index, {
	        get: function(){
	          return getter(this, index);
	        },
	        set: function(value){
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if(FORCED){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME, '_d');
	        var index  = 0
	          , offset = 0
	          , buffer, byteLength, length, klass;
	        if(!isObject(data)){
	          length     = strictToLength(data, true)
	          byteLength = length * BYTES;
	          buffer     = new $ArrayBuffer(byteLength);
	        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if($length === undefined){
	            if($len % BYTES)throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if(TYPED_ARRAY in data){
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while(index < length)addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if(!$iterDetect(function(iter){
	      // V8 works with iterators, but fails in many other cases
	      // https://code.google.com/p/v8/issues/detail?id=4552
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
	        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
	        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
	      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
	      , $iterator         = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
	
	    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
	      dP(TypedArrayPrototype, TAG, {
	        get: function(){ return NAME; }
	      });
	    }
	
	    O[NAME] = TypedArray;
	
	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
	
	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES,
	      from: $from,
	      of: $of
	    });
	
	    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
	
	    $export($export.P, NAME, proto);
	
	    setSpecies(NAME);
	
	    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});
	
	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
	
	    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});
	
	    $export($export.P + $export.F * fails(function(){
	      new TypedArray(1).slice();
	    }), NAME, {slice: $slice});
	
	    $export($export.P + $export.F * (fails(function(){
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
	    }) || !fails(function(){
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, {toLocaleString: $toLocaleString});
	
	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function(){ /* empty */ };

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint8', 1, function(init){
	  return function Uint8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint8', 1, function(init){
	  return function Uint8ClampedArray(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	}, true);

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int16', 2, function(init){
	  return function Int16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint16', 2, function(init){
	  return function Uint16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int32', 4, function(init){
	  return function Int32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint32', 4, function(init){
	  return function Uint32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Float32', 4, function(init){
	  return function Float32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Float64', 8, function(init){
	  return function Float64Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export   = __webpack_require__(8)
	  , aFunction = __webpack_require__(21)
	  , anObject  = __webpack_require__(12)
	  , rApply    = (__webpack_require__(4).Reflect || {}).apply
	  , fApply    = Function.apply;
	// MS Edge argumentsList argument is optional
	$export($export.S + $export.F * !__webpack_require__(7)(function(){
	  rApply(function(){});
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList){
	    var T = aFunction(target)
	      , L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export    = __webpack_require__(8)
	  , create     = __webpack_require__(46)
	  , aFunction  = __webpack_require__(21)
	  , anObject   = __webpack_require__(12)
	  , isObject   = __webpack_require__(13)
	  , fails      = __webpack_require__(7)
	  , bind       = __webpack_require__(77)
	  , rConstruct = (__webpack_require__(4).Reflect || {}).construct;
	
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function(){
	  function F(){}
	  return !(rConstruct(function(){}, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function(){
	  rConstruct(function(){});
	});
	
	$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /*, newTarget*/){
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
	    if(Target == newTarget){
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch(args.length){
	        case 0: return new Target;
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args));
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto    = newTarget.prototype
	      , instance = create(isObject(proto) ? proto : Object.prototype)
	      , result   = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP          = __webpack_require__(11)
	  , $export     = __webpack_require__(8)
	  , anObject    = __webpack_require__(12)
	  , toPrimitive = __webpack_require__(16);
	
	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes){
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export  = __webpack_require__(8)
	  , gOPD     = __webpack_require__(51).f
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey){
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $export  = __webpack_require__(8)
	  , anObject = __webpack_require__(12);
	var Enumerate = function(iterated){
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = []       // keys
	    , key;
	  for(key in iterated)keys.push(key);
	};
	__webpack_require__(130)(Enumerate, 'Object', function(){
	  var that = this
	    , keys = that._k
	    , key;
	  do {
	    if(that._i >= keys.length)return {value: undefined, done: true};
	  } while(!((key = keys[that._i++]) in that._t));
	  return {value: key, done: false};
	});
	
	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target){
	    return new Enumerate(target);
	  }
	});

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD           = __webpack_require__(51)
	  , getPrototypeOf = __webpack_require__(59)
	  , has            = __webpack_require__(5)
	  , $export        = __webpack_require__(8)
	  , isObject       = __webpack_require__(13)
	  , anObject       = __webpack_require__(12);
	
	function get(target, propertyKey/*, receiver*/){
	  var receiver = arguments.length < 3 ? target : arguments[2]
	    , desc, proto;
	  if(anObject(target) === receiver)return target[propertyKey];
	  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
	}
	
	$export($export.S, 'Reflect', {get: get});

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD     = __webpack_require__(51)
	  , $export  = __webpack_require__(8)
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export  = __webpack_require__(8)
	  , getProto = __webpack_require__(59)
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target){
	    return getProto(anObject(target));
	  }
	});

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey){
	    return propertyKey in target;
	  }
	});

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export       = __webpack_require__(8)
	  , anObject      = __webpack_require__(12)
	  , $isExtensible = Object.isExtensible;
	
	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target){
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Reflect', {ownKeys: __webpack_require__(243)});

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var gOPN     = __webpack_require__(50)
	  , gOPS     = __webpack_require__(43)
	  , anObject = __webpack_require__(12)
	  , Reflect  = __webpack_require__(4).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
	  var keys       = gOPN.f(anObject(it))
	    , getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export            = __webpack_require__(8)
	  , anObject           = __webpack_require__(12)
	  , $preventExtensions = Object.preventExtensions;
	
	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target){
	    anObject(target);
	    try {
	      if($preventExtensions)$preventExtensions(target);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP             = __webpack_require__(11)
	  , gOPD           = __webpack_require__(51)
	  , getPrototypeOf = __webpack_require__(59)
	  , has            = __webpack_require__(5)
	  , $export        = __webpack_require__(8)
	  , createDesc     = __webpack_require__(17)
	  , anObject       = __webpack_require__(12)
	  , isObject       = __webpack_require__(13);
	
	function set(target, propertyKey, V/*, receiver*/){
	  var receiver = arguments.length < 4 ? target : arguments[3]
	    , ownDesc  = gOPD.f(anObject(target), propertyKey)
	    , existingDescriptor, proto;
	  if(!ownDesc){
	    if(isObject(proto = getPrototypeOf(target))){
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if(has(ownDesc, 'value')){
	    if(ownDesc.writable === false || !isObject(receiver))return false;
	    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
	    existingDescriptor.value = V;
	    dP.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}
	
	$export($export.S, 'Reflect', {set: set});

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export  = __webpack_require__(8)
	  , setProto = __webpack_require__(73);
	
	if(setProto)$export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto){
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/Array.prototype.includes
	var $export   = __webpack_require__(8)
	  , $includes = __webpack_require__(36)(true);
	
	$export($export.P, 'Array', {
	  includes: function includes(el /*, fromIndex = 0 */){
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	
	__webpack_require__(186)('includes');

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(8)
	  , $at     = __webpack_require__(127)(true);
	
	$export($export.P, 'String', {
	  at: function at(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(8)
	  , $pad    = __webpack_require__(250);
	
	$export($export.P, 'String', {
	  padStart: function padStart(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(37)
	  , repeat   = __webpack_require__(91)
	  , defined  = __webpack_require__(35);
	
	module.exports = function(that, maxLength, fillString, left){
	  var S            = String(defined(that))
	    , stringLength = S.length
	    , fillStr      = fillString === undefined ? ' ' : String(fillString)
	    , intMaxLength = toLength(maxLength);
	  if(intMaxLength <= stringLength || fillStr == '')return S;
	  var fillLen = intMaxLength - stringLength
	    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(8)
	  , $pad    = __webpack_require__(250);
	
	$export($export.P, 'String', {
	  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(83)('trimLeft', function($trim){
	  return function trimLeft(){
	    return $trim(this, 1);
	  };
	}, 'trimStart');

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(83)('trimRight', function($trim){
	  return function trimRight(){
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/String.prototype.matchAll/
	var $export     = __webpack_require__(8)
	  , defined     = __webpack_require__(35)
	  , toLength    = __webpack_require__(37)
	  , isRegExp    = __webpack_require__(134)
	  , getFlags    = __webpack_require__(196)
	  , RegExpProto = RegExp.prototype;
	
	var $RegExpStringIterator = function(regexp, string){
	  this._r = regexp;
	  this._s = string;
	};
	
	__webpack_require__(130)($RegExpStringIterator, 'RegExp String', function next(){
	  var match = this._r.exec(this._s);
	  return {value: match, done: match === null};
	});
	
	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp){
	    defined(this);
	    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
	    var S     = String(this)
	      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
	      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(27)('asyncIterator');

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(27)('observable');

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export        = __webpack_require__(8)
	  , ownKeys        = __webpack_require__(243)
	  , toIObject      = __webpack_require__(32)
	  , gOPD           = __webpack_require__(51)
	  , createProperty = __webpack_require__(163);
	
	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
	    var O       = toIObject(object)
	      , getDesc = gOPD.f
	      , keys    = ownKeys(O)
	      , result  = {}
	      , i       = 0
	      , key;
	    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
	    return result;
	  }
	});

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(8)
	  , $values = __webpack_require__(259)(false);
	
	$export($export.S, 'Object', {
	  values: function values(it){
	    return $values(it);
	  }
	});

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(30)
	  , toIObject = __webpack_require__(32)
	  , isEnum    = __webpack_require__(44).f;
	module.exports = function(isEntries){
	  return function(it){
	    var O      = toIObject(it)
	      , keys   = getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = []
	      , key;
	    while(length > i)if(isEnum.call(O, key = keys[i++])){
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export  = __webpack_require__(8)
	  , $entries = __webpack_require__(259)(true);
	
	$export($export.S, 'Object', {
	  entries: function entries(it){
	    return $entries(it);
	  }
	});

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(8)
	  , toObject        = __webpack_require__(58)
	  , aFunction       = __webpack_require__(21)
	  , $defineProperty = __webpack_require__(11);
	
	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(6) && $export($export.P + __webpack_require__(262), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter){
	    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(28)|| !__webpack_require__(7)(function(){
	  var K = Math.random();
	  // In FF throws only define methods
	  __defineSetter__.call(null, K, function(){ /* empty */});
	  delete __webpack_require__(4)[K];
	});

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(8)
	  , toObject        = __webpack_require__(58)
	  , aFunction       = __webpack_require__(21)
	  , $defineProperty = __webpack_require__(11);
	
	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(6) && $export($export.P + __webpack_require__(262), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter){
	    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(8)
	  , toObject                 = __webpack_require__(58)
	  , toPrimitive              = __webpack_require__(16)
	  , getPrototypeOf           = __webpack_require__(59)
	  , getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(6) && $export($export.P + __webpack_require__(262), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.get;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(8)
	  , toObject                 = __webpack_require__(58)
	  , toPrimitive              = __webpack_require__(16)
	  , getPrototypeOf           = __webpack_require__(59)
	  , getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(6) && $export($export.P + __webpack_require__(262), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.set;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(8);
	
	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(267)('Map')});

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(75)
	  , from    = __webpack_require__(268);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(206);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(8);
	
	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(267)('Set')});

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-global
	var $export = __webpack_require__(8);
	
	$export($export.S, 'System', {global: __webpack_require__(4)});

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(8)
	  , cof     = __webpack_require__(34);
	
	$export($export.S, 'Error', {
	  isError: function isError(it){
	    return cof(it) === 'Error';
	  }
	});

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  imulh: function imulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >> 16
	      , v1 = $v >> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  umulh: function umulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >>> 16
	      , v1 = $v >>> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(277)
	  , anObject                  = __webpack_require__(12)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	}});

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	var Map     = __webpack_require__(211)
	  , $export = __webpack_require__(8)
	  , shared  = __webpack_require__(23)('metadata')
	  , store   = shared.store || (shared.store = new (__webpack_require__(215)));
	
	var getOrCreateMetadataMap = function(target, targetKey, create){
	  var targetMetadata = store.get(target);
	  if(!targetMetadata){
	    if(!create)return undefined;
	    store.set(target, targetMetadata = new Map);
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if(!keyMetadata){
	    if(!create)return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map);
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function(target, targetKey){
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
	    , keys        = [];
	  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
	  return keys;
	};
	var toMetaKey = function(it){
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function(O){
	  $export($export.S, 'Reflect', O);
	};
	
	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , toMetaKey              = metadata.key
	  , getOrCreateMetadataMap = metadata.map
	  , store                  = metadata.store;
	
	metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
	  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
	    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
	  if(metadataMap.size)return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	}});

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , getPrototypeOf         = __webpack_require__(59)
	  , ordinaryHasOwnMetadata = metadata.has
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	var ordinaryGetMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};
	
	metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	var Set                     = __webpack_require__(214)
	  , from                    = __webpack_require__(268)
	  , metadata                = __webpack_require__(277)
	  , anObject                = __webpack_require__(12)
	  , getPrototypeOf          = __webpack_require__(59)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	var ordinaryMetadataKeys = function(O, P){
	  var oKeys  = ordinaryOwnMetadataKeys(O, P)
	    , parent = getPrototypeOf(O);
	  if(parent === null)return oKeys;
	  var pKeys  = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};
	
	metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                = __webpack_require__(277)
	  , anObject                = __webpack_require__(12)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , getPrototypeOf         = __webpack_require__(59)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	var ordinaryHasMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};
	
	metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(277)
	  , anObject                  = __webpack_require__(12)
	  , aFunction                 = __webpack_require__(21)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({metadata: function metadata(metadataKey, metadataValue){
	  return function decorator(target, targetKey){
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	}});

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export   = __webpack_require__(8)
	  , microtask = __webpack_require__(209)()
	  , process   = __webpack_require__(4).process
	  , isNode    = __webpack_require__(34)(process) == 'process';
	
	$export($export.G, {
	  asap: function asap(fn){
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/zenparsing/es-observable
	var $export     = __webpack_require__(8)
	  , global      = __webpack_require__(4)
	  , core        = __webpack_require__(9)
	  , microtask   = __webpack_require__(209)()
	  , OBSERVABLE  = __webpack_require__(25)('observable')
	  , aFunction   = __webpack_require__(21)
	  , anObject    = __webpack_require__(12)
	  , anInstance  = __webpack_require__(205)
	  , redefineAll = __webpack_require__(210)
	  , hide        = __webpack_require__(10)
	  , forOf       = __webpack_require__(206)
	  , RETURN      = forOf.RETURN;
	
	var getMethod = function(fn){
	  return fn == null ? undefined : aFunction(fn);
	};
	
	var cleanupSubscription = function(subscription){
	  var cleanup = subscription._c;
	  if(cleanup){
	    subscription._c = undefined;
	    cleanup();
	  }
	};
	
	var subscriptionClosed = function(subscription){
	  return subscription._o === undefined;
	};
	
	var closeSubscription = function(subscription){
	  if(!subscriptionClosed(subscription)){
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};
	
	var Subscription = function(observer, subscriber){
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup      = subscriber(observer)
	      , subscription = cleanup;
	    if(cleanup != null){
	      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch(e){
	    observer.error(e);
	    return;
	  } if(subscriptionClosed(this))cleanupSubscription(this);
	};
	
	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe(){ closeSubscription(this); }
	});
	
	var SubscriptionObserver = function(subscription){
	  this._s = subscription;
	};
	
	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if(m)return m.call(observer, value);
	      } catch(e){
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value){
	    var subscription = this._s;
	    if(subscriptionClosed(subscription))throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if(!m)throw value;
	      value = m.call(observer, value);
	    } catch(e){
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch(e){
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});
	
	var $Observable = function Observable(subscriber){
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};
	
	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer){
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn){
	    var that = this;
	    return new (core.Promise || global.Promise)(function(resolve, reject){
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next : function(value){
	          try {
	            return fn(value);
	          } catch(e){
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});
	
	redefineAll($Observable, {
	  from: function from(x){
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if(method){
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function(observer){
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          try {
	            if(forOf(x, false, function(it){
	              observer.next(it);
	              if(done)return RETURN;
	            }) === RETURN)return;
	          } catch(e){
	            if(done)throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  },
	  of: function of(){
	    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          for(var i = 0; i < items.length; ++i){
	            observer.next(items[i]);
	            if(done)return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  }
	});
	
	hide($Observable.prototype, OBSERVABLE, function(){ return this; });
	
	$export($export.G, {Observable: $Observable});
	
	__webpack_require__(192)('Observable');

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global     = __webpack_require__(4)
	  , $export    = __webpack_require__(8)
	  , invoke     = __webpack_require__(78)
	  , partial    = __webpack_require__(289)
	  , navigator  = global.navigator
	  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
	var wrap = function(set){
	  return MSIE ? function(fn, time /*, ...args */){
	    return set(invoke(
	      partial,
	      [].slice.call(arguments, 2),
	      typeof fn == 'function' ? fn : Function(fn)
	    ), time);
	  } : set;
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout:  wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path      = __webpack_require__(290)
	  , invoke    = __webpack_require__(78)
	  , aFunction = __webpack_require__(21);
	module.exports = function(/* ...pargs */){
	  var fn     = aFunction(this)
	    , length = arguments.length
	    , pargs  = Array(length)
	    , i      = 0
	    , _      = path._
	    , holder = false;
	  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
	  return function(/* ...args */){
	    var that = this
	      , aLen = arguments.length
	      , j = 0, k = 0, args;
	    if(!holder && !aLen)return invoke(fn, pargs, that);
	    args = pargs.slice();
	    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
	    while(aLen > k)args.push(arguments[k++]);
	    return invoke(fn, args, that);
	  };
	};

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(4);

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , $task   = __webpack_require__(208);
	$export($export.G + $export.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	var $iterators    = __webpack_require__(193)
	  , redefine      = __webpack_require__(18)
	  , global        = __webpack_require__(4)
	  , hide          = __webpack_require__(10)
	  , Iterators     = __webpack_require__(129)
	  , wks           = __webpack_require__(25)
	  , ITERATOR      = wks('iterator')
	  , TO_STRING_TAG = wks('toStringTag')
	  , ArrayValues   = Iterators.Array;
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype
	    , key;
	  if(proto){
	    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
	    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
	  }
	}

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(294)))

/***/ },
/* 294 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(296);
	module.exports = __webpack_require__(9).RegExp.escape;

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(8)
	  , $re     = __webpack_require__(297)(/[\\^$*+?.()|[\]{}]/g, '\\$&');
	
	$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});


/***/ },
/* 297 */
/***/ function(module, exports) {

	module.exports = function(regExp, replace){
	  var replacer = replace === Object(replace) ? function(part){
	    return replace[part];
	  } : replace;
	  return function(it){
	    return String(it).replace(regExp, replacer);
	  };
	};

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.setLogLevel = exports.PlaybackVideoEncoder = exports.PlaybackAudioEncoder = exports.SharedObjectEventTypes = exports.FailoverSubscriberEventTypes = exports.RTCSubscriberEventTypes = exports.SubscriberEventTypes = exports.FailoverPublisherEventTypes = exports.RTCPublisherEventTypes = exports.PublisherEventTypes = exports.Red5ProSharedObject = exports.PublisherView = exports.RTCPublisher = exports.RTMPPublisher = exports.Red5ProPublisher = exports.PlaybackView = exports.RTMPSubscriber = exports.R5LiveSubscriber = exports.VideoJSSubscriber = exports.HLSSubscriber = exports.RTCSubscriber = exports.Red5ProSubscriber = exports.getLogger = exports.LogLevels = undefined;
	
	var _log = __webpack_require__(299);
	
	Object.defineProperty(exports, 'LogLevels', {
	  enumerable: true,
	  get: function get() {
	    return _log.LEVELS;
	  }
	});
	Object.defineProperty(exports, 'getLogger', {
	  enumerable: true,
	  get: function get() {
	    return _log.getLogger;
	  }
	});
	
	var _publisherEvent = __webpack_require__(302);
	
	Object.defineProperty(exports, 'PublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.common;
	  }
	});
	Object.defineProperty(exports, 'RTCPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.rtc;
	  }
	});
	Object.defineProperty(exports, 'FailoverPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.failover;
	  }
	});
	
	var _subscriberEvent = __webpack_require__(303);
	
	Object.defineProperty(exports, 'SubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.common;
	  }
	});
	Object.defineProperty(exports, 'RTCSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.rtc;
	  }
	});
	Object.defineProperty(exports, 'FailoverSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.failover;
	  }
	});
	
	var _sharedobjectEvent = __webpack_require__(304);
	
	Object.defineProperty(exports, 'SharedObjectEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _sharedobjectEvent.common;
	  }
	});
	
	var _playback = __webpack_require__(305);
	
	Object.defineProperty(exports, 'PlaybackAudioEncoder', {
	  enumerable: true,
	  get: function get() {
	    return _playback.PlaybackAudioEncoder;
	  }
	});
	Object.defineProperty(exports, 'PlaybackVideoEncoder', {
	  enumerable: true,
	  get: function get() {
	    return _playback.PlaybackVideoEncoder;
	  }
	});
	
	var _index = __webpack_require__(306);
	
	var subscriberLib = _interopRequireWildcard(_index);
	
	var _index2 = __webpack_require__(329);
	
	var publisherLib = _interopRequireWildcard(_index2);
	
	var _index3 = __webpack_require__(336);
	
	var sharedObjectLib = _interopRequireWildcard(_index3);
	
	var _playback2 = __webpack_require__(337);
	
	var _playback3 = _interopRequireDefault(_playback2);
	
	var _publish = __webpack_require__(338);
	
	var _publish2 = _interopRequireDefault(_publish);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/**
	 * Subscription related references.
	*/
	var Red5ProSubscriber = exports.Red5ProSubscriber = subscriberLib.Red5ProSubscriber;
	var RTCSubscriber = exports.RTCSubscriber = subscriberLib.RTCSubscriber;
	var HLSSubscriber = exports.HLSSubscriber = subscriberLib.HLSSubscriber;
	var VideoJSSubscriber = exports.VideoJSSubscriber = subscriberLib.VideoJSSubscriber;
	var R5LiveSubscriber = exports.R5LiveSubscriber = subscriberLib.R5LiveSubscriber;
	var RTMPSubscriber = exports.RTMPSubscriber = subscriberLib.RTMPSubscriber;
	exports.PlaybackView = _playback3.default;
	
	/**
	 * Broadcast related references.
	 */
	
	var Red5ProPublisher = exports.Red5ProPublisher = publisherLib.Red5ProPublisher;
	var RTMPPublisher = exports.RTMPPublisher = publisherLib.RTMPPublisher;
	var RTCPublisher = exports.RTCPublisher = publisherLib.RTCPublisher;
	exports.PublisherView = _publish2.default;
	
	/**
	 * Shared Object references.
	 */
	
	var Red5ProSharedObject = exports.Red5ProSharedObject = sharedObjectLib.Red5ProSharedObject;
	
	/**
	 * Events
	 */
	
	
	(0, _log.establishLogger)('' + ("debug") || _log.LEVELS.DEBUG); // eslint-disable-line no-undef
	(0, _log.getLogger)().debug('Red5 Pro SDK Version ' + ("3.1.1")); // eslint-disable-line no-undef
	
	var setLogLevel = exports.setLogLevel = function setLogLevel(level) {
	  if (_log.LEVELS.hasOwnProperty(level.toUpperCase())) {
	    (0, _log.establishLogger)(level);
	  }
	};

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.fatal = exports.error = exports.warn = exports.debug = exports.info = exports.trace = exports.getLogger = exports.establishLogger = exports.LEVELS = undefined;
	
	var _browserBunyan = __webpack_require__(300);
	
	var _bunyanWriter = __webpack_require__(301);
	
	var logger = void 0;
	var formatMessage = function formatMessage(dispatcher) {
	  return function (message) {
	    return '(' + dispatcher + ') ' + message;
	  };
	};
	var decorate = function decorate(level) {
	  return function (source, message) {
	    logger[level](formatMessage(source)(message));
	  };
	};
	var LEVELS = exports.LEVELS = {
	  TRACE: 'trace',
	  INFO: 'info',
	  DEBUG: 'debug',
	  WARN: 'warn',
	  ERROR: 'error',
	  FATAL: 'fatal'
	};
	
	var establishLogger = exports.establishLogger = function establishLogger(level) {
	  var streamList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	
	  var streams = [];
	  streams.push({
	    level: level,
	    stream: new _bunyanWriter.RawStream(),
	    type: 'raw'
	  });
	  if (streamList) {
	    var list = streamList.map(function (item) {
	      item.level = level;
	    });
	    streams = streams.concat(list);
	  }
	  logger = (0, _browserBunyan.createLogger)({
	    level: level,
	    name: 'red5pro-sdk',
	    streams: streams
	  });
	};
	
	var getLogger = exports.getLogger = function getLogger() {
	  return logger;
	};
	
	var trace = exports.trace = decorate(LEVELS.TRACE);
	var info = exports.info = decorate(LEVELS.INFO);
	var debug = exports.debug = decorate(LEVELS.DEBUG);
	var warn = exports.warn = decorate(LEVELS.WARN);
	var error = exports.error = decorate(LEVELS.ERROR);
	var fatal = exports.fatal = decorate(LEVELS.FATAL);

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * !This is a stripped down version of Bunyan targeted specifically for the browser
	 *
	 * -------------------------------------------------------------------------------
	 *
	 * Copyright (c) 2014 Trent Mick. All rights reserved.
	 * Copyright (c) 2014 Joyent Inc. All rights reserved.
	 *
	 * The bunyan logging library for node.js.
	 *
	 * -*- mode: js -*-
	 * vim: expandtab:ts=4:sw=4
	 */
	
	'use strict';
	
	var VERSION = '0.2.3';
	
	// Bunyan log format version. This becomes the 'v' field on all log records.
	// `0` is until I release a version '1.0.0' of node-bunyan. Thereafter,
	// starting with `1`, this will be incremented if there is any backward
	// incompatible change to the log record format. Details will be in
	// 'CHANGES.md' (the change log).
	var LOG_VERSION = 0;
	
	//---- Internal support stuff
	
	/**
	 * A shallow copy of an object. Bunyan logging attempts to never cause
	 * exceptions, so this function attempts to handle non-objects gracefully.
	 */
	function objCopy(obj) {
	    if (typeof obj === 'undefined' || obj === null) {  // null or undefined
	        return obj;
	    } else if (Array.isArray(obj)) {
	        return obj.slice();
	    } else if (typeof (obj) === 'object') {
	        var copy = {};
	        Object.keys(obj).forEach(function (k) {
	            copy[k] = obj[k];
	        });
	        return copy;
	    } else {
	        return obj;
	    }
	}
	
	var format = function(f) {
	
	    if(f === null) {
	        return 'null';
	    }
	
	    if(typeof f !== 'string') {
	        return f.toString();
	    }
	    var formatRegExp = /%[sdj%]/g;
	
	    var i = 1;
	    var args = arguments;
	    var len = args.length;
	    var str = String(f).replace(formatRegExp, function(x) {
	        if (x === '%%') {
	            return '%';
	        }
	        if (i >= len) {
	            return x;
	        }
	        switch (x) {
	            case '%s': return String(args[i++]);
	            case '%d': return Number(args[i++]);
	            case '%j':
	                try {
	                    return JSON.stringify(args[i++]);
	                } catch (_) {
	                    return '[Circular]';
	                }
	                break;
	            default:
	                return x;
	        }
	    });
	    for (var x = args[i]; i < len; x = args[++i]) {
	        str += ' ' + x;
	    }
	    return str;
	};
	
	/**
	 * Gather some caller info 3 stack levels up.
	 * See <http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi>.
	 */
	function getCaller3Info() {
	    var obj = {};
	    var saveLimit = Error.stackTraceLimit;
	    var savePrepare = Error.prepareStackTrace;
	    Error.stackTraceLimit = 3;
	    //Error.captureStackTrace(this, getCaller3Info);
	
	    Error.prepareStackTrace = function (_, stack) {
	        var caller = stack[2];
	        obj.file = caller.getFileName();
	        obj.line = caller.getLineNumber();
	        var func = caller.getFunctionName();
	        if (func) {
	            obj.func = func;
	        }
	    };
	    Error.stackTraceLimit = saveLimit;
	    Error.prepareStackTrace = savePrepare;
	    return obj;
	}
	
	
	function _indent(s, indent) {
	    if (!indent) {
	        indent = '    ';
	    }
	    var lines = s.split(/\r?\n/g);
	    return indent + lines.join('\n' + indent);
	}
	
	
	/**
	 * Warn about an bunyan processing error.
	 *
	 * @param msg {String} Message with which to warn.
	 * @param dedupKey {String} Optional. A short string key for this warning to
	 *      have its warning only printed once.
	 */
	function _warn(msg, dedupKey) {
	    if (dedupKey) {
	        if (_warned[dedupKey]) {
	            return;
	        }
	        _warned[dedupKey] = true;
	    }
	    console.error(msg + '\n');
	}
	function _haveWarned(dedupKey) {
	    return _warned[dedupKey];
	}
	var _warned = {};
	
	
	function ConsoleRawStream() {
	}
	ConsoleRawStream.prototype.write = function (rec) {
	    if (rec.level < INFO) {
	        console.log(rec);
	    } else if (rec.level < WARN) {
	        console.info(rec);
	    } else if (rec.level < ERROR) {
	        console.warn(rec);
	    } else {
	        console.error(rec);
	    }
	
	    if(rec.err && rec.err.stack) {
	        console.error(rec.err.stack);
	    }
	};
	
	function ConsoleFormattedStream() {}
	ConsoleFormattedStream.prototype.write = function (rec) {
	
	    var levelCss, defaultCss = 'color: DimGray', msgCss = 'color: SteelBlue';
	
	    if (rec.level < (false)) {
	        levelCss = 'color: DeepPink';
	    } else if (rec.level < INFO) {
	        levelCss = 'color: GoldenRod';
	    } else if (rec.level < WARN) {
	        levelCss = 'color: DarkTurquoise';
	    } else if (rec.level < ERROR) {
	        levelCss = 'color: Purple';
	    } else if (rec.level < FATAL) {
	        levelCss = 'color: Crimson';
	    } else {
	        levelCss = 'color: Black';
	    }
	
	    var loggerName = rec.childName ? rec.name + '/' + rec.childName : rec.name;
	
	    //get level name and pad start with spacs
	    var levelName = nameFromLevel[rec.level].toUpperCase();
	    levelName = Array(6 - levelName.length).join(' ') + levelName;
	
	    function padZeros(number, len) {
	        return Array((len + 1) - (number + '').length).join('0') + number;
	    }
	
	    console.log('[%s:%s:%s:%s] %c%s%c: %s: %c%s',
	        padZeros(rec.time.getHours(), 2), padZeros(rec.time.getMinutes(), 2),
	        padZeros(rec.time.getSeconds(), 2), padZeros(rec.time.getMilliseconds(), 4),
	        levelCss, levelName,
	        defaultCss, loggerName,
	        msgCss, rec.msg);
	    if(rec.err && rec.err.stack) {
	        console.log('%c%s,', levelCss, rec.err.stack);
	    }
	};
	
	//---- Levels
	
	var TRACE = 10;
	var DEBUG = 20;
	var INFO = 30;
	var WARN = 40;
	var ERROR = 50;
	var FATAL = 60;
	
	var levelFromName = {
	    'trace': TRACE,
	    'debug': DEBUG,
	    'info': INFO,
	    'warn': WARN,
	    'error': ERROR,
	    'fatal': FATAL
	};
	var nameFromLevel = {};
	Object.keys(levelFromName).forEach(function (name) {
	    nameFromLevel[levelFromName[name]] = name;
	});
	
	
	/**
	 * Resolve a level number, name (upper or lowercase) to a level number value.
	 *
	 * @api public
	 */
	function resolveLevel(nameOrNum) {
	    var level = (typeof (nameOrNum) === 'string' ? levelFromName[nameOrNum.toLowerCase()] : nameOrNum);
	    return level;
	}
	
	
	//---- Logger class
	
	/**
	 * Create a Logger instance.
	 *
	 * @param options {Object} See documentation for full details. At minimum
	 *    this must include a 'name' string key. Configuration keys:
	 *      - `streams`: specify the logger output streams. This is an array of
	 *        objects with these fields:
	 *          - `type`: The stream type. See README.md for full details.
	 *            Often this is implied by the other fields. Examples are
	 *            'file', 'stream' and "raw".
	 *          - `level`: Defaults to 'info'.
	 *          - `path` or `stream`: The specify the file path or writeable
	 *            stream to which log records are written. E.g.
	 *            `stream: process.stdout`.
	 *          - `closeOnExit` (boolean): Optional. Default is true for a
	 *            'file' stream when `path` is given, false otherwise.
	 *        See README.md for full details.
	 *      - `level`: set the level for a single output stream (cannot be used
	 *        with `streams`)
	 *      - `stream`: the output stream for a logger with just one, e.g.
	 *        `process.stdout` (cannot be used with `streams`)
	 *      - `serializers`: object mapping log record field names to
	 *        serializing functions. See README.md for details.
	 *      - `src`: Boolean (default false). Set true to enable 'src' automatic
	 *        field with log call source info.
	 *    All other keys are log record fields.
	 *
	 * An alternative *internal* call signature is used for creating a child:
	 *    new Logger(<parent logger>, <child options>[, <child opts are simple>]);
	 *
	 * @param _childSimple (Boolean) An assertion that the given `_childOptions`
	 *    (a) only add fields (no config) and (b) no serialization handling is
	 *    required for them. IOW, this is a fast path for frequent child
	 *    creation.
	 */
	function Logger(options, _childOptions, _childSimple) {
	    if (!(this instanceof Logger)) {
	        return new Logger(options, _childOptions);
	    }
	
	    // Input arg validation.
	    var parent;
	    if (_childOptions !== undefined) {
	        parent = options;
	        options = _childOptions;
	        if (!(parent instanceof Logger)) {
	            throw new TypeError(
	                'invalid Logger creation: do not pass a second arg');
	        }
	    }
	    if (!options) {
	        throw new TypeError('options (object) is required');
	    }
	    if (!parent) {
	        if (!options.name) {
	            throw new TypeError('options.name (string) is required');
	        }
	    } else {
	        if (options.name) {
	            throw new TypeError(
	                'invalid options.name: child cannot set logger name');
	        }
	    }
	    if (options.stream && options.streams) {
	        throw new TypeError('cannot mix "streams" and "stream" options');
	    }
	    if (options.streams && !Array.isArray(options.streams)) {
	        throw new TypeError('invalid options.streams: must be an array');
	    }
	    if (options.serializers && (typeof (options.serializers) !== 'object' || Array.isArray(options.serializers))) {
	        throw new TypeError('invalid options.serializers: must be an object');
	    }
	
	    var fields, name, i;
	
	    // Fast path for simple child creation.
	    if (parent && _childSimple) {
	        // `_isSimpleChild` is a signal to stream close handling that this child
	        // owns none of its streams.
	        this._isSimpleChild = true;
	
	        this._level = parent._level;
	        this.streams = parent.streams;
	        this.serializers = parent.serializers;
	        this.src = parent.src;
	        fields = this.fields = {};
	        var parentFieldNames = Object.keys(parent.fields);
	        for (i = 0; i < parentFieldNames.length; i++) {
	            name = parentFieldNames[i];
	            fields[name] = parent.fields[name];
	        }
	        var names = Object.keys(options);
	        for (i = 0; i < names.length; i++) {
	            name = names[i];
	            fields[name] = options[name];
	        }
	        return;
	    }
	
	    // Null values.
	    var self = this;
	    if (parent) {
	        this._level = parent._level;
	        this.streams = [];
	        for (i = 0; i < parent.streams.length; i++) {
	            var s = objCopy(parent.streams[i]);
	            s.closeOnExit = false; // Don't own parent stream.
	            this.streams.push(s);
	        }
	        this.serializers = objCopy(parent.serializers);
	        this.src = parent.src;
	        this.fields = objCopy(parent.fields);
	        if (options.level) {
	            this.level(options.level);
	        }
	    } else {
	        this._level = Number.POSITIVE_INFINITY;
	        this.streams = [];
	        this.serializers = null;
	        this.src = false;
	        this.fields = {};
	    }
	
	    // Handle *config* options (i.e. options that are not just plain data
	    // for log records).
	    if (options.stream) {
	        self.addStream({
	            type: 'stream',
	            stream: options.stream,
	            closeOnExit: false,
	            level: options.level
	        });
	    } else if (options.streams) {
	        options.streams.forEach(function (s) {
	            self.addStream(s, options.level);
	        });
	    } else if (parent && options.level) {
	        this.level(options.level);
	    } else if (!parent) {
	
	        /*
	         * In the browser we'll be emitting to console.log by default.
	         * Any console.log worth its salt these days can nicely render
	         * and introspect objects (e.g. the Firefox and Chrome console)
	         * so let's emit the raw log record. Are there browsers for which
	         * that breaks things?
	         */
	        self.addStream({
	            type: 'raw',
	            stream: new ConsoleRawStream(),
	            closeOnExit: false,
	            level: options.level
	        });
	
	    }
	    if (options.serializers) {
	        self.addSerializers(options.serializers);
	    }
	    if (options.src) {
	        this.src = true;
	    }
	
	    // Fields.
	    // These are the default fields for log records (minus the attributes
	    // removed in this constructor). To allow storing raw log records
	    // (unrendered), `this.fields` must never be mutated. Create a copy for
	    // any changes.
	    fields = objCopy(options);
	    delete fields.stream;
	    delete fields.level;
	    delete fields.streams;
	    delete fields.serializers;
	    delete fields.src;
	    if (this.serializers) {
	        this._applySerializers(fields);
	    }
	    Object.keys(fields).forEach(function (k) {
	        self.fields[k] = fields[k];
	    });
	}
	
	/**
	 * Add a stream
	 *
	 * @param stream {Object}. Object with these fields:
	 *    - `type`: The stream type. See README.md for full details.
	 *      Often this is implied by the other fields. Examples are
	 *      'file', 'stream' and "raw".
	 *    - `path` or `stream`: The specify the file path or writeable
	 *      stream to which log records are written. E.g.
	 *      `stream: process.stdout`.
	 *    - `level`: Optional. Falls back to `defaultLevel`.
	 *    - `closeOnExit` (boolean): Optional. Default is true for a
	 *      'file' stream when `path` is given, false otherwise.
	 *    See README.md for full details.
	 * @param defaultLevel {Number|String} Optional. A level to use if
	 *      `stream.level` is not set. If neither is given, this defaults to INFO.
	 */
	Logger.prototype.addStream = function addStream(s, defaultLevel) {
	    var self = this;
	    if (defaultLevel === null || defaultLevel === undefined) {
	        defaultLevel = INFO;
	    }
	
	    s = objCopy(s);
	
	    // Implicit 'type' from other args.
	    if (!s.type && s.stream) {
	        s.type = 'raw';
	    }
	    s.raw = (s.type === 'raw');  // PERF: Allow for faster check in `_emit`.
	
	    if (s.level) {
	        s.level = resolveLevel(s.level);
	    } else {
	        s.level = resolveLevel(defaultLevel);
	    }
	    if (s.level < self._level) {
	        self._level = s.level;
	    }
	
	    switch (s.type) {
	        case 'stream':
	            if (!s.closeOnExit) {
	                s.closeOnExit = false;
	            }
	            break;
	        case 'raw':
	            if (!s.closeOnExit) {
	                s.closeOnExit = false;
	            }
	            break;
	        default:
	            throw new TypeError('unknown stream type "' + s.type + '"');
	    }
	
	    self.streams.push(s);
	    delete self.haveNonRawStreams;  // reset
	};
	
	
	/**
	 * Add serializers
	 *
	 * @param serializers {Object} Optional. Object mapping log record field names
	 *    to serializing functions. See README.md for details.
	 */
	Logger.prototype.addSerializers = function addSerializers(serializers) {
	    var self = this;
	
	    if (!self.serializers) {
	        self.serializers = {};
	    }
	    Object.keys(serializers).forEach(function (field) {
	        var serializer = serializers[field];
	        if (typeof (serializer) !== 'function') {
	            throw new TypeError(format(
	                'invalid serializer for "%s" field: must be a function',
	                field));
	        } else {
	            self.serializers[field] = serializer;
	        }
	    });
	};
	
	
	/**
	 * Create a child logger, typically to add a few log record fields.
	 *
	 * This can be useful when passing a logger to a sub-component, e.g. a
	 * 'wuzzle' component of your service:
	 *
	 *    var wuzzleLog = log.child({component: 'wuzzle'})
	 *    var wuzzle = new Wuzzle({..., log: wuzzleLog})
	 *
	 * Then log records from the wuzzle code will have the same structure as
	 * the app log, *plus the component='wuzzle' field*.
	 *
	 * @param options {Object} Optional. Set of options to apply to the child.
	 *    All of the same options for a new Logger apply here. Notes:
	 *      - The parent's streams are inherited and cannot be removed in this
	 *        call. Any given `streams` are *added* to the set inherited from
	 *        the parent.
	 *      - The parent's serializers are inherited, though can effectively be
	 *        overwritten by using duplicate keys.
	 *      - Can use `level` to set the level of the streams inherited from
	 *        the parent. The level for the parent is NOT affected.
	 * @param simple {Boolean} Optional. Set to true to assert that `options`
	 *    (a) only add fields (no config) and (b) no serialization handling is
	 *    required for them. IOW, this is a fast path for frequent child
	 *    creation. See 'tools/timechild.js' for numbers.
	 */
	Logger.prototype.child = function (options, simple) {
	    return new (this.constructor)(this, options || {}, simple);
	};
	
	/**
	 * Get/set the level of all streams on this logger.
	 *
	 * Get Usage:
	 *    // Returns the current log level (lowest level of all its streams).
	 *    log.level() -> INFO
	 *
	 * Set Usage:
	 *    log.level(INFO)       // set all streams to level INFO
	 *    log.level('info')     // can use 'info' et al aliases
	 */
	Logger.prototype.level = function level(value) {
	    if (value === undefined) {
	        return this._level;
	    }
	    var newLevel = resolveLevel(value);
	    var len = this.streams.length;
	    for (var i = 0; i < len; i++) {
	        this.streams[i].level = newLevel;
	    }
	    this._level = newLevel;
	};
	
	
	/**
	 * Get/set the level of a particular stream on this logger.
	 *
	 * Get Usage:
	 *    // Returns an array of the levels of each stream.
	 *    log.levels() -> [TRACE, INFO]
	 *
	 *    // Returns a level of the identified stream.
	 *    log.levels(0) -> TRACE      // level of stream at index 0
	 *    log.levels('foo')           // level of stream with name 'foo'
	 *
	 * Set Usage:
	 *    log.levels(0, INFO)         // set level of stream 0 to INFO
	 *    log.levels(0, 'info')       // can use 'info' et al aliases
	 *    log.levels('foo', WARN)     // set stream named 'foo' to WARN
	 *
	 * Stream names: When streams are defined, they can optionally be given
	 * a name. For example,
	 *       log = new Logger({
	 *         streams: [
	 *           {
	 *             name: 'foo',
	 *             path: '/var/log/my-service/foo.log'
	 *             level: 'trace'
	 *           },
	 *         ...
	 *
	 * @param name {String|Number} The stream index or name.
	 * @param value {Number|String} The level value (INFO) or alias ('info').
	 *    If not given, this is a 'get' operation.
	 * @throws {Error} If there is no stream with the given name.
	 */
	Logger.prototype.levels = function levels(name, value) {
	    if (name === undefined) {
	        return this.streams.map(
	            function (s) {
	                return s.level;
	            });
	    }
	    var stream;
	    if (typeof (name) === 'number') {
	        stream = this.streams[name];
	        if (stream === undefined) {
	            throw new Error('invalid stream index: ' + name);
	        }
	    } else {
	        var len = this.streams.length;
	        for (var i = 0; i < len; i++) {
	            var s = this.streams[i];
	            if (s.name === name) {
	                stream = s;
	                break;
	            }
	        }
	        if (!stream) {
	            throw new Error(format('no stream with name "%s"', name));
	        }
	    }
	    if (value === undefined) {
	        return stream.level;
	    } else {
	        var newLevel = resolveLevel(value);
	        stream.level = newLevel;
	        if (newLevel < this._level) {
	            this._level = newLevel;
	        }
	    }
	};
	
	
	/**
	 * Apply registered serializers to the appropriate keys in the given fields.
	 *
	 * Pre-condition: This is only called if there is at least one serializer.
	 *
	 * @param fields (Object) The log record fields.
	 * @param excludeFields (Object) Optional mapping of keys to `true` for
	 *    keys to NOT apply a serializer.
	 */
	Logger.prototype._applySerializers = function (fields, excludeFields) {
	    var self = this;
	
	    // Check each serializer against these (presuming number of serializers
	    // is typically less than number of fields).
	    Object.keys(this.serializers).forEach(function (name) {
	        if (fields[name] === undefined ||
	            (excludeFields && excludeFields[name])) {
	            return;
	        }
	        try {
	            fields[name] = self.serializers[name](fields[name]);
	        } catch (err) {
	            _warn(format('bunyan: ERROR: Exception thrown from the "%s" ' +
	                    'Bunyan serializer. This should never happen. This is a bug' +
	                    'in that serializer function.\n%s',
	                name, err.stack || err));
	            fields[name] = format('(Error in Bunyan log "%s" serializer broke field. See stderr for details.)', name);
	        }
	    });
	};
	
	
	/**
	 * Emit a log record.
	 *
	 * @param rec {log record}
	 * @param noemit {Boolean} Optional. Set to true to skip emission
	 *      and just return the JSON string.
	 */
	Logger.prototype._emit = function (rec, noemit) {
	    var i;
	
	    // Lazily determine if this Logger has non-'raw' streams. If there are
	    // any, then we need to stringify the log record.
	    if (this.haveNonRawStreams === undefined) {
	        this.haveNonRawStreams = false;
	        for (i = 0; i < this.streams.length; i++) {
	            if (!this.streams[i].raw) {
	                this.haveNonRawStreams = true;
	                break;
	            }
	        }
	    }
	
	    // Stringify the object. Attempt to warn/recover on error.
	    var str;
	    if (noemit || this.haveNonRawStreams) {
	        try {
	            str = JSON.stringify(rec, safeCycles()) + '\n';
	        } catch (e) {
	            var dedupKey = e.stack.split(/\n/g, 2).join('\n');
	            _warn('bunyan: ERROR: Exception in ' +
	                    '`JSON.stringify(rec)`. You can install the ' +
	                    '"safe-json-stringify" module to have Bunyan fallback ' +
	                    'to safer stringification. Record:\n' +
	                    _indent(format('%s\n%s', rec, e.stack)),
	                dedupKey);
	            str = format('(Exception in JSON.stringify(rec): %j. See stderr for details.)\n', e.message);
	
	        }
	    }
	
	    if (noemit) {
	        return str;
	    }
	
	
	    var level = rec.level;
	    for (i = 0; i < this.streams.length; i++) {
	        var s = this.streams[i];
	        if (s.level <= level) {
	            s.stream.write(s.raw ? rec : str);
	        }
	    }
	
	    return str;
	};
	
	
	/**
	 * Build a log emitter function for level minLevel. I.e. this is the
	 * creator of `log.info`, `log.error`, etc.
	 */
	function mkLogEmitter(minLevel) {
	    return function () {
	        var log = this;
	
	        function mkRecord(args) {
	            var excludeFields;
	            if (args[0] instanceof Error) {
	                // `log.<level>(err, ...)`
	                fields = {
	                    // Use this Logger's err serializer, if defined.
	                    err: (log.serializers && log.serializers.err ? log.serializers.err(args[0]) : Logger.stdSerializers.err(args[0]))
	                };
	                excludeFields = {err: true};
	                if (args.length === 1) {
	                    msgArgs = [fields.err.message];
	                } else {
	                    msgArgs = Array.prototype.slice.call(args, 1);
	                }
	            } else if (typeof (args[0]) !== 'object' && args[0] !== null ||
	                Array.isArray(args[0])) {
	                // `log.<level>(msg, ...)`
	                fields = null;
	                msgArgs = Array.prototype.slice.call(args);
	            } else {  // `log.<level>(fields, msg, ...)`
	                fields = args[0];
	                msgArgs = Array.prototype.slice.call(args, 1);
	            }
	
	            // Build up the record object.
	            var rec = objCopy(log.fields);
	            rec.level = minLevel;
	            var recFields = (fields ? objCopy(fields) : null);
	            if (recFields) {
	                if (log.serializers) {
	                    log._applySerializers(recFields, excludeFields);
	                }
	                Object.keys(recFields).forEach(function (k) {
	                    rec[k] = recFields[k];
	                });
	            }
	            rec.levelName = nameFromLevel[minLevel];
	            rec.msg = format.apply(log, msgArgs);
	            if (!rec.time) {
	                rec.time = (new Date());
	            }
	            // Get call source info
	            if (log.src && !rec.src) {
	                rec.src = getCaller3Info();
	            }
	            rec.v = LOG_VERSION;
	
	            return rec;
	        }
	
	        var fields = null;
	        var msgArgs = arguments;
	        var rec = null;
	        if (!this._emit) {
	            /*
	             * Show this invalid Bunyan usage warning *once*.
	             *
	             * See <https://github.com/trentm/node-bunyan/issues/100> for
	             * an example of how this can happen.
	             */
	            var dedupKey = 'unbound';
	            if (!_haveWarned[dedupKey]) {
	                var caller = getCaller3Info();
	                _warn(format('bunyan usage error: %s:%s: attempt to log with an unbound log method: `this` is: %s',
	                        caller.file, caller.line, this.toString()),
	                    dedupKey);
	            }
	            return;
	        } else if (arguments.length === 0) {   // `log.<level>()`
	            return (this._level <= minLevel);
	        } else if (this._level > minLevel) {
	            /* pass through */
	        } else {
	            rec = mkRecord(msgArgs);
	            this._emit(rec);
	        }
	    };
	}
	
	
	/**
	 * The functions below log a record at a specific level.
	 *
	 * Usages:
	 *    log.<level>()  -> boolean is-trace-enabled
	 *    log.<level>(<Error> err, [<string> msg, ...])
	 *    log.<level>(<string> msg, ...)
	 *    log.<level>(<object> fields, <string> msg, ...)
	 *
	 * where <level> is the lowercase version of the log level. E.g.:
	 *
	 *    log.info()
	 *
	 * @params fields {Object} Optional set of additional fields to log.
	 * @params msg {String} Log message. This can be followed by additional
	 *    arguments that are handled like
	 *    [util.format](http://nodejs.org/docs/latest/api/all.html#util.format).
	 */
	Logger.prototype.trace = mkLogEmitter(TRACE);
	Logger.prototype.debug = mkLogEmitter(DEBUG);
	Logger.prototype.info = mkLogEmitter(INFO);
	Logger.prototype.warn = mkLogEmitter(WARN);
	Logger.prototype.error = mkLogEmitter(ERROR);
	Logger.prototype.fatal = mkLogEmitter(FATAL);
	
	
	//---- Standard serializers
	// A serializer is a function that serializes a JavaScript object to a
	// JSON representation for logging. There is a standard set of presumed
	// interesting objects in node.js-land.
	
	Logger.stdSerializers = {};
	
	/*
	 * This function dumps long stack traces for exceptions having a cause()
	 * method. The error classes from
	 * [verror](https://github.com/davepacheco/node-verror) and
	 * [restify v2.0](https://github.com/mcavage/node-restify) are examples.
	 *
	 * Based on `dumpException` in
	 * https://github.com/davepacheco/node-extsprintf/blob/master/lib/extsprintf.js
	 */
	function getFullErrorStack(ex) {
	    var ret = ex.stack || ex.toString();
	    if (ex.cause && typeof (ex.cause) === 'function') {
	        var cex = ex.cause();
	        if (cex) {
	            ret += '\nCaused by: ' + getFullErrorStack(cex);
	        }
	    }
	    return (ret);
	}
	
	// Serialize an Error object
	// (Core error properties are enumerable in node 0.4, not in 0.6).
	Logger.stdSerializers.err = function(err) {
	    if (!err || !err.stack) {
	        return err;
	    }
	
	    var obj = {
	        message: err.message,
	        name: err.name,
	        stack: getFullErrorStack(err),
	        code: err.code,
	        signal: err.signal
	    };
	    return obj;
	};
	
	
	// A JSON stringifier that handles cycles safely.
	// Usage: JSON.stringify(obj, safeCycles())
	function safeCycles() {
	    var seen = [];
	    return function (key, val) {
	        if (!val || typeof (val) !== 'object') {
	            return val;
	        }
	        if (seen.indexOf(val) !== -1) {
	            return '[Circular]';
	        }
	        seen.push(val);
	        return val;
	    };
	}
	
	//---- Exports
	
	module.exports = Logger;
	
	module.exports.TRACE = TRACE;
	module.exports.DEBUG = DEBUG;
	module.exports.INFO = INFO;
	module.exports.WARN = WARN;
	module.exports.ERROR = ERROR;
	module.exports.FATAL = FATAL;
	module.exports.resolveLevel = resolveLevel;
	module.exports.levelFromName = levelFromName;
	module.exports.nameFromLevel = nameFromLevel;
	
	module.exports.VERSION = VERSION;
	module.exports.LOG_VERSION = LOG_VERSION;
	
	module.exports.createLogger = function createLogger(options) {
	    return new Logger(options);
	};
	
	// Useful for custom `type == 'raw'` streams that may do JSON stringification
	// of log records themselves. Usage:
	//    var str = JSON.stringify(rec, bunyan.safeCycles());
	module.exports.safeCycles = safeCycles;
	
	//streams
	module.exports.ConsoleFormattedStream = ConsoleFormattedStream;
	module.exports.ConsoleRawStream = ConsoleRawStream;

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RawStream = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _browserBunyan = __webpack_require__(300);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var RawStream = exports.RawStream = function () {
	  function RawStream() {
	    _classCallCheck(this, RawStream);
	  }
	
	  _createClass(RawStream, [{
	    key: 'write',
	    value: function write(rec) {
	      console.log('[%s] %s: %s',
	      //                rec.time.toISOString(),
	      rec.name, _browserBunyan.nameFromLevel[rec.level], rec.msg);
	    }
	  }]);

	  return RawStream;
	}();

/***/ },
/* 302 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var common = exports.common = Object.freeze({
	  CONNECT_SUCCESS: 'Connect.Success',
	  CONNECT_FAILURE: 'Connect.Failure',
	  PUBLISH_START: 'Publish.Start',
	  PUBLISH_FAIL: 'Publish.Fail',
	  PUBLISH_INVALID_NAME: 'Publish.InvalidName',
	  UNPUBLISH_SUCCESS: 'Unpublish.Success',
	  PUBLISH_METADATA: 'Publish.Metadata'
	});
	
	var failover = exports.failover = Object.freeze({
	  PUBLISHER_REJECT: 'Publisher.Reject',
	  PUBLISHER_ACCEPT: 'Publisher.Accept'
	});
	
	var rtc = exports.rtc = Object.freeze({
	  MEDIA_STREAM_AVAILABLE: 'WebRTC.MediaStream.Available',
	  PEER_CONNECTION_AVAILABLE: 'WebRTC.PeerConnection.Available',
	  OFFER_START: 'WebRTC.Offer.Start',
	  OFFER_END: 'WebRTC.Offer.End',
	  ICE_TRICKLE_COMPLETE: 'WebRTC.IceTrickle.Complete'
	});
	
	var rtmp = exports.rtmp = Object.freeze({
	  EMBED_SUCCESS: 'FlashPlayer.Embed.Success',
	  EMBED_FAILURE: 'FlashPlayer.Embed.Failure'
	});

/***/ },
/* 303 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var common = exports.common = Object.freeze({
	  CONNECT_SUCCESS: 'Connect.Success',
	  CONNECT_FAILURE: 'Connect.Failure',
	  SUBSCRIBE_START: 'Subscribe.Start',
	  SUBSCRIBE_STOP: 'Subscribe.Stop',
	  SUBSCRIBE_FAIL: 'Subscribe.Fail',
	  SUBSCRIBE_INVALID_NAME: 'Subscribe.InvalidName',
	  SUBSCRIBE_METADATA: 'Subscribe.Metadata',
	  PLAY_UNPUBLISH: 'Subscriber.Play.Unpublish',
	  CONNECTION_CLOSED: 'Subscriber.Connection.Closed'
	});
	
	var failover = exports.failover = Object.freeze({
	  SUBSCRIBER_REJECT: 'Subscriber.Reject',
	  SUBSCRIBER_ACCEPT: 'Subscriber.Accept'
	});
	
	var rtc = exports.rtc = Object.freeze({
	  PEER_CONNECTION_AVAILABLE: 'WebRTC.PeerConnection.Available',
	  OFFER_START: 'WebRTC.Offer.Start',
	  OFFER_END: 'WebRTC.Offer.End',
	  ANSWER_START: 'WebRTC.Answer.Start',
	  ANSWER_END: 'WebRTC.Answer.End',
	  CANDIDATE_START: 'WebRTC.Candidate.Start',
	  CANDIDATE_END: 'WebRTC.Candidate.End',
	  ICE_TRICKLE_COMPLETE: 'WebRTC.IceTrickle.Complete'
	});
	
	var rtmp = exports.rtmp = Object.freeze({
	  EMBED_SUCCESS: 'FlashPlayer.Embed.Success',
	  EMBED_FAILURE: 'FlashPlayer.Embed.Failure'
	});

/***/ },
/* 304 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var common = exports.common = Object.freeze({
	  CONNECT_SUCCESS: 'Connect.Success',
	  CONNECT_FAILURE: 'Connect.Failure',
	  PROPERTY_UPDATE: 'SharedObject.PropertyUpdate',
	  METHOD_UPDATE: 'SharedObject.MethodUpdate'
	});

/***/ },
/* 305 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var PlaybackTypes = exports.PlaybackTypes = Object.freeze({
	  RTMP: 'rtmp',
	  RTC: 'rtc',
	  HLS: 'hls'
	});
	
	var PlaybackAudioEncoder = exports.PlaybackAudioEncoder = Object.freeze({
	  OPUS: 'Opus',
	  PCMU: 'PCMU',
	  PCMA: 'PCMA',
	  SPEEX: 'Speex',
	  NONE: 'NONE'
	});
	
	var PlaybackVideoEncoder = exports.PlaybackVideoEncoder = Object.freeze({
	  VP8: 'VP8',
	  H264: 'H264',
	  NONE: 'NONE'
	});

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Main entry for failover support of all subscriber implementations.
	 */
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RTMPSubscriber = exports.R5LiveSubscriber = exports.VideoJSSubscriber = exports.HLSSubscriber = exports.RTCSubscriber = exports.Red5ProSubscriber = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _red5proRtc = __webpack_require__(308);
	
	var _red5proRtc2 = _interopRequireDefault(_red5proRtc);
	
	var _red5proHls = __webpack_require__(319);
	
	var _red5proHls2 = _interopRequireDefault(_red5proHls);
	
	var _red5proRtmp = __webpack_require__(322);
	
	var _red5proRtmp2 = _interopRequireDefault(_red5proRtmp);
	
	var _red5proRtmpLive = __webpack_require__(324);
	
	var _red5proRtmpLive2 = _interopRequireDefault(_red5proRtmpLive);
	
	var _red5proRtmpVideojs = __webpack_require__(323);
	
	var _red5proRtmpVideojs2 = _interopRequireDefault(_red5proRtmpVideojs);
	
	var _implFactoryOrder = __webpack_require__(328);
	
	var _implFactoryOrder2 = _interopRequireDefault(_implFactoryOrder);
	
	var _promise = __webpack_require__(310);
	
	var _playback = __webpack_require__(305);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProSubscriber';
	var playbackFactory = new _implFactoryOrder2.default();
	
	var playbackImpl = function () {
	  var map = new Map();
	  map.set(_playback.PlaybackTypes.RTMP, _red5proRtmp2.default);
	  map.set(_playback.PlaybackTypes.RTC, _red5proRtc2.default);
	  map.set(_playback.PlaybackTypes.HLS, _red5proHls2.default);
	  return map;
	}();
	
	var Red5ProSubscriber = function (_EventEmitter) {
	  _inherits(Red5ProSubscriber, _EventEmitter);
	
	  function Red5ProSubscriber() {
	    _classCallCheck(this, Red5ProSubscriber);
	
	    // Configuration options
	    var _this = _possibleConstructorReturn(this, (Red5ProSubscriber.__proto__ || Object.getPrototypeOf(Red5ProSubscriber)).call(this));
	
	    _this._options = undefined;
	    // The playback view
	    _this._view = undefined;
	    // Selected failover subscriber.
	    _this._currentSubscriber = undefined;
	    // Default order.
	    _this._order = [_playback.PlaybackTypes.RTMP, _playback.PlaybackTypes.RTC, _playback.PlaybackTypes.HLS];
	    _this._boundBubbleSubscriberEvent = _this.bubbleSubscriberEvent.bind(_this);
	    return _this;
	  }
	
	  _createClass(Red5ProSubscriber, [{
	    key: 'getPlaybackOrder',
	    value: function getPlaybackOrder() {
	      return this._order;
	    }
	  }, {
	    key: 'setPlaybackOrder',
	    value: function setPlaybackOrder(order) {
	      // Allow for string value to define single item in order.
	      order = typeof order === 'string' ? [order] : order;
	
	      // Filter out values not available in enumeration of playback types.
	      var t = order.filter(function (entry) {
	        var key = void 0;
	        for (key in _playback.PlaybackTypes) {
	          if (_playback.PlaybackTypes[key].toLowerCase() === entry.toLowerCase()) {
	            return true;
	          }
	        }
	        return false;
	      }).map(function (entry) {
	        return entry.toLowerCase();
	      });
	
	      // Define new order.
	      this._order = [].concat(_toConsumableArray(new Set(t)));
	      (0, _log.debug)(NAME, '[orderupdate]: ' + this._order);
	      return this;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(playbackView) {
	      this._view = playbackView;
	      return this;
	    }
	  }, {
	    key: 'getPlaybackFromOrder',
	    value: function getPlaybackFromOrder(order, options) {
	      return playbackFactory.create(order, playbackImpl, options, 'init');
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var _this2 = this;
	
	      this._options = options;
	      var deferred = new _promise.DeferredPromise();
	      (0, _log.debug)(NAME, '[play]');
	      this.getPlaybackFromOrder(this._order, this._options).then(function (subscriber) {
	        (0, _log.debug)(NAME, '[playsuccess]: subscriber found ' + subscriber.getType());
	        subscriber.on('*', _this2._boundBubbleSubscriberEvent);
	        _this2._currentSubscriber = subscriber;
	        if (_this2._view) {
	          _this2._currentSubscriber.setView(_this2._view);
	        }
	        deferred.resolve(_this2._currentSubscriber);
	      }).catch(function (err) {
	        (0, _log.warn)(NAME, '[playerror]: Could not implement a subscriber: ' + err);
	        deferred.reject(err);
	      });
	      return deferred.promise;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      var _this3 = this;
	
	      var deferred = new _promise.DeferredPromise();
	      if (!this._currentSubscriber) {
	        (0, _log.warn)(NAME, '[stop]: Could not invoke stop() on undefined subscriber.');
	        deferred.reject('A current subscriber is not available to issue a :stop() command to.');
	      } else {
	        (0, _log.debug)(NAME, '[stop]: Invoking stop on held subscriber.');
	        this._currentSubscriber.stop().then(function () {
	          (0, _log.debug)(NAME, '[stopsuccess]');
	          _this3._currentSubscriber.off('*', _this3._boundBubbleSubscriberEvent);
	          _this3._currentSubscriber = undefined;
	          deferred.resolve();
	        }).catch(function (err) {
	          (0, _log.debug)(NAME, '[stoperror]: ' + err);
	          if (_this3._currentSubscriber) {
	            _this3._currentSubscriber.off('*', _this3._boundBubbleSubscriberEvent);
	          }
	          _this3._currentSubscriber = undefined;
	          deferred.reject(err);
	        });
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'bubbleSubscriberEvent',
	    value: function bubbleSubscriberEvent(subscriberEvent) {
	      this.trigger.call(this, subscriberEvent);
	    }
	  }, {
	    key: 'playbackTypes',
	    get: function get() {
	      return _playback.PlaybackTypes;
	    }
	  }, {
	    key: 'currentSubscriber',
	    get: function get() {
	      return this._currentSubscriber;
	    }
	  }]);
	
	  return Red5ProSubscriber;
	}(_eventEmitter2.default);
	
	exports.Red5ProSubscriber = Red5ProSubscriber;
	exports.RTCSubscriber = _red5proRtc2.default;
	exports.HLSSubscriber = _red5proHls2.default;
	exports.VideoJSSubscriber = _red5proRtmpVideojs2.default;
	exports.R5LiveSubscriber = _red5proRtmpLive2.default;
	/**
	 * Using the RTMPSubscriber will determine the RTMP-based Subscriber
	 * to be used based on `options.useVideoJS` property.
	 *
	 * If `options.useVideoJS` is left undefined, it will default to `true`
	 * If `options.useVideoJs` is defined, it is required to be a boolean value
	 *
	 * true: VideoJSSubscriber - utilizes the videojs lib and custom SWF.
	 * false: R5LiveSubscriber - utilized the default "live" SWF shipped with Red5 Pro examples.
	*/
	
	var RTMPSubscriber = exports.RTMPSubscriber = _red5proRtmp2.default;

/***/ },
/* 307 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var WILDCARD = '*';
	var WILDCARD_KEY = 'RED5PRO';
	
	var EventEmitter = function () {
	  function EventEmitter() {
	    _classCallCheck(this, EventEmitter);
	
	    this._callbacks = {};
	    this._callbacks[WILDCARD_KEY] = [];
	  }
	
	  _createClass(EventEmitter, [{
	    key: '_notify',
	    value: function _notify(callbacks, event) {
	      var i = void 0,
	          length = callbacks.length;
	      for (i = 0; i < length; i++) {
	        callbacks[i](event);
	      }
	    }
	  }, {
	    key: 'on',
	    value: function on(type, fn) {
	      if (typeof fn !== 'function') {
	        return;
	      }
	
	      if (type === WILDCARD) {
	        this._callbacks[WILDCARD_KEY].push(fn);
	        return;
	      }
	
	      if (this._callbacks[type] === undefined) {
	        this._callbacks[type] = [];
	      }
	
	      if (this._callbacks[type].indexOf(fn) === -1) {
	        this._callbacks[type].push(fn);
	      }
	    }
	  }, {
	    key: 'off',
	    value: function off(type, fn) {
	      var map = this._callbacks[type];
	      if (type === WILDCARD) {
	        map = this._callbacks[WILDCARD_KEY];
	      }
	      if (map) {
	        var index = map.indexOf(fn);
	        if (index !== -1) {
	          map.splice(index, 1);
	        }
	      }
	    }
	  }, {
	    key: 'trigger',
	    value: function trigger(event) {
	      var type = event.type;
	      if (this._callbacks[type]) {
	        this._notify(this._callbacks[type], event);
	      }
	      this._notify(this._callbacks[WILDCARD_KEY], event);
	    }
	  }]);
	
	  return EventEmitter;
	}();
	
	exports.default = EventEmitter;

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _event = __webpack_require__(313);
	
	var _socketHelperSub = __webpack_require__(314);
	
	var _socketHelperSub2 = _interopRequireDefault(_socketHelperSub);
	
	var _webrtcHelperSub = __webpack_require__(317);
	
	var _webrtcHelperSub2 = _interopRequireDefault(_webrtcHelperSub);
	
	var _promise = __webpack_require__(310);
	
	var _webrtc = __webpack_require__(318);
	
	var webrtc = _interopRequireWildcard(_webrtc);
	
	var _websocket = __webpack_require__(316);
	
	var websocket = _interopRequireWildcard(_websocket);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProRTCSubscriber';
	var defaultOptions = {
	  streamType: 'webrtc'
	};
	var generateSubscriptionId = function generateSubscriptionId() {
	  var id = Math.floor(Math.random() * 0x10000).toString(16);
	  return 'subscriber-' + id;
	};
	var endpointFromOptions = function endpointFromOptions(options) {
	  var protocol = options.wsprotocol || options.protocol;
	  var port = options.wsport || options.port;
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  var endpoint = protocol + '://' + options.host + ':' + port + '/' + appEndpoint + '?id=' + options.subscriptionId;
	  if (typeof options.connectionParams !== 'undefined') {
	    (function () {
	      var params = [];
	      Object.keys(options.connectionParams).forEach(function (key, index) {
	        // eslint-disable-line no-unused-vars
	        params.push([key, options.connectionParams[key]].join('='));
	      });
	      if (params.length > 0) {
	        endpoint += '&' + params.join('&');
	      }
	    })();
	  }
	  return endpoint;
	};
	
	var RTCSubscriber = function (_EventEmitter) {
	  _inherits(RTCSubscriber, _EventEmitter);
	
	  function RTCSubscriber() {
	    _classCallCheck(this, RTCSubscriber);
	
	    var _this = _possibleConstructorReturn(this, (RTCSubscriber.__proto__ || Object.getPrototypeOf(RTCSubscriber)).call(this));
	
	    _this._view = undefined;
	    _this._options = undefined;
	    _this._peerHelper = undefined;
	    _this._socketHelper = undefined;
	    _this._orientation = 0;
	    return _this;
	  }
	
	  _createClass(RTCSubscriber, [{
	    key: 'init',
	    value: function init(options) {
	      var deferred = new _promise.DeferredPromise();
	      if (!webrtc.isSupported() || !websocket.isSupported()) {
	        deferred.reject('Cannot create WebRTC playback instance. Your environment does not support WebRTC and/or WebSockets.');
	      } else {
	        this._options = Object.assign({}, defaultOptions, options);
	        this._options.subscriptionId = this._options.subscriptionId || generateSubscriptionId();
	        this._peerHelper = new _webrtcHelperSub2.default(this);
	        this._socketHelper = new _socketHelperSub2.default(this);
	        deferred.resolve(this);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	      //  TODO: Normalize returns to either all be chainable or not be chainable
	      return this;
	    }
	  }, {
	    key: 'requestAvailability',
	    value: function requestAvailability(streamName, type) {
	      (0, _log.debug)(NAME, '[requestavailability]');
	      // message on socket returns -> onStream(Un)Available
	      this._socketHelper.post({
	        isAvailable: streamName,
	        type: type
	      });
	      //  TODO: Normalize returns to either all be chainable or not be chainable
	      return this;
	    }
	  }, {
	    key: 'requestOffer',
	    value: function requestOffer(streamName, subscriptionId) {
	      var vEncoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
	      var aEncoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
	
	      (0, _log.debug)(NAME, '[requestoffer]');
	      var offer = {
	        requestOffer: streamName,
	        requestId: subscriptionId
	      };
	      if (typeof vEncoding !== 'undefined') {
	        offer.videoEncoding = vEncoding;
	      }
	      if (typeof aEncoding !== 'undefined') {
	        offer.audioEncoding = aEncoding;
	      }
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.OFFER_START, this));
	      // message on socket returns -> onSDPOffer
	      this._socketHelper.post(offer);
	    }
	  }, {
	    key: 'requestAnswer',
	    value: function requestAnswer(sdp) {
	      var _this2 = this;
	
	      (0, _log.debug)(NAME, '[requestanswer]');
	      // invokes -> sendAnswer
	      this._peerHelper.createAnswer(sdp).then(function (sessionDescription) {
	        (0, _log.debug)(NAME, '[onanswercreated]');
	        if (_this2._options.bandwidth) {
	          sessionDescription.sdp = webrtc.updateBandwidth(_this2._options.bandwidth, sessionDescription.sdp);
	        }
	        (0, _log.debug)(NAME, '[> sendanswer]');
	        _this2.sendAnswer(_this2._options.streamName, _this2._options.subscriptionId, sessionDescription);
	      }).catch(function (error) {
	        _this2.onSDPError(error);
	      });
	    }
	  }, {
	    key: 'sendAnswer',
	    value: function sendAnswer(streamName, subscriptionId, sdp) {
	      (0, _log.debug)(NAME, '[sendanswer]: streamname(' + streamName + '), subscriptionid(' + subscriptionId + ')');
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.ANSWER_START, this, sdp));
	      // message on socket response -> onAddIceCandidate
	      // message on peer response -> onaddstream
	      this._socketHelper.post({
	        handleAnswer: streamName,
	        requestId: subscriptionId,
	        data: {
	          sdp: sdp
	        }
	      });
	    }
	  }, {
	    key: 'sendCandidate',
	    value: function sendCandidate(candidate) {
	      (0, _log.debug)(NAME, '[sendcandidate]');
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.CANDIDATE_START, this, candidate));
	      // message on peer response -> onicecandidate
	      this._socketHelper.post({
	        handleCandidate: this._options.streamName,
	        requestId: this._options.subscriptionId,
	        data: {
	          candidate: candidate
	        }
	      });
	    }
	  }, {
	    key: 'sendSubscribe',
	    value: function sendSubscribe() {
	      (0, _log.debug)(NAME, '[sendsubscribe]');
	      this._socketHelper.post({
	        subscribe: this._options.streamName,
	        requestId: this._options.subscriptionId
	      });
	    }
	  }, {
	    key: 'onStreamAvailable',
	    value: function onStreamAvailable(receipt) {
	      (0, _log.debug)(NAME, '[onstreamavailable]: ' + JSON.stringify(receipt, null, 2));
	      this._connect(this._options.iceServers);
	    }
	  }, {
	    key: 'onStreamUnavailable',
	    value: function onStreamUnavailable(receipt) {
	      (0, _log.debug)(NAME, 'Stream ' + this._options.streamName + ' does not exist.');
	      (0, _log.debug)(NAME, '[onstreamunavailable]: ' + JSON.stringify(receipt, null, 2));
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_INVALID_NAME, this));
	      this._disconnect();
	    }
	  }, {
	    key: 'onSDPSuccess',
	    value: function onSDPSuccess(receipt) {
	      (0, _log.debug)(NAME, '[onsdpsuccess]: ' + JSON.stringify(receipt, null, 2));
	    }
	  }, {
	    key: 'onSDPOffer',
	    value: function onSDPOffer(receipt) {
	      (0, _log.debug)(NAME, '[onsdpoffer]: ' + JSON.stringify(receipt, null, 2));
	      var sdp = new webrtc.RTCSessionDescription(receipt.sdp);
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.OFFER_END, this));
	      this.requestAnswer(sdp);
	    }
	  }, {
	    key: 'onSDPError',
	    value: function onSDPError(receipt) {
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL, this, receipt));
	      (0, _log.error)(NAME, '[onsdperror]');
	      (0, _log.error)(receipt);
	    }
	  }, {
	    key: 'onAnswerMediaStream',
	    value: function onAnswerMediaStream() {
	      var stream = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
	      // eslint-disable-line no-unused-vars
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.ANSWER_END, this));
	    }
	  }, {
	    key: 'onIceCandidate',
	    value: function onIceCandidate(candidate) {
	      (0, _log.debug)(NAME, '[onicecandidate]');
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.CANDIDATE_END, this));
	      this.sendCandidate(candidate);
	    }
	  }, {
	    key: 'onIceCandidateTrickleEnd',
	    value: function onIceCandidateTrickleEnd(stream) {
	      (0, _log.debug)(NAME, '[onicetrickleend]');
	      this._view.attachStream(stream, this._options.autoplay || true);
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_START, this));
	    }
	  }, {
	    key: 'onAddIceCandidate',
	    value: function onAddIceCandidate(candidate) {
	      (0, _log.debug)(NAME, '[onaddicecandidate]');
	      this._peerHelper.addIceCandidate(candidate);
	    }
	  }, {
	    key: 'onSocketIceCandidateEnd',
	    value: function onSocketIceCandidateEnd() {
	      (0, _log.debug)(NAME, '[onsocketicecandidateend]');
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.ICE_TRICKLE_COMPLETE, this));
	      this.sendSubscribe();
	    }
	  }, {
	    key: 'onSocketMessageError',
	    value: function onSocketMessageError(message) {
	      var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	
	      (0, _log.error)(NAME, 'Error in stream subscription: ' + message + '.\n[Optional detail]: ' + detail);
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL, this, message));
	    }
	  }, {
	    key: 'onUnpublish',
	    value: function onUnpublish() {
	      (0, _log.debug)(NAME, '[onunpublish]');
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAY_UNPUBLISH, this));
	    }
	  }, {
	    key: 'onConnectionClosed',
	    value: function onConnectionClosed() {
	      (0, _log.debug)(NAME, '[onconnectionclosed]');
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECTION_CLOSED, this));
	    }
	  }, {
	    key: 'onMetadata',
	    value: function onMetadata(metadata) {
	      if (typeof metadata.orientation !== 'undefined' && metadata.orientation !== this._orientation) {
	        _browser2.default.applyOrientation(this._view.view, metadata.orientation);
	        this._orientation = metadata.orientation;
	      }
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_METADATA, this, metadata));
	    }
	  }, {
	    key: '_disconnect',
	    value: function _disconnect() {
	      (0, _log.debug)(NAME, '[disconnect]');
	      if (this._socketHelper) {
	        this._socketHelper.tearDown();
	      }
	      if (this._peerHelper) {
	        this._peerHelper.tearDown();
	      }
	    }
	  }, {
	    key: '_connect',
	    value: function _connect(iceServers) {
	      var _this3 = this;
	
	      (0, _log.debug)(NAME, '[connect]');
	      this._options.iceServers = iceServers;
	      var p = this._peerHelper.setUp(this._options.iceServers);
	      p.then(function () {
	        _this3.requestOffer(_this3._options.streamName, _this3._options.subscriptionId, _this3._options.videoEncoding, _this3._options.audioEncoding);
	      }).catch(function () {
	        (0, _log.warn)(NAME, 'Could not establish RTCPeerConnection.');
	        _this3.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE, _this3));
	      });
	      //  TODO: Normalize returns to either all be chainable or not be chainable
	      return this;
	    }
	  }, {
	    key: 'play',
	    value: function play() {
	      var _this4 = this;
	
	      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	      (0, _log.debug)(NAME, '[play]');
	      this._options.streamName = streamName || this._options.streamName;
	      var p = promise || new _promise.DeferredPromise();
	      var socketPromise = new _promise.DeferredPromise();
	      var socketurl = endpointFromOptions(this._options);
	      this._socketHelper.setUp(socketurl, socketPromise);
	      socketPromise.promise.then(function () {
	        p.resolve(_this4);
	        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_SUCCESS, _this4));
	        _this4.requestAvailability(_this4._options.streamName, _this4._options.streamType);
	      }).catch(function (error) {
	        p.reject(error);
	        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE, _this4, error));
	      });
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      (0, _log.debug)(NAME, '[stop]');
	      var deferred = new _promise.DeferredPromise();
	      this._disconnect();
	      this._view.stop();
	      deferred.resolve(this);
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.UNSUBSCRIBE_SUCCESS, this));
	      return deferred.promise;
	    }
	  }, {
	    key: 'getConnection',
	    value: function getConnection() {
	      return this._socketHelper;
	    }
	  }, {
	    key: 'getPeerConnection',
	    value: function getPeerConnection() {
	      return this._peerHelper ? this._peerHelper.connection : undefined;
	    }
	  }, {
	    key: 'getOptions',
	    value: function getOptions() {
	      return this._options;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'RTC';
	    }
	  }]);
	
	  return RTCSubscriber;
	}(_eventEmitter2.default);
	
	exports.default = RTCSubscriber;

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(310);
	
	var _errors = __webpack_require__(311);
	
	var _metadataUtil = __webpack_require__(312);
	
	var closeHandlers = [];
	function onwindowclose(e) {
	  // eslint-disable-line no-unused-vars
	  //  closeHandlers.forEach(h => h())
	  var i = void 0,
	      length = closeHandlers.length;
	  for (i = 0; i < length; i++) {
	    closeHandlers[i]();
	  }
	  // Returning a string value forces a leaving confirmation popup on the browser.
	  //  e.returnValue = 'goodbye'
	  //  return 'goodbye'
	}
	
	// https://github.com/videojs/video.js/blob/master/src/js/tech/flash.js#L476
	var flashVersion = function flashVersion() {
	  var version = '0,0,0';
	  // IE
	  try {
	    version = new window.ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
	
	    // other browsers
	  } catch (e) {
	    try {
	      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {
	        version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
	      }
	    } catch (err) {
	      // nada
	    }
	  }
	  return version.split(',');
	};
	
	var isMoz = !!navigator.mozGetUserMedia;
	navigator.getUserMedia = navigator.getUserMedia || navigator.mozGetUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia;
	
	var defaultUserMediaAudio = isMoz ? true : {
	  manditory: {
	    googAutoGainControl: true,
	    googHighpassFilter: true,
	    googEchoCancellation: true,
	    googNoiseSuppression: true
	  },
	  optional: [{
	    bandwidth: 50
	  }, {
	    echoCancellation: true
	  }]
	};
	var defaultUserMediaVideo = isMoz ? true : {
	  mandatory: {
	    minWidth: 320,
	    minHeight: 240,
	    minFrameRate: 4,
	    maxWidth: 640,
	    maxHeight: 480,
	    maxFrameRate: 24
	  },
	  optional: [{
	    bandwidth: 256
	  }]
	};
	
	var origin = ['webkitTransformOrigin', 'mozTransformOrigin', 'msTransformOrigin', 'oTransformOrigin', 'transformOrigin'];
	var styles = ['webkitTransform', 'mozTransform', 'msTransform', 'oTransform', 'transform'];
	var transition = ['webkitTransition', 'mozTransition', 'msTransition', 'oTransition', 'transition'];
	var rotationTranslations = {
	  '0': {
	    origin: 'center center',
	    transform: 'rotate(0deg)'
	  },
	  '90': {
	    origin: 'left top',
	    transform: 'rotate(90deg) translateY(-100%)'
	  },
	  '180': {
	    origin: 'center center',
	    transform: 'rotate(180deg)'
	  },
	  '270': {
	    origin: 'top left',
	    transform: 'rotate(270deg) translateX(-100%) translateY(0%)'
	  },
	  '-90': {
	    origin: 'left top',
	    transform: 'rotate(-90deg) translateX(-100%)'
	  },
	  '-180': {
	    origin: 'center center',
	    transform: 'rotate(-180deg)'
	  },
	  '-270': {
	    origin: 'top left',
	    transform: 'rotate(-270deg) translateY(-100%)'
	  }
	};
	
	exports.default = {
	  supportsWebSocket: function supportsWebSocket() {
	    return !!window.WebSocket;
	  },
	
	  supportsFlashVersion: function supportsFlashVersion(version) {
	    var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';
	
	    return flashVersion()[0] >= version.split(delimiter)[0];
	  },
	
	  resolveElement: function resolveElement(id) {
	    try {
	      var el = document.getElementById(id);
	      if (!el) {
	        throw new _errors.NoElementFoundError('Element with id(' + id + ') could not be found.');
	      }
	      return el;
	    } catch (e) {
	      throw new _errors.NoElementFoundError('Error in accessing element with id(' + id + '). ' + e.message);
	    }
	  },
	
	  createWebSocket: function createWebSocket(url) {
	    return new window.WebSocket(url);
	  },
	
	  setVideoSource: function setVideoSource(videoElement, mediaStream) {
	    var autoplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	
	    if (isMoz) {
	      videoElement['mozSrcObject'] = mediaStream;
	    } else {
	      videoElement.src = window.URL.createObjectURL(mediaStream);
	    }
	    if (autoplay) {
	      videoElement.play();
	    }
	  },
	
	  injectScript: function injectScript(url) {
	    var dfd = new _promise.DeferredPromise();
	    var script = document.createElement('script');
	    script.type = 'text/javascript';
	    script.onload = function () {
	      dfd.resolve();
	    };
	    script.onreadystatechange = function () {
	      if (script.readyState === 'loaded' || script.readyState === 'complete') {
	        script.onreadystatechange = null;
	        dfd.resolve();
	      }
	    };
	    script.src = url;
	    document.getElementsByTagName('head')[0].appendChild(script);
	    return dfd.promise;
	  },
	
	  setGlobal: function setGlobal(prop, value) {
	    window[prop] = value;
	  },
	
	  getSwfObject: function getSwfObject() {
	    return window.swfobject;
	  },
	
	  getEmbedObject: function getEmbedObject(id) {
	    return document.getElementById(id);
	  },
	
	  getElementId: function getElementId(el) {
	    return el.getAttribute('id');
	  },
	
	  getVideoJs: function getVideoJs() {
	    return window.videojs;
	  },
	
	  getUserMedia: function getUserMedia() {
	    var audio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    var video = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	    var deferred = new _promise.DeferredPromise();
	    navigator.getUserMedia({
	      audio: audio || defaultUserMediaAudio,
	      video: video || defaultUserMediaVideo
	    }, deferred.resolve, deferred.reject);
	    return deferred.promise;
	  },
	
	  getDefaultPublishConstraints: function getDefaultPublishConstraints() {
	    var audio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	    var video = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	    if (isMoz) {
	      return {
	        offerToReceiveVideo: video,
	        offerToReceiveAudio: audio
	      };
	    }
	    return {
	      mandatory: {
	        offerToReceiveVideo: video,
	        offerToReceiveAudio: audio
	      }
	    };
	  },
	
	  getIsMoz: function getIsMoz() {
	    return isMoz;
	  },
	
	  addCloseHandler: function addCloseHandler(handler) {
	    var insertValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
	
	    closeHandlers.slice(insertValue === -1 ? closeHandlers.length : insertValue, 0, handler);
	    if (window.onbeforeunload !== onwindowclose) {
	      window.onbeforeunload = onwindowclose;
	      window.addEventListener('unload', onwindowclose);
	    }
	  },
	
	  removeCloseHandler: function removeCloseHandler(handler) {
	    var i = closeHandlers.length;
	    while (--i > -1) {
	      if (closeHandlers[i] === handler) {
	        closeHandlers.slice(i, 1);
	        break;
	      }
	    }
	  },
	
	  onOrientationMetadata: _metadataUtil.onOrientationMetadata,
	
	  applyOrientation: function applyOrientation(element, value) {
	    var i = void 0,
	        length = styles.length;
	    value = value % 360;
	    var translations = rotationTranslations[value.toString()];
	    for (i = 0; i < length; i++) {
	      element.style[origin[i]] = translations.origin;
	      element.style[styles[i]] = translations.transform;
	      element.style[transition[i]] = 'transform 0.0s linear';
	    }
	  }
	
	};

/***/ },
/* 310 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _DeferredPromise = function _DeferredPromise() {
	  var _this = this;
	
	  _classCallCheck(this, _DeferredPromise);
	
	  this.resolve = undefined;
	  this.reject = undefined;
	  this.promise = new Promise(function (resolve, reject) {
	    _this.resolve = resolve;
	    _this.reject = reject;
	  });
	};
	
	var _Future = {
	  createIfNotExist: function createIfNotExist(deferredIfExist) {
	    var f = deferredIfExist;
	    if (!f) {
	      f = new _DeferredPromise();
	    }
	    return f;
	  }
	};
	
	var DeferredPromise = exports.DeferredPromise = _DeferredPromise;
	var Future = exports.Future = _Future;

/***/ },
/* 311 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NoElementFoundError = exports.NoElementFoundError = function NoElementFoundError(message) {
	  _classCallCheck(this, NoElementFoundError);
	
	  this.name = 'NoElementFound';
	  this.message = message;
	};

/***/ },
/* 312 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var jsonAttr = /['"](.*?)['"]:/gi;
	var jsonVal = /:['"](.*?)['"]/gi;
	
	function readUTF(data, start, len) {
	  var result = '',
	      offset = start,
	      end = start + len;
	  do {
	    result += String.fromCharCode(data[offset++]);
	  } while (offset < end);
	  return result;
	}
	
	function parseJSONForOrientation(text) {
	  try {
	    var value = JSON.parse(text);
	    if (value.hasOwnProperty('orientation')) {
	      return {
	        orientation: parseInt(value.orientation)
	      };
	    }
	    return undefined;
	  } catch (e) {
	    var match = jsonAttr.exec(text);
	    var match2 = void 0;
	    if (match && match.length > 1) {
	      match2 = jsonVal.exec(text);
	      if (match[1] === 'orientation' && match2 && match2.length > 1) {
	        return {
	          orientation: parseInt(match2[1])
	        };
	      }
	    }
	    return undefined;
	  }
	}
	
	var onOrientationMetadata = exports.onOrientationMetadata = function onOrientationMetadata(player, callback) {
	
	  var textTracks = typeof player.textTracks === 'function' ? player.textTracks() : player.textTracks;
	
	  if (textTracks) {
	
	    player.addTextTrack('metadata');
	
	    textTracks.addEventListener('addtrack', function (addTrackEvent) {
	
	      var track = addTrackEvent.track;
	      track.mode = 'hidden';
	      /**
	      var cue = new VTTCue(1.0, 0, 'Testing')
	      cue.id = 1
	      cue.pauseOnExit = false
	      track.addCue(cue)
	      */
	
	      track.addEventListener('cuechange', function (cueChangeEvent) {
	        var cues = void 0;
	        var i = void 0;
	        // Mostly Chrome.
	        if (cueChangeEvent && cueChangeEvent.currentTarget) {
	          cues = cueChangeEvent.currentTarget.cues;
	        } else if (undefined === undefined) {
	          cues = track.cues;
	          cues = cues && cues.length > 0 ? cues : track.activeCues;
	        } else if (undefined !== undefined) {
	          // Mostly Firefox & Safari.
	          cues = cues && cues.length > 0 ? cues : undefined.activeCues;
	        }
	        // Mostly failure.
	        cues = cues || [];
	        for (i = 0; i < cues.length; i++) {
	          var data = cues[i];
	          if (data.value) {
	            var text = typeof data.value.data === 'string' ? data.value.data : readUTF(data.value.data, 0, data.size);
	            var orientation = parseJSONForOrientation(text);
	            if (typeof orientation !== 'undefined') {
	              callback(orientation);
	              break;
	            }
	          }
	        }
	      });
	    });
	  }
	};

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _publisherEvent = __webpack_require__(302);
	
	Object.defineProperty(exports, 'PublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.common;
	  }
	});
	Object.defineProperty(exports, 'RTCPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.rtc;
	  }
	});
	Object.defineProperty(exports, 'RTMPPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.rtmp;
	  }
	});
	Object.defineProperty(exports, 'FailoverPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.failover;
	  }
	});
	
	var _subscriberEvent = __webpack_require__(303);
	
	Object.defineProperty(exports, 'SubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.common;
	  }
	});
	Object.defineProperty(exports, 'RTCSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.rtc;
	  }
	});
	Object.defineProperty(exports, 'RTMPSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.rtmp;
	  }
	});
	Object.defineProperty(exports, 'FailoverSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.failover;
	  }
	});
	
	var _sharedobjectEvent = __webpack_require__(304);
	
	Object.defineProperty(exports, 'SharedObjectEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _sharedobjectEvent.common;
	  }
	});
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Event = function () {
	  function Event(type) {
	    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	
	    _classCallCheck(this, Event);
	
	    this._type = type;
	    this._data = data;
	  }
	
	  _createClass(Event, [{
	    key: 'type',
	    get: function get() {
	      return this._type;
	    }
	  }, {
	    key: 'data',
	    get: function get() {
	      return this._data;
	    }
	  }]);
	
	  return Event;
	}();
	
	var PublisherEvent = function (_Event) {
	  _inherits(PublisherEvent, _Event);
	
	  function PublisherEvent(type, publisher, data) {
	    _classCallCheck(this, PublisherEvent);
	
	    var _this = _possibleConstructorReturn(this, (PublisherEvent.__proto__ || Object.getPrototypeOf(PublisherEvent)).call(this, type, data));
	
	    _this._publisher = publisher;
	    return _this;
	  }
	
	  _createClass(PublisherEvent, [{
	    key: 'publisher',
	    get: function get() {
	      return this._publisher;
	    }
	  }]);
	
	  return PublisherEvent;
	}(Event);
	
	var SubscriberEvent = function (_Event2) {
	  _inherits(SubscriberEvent, _Event2);
	
	  function SubscriberEvent(type, subscriber, data) {
	    _classCallCheck(this, SubscriberEvent);
	
	    var _this2 = _possibleConstructorReturn(this, (SubscriberEvent.__proto__ || Object.getPrototypeOf(SubscriberEvent)).call(this, type, data));
	
	    _this2._subscriber = subscriber;
	    return _this2;
	  }
	
	  _createClass(SubscriberEvent, [{
	    key: 'subscriber',
	    get: function get() {
	      return this._subscriber;
	    }
	  }]);
	
	  return SubscriberEvent;
	}(Event);
	
	var SharedObjectEvent = function (_Event3) {
	  _inherits(SharedObjectEvent, _Event3);
	
	  function SharedObjectEvent(type, sharedObjectName, data) {
	    _classCallCheck(this, SharedObjectEvent);
	
	    var _this3 = _possibleConstructorReturn(this, (SharedObjectEvent.__proto__ || Object.getPrototypeOf(SharedObjectEvent)).call(this, type, data));
	
	    _this3._name = sharedObjectName;
	    return _this3;
	  }
	
	  _createClass(SharedObjectEvent, [{
	    key: 'name',
	    get: function get() {
	      return this._name;
	    }
	  }]);
	
	  return SharedObjectEvent;
	}(Event);
	
	exports.PublisherEvent = PublisherEvent;
	exports.SubscriberEvent = SubscriberEvent;
	exports.SharedObjectEvent = SharedObjectEvent;

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _socketHelper = __webpack_require__(315);
	
	var _socketHelper2 = _interopRequireDefault(_socketHelper);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProSubscriptionSocket';
	
	var SubscriptionSocketHelper = function (_SocketHelper) {
	  _inherits(SubscriptionSocketHelper, _SocketHelper);
	
	  function SubscriptionSocketHelper(responder) {
	    _classCallCheck(this, SubscriptionSocketHelper);
	
	    return _possibleConstructorReturn(this, (SubscriptionSocketHelper.__proto__ || Object.getPrototypeOf(SubscriptionSocketHelper)).call(this, responder, NAME));
	  }
	
	  _createClass(SubscriptionSocketHelper, [{
	    key: 'respond',
	    value: function respond(message) {
	      //    console.log(message)
	      if (message.data) {
	        var json = this.getJsonFromSocketMessage(message);
	        try {
	          if (!_get(SubscriptionSocketHelper.prototype.__proto__ || Object.getPrototypeOf(SubscriptionSocketHelper.prototype), 'respond', this).call(this, message)) {
	            if (json.data !== undefined) {
	              if (json.data.sdp !== undefined) {
	                if (json.data.sdp.type === 'offer') {
	                  this._responder.onSDPOffer(json.data);
	                }
	              }
	              if (json.data.candidate !== undefined) {
	                this._responder.onAddIceCandidate(json.data.candidate);
	              }
	              if (json.data.type === 'status') {
	                if (json.data.code === 'NetConnection.ICE.TricleCompleted' || json.data.code === 'NetConnection.ICE.TrickleCompleted') {
	                  this._responder.onSocketIceCandidateEnd();
	                } else if (json.data.code === 'NetStream.Play.UnpublishNotify') {
	                  this._responder.onUnpublish();
	                } else if (json.data.code === 'NetConnection.Connect.Closed') {
	                  this._responder.onConnectionClosed();
	                }
	              }
	              if (json.data.hasOwnProperty('status')) {
	                if (json.data.status === 'NetStream.Play.UnpublishNotify') {
	                  this._responder.onUnpublish();
	                }
	              }
	              if (json.type !== undefined) {
	                if (json.type === 'metadata') {
	                  this._responder.onMetadata(json.data);
	                }
	              }
	            } else if (json.type !== undefined) {
	              if (json.type === 'metadata') {
	                this._responder.onMetadata(json.metadata);
	              }
	            }
	          }
	        } catch (e) {
	          (0, _log.error)(NAME, '[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
	          this._responder.onSocketMessageError('[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
	        }
	      } else {
	        (0, _log.warn)(NAME, '[ws.onmessage] - No Message Data.');
	      }
	    }
	  }]);
	
	  return SubscriptionSocketHelper;
	}(_socketHelper2.default);
	
	exports.default = SubscriptionSocketHelper;

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _websocket = __webpack_require__(316);
	
	var websocket = _interopRequireWildcard(_websocket);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SocketHelper = function () {
	  function SocketHelper(responder, name) {
	    _classCallCheck(this, SocketHelper);
	
	    this._responder = responder;
	    this._pendingPostRequests = [];
	    this._websocket = undefined;
	    this._connectionPromise = undefined;
	    this._name = name;
	    this._responseHandlers = [];
	    this._onclose = this.tearDown.bind(this);
	  }
	
	  _createClass(SocketHelper, [{
	    key: '_removeSocketHandlers',
	    value: function _removeSocketHandlers(ws) {
	      ws.onopen = undefined;
	      ws.onmessage = undefined;
	      ws.onerror = undefined;
	    }
	  }, {
	    key: '_addSocketHandlers',
	    value: function _addSocketHandlers(ws, promise) {
	      var _this = this;
	
	      ws.onopen = function () {
	        (0, _log.info)(_this._name, '[websocketopen]');
	        while (_this._pendingPostRequests.length > 0) {
	          _this.post(_this._pendingPostRequests.shift());
	        }
	      };
	
	      ws.onerror = function (error) {
	        _this.tearDown();
	        (0, _log.warn)(_this._name, '[websocketerror]: Error from WebSocket. ' + error.type);
	        promise.reject(error);
	      };
	
	      ws.onmessage = function (message) {
	        _this.respond(message);
	      };
	    }
	  }, {
	    key: 'setUp',
	    value: function setUp(url, setupPromise) {
	      this.tearDown();
	      this._connectionPromise = setupPromise;
	      _browser2.default.addCloseHandler(this._onclose);
	      this._websocket = websocket.create(url);
	      this._addSocketHandlers(this._websocket, this._connectionPromise);
	    }
	  }, {
	    key: 'tearDown',
	    value: function tearDown() {
	      this._pendingPostRequests.length = 0;
	      if (typeof this._websocket !== 'undefined') {
	        this._removeSocketHandlers(this._websocket);
	        this._websocket.close();
	      }
	      this._websocket = undefined;
	      while (this._responseHandlers.length > 0) {
	        this._responseHandlers.shift();
	      }
	      _browser2.default.removeCloseHandler(this._onclose);
	    }
	  }, {
	    key: 'getJsonFromSocketMessage',
	    value: function getJsonFromSocketMessage(message) {
	      try {
	        return typeof message.data === 'string' ? JSON.parse(message.data) : message.data;
	      } catch (e) {
	        (0, _log.warn)(this._name, 'Could not parse message as JSON. Message= ' + message.data + '. Error= ' + e.message);
	      }
	      return null;
	    }
	  }, {
	    key: 'addSharedObjectResponseHandler',
	    value: function addSharedObjectResponseHandler(handler) {
	      this._responseHandlers.push(handler);
	    }
	  }, {
	    key: 'removeSharedObjectResponseHandler',
	    value: function removeSharedObjectResponseHandler(handler) {
	      var i = this._responseHandlers.length;
	      var rHandler = void 0;
	      while (--i > -1) {
	        rHandler = this._responseHandlers[i];
	        if (rHandler === handler) {
	          this._responseHandlers.splice(i, 1);
	          return;
	        }
	      }
	    }
	  }, {
	    key: 'handleMessageResponse',
	    value: function handleMessageResponse(message) {
	      var i = void 0,
	          handler = void 0;
	      var length = this._responseHandlers.length;
	      for (i = 0; i < length; i++) {
	        handler = this._responseHandlers[i];
	        if (handler.respond(message)) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: 'post',
	    value: function post(sendRequest) {
	      if (this._websocket !== undefined && this._websocket.readyState === 1 /* WebSocket.OPEN */) {
	          try {
	            (0, _log.debug)(this._name, '[websocket-post]: ' + JSON.stringify(sendRequest, null, 2));
	            this._websocket.send(JSON.stringify(sendRequest));
	          } catch (e) {
	            (0, _log.debug)(this._name, 'Could not send request: ' + sendRequest + '. ' + e);
	          }
	        } else {
	        this._pendingPostRequests.push(sendRequest);
	      }
	    }
	  }, {
	    key: 'respond',
	    value: function respond(message) {
	      // eslint-disable-line no-unused-vars
	      var handled = this.handleMessageResponse(message);
	      if (!handled && message.data) {
	        var json = this.getJsonFromSocketMessage(message);
	        if (json === null) {
	          (0, _log.warn)(this._name, 'Determined websocket response not in correct format. Aborting message handle.');
	          return true;
	        }
	        (0, _log.debug)(this._name, '[websocket-response]: ' + JSON.stringify(json, null, 2));
	        if (json.isAvailable !== undefined) {
	          if (typeof json.isAvailable === 'boolean' && json.isAvailable) {
	            this._responder.onStreamAvailable(json);
	            return true;
	          } else {
	            this._responder.onStreamUnavailable(json);
	            return true;
	          }
	        } else if (json.data !== undefined) {
	          if (json.data.message !== undefined) {
	            if (json.data.type === 'error') {
	              this._responder.onSocketMessageError(json.data.message, json.data.detail);
	              return true;
	            }
	          } else if (json.data.type === 'status') {
	            if (json.data.code === 'NetConnection.Connect.Success') {
	              this._connectionPromise.resolve();
	              return true;
	            } else if (json.data.code === 'NetConnection.Connect.Rejected') {
	              this._connectionPromise.reject('NetConnection.Connect.Rejected');
	              return true;
	            }
	          } else if (json.data.type === 'error') {
	            if (json.data.code === 'NetConnection.Connect.Rejected') {
	              this._connectionPromise.reject('NetConnection.Connect.Rejected');
	              return true;
	            }
	          }
	        }
	      }
	      return handled;
	    }
	  }, {
	    key: 'getRemoteSharedObject',
	    value: function getRemoteSharedObject(name) {
	      this.post({
	        sharedObjectGetRemote: {
	          name: name
	        }
	      });
	    }
	  }, {
	    key: 'connectToSharedObject',
	    value: function connectToSharedObject(name) {
	      this.post({
	        sharedObjectConnect: {
	          name: name
	        }
	      });
	    }
	  }, {
	    key: 'sendToSharedObject',
	    value: function sendToSharedObject(name, callName, data) {
	      this.post({
	        sharedObjectSend: {
	          name: name,
	          call: callName,
	          params: [data]
	        }
	      });
	    }
	  }, {
	    key: 'sendPropertyToSharedObject',
	    value: function sendPropertyToSharedObject(name, key, value) {
	      this.post({
	        sharedObjectSetProperty: {
	          name: name,
	          key: key,
	          value: value
	        }
	      });
	    }
	  }, {
	    key: 'closeSharedObject',
	    value: function closeSharedObject(name) {
	      this.post({
	        sharedObjectClose: {
	          name: name
	        }
	      });
	    }
	  }]);
	
	  return SocketHelper;
	}();
	
	exports.default = SocketHelper;

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.create = exports.isSupported = undefined;
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var isSupported = exports.isSupported = function isSupported() {
	  return _browser2.default.supportsWebSocket();
	};
	
	var create = exports.create = function create(url) {
	  return _browser2.default.createWebSocket(url);
	};

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _webrtc = __webpack_require__(318);
	
	var webrtc = _interopRequireWildcard(_webrtc);
	
	var _promise = __webpack_require__(310);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProSubscriptionPeer';
	
	var SubscriptionPeerHelper = function () {
	  function SubscriptionPeerHelper(responder) {
	    _classCallCheck(this, SubscriptionPeerHelper);
	
	    this._responder = responder;
	    this._peerConnection = undefined;
	    this._pendingMediaStream = undefined;
	  }
	
	  _createClass(SubscriptionPeerHelper, [{
	    key: '_removeConnectionHandlers',
	    value: function _removeConnectionHandlers(connection) {
	      connection.onconnectionstatechange = undefined;
	      connection.onicecandidate = undefined;
	      connection.onaddstream = undefined;
	      connection.ontrack = undefined;
	    }
	  }, {
	    key: '_addConnectionHandlers',
	    value: function _addConnectionHandlers(connection, promise) {
	      var _this = this;
	
	      connection.onconnectionstatechange = function () {
	        if (connection.connectionState === 'connected') {
	          (0, _log.debug)(NAME, '[peerconnection:open]');
	          if (promise) {
	            promise.resolve(_this);
	          }
	        } else if (connection.connectionState === 'failed' || connection.connectionState === 'disconnected') {
	          (0, _log.warn)(NAME, '[peerconnection:error]');
	          if (promise) {
	            promise.reject();
	          }
	        }
	      };
	
	      connection.onicecandidate = function (event) {
	        (0, _log.debug)(NAME, '[peer.onicecandidate] - Peer Candidate: ' + event.candidate);
	        if (event.candidate) {
	          _this._responder.onIceCandidate(event.candidate);
	        } else if (event.candidate === null) {
	          // null means they have finished sending candidates back and forth?
	          _this._responder.onIceCandidateTrickleEnd(_this._pendingMediaStream);
	          _this._pendingMediaStream = undefined;
	        }
	      };
	
	      connection.onaddstream = function (event) {
	        (0, _log.debug)(NAME, 'Peer Add Stream: ' + event.stream);
	        if (event.stream) {
	          _this._pendingMediaStream = event.stream;
	          _this._responder.onAnswerMediaStream(event.stream);
	        }
	      };
	
	      connection.ontrack = function (event) {
	        (0, _log.debug)(NAME, 'Peer Add Stream: ' + event.streams);
	        if (event.streams && event.streams.length > 0) {
	          _this._pendingMediaStream = event.streams[0];
	        }
	      };
	    }
	  }, {
	    key: 'setUp',
	    value: function setUp(iceServers, setUpPromise) {
	      this.tearDown();
	      (0, _log.debug)(NAME, '[setup]');
	      var p = setUpPromise || new _promise.DeferredPromise();
	      try {
	        var peer = new webrtc.RTCPeerConnection({
	          iceServers: iceServers,
	          rtcpMuxPolicy: 'negotiate'
	        }, {
	          optional: [{ DtlsSrtpKeyAgreement: true }, { RtpDataChannels: false }, { googCpuOveruseDetection: true }]
	        });
	        this._peerConnection = peer;
	        this._addConnectionHandlers(peer);
	        p.resolve();
	      } catch (e) {
	        (0, _log.warn)(NAME, 'Could not create a RTCPeerConnection. Error: ' + e.message);
	        p.reject(e.message);
	      }
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'tearDown',
	    value: function tearDown() {
	      (0, _log.debug)(NAME, '[teardown]');
	      if (this._peerConnection) {
	        this._removeConnectionHandlers(this._peerConnection);
	        try {
	          this._peerConnection.close();
	        } catch (e) {
	          (0, _log.warn)(NAME, '[peerconnection.close] error: ' + e.message);
	        }
	      }
	      this._pendingMediaStream = undefined;
	      this._peerConnection = undefined;
	    }
	  }, {
	    key: 'createAnswer',
	    value: function createAnswer(sdp) {
	      var _this2 = this;
	
	      (0, _log.debug)(NAME, '[createanswer]');
	      var deferred = new _promise.DeferredPromise();
	
	      this._peerConnection.setRemoteDescription(sdp).then(this._responder.onSDPSuccess).catch(function (err) {
	        _this2._responder.onSDPError(err);
	      });
	
	      this._peerConnection.createAnswer().then(function (sessionDescription) {
	        _this2._peerConnection.setLocalDescription(sessionDescription).then(_this2._responder.onSDPSuccess).catch(function (err) {
	          _this2._responder.onSDPError(err);
	        });
	        deferred.resolve(sessionDescription);
	      }).catch(deferred.reject);
	
	      return deferred.promise;
	    }
	  }, {
	    key: 'addIceCandidate',
	    value: function addIceCandidate(candidate) {
	      (0, _log.debug)(NAME, '[addicecandidate]');
	      var iceCandidate = new webrtc.RTCIceCandidate({
	        sdpMLineIndex: candidate.sdpMLineIndex,
	        candidate: candidate.candidate
	      });
	      this._peerConnection.addIceCandidate(iceCandidate).then(function () {
	        // nada
	      }).catch(function (err) {
	        (0, _log.error)(NAME, 'Error in add of ICE Candidiate + ' + err);
	      });
	    }
	  }, {
	    key: 'connection',
	    get: function get() {
	      return this._peerConnection;
	    }
	  }]);
	
	  return SubscriptionPeerHelper;
	}();
	
	exports.default = SubscriptionPeerHelper;

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RTCSessionDescription = exports.RTCIceCandidate = exports.RTCPeerConnection = exports.updateBandwidth = exports.isSupported = undefined;
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/** -- handled by adapter.js -- */
	var _RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
	var _RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate || window.webkitRTCIceCandidate;
	var _RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription;
	
	var isSupported = exports.isSupported = function isSupported() {
	  return _RTCPeerConnection && _RTCIceCandidate && _RTCSessionDescription;
	};
	
	// https://github.com/muaz-khan/WebRTC-Experiment/blob/master/RTCPeerConnection/RTCPeerConnection-v1.6.js#L158
	// Muaz Khan     - github.com/muaz-khan
	// MIT License   - www.WebRTC-Experiment.com/licence
	// Documentation - github.com/muaz-khan/WebRTC-Experiment/tree/master/RTCPeerConnection
	var updateBandwidth = exports.updateBandwidth = function updateBandwidth(options, sdp) {
	  if (_browser2.default.getIsMoz()) {
	    return sdp;
	  }
	  sdp = sdp.replace(/b=AS([^\r\n]+\r\n)/g, '');
	  if (options.audio) {
	    sdp = sdp.replace(/a=mid:audio\r\n/g, 'a=mid:audio\r\nb=AS:' + options.audio + '\r\n');
	  }
	  if (options.video) {
	    sdp = sdp.replace(/a=mid:video\r\n/g, 'a=mid:video\r\nb=AS:' + options.video + '\r\n');
	  }
	  return sdp;
	};
	
	var RTCPeerConnection = exports.RTCPeerConnection = _RTCPeerConnection;
	var RTCIceCandidate = exports.RTCIceCandidate = _RTCIceCandidate;
	var RTCSessionDescription = exports.RTCSessionDescription = _RTCSessionDescription;

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(313);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _videojsSourceHandler = __webpack_require__(320);
	
	var _videojsSourceHandler2 = _interopRequireDefault(_videojsSourceHandler);
	
	var _promise = __webpack_require__(310);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProHLSSubscriber';
	var videojs = _browser2.default.getVideoJs();
	var defaultOptions = {
	  protocol: 'https',
	  port: 80,
	  mimeType: 'application/x-mpegURL',
	  swf: 'lib/red5pro/red5pro-video-js.swf'
	};
	var optionsToHlsURL = function optionsToHlsURL(options) {
	  var protocol = options.hlsprotocol ? options.hlsprotocol : options.protocol;
	  var port = options.hlsport ? options.hlsport : options.port;
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  return protocol + '://' + options.host + ':' + port + '/' + appEndpoint + '/' + options.streamName + '.m3u8';
	};
	
	var HLSSubscriber = function (_EventEmitter) {
	  _inherits(HLSSubscriber, _EventEmitter);
	
	  function HLSSubscriber() {
	    _classCallCheck(this, HLSSubscriber);
	
	    var _this = _possibleConstructorReturn(this, (HLSSubscriber.__proto__ || Object.getPrototypeOf(HLSSubscriber)).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._videojsHandler = undefined;
	    _this._boundBubbleSubscriberEvents = _this.bubbleSubscriberEvents.bind(_this);
	    return _this;
	  }
	
	  _createClass(HLSSubscriber, [{
	    key: 'bubbleSubscriberEvents',
	    value: function bubbleSubscriberEvents(event) {
	      this.trigger(new _event.SubscriberEvent(event.type, this, event.data));
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var deferred = new _promise.DeferredPromise();
	      if (!_browser2.default.getVideoJs()) {
	        deferred.reject('Could not resolve HLSSubscriber. Requires videojs library.');
	      } else {
	        this._options = Object.assign({}, defaultOptions, options);
	        deferred.resolve(this);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	      if (this._videojsHandler !== undefined) {
	        this._videojsHandler.off('*', this._boundBubbleSubscriberEvents);
	        this._videojsHandler.disconnect();
	        this._videojsHandler = undefined;
	      }
	      this._videojsHandler = new _videojsSourceHandler2.default(this._view.view, this.getType());
	      return this;
	    }
	  }, {
	    key: 'play',
	    value: function play() {
	      var _this2 = this;
	
	      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	      var p = promise || new _promise.DeferredPromise();
	      var urlRegex = /^http(|s).*\.m3u8/g;
	      this._options.streamName = streamName || this._options.streamName;
	      var url = this._options.streamName.match(urlRegex) ? this._options.streamName : optionsToHlsURL(this._options);
	      var type = this._options.mimeType;
	      var swfURL = this._options.swf;
	      if (_typeof(this._options) === 'object') {
	        type = this._options.rtmpMimeType || this._options.mimeType;
	      }
	      (0, _log.debug)(NAME, '[play]: URL(' + url + ').');
	      this._videojsHandler.on('*', this._boundBubbleSubscriberEvents);
	      this._videojsHandler.addSource(url, type, videojs, swfURL).then(function () {
	        p.resolve(_this2);
	        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_SUCCESS));
	      }).catch(function (error) {
	        p.reject(error);
	        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE));
	      });
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      (0, _log.debug)(NAME, '[stop]');
	      var deferred = new _promise.DeferredPromise();
	      try {
	        this._videojsHandler.off('*', this._boundBubbleSubscriberEvents);
	        this._videojsHandler.disconnect();
	        deferred.resolve();
	      } catch (e) {
	        deferred.reject(e.message);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'getOptions',
	    value: function getOptions() {
	      return this._options;
	    }
	  }, {
	    key: 'getPlayer',
	    value: function getPlayer() {
	      return this._videojsHandler.getPlayer();
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'HLS';
	    }
	  }]);
	
	  return HLSSubscriber;
	}(_eventEmitter2.default);
	
	exports.default = HLSSubscriber;

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Base handler for utilizing the videojs
	 * library to intergate playback of live video.
	 *
	 * @see red5pro-hls
	 * @see red5pro-rtmp
	 */
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(313);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _object = __webpack_require__(321);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProBaseVideoJSHandler';
	
	var videojs = _browser2.default.getVideoJs();
	var mimeType = 'video/webm';
	var optionsToURL = function optionsToURL(options) {
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  return options.protocol + '://' + options.host + ':' + options.port + '/' + appEndpoint + '/' + options.streamName;
	};
	
	var BaseHandler = function (_EventEmitter) {
	  _inherits(BaseHandler, _EventEmitter);
	
	  function BaseHandler(video) {
	    var playerType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	    _classCallCheck(this, BaseHandler);
	
	    var _this = _possibleConstructorReturn(this, (BaseHandler.__proto__ || Object.getPrototypeOf(BaseHandler)).call(this));
	
	    _this.video = video;
	    _this.clone = _this.video.cloneNode(true);
	    _this.holder = _this.video.parentNode;
	    _this.videojs = null;
	    _this.source = null;
	    _this.playerType = playerType;
	    _this.hasAssignedEventListeners = false;
	
	    //  TODO: Temporary adjustment. Better to pass videojs up the chain so end users can set their own handlers.
	    _this.onVideoJSError = _this.onVideoJSError.bind(_this);
	    _this.onVideoJSLoadedData = _this.onVideoJSLoadedData.bind(_this);
	    _this.onVideoJSLoadedMetadata = _this.onVideoJSLoadedMetadata.bind(_this);
	    _this.onVideoJSTimeUpdate = _this.onVideoJSTimeUpdate.bind(_this);
	    _this.onVideoJSUserActive = _this.onVideoJSUserActive.bind(_this);
	    _this.onVideoJSUserInactive = _this.onVideoJSUserInactive.bind(_this);
	    _this.onVideoJSVolumeChange = _this.onVideoJSVolumeChange.bind(_this);
	    _this.onVideoJSEnded = _this.onVideoJSEnded.bind(_this);
	    return _this;
	  }
	
	  //  Assign all video.js listeners (those which are listed on http://docs.videojs.com/docs/api/player.html#events)
	
	
	  _createClass(BaseHandler, [{
	    key: 'addVideoJSEventListeners',
	    value: function addVideoJSEventListeners() {
	      if (this.hasAssignedEventListeners) {
	        return;
	      }
	      this.videojs.on('error', this.onVideoJSError);
	      this.videojs.on('loadeddata', this.onVideoJSLoadedData);
	      this.videojs.on('loadedmetadata', this.onVideoJSLoadedMetadata);
	      this.videojs.on('timeupdate', this.onVideoJSTimeUpdate);
	      this.videojs.on('useractive', this.onVideoJSUserActive);
	      this.videojs.on('userinactive', this.onVideoJSUserInactive);
	      this.videojs.on('volumechange', this.onVideoJSVolumeChange);
	      this.videojs.on('ended', this.onVideoJSEnded);
	      this.hasAssignedEventListeners = true;
	    }
	
	    //  Remove all video.js listeners (those which are listed on http://docs.videojs.com/docs/api/player.html#events)
	
	  }, {
	    key: 'removeVideoJSEventListeners',
	    value: function removeVideoJSEventListeners() {
	      if (!this.hasAssignedEventListeners) {
	        return;
	      }
	      this.videojs.off('error', this.onVideoJSError);
	      this.videojs.off('loadeddata', this.onVideoJSLoadedData);
	      this.videojs.off('loadedmetadata', this.onVideoJSLoadedMetadata);
	      this.videojs.off('timeupdate', this.onVideoJSTimeUpdate);
	      this.videojs.off('useractive', this.onVideoJSUserActive);
	      this.videojs.off('userinactive', this.onVideoJSUserInactive);
	      this.videojs.off('volumechange', this.onVideoJSVolumeChange);
	      this.videojs.off('ended', this.onVideoJSEnded);
	      this.hasAssignedEventListeners = false;
	    }
	
	    //  Cleanup our <source> if it exists
	
	  }, {
	    key: 'cleanup',
	    value: function cleanup() {
	      if (this.source) {
	        this.source.remove();
	      }
	      this.source = null;
	    }
	
	    //  Cleanup our video.js implementation
	
	  }, {
	    key: 'cleanupVideoJS',
	    value: function cleanupVideoJS() {
	      if (this.videojs) {
	        this.video.remove();
	        this.removeVideoJSEventListeners();
	        this.videojs.dispose();
	        //  This recreates our original <video> element and appends it to the original containing element
	        this.video = this.clone.cloneNode(true);
	        this.holder.appendChild(this.video);
	      }
	      this.videojs = null;
	    }
	
	    //  Add a new <source> for our <video> and startup video.js
	
	  }, {
	    key: 'addSource',
	    value: function addSource(src) {
	      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : mimeType;
	      var videoImpl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : videojs;
	      var swfURL = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	
	      var self = this;
	
	      function createSource(_src, _type) {
	        var sourceEl = document.createElement('source');
	        sourceEl.src = _src;
	        sourceEl.type = _type;
	        return sourceEl;
	      }
	
	      function insertSourceInto(_src, _type, _parent) {
	        var sourceEl = createSource(_src, _type);
	        if (_parent.firstChild) {
	          _parent.insertBefore(sourceEl, _parent.firstChild);
	        } else {
	          _parent.appendChild(sourceEl);
	        }
	        return sourceEl;
	      }
	
	      return new Promise(function (resolve, reject) {
	        try {
	          (function () {
	            //  If we have a current <source> element, remove it
	            self.cleanup();
	            //  If video.js has already been instantiated, dispose of it
	            self.cleanupVideoJS();
	
	            //  Create the new <source> element
	            var srcURL = typeof src === 'string' ? src : optionsToURL(src);
	            var mimeType = typeof src === 'string' ? type : src.mimeType ? src.mimeType : type;
	            (0, _log.debug)(NAME, '"' + self.playerType + '" loading ' + srcURL);
	            self.source = insertSourceInto(srcURL, mimeType, self.video);
	
	            //  Instantiate video.js
	            var opts = {
	              techOrder: ['html5', 'flash']
	            };
	            if (swfURL) {
	              (0, _object.deepDefine)(videoImpl, ['options', 'flash', 'swf'], swfURL);
	            }
	
	            var orientation = 0;
	            self.videojs = videoImpl(self.video, opts, function () {
	              (0, _log.debug)(NAME, 'videoJS embed complete.');
	              var player = self.getPlayer();
	              if (player) {
	                _browser2.default.onOrientationMetadata(player, function (metadata) {
	                  (0, _log.debug)(NAME, 'Metadata received: ' + JSON.stringify(metadata, null, 2));
	                  if (orientation !== metadata.orientation) {
	                    _browser2.default.applyOrientation(self.video, metadata.orientation);
	                    self.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_METADATA, metadata));
	                  }
	                  orientation = metadata.orientation;
	                });
	              }
	              resolve(self);
	            });
	            self.addVideoJSEventListeners();
	          })();
	        } catch (e) {
	          (0, _log.error)(NAME, 'Could not instantiate new VideoJS-based "' + self.playerType + '" Player.\nReason: ' + e.message);
	          reject('Could not instantiate new VideoJS-based "' + self.playerType + '" Player.\nReason: ' + e.message);
	        }
	      });
	    }
	  }, {
	    key: 'onVideoJSError',
	    value: function onVideoJSError(e) {
	      (0, _log.error)(NAME, 'onVideoJSError: ' + JSON.stringify(e, null, 2));
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL, null, e));
	    }
	  }, {
	    key: 'onVideoJSLoadedData',
	    value: function onVideoJSLoadedData() {
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_START));
	    }
	  }, {
	    key: 'onVideoJSEnded',
	    value: function onVideoJSEnded() {
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_STOP));
	    }
	  }, {
	    key: 'onVideoJSLoadedMetadata',
	    value: function onVideoJSLoadedMetadata() {}
	  }, {
	    key: 'onVideoJSTimeUpdate',
	    value: function onVideoJSTimeUpdate() {}
	  }, {
	    key: 'onVideoJSUserActive',
	    value: function onVideoJSUserActive() {}
	  }, {
	    key: 'onVideoJSUserInactive',
	    value: function onVideoJSUserInactive() {}
	  }, {
	    key: 'onVideoJSVolumeChange',
	    value: function onVideoJSVolumeChange() {}
	  }, {
	    key: 'addSharedObjectResponseHandler',
	    value: function addSharedObjectResponseHandler(handler) {// eslint-disable-line no-unused-vars
	      // unsupported at the moment.
	    }
	  }, {
	    key: 'removeSharedObjectResponseHandler',
	    value: function removeSharedObjectResponseHandler(handler) {// eslint-disable-line no-unused-vars
	      // unsupported at the moment.
	    }
	  }, {
	    key: 'sendToSharedObject',
	    value: function sendToSharedObject(name, callName, message) {// eslint-disable-line no-unused-vars
	      // unsupported at the moment.
	    }
	  }, {
	    key: 'sendPropertyToSharedObject',
	    value: function sendPropertyToSharedObject(name, key, value) {// eslint-disable-line no-unused-vars
	      // unsupported at the moment.
	    }
	  }, {
	    key: 'getRemoteSharedObject',
	    value: function getRemoteSharedObject(sharedObjectName) {// eslint-disable-line no-unused-vars
	      // unsupported at the moment.
	    }
	  }, {
	    key: 'connectToSharedObject',
	    value: function connectToSharedObject(sharedObjectName) {// eslint-disable-line no-unused-vars
	      // unsupported at the moment.
	    }
	  }, {
	    key: 'disconnectFromSharedObject',
	    value: function disconnectFromSharedObject(sharedObjectName) {// eslint-disable-line no-unused-vars
	      // unsupported at the moment.
	    }
	  }, {
	    key: 'getPlayer',
	    value: function getPlayer() {
	      return this.videojs;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return this.playerType;
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      try {
	        this.video.pause();
	      } catch (e) {
	        // nada.
	      }
	      this.cleanup();
	      this.cleanupVideoJS();
	    }
	  }]);
	
	  return BaseHandler;
	}(_eventEmitter2.default);
	
	exports.default = BaseHandler;

/***/ },
/* 321 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Modifies target `object` in place with a namespaced value.
	 */
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var deepDefine = exports.deepDefine = function deepDefine(object, paths, value) {
	  var i = 0;
	  var tail = object;
	  var prop = paths.pop();
	  var length = paths.length;
	  for (i; i < length; i++) {
	    var path = paths[i];
	    tail[path] = tail[path] || {};
	    tail = tail[path];
	  }
	  tail[prop] = value;
	};

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _red5proRtmpVideojs = __webpack_require__(323);
	
	var _red5proRtmpVideojs2 = _interopRequireDefault(_red5proRtmpVideojs);
	
	var _red5proRtmpLive = __webpack_require__(324);
	
	var _red5proRtmpLive2 = _interopRequireDefault(_red5proRtmpLive);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProRTMPSubscriberProxy';
	
	var RTMPSubscriberProxy = function (_EventEmitter) {
	  _inherits(RTMPSubscriberProxy, _EventEmitter);
	
	  function RTMPSubscriberProxy() {
	    _classCallCheck(this, RTMPSubscriberProxy);
	
	    var _this = _possibleConstructorReturn(this, (RTMPSubscriberProxy.__proto__ || Object.getPrototypeOf(RTMPSubscriberProxy)).call(this));
	
	    _this._view = undefined;
	    _this._boundBubbleSubImplEvent = _this.bubbleSubscriberEvent.bind(_this);
	    return _this;
	  }
	
	  _createClass(RTMPSubscriberProxy, [{
	    key: 'init',
	    value: function init(options) {
	      var impl = void 0;
	      (0, _log.debug)(NAME, 'Options property for useVideoJS: ' + options.useVideoJS + '.');
	      if (options.hasOwnProperty('useVideoJS') && typeof options.useVideoJS === 'boolean' && options.useVideoJS) {
	        (0, _log.debug)(NAME, 'Default to RTMPSubscriber using videojs support.');
	        impl = new _red5proRtmpVideojs2.default();
	        impl.on('*', this._boundBubbleSubImplEvent);
	      } else {
	        (0, _log.debug)(NAME, 'Defaulting to RTMPSubscriber using custom live SWF.');
	        impl = new _red5proRtmpLive2.default();
	        impl.on('*', this._boundBubbleSubImplEvent);
	      }
	      if (this._view) {
	        impl.setView(this._view);
	        this._view = undefined;
	      }
	      return impl.init(options);
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	    }
	  }, {
	    key: 'bubbleSubscriberEvent',
	    value: function bubbleSubscriberEvent(subscriberEvent) {
	      this.trigger.call(this, subscriberEvent);
	    }
	  }, {
	    key: 'getOptions',
	    value: function getOptions() {
	      return this._options;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'RTMPSubscriberProxy';
	    }
	  }]);
	
	  return RTMPSubscriberProxy;
	}(_eventEmitter2.default);
	
	exports.default = RTMPSubscriberProxy;

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _videojsSourceHandler = __webpack_require__(320);
	
	var _videojsSourceHandler2 = _interopRequireDefault(_videojsSourceHandler);
	
	var _promise = __webpack_require__(310);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProRTMPSubscriber';
	var videojs = _browser2.default.getVideoJs();
	var defaultMimeType = 'rtmp/flv';
	var defaultFlashVersion = '10.0.0';
	var defaultSWF = 'lib/red5pro/red5pro-video-js.swf';
	var optionsToRtmpURL = function optionsToRtmpURL(options) {
	  var protocol = options.rtmpprotocol ? options.rtmpprotocol : options.protocol;
	  var port = options.rtmpport ? options.rtmpport : options.port;
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  return protocol + '://' + options.host + ':' + port + '/' + appEndpoint + '/' + options.streamName;
	};
	
	var VideoJSSubscriber = function (_EventEmitter) {
	  _inherits(VideoJSSubscriber, _EventEmitter);
	
	  function VideoJSSubscriber() {
	    _classCallCheck(this, VideoJSSubscriber);
	
	    var _this = _possibleConstructorReturn(this, (VideoJSSubscriber.__proto__ || Object.getPrototypeOf(VideoJSSubscriber)).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._videojsHandler = undefined;
	    _this._boundBubbleSubscriberEvents = _this.bubbleSubscriberEvents.bind(_this);
	    return _this;
	  }
	
	  _createClass(VideoJSSubscriber, [{
	    key: 'bubbleSubscriberEvents',
	    value: function bubbleSubscriberEvents(event) {
	      this.trigger.call(this, event);
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var deferred = new _promise.DeferredPromise();
	      if (!_browser2.default.supportsFlashVersion(defaultFlashVersion)) {
	        deferred.reject('Could not resolve RTMPSubscriber instance. Requires minimum Flash Player install of ' + defaultFlashVersion + '.');
	      } else if (!_browser2.default.getVideoJs()) {
	        deferred.reject('Could not resolve RTMPSubscriber instance. Requires videojs library.');
	      } else {
	        this._options = options;
	        deferred.resolve(this);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	      if (this._videojsHandler !== undefined) {
	        this._videojsHandler.off('*', this._boundBubbleSubscriberEvents);
	        this._videojsHandler.disconnect();
	        this._videojsHandler = undefined;
	      }
	      if (view) {
	        this._videojsHandler = new _videojsSourceHandler2.default(this._view.view, this.getType());
	      }
	      return this;
	    }
	  }, {
	    key: 'play',
	    value: function play() {
	      var _this2 = this;
	
	      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	      var p = promise || new _promise.DeferredPromise();
	      this._options.streamName = streamName || this._options.streamName;
	      var url = optionsToRtmpURL(this._options);
	      var type = defaultMimeType;
	      var swfURL = defaultSWF;
	      if (_typeof(this._options) === 'object') {
	        type = this._options.rtmpMimeType || this._options.mimeType || type;
	        swfURL = this._options.swf || swfURL;
	      }
	      (0, _log.debug)(NAME, '[play]: URL(' + url + ').');
	      this._videojsHandler.on('*', this._boundBubbleSubscriberEvents);
	      this._videojsHandler.addSource(url, type, videojs, swfURL).then(function () {
	        p.resolve(_this2);
	      }).catch(p.reject);
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      (0, _log.debug)(NAME, '[stop]');
	      var deferred = new _promise.DeferredPromise();
	      try {
	        this._videojsHandler.off('*', this._boundBubbleSubscriberEvents);
	        this._videojsHandler.disconnect();
	        deferred.resolve();
	      } catch (e) {
	        deferred.reject(e.message);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'getConnection',
	    value: function getConnection() {
	      return this._videojsHandler;
	    }
	  }, {
	    key: 'getOptions',
	    value: function getOptions() {
	      return this._options;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'RTMP - VideoJS';
	    }
	  }]);
	
	  return VideoJSSubscriber;
	}(_eventEmitter2.default);
	
	exports.default = VideoJSSubscriber;

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(313);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _promise = __webpack_require__(310);
	
	var _liveSourceHandler = __webpack_require__(325);
	
	var _liveSourceHandler2 = _interopRequireDefault(_liveSourceHandler);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProLiveRTMPSubcriber';
	var defaultOptions = {
	  protocol: 'rtmp',
	  port: 1935,
	  width: 320, // video playback
	  height: 240, // video playback
	  embedWidth: '100%', // DOM display style
	  embedHeight: '100%', // DOM display style
	  minFlashVersion: '10.0.0',
	  swf: 'lib/red5pro/red5pro-subscriber.swf',
	  swfobjectURL: 'lib/red5pro/red5pro-subscriber.swf',
	  productInstallUrl: 'lib/swfobject/playerProductInstall.swf'
	};
	
	var R5LiveSubscriber = function (_EventEmitter) {
	  _inherits(R5LiveSubscriber, _EventEmitter);
	
	  function R5LiveSubscriber() {
	    _classCallCheck(this, R5LiveSubscriber);
	
	    var _this = _possibleConstructorReturn(this, (R5LiveSubscriber.__proto__ || Object.getPrototypeOf(R5LiveSubscriber)).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._sourceHandler = undefined;
	    _this._elementId = undefined;
	    _this._playbackPromise = undefined;
	    return _this;
	  }
	
	  _createClass(R5LiveSubscriber, [{
	    key: 'init',
	    value: function init(options) {
	      var self = this;
	      var deferred = new _promise.DeferredPromise();
	      var version = options.minFlashVersion || defaultOptions.minFlashVersion;
	      if (!_browser2.default.supportsFlashVersion(version)) {
	        deferred.reject('Could not resolve LiveRTMPSubscriber instance. Requires minimum Flash Player install of ' + version + '.');
	      } else {
	        this._options = Object.assign({}, defaultOptions, options);
	        try {
	          _browser2.default.injectScript(this._options.swfobjectURL).then(function () {
	            (0, _log.debug)(NAME, 'SWFObject embedded.');
	            if (self._sourceHandler) {
	              return self._sourceHandler.addSource(self._elementId, self._options);
	            }
	            return true;
	          }).then(function () {
	            deferred.resolve(self);
	            self.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_SUCCESS, self));
	          }).catch(function (err) {
	            (0, _log.error)(NAME, 'Could not embed Flash-based RTMP Player. Reason: ' + err);
	            if (self._sourceHandler) {
	              self._sourceHandler.disconnect();
	            }
	            deferred.reject(err);
	            self.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_FAILURE, self));
	          });
	        } catch (e) {
	          deferred.reject('Could not inject Flash-based Player into the page. Reason: ' + e.message);
	          self.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_FAILURE, self));
	        }
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view, elementId) {
	      var self = this;
	      this._view = view;
	      this._elementId = elementId;
	      if (this._sourceHandler !== undefined) {
	        this._sourceHandler.disconnect();
	        this._sourceHandler = undefined;
	      }
	
	      if (view) {
	        this._sourceHandler = new _liveSourceHandler2.default(this._view.view, this.getType());
	        if (this._options) {
	          this._sourceHandler.addSource(this._elementId, this._options).catch(function () {
	            self.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_FAILURE, self));
	          });
	        }
	      }
	      return this;
	    }
	  }, {
	    key: '_establishExtIntHandlers',
	    value: function _establishExtIntHandlers() {
	      var _this2 = this;
	
	      var id = this._options.streamName;
	      var invokeFn = function invokeFn(label) {
	        return ['subscriber', label, id].join('_');
	      };
	      window[invokeFn('r5proConnectSuccess')] = function () {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_SUCCESS, _this2));
	      };
	      window[invokeFn('r5proConnectFailure')] = function () {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE, _this2));
	      };
	      window[invokeFn('r5proSubscribeStop')] = function () {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_STOP, _this2));
	      };
	      window[invokeFn('r5proSubscribeInvalidName')] = function () {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_INVALID_NAME, _this2));
	      };
	      window[invokeFn('r5proSubscribeMetadata')] = function (metadata) {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_METADATA, _this2, metadata));
	      };
	      window[invokeFn('r5proSubscribeStart')] = function () {
	        _this2._playbackPromise.resolve(_this2);
	        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_START, _this2));
	      };
	      window[invokeFn('r5proSubscribeFail')] = function () {
	        _this2._playbackPromise.reject("Failed to start playback stream.");
	        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL, _this2));
	      };
	    }
	  }, {
	    key: 'play',
	    value: function play() {
	      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      // eslint-disable-line no-unused-vars
	      this._playbackPromise = new _promise.DeferredPromise();
	      this._establishExtIntHandlers();
	      return this._playbackPromise.promise;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      var _this3 = this;
	
	      var cb = function cb(resolve, reject) {
	        try {
	          _this3._sourceHandler.disconnect();
	          resolve();
	        } catch (e) {
	          reject(e.message);
	        }
	      };
	      this._playbackPromise = undefined;
	      return new Promise(cb);
	    }
	  }, {
	    key: 'getConnection',
	    value: function getConnection() {
	      return this._sourceHandler;
	    }
	  }, {
	    key: 'getOptions',
	    value: function getOptions() {
	      return this._options;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'RTMP';
	    }
	  }]);
	
	  return R5LiveSubscriber;
	}(_eventEmitter2.default);
	
	exports.default = R5LiveSubscriber;

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	'use script';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _embed = __webpack_require__(326);
	
	var embed = _interopRequireWildcard(_embed);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _promise = __webpack_require__(310);
	
	var _log = __webpack_require__(299);
	
	var _sharedobjectHelperRtmp = __webpack_require__(327);
	
	var _sharedobjectHelperRtmp2 = _interopRequireDefault(_sharedobjectHelperRtmp);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'RTMPLiveSourceHandler';
	var toInt = function toInt(value) {
	  if (typeof value === 'string') {
	    return value.parseInt(10);
	  } else {
	    return Math.round(value);
	  }
	};
	
	var LiveSourceHandler = function () {
	  function LiveSourceHandler(video, type) {
	    var soResponder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
	
	    _classCallCheck(this, LiveSourceHandler);
	
	    this.video = video;
	    this.clone = this.video.cloneNode(true);
	    this.holder = this.video.parentNode;
	    this.playerType = type;
	    this._swfId = null;
	    this._soResponder = soResponder || new _sharedobjectHelperRtmp2.default();
	  }
	
	  _createClass(LiveSourceHandler, [{
	    key: 'cleanUp',
	    value: function cleanUp() {
	      // Return to prior DOM manipulation.
	      this.video.remove();
	      this.video = this.clone.cloneNode(true);
	      this.holder.appendChild(this.video);
	    }
	  }, {
	    key: '_setUpInitCallback',
	    value: function _setUpInitCallback(promise) {
	      var _this = this;
	
	      window.setSubscriberId = function (successId) {
	        // successId === _options.streamName
	        (0, _log.debug)(NAME, 'Embed and init() complete for subscriber swf. successId(' + successId + ').');
	        promise.resolve(successId);
	        _this._tearDownInitCallback();
	      };
	      // TODO: Setup timeout to reject?
	    }
	  }, {
	    key: '_tearDownInitCallback',
	    value: function _tearDownInitCallback() {
	      window.setActiveId = undefined;
	    }
	  }, {
	    key: 'addSource',
	    value: function addSource(swfId, options) {
	      var swfUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	      var minFlashVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	
	      (0, _log.debug)(NAME, '[addsource]');
	      this._swfId = swfId;
	      var soResponder = this._soResponder;
	      var deferred = new _promise.DeferredPromise();
	      options.swf = swfUrl || options.swf;
	      options.minFlashVersion = minFlashVersion || options.minFlashVersion;
	      this._setUpInitCallback(deferred);
	      embed.defineEmbedElement(this.video, this.holder).then(function (elementId) {
	        var flashvars = {
	          stream: options.streamName,
	          app: options.context ? options.app + '/' + options.context : options.app,
	          host: options.host
	        };
	        if (options.buffer && !isNaN(Number(options.buffer))) {
	          flashvars.buffer = options.buffer;
	        }
	        if (options.width && !isNaN(options.width)) {
	          flashvars.width = toInt(options.width);
	        }
	        if (options.height && !isNaN(options.height)) {
	          flashvars.height = toInt(options.height);
	        }
	        if (options.embedWidth === '100%' || options.embedHeight === '100%') {
	          flashvars.autosize = true;
	        }
	        if (typeof options.connectionParams !== 'undefined') {
	          flashvars.connectionParams = encodeURIComponent(JSON.stringify(options.connectionParams));
	        }
	        return embed.embedSwfObject(swfId, options, flashvars, _browser2.default.getSwfObject(), elementId);
	      }).then(function () {
	        soResponder.connect(swfId);
	        return true;
	      }).catch(function (e) {
	        return deferred.reject(e);
	      });
	      return deferred.promise;
	    }
	  }, {
	    key: 'connect',
	    value: function connect() {
	      (0, _log.debug)(NAME, '[connect]');
	      try {
	        _browser2.default.getEmbedObject(this._swfId).connect();
	      } catch (e) {
	        // nada.
	      }
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      (0, _log.debug)(NAME, '[disconnect]');
	      try {
	        _browser2.default.getEmbedObject().disconnect();
	      } catch (e) {
	        // nada.
	      }
	      this.cleanUp();
	      this._soResponder.disconnect();
	    }
	  }, {
	    key: 'addSharedObjectResponseHandler',
	    value: function addSharedObjectResponseHandler(handler) {
	      this._soResponder.addResponseHandler(handler);
	    }
	  }, {
	    key: 'removeSharedObjectResponseHandler',
	    value: function removeSharedObjectResponseHandler(handler) {
	      this._soResponder.removeResponseHandler(handler);
	    }
	  }, {
	    key: 'sendToSharedObject',
	    value: function sendToSharedObject(name, callName, message) {
	      this._soResponder.sendToSharedObject(name, callName, message);
	    }
	  }, {
	    key: 'sendPropertyToSharedObject',
	    value: function sendPropertyToSharedObject(name, key, value) {
	      this._soResponder.sendPropertyToSharedObject(name, key, value);
	    }
	  }, {
	    key: 'getRemoteSharedObject',
	    value: function getRemoteSharedObject(sharedObjectName) {
	      this._soResponder.getRemoteSharedObject(sharedObjectName);
	    }
	  }, {
	    key: 'connectToSharedObject',
	    value: function connectToSharedObject(sharedObjectName) {
	      this._soResponder.connectToSharedObject(sharedObjectName);
	    }
	  }, {
	    key: 'closeSharedObject',
	    value: function closeSharedObject(sharedObjectName) {
	      this._soResponder.closeSharedObject(sharedObjectName);
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return this.playerType;
	    }
	  }]);
	
	  return LiveSourceHandler;
	}();
	
	exports.default = LiveSourceHandler;

/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.embedSwfObject = exports.defineEmbedElement = undefined;
	
	var _promise = __webpack_require__(310);
	
	var defineEmbedElement = exports.defineEmbedElement = function defineEmbedElement(targetElement, targetParent) {
	  var dfd = new _promise.DeferredPromise();
	  var elementId = targetElement.id;
	  if (targetElement.nodeName.toLowerCase() === 'video') {
	    var div = document.createElement('div');
	    div.id = elementId + '_rtmp';
	    targetParent.appendChild(div);
	    targetElement.remove();
	    dfd.resolve(div.id);
	  } else {
	    dfd.resolve(elementId);
	  }
	  return dfd.promise;
	};
	
	var embedSwfObject = exports.embedSwfObject = function embedSwfObject(idName, options, flashvars, swfobject, elementId) {
	  var dfd = new _promise.DeferredPromise();
	  var params = {
	    quality: 'high',
	    bgcolor: '#000',
	    allowscriptaccess: 'always',
	    allowfullscreen: 'true'
	  };
	  var attributes = {
	    id: idName,
	    name: idName,
	    align: 'middle'
	  };
	  if (swfobject.hasFlashPlayerVersion(options.minFlashVersion)) {
	    swfobject.embedSWF(options.swf, elementId, options.embedWidth || options.width, options.embedHeight || options.height, options.minFlashVersion, options.productInstallURL, flashvars, params, attributes, dfd.resolve);
	  } else {
	    dfd.reject('Flash Player Version is not supported.');
	  }
	  return dfd.promise;
	};

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProRTMPSharedObjectHandler';
	
	var RTMPSharedObjectHandler = function () {
	  function RTMPSharedObjectHandler() {
	    _classCallCheck(this, RTMPSharedObjectHandler);
	
	    this._element = undefined;
	    this._responseHandlers = [];
	  }
	
	  _createClass(RTMPSharedObjectHandler, [{
	    key: 'addResponseHandler',
	    value: function addResponseHandler(handler) {
	      this._responseHandlers.push(handler);
	    }
	  }, {
	    key: 'removeResponseHandler',
	    value: function removeResponseHandler(handler) {
	      var i = this._responseHandlers.length;
	      var rHandler = void 0;
	      while (--i > -1) {
	        rHandler = this._responseHandlers[i];
	        if (rHandler === handler) {
	          this._responseHandlers.splice(i, 1);
	          return;
	        }
	      }
	    }
	  }, {
	    key: 'handleSharedObjectEvent',
	    value: function handleSharedObjectEvent(event) {
	      (0, _log.debug)(NAME, '[sharedobject:event]');
	      var i = void 0;
	      var length = this._responseHandlers.length;
	      var handler = void 0;
	      for (i = 0; i < length; i++) {
	        handler = this._responseHandlers[i];
	        if (handler.respond(JSON.parse(event))) {
	          break;
	        }
	      }
	    }
	  }, {
	    key: 'assignSharedObjectResponder',
	    value: function assignSharedObjectResponder(name, el) {
	      var _handleSharedObjectEvent = this.handleSharedObjectEvent.bind(this);
	      var elId = el.id.split('-').join('_');
	      var handlerName = ['handleSharedObjectEvent', elId].join('_');
	      (0, _log.debug)(NAME, '[assign:sharedobject:responder] :: ' + elId);
	      (0, _log.debug)(NAME, '[sharedoject:responder] :: ' + handlerName);
	      el.setSharedObjectResponder(name, handlerName);
	      _browser2.default.setGlobal(handlerName, _handleSharedObjectEvent);
	    }
	  }, {
	    key: 'connect',
	    value: function connect(swfId) {
	      this._element = _browser2.default.getEmbedObject(swfId);
	      if (!this._element) {
	        (0, _log.warn)('Could not locate embedded Flash object for id: ' + swfId);
	      }
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      while (this._responseHandlers.length > 0) {
	        this._responseHandlers.shift();
	      }
	    }
	  }, {
	    key: 'sendToSharedObject',
	    value: function sendToSharedObject(name, callName, message) {
	      (0, _log.debug)(NAME, '[sendToSharedObject]');
	      try {
	        this._element.sharedObjectSend(name, callName, typeof message === 'string' ? message : JSON.stringify(message));
	      } catch (e) {
	        (0, _log.warn)('Could not send to shared object (' + name + '). Error: ' + e.message);
	      }
	    }
	  }, {
	    key: 'sendPropertyToSharedObject',
	    value: function sendPropertyToSharedObject(name, key, value) {
	      (0, _log.debug)(NAME, '[sendPropertyToSharedObject]');
	      try {
	        this._element.sharedObjectSendProperty(name, key, value);
	      } catch (e) {
	        (0, _log.warn)('Could not send to shared object (' + name + '). Error: ' + e.message);
	      }
	    }
	  }, {
	    key: 'getRemoteSharedObject',
	    value: function getRemoteSharedObject(sharedObjectName) {
	      (0, _log.debug)(NAME, '[getRemoteSharedObject]');
	      try {
	        this.assignSharedObjectResponder(sharedObjectName, this._element);
	        this._element.getRemoteSharedObject(sharedObjectName);
	      } catch (e) {
	        (0, _log.warn)('Could not get remote shared object (' + name + '). Error: ' + e.message);
	      }
	    }
	  }, {
	    key: 'connectToSharedObject',
	    value: function connectToSharedObject(sharedObjectName) {
	      (0, _log.debug)(NAME, '[connectToSharedObject]');
	      try {
	        this._element.connectToSharedObject(sharedObjectName);
	      } catch (e) {
	        (0, _log.warn)('Could not connect to shared object (' + name + '). Error: ' + e.message);
	      }
	    }
	  }, {
	    key: 'closeSharedObject',
	    value: function closeSharedObject(sharedObjectName) {
	      (0, _log.debug)(NAME, '[disconnectToSharedObject]');
	      try {
	        this._element.disconnectFromSharedObject(sharedObjectName);
	      } catch (e) {
	        (0, _log.warn)('Could not disconnect to shared object (' + name + '). Error: ' + e.message);
	      }
	    }
	  }]);
	
	  return RTMPSharedObjectHandler;
	}();
	
	exports.default = RTMPSharedObjectHandler;

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ImplFactoryOrder = undefined;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _promise = __webpack_require__(310);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var map = new WeakMap();
	
	var pvt = function pvt(ctx) {
	  if (!map.has(ctx)) {
	    map.set(ctx, {});
	  }
	
	  return map.get(ctx);
	};
	
	var ImplFactoryOrder = exports.ImplFactoryOrder = function () {
	  function ImplFactoryOrder() {
	    var _this = this;
	
	    _classCallCheck(this, ImplFactoryOrder);
	
	    this.listorder = function () {
	      return regeneratorRuntime.mark(function listorder(list) {
	        return regeneratorRuntime.wrap(function listorder$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (!(list.length > 0)) {
	                  _context.next = 5;
	                  break;
	                }
	
	                _context.next = 3;
	                return list.shift();
	
	              case 3:
	                _context.next = 0;
	                break;
	
	              case 5:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, listorder, this);
	      });
	    }();
	
	    pvt(this).find = function (iterator, map, options, promise) {
	      var initFn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
	
	      var _pvt$next = pvt(_this).next(iterator, map),
	          _pvt$next2 = _slicedToArray(_pvt$next, 2),
	          type = _pvt$next2[0],
	          Impl = _pvt$next2[1];
	
	      if (!Impl) {
	        promise.reject();
	      } else {
	        var p = void 0;
	        var src = options[type];
	        src = src || options;
	        if (initFn) {
	          p = new Impl()[initFn](src);
	        } else {
	          p = new Impl(src);
	        }
	        p.then(function (concrete) {
	          promise.resolve(concrete);
	        }).catch(function () {
	          // eslint-disable-line no-unused-vars
	          pvt(_this).find(iterator, map, options, promise, initFn);
	        });
	      }
	    };
	
	    pvt(this).next = function (order, map) {
	      var Impl = void 0;
	      var key = void 0;
	      var next = order.next();
	      if (!next.done) {
	        key = next.value;
	        Impl = map.get(key);
	      }
	      return [key, Impl];
	    };
	  }
	
	  _createClass(ImplFactoryOrder, [{
	    key: 'create',
	    value: function create(order, map, options) {
	      var initFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	
	      var promise = new _promise.DeferredPromise();
	      pvt(this).find(this.listorder(order.slice()), map, options, promise, initFn);
	      return promise.promise;
	    }
	  }]);
	
	  return ImplFactoryOrder;
	}();
	
	exports.default = ImplFactoryOrder;

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Main entry for failover support of all publisher implementations.
	 */
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RTCPublisher = exports.RTMPPublisher = exports.Red5ProPublisher = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _implFactoryOrder = __webpack_require__(328);
	
	var _implFactoryOrder2 = _interopRequireDefault(_implFactoryOrder);
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _red5proRtmp = __webpack_require__(330);
	
	var _red5proRtmp2 = _interopRequireDefault(_red5proRtmp);
	
	var _red5proRtc = __webpack_require__(333);
	
	var _red5proRtc2 = _interopRequireDefault(_red5proRtc);
	
	var _promise = __webpack_require__(310);
	
	var _publish = __webpack_require__(331);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProPublisher';
	var publishFactory = new _implFactoryOrder2.default();
	var publisherImpl = function () {
	  var map = new Map();
	  map.set(_publish.PublishTypes.RTMP, _red5proRtmp2.default);
	  map.set(_publish.PublishTypes.RTC, _red5proRtc2.default);
	  return map;
	}();
	
	var Red5ProPublisher = function (_EventEmitter) {
	  _inherits(Red5ProPublisher, _EventEmitter);
	
	  function Red5ProPublisher() {
	    _classCallCheck(this, Red5ProPublisher);
	
	    var _this = _possibleConstructorReturn(this, (Red5ProPublisher.__proto__ || Object.getPrototypeOf(Red5ProPublisher)).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._currentPublisher = undefined;
	    _this._boundBubblePublisherEvent = _this.bubblePublisherEvent.bind(_this);
	    _this._order = [_publish.PublishTypes.RTMP, _publish.PublishTypes.RTC];
	    return _this;
	  }
	
	  _createClass(Red5ProPublisher, [{
	    key: 'getPublishOrder',
	    value: function getPublishOrder() {
	      return this._order;
	    }
	  }, {
	    key: 'setPublishOrder',
	    value: function setPublishOrder(order) {
	      // Allow for string value to define single item in order.
	      order = typeof order === 'string' ? [order] : order;
	
	      // Filter out values not available in enumeration of playback types.
	      var t = order.filter(function (entry) {
	        var key = void 0;
	        for (key in _publish.PublishTypes) {
	          if (_publish.PublishTypes[key].toLowerCase() === entry.toLowerCase()) {
	            return true;
	          }
	        }
	        return false;
	      }).map(function (entry) {
	        return entry.toLowerCase();
	      });
	
	      // Define new order.
	      this._order = [].concat(_toConsumableArray(new Set(t)));
	      (0, _log.debug)(NAME, '[orderupdate]: ' + this._order);
	      return this;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(publishView) {
	      this._view = publishView;
	      return this;
	    }
	  }, {
	    key: 'getPublisherFromOrder',
	    value: function getPublisherFromOrder(order, options) {
	      return publishFactory.create(order, publisherImpl, options, 'init');
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var _this2 = this;
	
	      var deferred = new _promise.DeferredPromise();
	      (0, _log.debug)(NAME, '[publish]');
	      this._options = options;
	      this.getPublisherFromOrder(this._order, this._options).then(function (publisher) {
	        _this2._currentPublisher = publisher;
	        _this2._currentPublisher.setView(_this2._view);
	        _this2._currentPublisher.on('*', _this2._boundBubblePublisherEvent);
	        deferred.resolve(_this2._currentPublisher);
	      }).catch(function (err) {
	        (0, _log.warn)(NAME, '[publisherror]: Could not implement a publisher: ' + err);
	        deferred.reject(err);
	      });
	      return deferred.promise;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      var _this3 = this;
	
	      var deferred = new _promise.DeferredPromise();
	      if (!this._currentPublisher) {
	        (0, _log.warn)(NAME, '[stop]: Could not invoke stop() on undefined publisher.');
	        deferred.reject('A current publisher is not available to issue a :stop() command to.');
	      } else {
	        (0, _log.debug)(NAME, '[stop]: Invoking stop on held publisher');
	        this._currentPublisher.unpublish().then(function () {
	          (0, _log.debug)(NAME, '[stopsuccess]');
	          _this3._currentPublisher.off('*', _this3._boundBubblePublisherEvent);
	          _this3._currentPublisher = undefined;
	          deferred.resolve();
	        }).catch(function (err) {
	          (0, _log.debug)(NAME, '[stoperror]: ' + err);
	          if (_this3._currentPublisher) {
	            _this3._currentPublisher.off('*', _this3._boundBubblePublisherEvent);
	          }
	          _this3._currentPublisher = undefined;
	          deferred.reject(err);
	        });
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'bubblePublisherEvent',
	    value: function bubblePublisherEvent(publisherEvent) {
	      this.trigger.call(this, publisherEvent);
	    }
	  }, {
	    key: 'publishTypes',
	    get: function get() {
	      return _publish.PublishTypes;
	    }
	  }, {
	    key: 'currentPublisher',
	    get: function get() {
	      return this._currentPublisher;
	    }
	  }]);
	
	  return Red5ProPublisher;
	}(_eventEmitter2.default);
	
	exports.Red5ProPublisher = Red5ProPublisher;
	exports.RTMPPublisher = _red5proRtmp2.default;
	exports.RTCPublisher = _red5proRtc2.default;

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(313);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _promise = __webpack_require__(310);
	
	var _publish = __webpack_require__(331);
	
	var _pubSourceHandler = __webpack_require__(332);
	
	var _pubSourceHandler2 = _interopRequireDefault(_pubSourceHandler);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProRTMPPublisher';
	var defaultOptions = {
	  protocol: 'rtmp',
	  port: 1935,
	  streamMode: 'live',
	  width: 320, // camera/video
	  height: 240, // camera/video
	  embedWidth: '100%', // DOM display style
	  embedHeight: '100%', // DOM display style
	  minFlashVersion: '10.0.0',
	  swf: 'lib/red5pro/red5pro-publisher.swf',
	  swfobjectURL: 'lib/swfobject/swfobject.js',
	  productInstallURL: 'lib/swfobject/playerProductInstall.swf'
	};
	
	var RTMPPublisher = function (_EventEmitter) {
	  _inherits(RTMPPublisher, _EventEmitter);
	
	  function RTMPPublisher() {
	    _classCallCheck(this, RTMPPublisher);
	
	    var _this = _possibleConstructorReturn(this, (RTMPPublisher.__proto__ || Object.getPrototypeOf(RTMPPublisher)).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._sourceHandler = undefined;
	    _this._elementId = undefined;
	    _this._connectFuture = undefined;
	    return _this;
	  }
	
	  _createClass(RTMPPublisher, [{
	    key: 'init',
	    value: function init(options) {
	      var self = this;
	      var deferred = new _promise.DeferredPromise();
	      var version = options.minFlashVersion || defaultOptions.minFlashVersion;
	      if (!_browser2.default.supportsFlashVersion(version)) {
	        deferred.reject('Could not resolve RTMPPublisher instance. Requires minimum Flash Player install of ' + version);
	      } else {
	        this._options = Object.assign({}, defaultOptions, options);
	        try {
	          _browser2.default.injectScript(this._options.swfobjectURL).then(function () {
	            (0, _log.debug)(NAME, 'SWFObject embedded.');
	            if (self._sourceHandler) {
	              (0, _log.debug)(NAME, 'Publish handler established.');
	              return self._sourceHandler.addSource(self._elementId, self._options);
	            } else {
	              (0, _log.debug)(NAME, 'Publish handler not established.');
	              return true;
	            }
	          }).then(function () {
	            return deferred.resolve(self);
	          }).catch(function (err) {
	            (0, _log.error)(NAME, 'Could not embed Flash-based RTMP Publisher. Reason: ' + err);
	            if (self._sourceHandler) {
	              self._sourceHandler.disconnect();
	            }
	            deferred.reject(err);
	            self.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_FAILURE, self));
	          });
	        } catch (e) {
	          deferred.reject('Could not inject Flash-based Publisher into the page. Reason: ' + e.message);
	          self.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_FAILURE, self));
	        }
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: '_setUpConnectCallback',
	    value: function _setUpConnectCallback(promise) {
	      var _this2 = this;
	
	      window.setActiveId = function (successId) {
	        // successId === _options.streamName
	        (0, _log.debug)(NAME, 'Embed and connect() complete for publisher swf. successId(' + successId + ').');
	        promise.resolve(successId);
	        _this2.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_SUCCESS, _this2));
	        _this2._tearDownConnectCallback();
	      };
	      // TODO: Setup timeout to reject?
	    }
	  }, {
	    key: '_tearDownConnectCallback',
	    value: function _tearDownConnectCallback() {
	      window.setActiveId = undefined;
	    }
	  }, {
	    key: '_establishExtIntHandlers',
	    value: function _establishExtIntHandlers() {
	      var _this3 = this;
	
	      var id = this._options.streamName;
	      var invokeFn = function invokeFn(label) {
	        return ['publisher', label, id].join('_');
	      };
	      window[invokeFn('r5proConnectSuccess')] = function () {
	        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_SUCCESS, _this3));
	      };
	      window[invokeFn('r5proUnpublishSuccess')] = function () {
	        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.UNPUBLISH_SUCCESS, _this3));
	      };
	      window[invokeFn('r5proPublishStart')] = function () {
	        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_START, _this3));
	      };
	      window[invokeFn('r5proPublishMetadata')] = function (metadata) {
	        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_METADATA, _this3, metadata));
	      };
	      window[invokeFn('r5proConnectFailure')] = function () {
	        _this3._connectFuture.reject(_event.PublisherEventTypes.CONNECT_FAILURE);
	        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, _this3));
	      };
	      window[invokeFn('r5proPublishFail')] = function () {
	        _this3._connectFuture.reject(_event.PublisherEventTypes.PUBLISH_FAIL);
	        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_FAIL, _this3));
	      };
	      window[invokeFn('r5proPublishInvalidName')] = function () {
	        _this3._connectFuture.reject(_event.PublisherEventTypes.PUBLISH_INVALID_NAME);
	        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_INVALID_NAME, _this3));
	      };
	    }
	  }, {
	    key: 'publish',
	    value: function publish() {
	      var _this4 = this;
	
	      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
	      // eslint-disable-line no-unused-vars
	      var dfd = new _promise.DeferredPromise();
	      this._setUpConnectCallback(dfd);
	      this._options.streamName = streamName || this._options.streamName;
	      var publishOptions = this._options;
	      try {
	        (function () {
	          var srcHandler = _this4._sourceHandler;
	          _this4._sourceHandler.getEmbedOperation().then(function () {
	            (0, _log.debug)(NAME, '[handler:embed:complete]');
	            var el = _browser2.default.getEmbedObject(_this4._elementId);
	            if (el) {
	              _this4._establishExtIntHandlers();
	            }
	            var count = 0;
	            var limit = 1000;
	            var tryConnect = function tryConnect() {
	              var timeout = void 0;
	              timeout = setTimeout(function () {
	                try {
	                  clearTimeout(timeout);
	                  srcHandler.connect(JSON.stringify(publishOptions));
	                } catch (e) {
	                  if (count++ > limit) {
	                    throw e;
	                  } else {
	                    tryConnect();
	                  }
	                }
	              }, 300);
	            };
	            tryConnect();
	          }).catch(function (err) {
	            dfd.reject(err);
	            _this4.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, _this4));
	          });
	        })();
	      } catch (e) {
	        (0, _log.error)(NAME, '[handler:embed:error]');
	        dfd.reject('Could not initiate connection sequence. Reason: ' + e.message);
	        this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, this));
	        this._tearDownConnectCallback();
	      }
	      this._connectFuture = dfd;
	      return dfd.promise;
	    }
	  }, {
	    key: 'unpublish',
	    value: function unpublish() {
	      var deferred = new _promise.DeferredPromise();
	      try {
	        _browser2.default.getEmbedObject(this._elementId).disconnect();
	        deferred.resolve();
	      } catch (e) {
	        (0, _log.error)(NAME, 'Could not initiate disconnection sequence. Reason: ' + e.message);
	        deferred.reject(e.message);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'send',
	    value: function send(methodName, data) {
	      this._sourceHandler.send(methodName, typeof data === 'string' ? data : JSON.stringify(data));
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view, elementId) {
	      var _this5 = this;
	
	      this._view = view;
	      this._elementId = elementId;
	      if (this._sourceHandler !== undefined) {
	        this._sourceHandler.disconnect();
	        this._sourceHandler = undefined;
	      }
	      if (this._view) {
	        this._sourceHandler = new _pubSourceHandler2.default(this._view.view, this.getType());
	      }
	      if (this._options && this._sourceHandler) {
	        this._sourceHandler.addSource(this._elementId, this._options).catch(function (err) {
	          (0, _log.error)(NAME, 'Could not establish proper RTMP publisher: ' + err);
	          _this5.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_FAILURE, _this5));
	        });
	      }
	      return this;
	    }
	  }, {
	    key: 'setMediaQuality',
	    value: function setMediaQuality(quality) {
	      if (this._sourceHandler) {
	        this._sourceHandler.setMediaQuality(quality);
	      }
	    }
	  }, {
	    key: 'overlayOptions',
	    value: function overlayOptions(newOptions) {
	      this._options = Object.assign(this._options, newOptions);
	    }
	  }, {
	    key: 'getConnection',
	    value: function getConnection() {
	      return this._sourceHandler;
	    }
	  }, {
	    key: 'getOptions',
	    value: function getOptions() {
	      return this._options;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return _publish.PublishTypes.RTMP.toUpperCase();
	    }
	  }]);
	
	  return RTMPPublisher;
	}(_eventEmitter2.default);
	
	exports.default = RTMPPublisher;

/***/ },
/* 331 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var PublishTypes = exports.PublishTypes = Object.freeze({
	  RTMP: 'rtmp',
	  RTC: 'rtc'
	});
	
	var PublishModeTypes = exports.PublishModeTypes = Object.freeze({
	  LIVE: 'live',
	  RECORD: 'record',
	  APPEND: 'append'
	});

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _embed = __webpack_require__(326);
	
	var embed = _interopRequireWildcard(_embed);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _promise = __webpack_require__(310);
	
	var _log = __webpack_require__(299);
	
	var _sharedobjectHelperRtmp = __webpack_require__(327);
	
	var _sharedobjectHelperRtmp2 = _interopRequireDefault(_sharedobjectHelperRtmp);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProPublisherSourceHandler';
	var toInt = function toInt(value) {
	  if (typeof value === 'string') {
	    return value.parseInt(10);
	  } else {
	    return Math.round(value);
	  }
	};
	
	var PublisherSourceHandler = function () {
	  function PublisherSourceHandler(video, type) {
	    var soResponder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
	
	    _classCallCheck(this, PublisherSourceHandler);
	
	    this.video = video;
	    this.clone = this.video.cloneNode(true);
	    this.holder = this.video.parentNode;
	    this.publisherType = type;
	    this._swfId = null;
	    this._embedFuture = undefined;
	    this._soResponder = soResponder || new _sharedobjectHelperRtmp2.default();
	  }
	
	  _createClass(PublisherSourceHandler, [{
	    key: 'getEmbedOperation',
	    value: function getEmbedOperation() {
	      this._embedFuture = _promise.Future.createIfNotExist(this._embedFuture);
	      return this._embedFuture.promise;
	    }
	  }, {
	    key: 'cleanUp',
	    value: function cleanUp() {
	      // Return to prior DOM manipulation.
	      this.video.remove();
	      this.video = this.clone.cloneNode(true);
	      this.holder.appendChild(this.video);
	      this._embedFuture = undefined;
	    }
	  }, {
	    key: 'addSource',
	    value: function addSource(swfId, options) {
	      var swfUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	      var minFlashVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	
	      (0, _log.debug)(NAME, '[addsource]');
	      var self = this;
	      this._swfId = swfId;
	      this._embedFuture = _promise.Future.createIfNotExist(this._embedFuture);
	      var deferred = this._embedFuture;
	      options.swf = swfUrl || options.swf;
	      options.minFlashVersion = minFlashVersion || options.minFlashVersion;
	      embed.defineEmbedElement(this.video, this.holder).then(function (elementId) {
	        (0, _log.debug)(NAME, '[element:complete]');
	        var flashvars = {
	          buffer: options.buffer != null ? options.buffer : 2,
	          streamMode: options.streamMode,
	          streamName: options.streamName,
	          appName: options.app,
	          host: options.host
	        };
	        if (options.context) {
	          flashvars.roomName = options.context;
	        }
	        if (options.width && !isNaN(options.width)) {
	          flashvars.width = toInt(options.width);
	        }
	        if (options.height && !isNaN(options.height)) {
	          flashvars.height = toInt(options.height);
	        }
	        if (options.embedWidth === '100%' || options.embedHeight === '100%') {
	          flashvars.autosize = true;
	        }
	        if (typeof options.connectionParams !== 'undefined') {
	          flashvars.connectionParams = encodeURIComponent(JSON.stringify(options.connectionParams));
	        }
	        return embed.embedSwfObject(swfId, options, flashvars, _browser2.default.getSwfObject(), elementId);
	      }).then(function () {
	        (0, _log.debug)(NAME, '[embed:complete]');
	        deferred.resolve(self);
	      }).catch(function (err) {
	        return deferred.reject(err);
	      });
	      return deferred.promise;
	    }
	  }, {
	    key: 'connect',
	    value: function connect(publishOptions) {
	      (0, _log.debug)(NAME, '[connect]');
	      var el = _browser2.default.getEmbedObject(this._swfId);
	      if (el) {
	        el.connect(publishOptions);
	        this._soResponder.connect(this._swfId);
	      }
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      (0, _log.debug)(NAME, '[disconnect]');
	      try {
	        // No invocable API for custom live flash publisher from Red5 Pro at the time.
	      } catch (e) {
	        // nada.
	      }
	      this.cleanUp();
	      this._soResponder.disconnect();
	    }
	  }, {
	    key: 'send',
	    value: function send(methodName, data) {
	      var el = _browser2.default.getEmbedObject(this._swfId);
	      if (el) {
	        el.send(methodName, data);
	      }
	    }
	  }, {
	    key: 'addSharedObjectResponseHandler',
	    value: function addSharedObjectResponseHandler(handler) {
	      this._soResponder.addResponseHandler(handler);
	    }
	  }, {
	    key: 'removeSharedObjectResponseHandler',
	    value: function removeSharedObjectResponseHandler(handler) {
	      this._soResponder.removeResponseHandler(handler);
	    }
	  }, {
	    key: 'sendToSharedObject',
	    value: function sendToSharedObject(name, callName, message) {
	      this._soResponder.sendToSharedObject(name, callName, message);
	    }
	  }, {
	    key: 'sendPropertyToSharedObject',
	    value: function sendPropertyToSharedObject(name, key, value) {
	      this._soResponder.sendPropertyToSharedObject(name, key, value);
	    }
	  }, {
	    key: 'getRemoteSharedObject',
	    value: function getRemoteSharedObject(sharedObjectName) {
	      this._soResponder.getRemoteSharedObject(sharedObjectName);
	    }
	  }, {
	    key: 'connectToSharedObject',
	    value: function connectToSharedObject(sharedObjectName) {
	      this._soResponder.connectToSharedObject(sharedObjectName);
	    }
	  }, {
	    key: 'closeSharedObject',
	    value: function closeSharedObject(sharedObjectName) {
	      this._soResponder.closeSharedObject(sharedObjectName);
	    }
	  }, {
	    key: 'setMediaQuality',
	    value: function setMediaQuality(quality) {
	      var el = _browser2.default.getEmbedObject(this._swfId);
	      if (el) {
	        if (quality.video && typeof quality.video !== 'boolean') {
	          var w = !isNaN(quality.video.width) ? toInt(quality.video.width) : Number.isNaN;
	          var h = !isNaN(quality.video.height) ? toInt(quality.video.height) : Number.isNaN;
	          el.updateResolution(w, h);
	        }
	      }
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return this.publisherType;
	    }
	  }]);
	
	  return PublisherSourceHandler;
	}();
	
	exports.default = PublisherSourceHandler;

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(313);
	
	var _socketHelperPub = __webpack_require__(334);
	
	var _socketHelperPub2 = _interopRequireDefault(_socketHelperPub);
	
	var _webrtcHelperPub = __webpack_require__(335);
	
	var _webrtcHelperPub2 = _interopRequireDefault(_webrtcHelperPub);
	
	var _publish = __webpack_require__(331);
	
	var _promise = __webpack_require__(310);
	
	var _webrtc = __webpack_require__(318);
	
	var webrtc = _interopRequireWildcard(_webrtc);
	
	var _websocket = __webpack_require__(316);
	
	var websocket = _interopRequireWildcard(_websocket);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// Default to secure settings.
	var defaultOptions = {
	  protocol: 'wss',
	  port: 8083,
	  streamType: 'webrtc',
	  streamMode: _publish.PublishModeTypes.LIVE,
	  bandwidth: {
	    audio: 56,
	    video: 512
	  }
	};
	var endpointFromOptions = function endpointFromOptions(options) {
	  var protocol = options.wsprotocol || options.protocol;
	  var port = options.wsport || options.port;
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  var endpoint = protocol + '://' + options.host + ':' + port + '/' + appEndpoint + '?id=' + options.streamName;
	  if (typeof options.connectionParams !== 'undefined') {
	    (function () {
	      var params = [];
	      Object.keys(options.connectionParams).forEach(function (key, index) {
	        // eslint-disable-line no-unused-vars
	        params.push([key, options.connectionParams[key]].join('='));
	      });
	      if (params.length > 0) {
	        endpoint += '&' + params.join('&');
	      }
	    })();
	  }
	  return endpoint;
	};
	
	var pubStartRegex = /(.*) starting/gi;
	var pubStopRegex = /(.*) stopping/gi;
	var NAME = 'RTCPublisher';
	var debug = function debug(message) {
	  (0, _log.debug)(NAME, message);
	};
	var warn = function warn(message) {
	  (0, _log.warn)(NAME, message);
	};
	var error = function error(message) {
	  (0, _log.error)(NAME, message);
	};
	
	var RTCPublisher = function (_EventEmitter) {
	  _inherits(RTCPublisher, _EventEmitter);
	
	  function RTCPublisher() {
	    _classCallCheck(this, RTCPublisher);
	
	    var _this = _possibleConstructorReturn(this, (RTCPublisher.__proto__ || Object.getPrototypeOf(RTCPublisher)).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._peerHelper = undefined;
	    _this._socketHelper = undefined;
	    _this._mediaStream = undefined;
	
	    _this._streamFuture = undefined;
	    _this._availableFuture = undefined;
	    _this._peerFuture = undefined;
	    _this._offerFuture = undefined;
	    _this._sendOfferFuture = undefined;
	    _this._trickleEndFuture = undefined;
	    _this._publishFuture = undefined;
	    _this._unpublishFuture = undefined;
	    return _this;
	  }
	
	  _createClass(RTCPublisher, [{
	    key: '_getMediaStream',
	    value: function _getMediaStream() {
	      this._streamFuture = _promise.Future.createIfNotExist(this._streamFuture);
	      return this._streamFuture.promise;
	    }
	  }, {
	    key: '_getTrickleEnd',
	    value: function _getTrickleEnd() {
	      return _promise.Future.createIfNotExist(this._trickleEndFuture);
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var deferred = new _promise.DeferredPromise();
	      if (!webrtc.isSupported() || !websocket.isSupported()) {
	        deferred.reject('Cannot create WebRTC playback instance. Your environment does not support WebRTC and/or WebSockets.');
	      } else {
	        this._options = Object.assign({}, defaultOptions, options);
	        this._peerHelper = new _webrtcHelperPub2.default(this);
	        this._socketHelper = new _socketHelperPub2.default(this);
	        deferred.resolve(this);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	      return this;
	    }
	  }, {
	    key: 'attachStream',
	    value: function attachStream(media) {
	      this._streamFuture = _promise.Future.createIfNotExist(this._streamFuture);
	      this._streamFuture.resolve(media);
	      return this;
	    }
	  }, {
	    key: 'detachStream',
	    value: function detachStream() {
	      if (this._mediaStream && this._mediaStream.stop) {
	        this._mediaStream.stop();
	      } else if (this._mediaStream && this._mediaStream.getTracks) {
	        var tracks = this._mediaStream.getTracks();
	        var trackLength = tracks.length;
	        while (--trackLength > -1) {
	          if (tracks[trackLength].stop) {
	            tracks[trackLength].stop();
	          }
	        }
	      }
	      this._streamFuture = undefined;
	      this._mediaStream = undefined;
	      return this;
	    }
	  }, {
	    key: 'requestAvailability',
	    value: function requestAvailability(streamName, type) {
	      debug('[requestavailability]');
	      this._availableFuture = undefined;
	      this._availableFuture = _promise.Future.createIfNotExist(this._availableFuture);
	      // message on socket returns -> onStream(Un)Available
	      this._socketHelper.post({
	        isAvailable: streamName,
	        type: type,
	        bundle: false
	      });
	      return this._availableFuture.promise;
	    }
	  }, {
	    key: 'createPeerConnection',
	    value: function createPeerConnection(iceServers) {
	      debug('[createpeeer]');
	      this._peerFuture = undefined;
	      this._peerFuture = _promise.Future.createIfNotExist(this._peerFuture);
	      this._peerHelper.setUp(iceServers, this._peerFuture);
	      return this._peerFuture.promise;
	    }
	  }, {
	    key: 'createOffer',
	    value: function createOffer() {
	      var bandwidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	      debug('[createoffer]');
	      this._offerFuture = undefined;
	      this._offerFuture = _promise.Future.createIfNotExist(this._offerFuture);
	      this._peerHelper.createOffer(bandwidth, this._offerFuture);
	      return this._offerFuture.promise;
	    }
	  }, {
	    key: 'setRemoteDescription',
	    value: function setRemoteDescription(sdp) {
	      debug('[setremotedescription]');
	      return this._peerHelper.setRemoteDescription(sdp);
	    }
	  }, {
	    key: 'sendOffer',
	    value: function sendOffer(sdp, streamName) {
	      debug('[sendoffer]');
	      this._sendOfferFuture = undefined;
	      this._sendOfferFuture = _promise.Future.createIfNotExist(this._sendOffFuture);
	      this._socketHelper.post({
	        handleOffer: streamName,
	        data: {
	          sdp: sdp
	        }
	      });
	      return this._sendOfferFuture.promise;
	    }
	  }, {
	    key: 'sendCandidate',
	    value: function sendCandidate(candidate, streamName) {
	      debug('[sendcandidate]');
	      this._socketHelper.post({
	        handleCandidate: streamName,
	        data: {
	          candidate: candidate
	        }
	      });
	    }
	  }, {
	    key: 'requestPublish',
	    value: function requestPublish(streamName, streamMode) {
	      debug('[requestpublish]');
	      this._publishFuture = undefined;
	      this._publishFuture = _promise.Future.createIfNotExist(this._publishFuture);
	      this._socketHelper.post({
	        publish: streamName,
	        mode: streamMode
	      });
	      return this._publishFuture.promise;
	    }
	  }, {
	    key: 'requestUnpublish',
	    value: function requestUnpublish(streamName) {
	      this._unpublishFuture = undefined;
	      this._unpublishFuture = _promise.Future.createIfNotExist(this._unpublishFuture);
	      this._socketHelper.post({
	        unpublish: streamName
	      });
	      return this._unpublishFuture.promise;
	    }
	  }, {
	    key: 'publish',
	    value: function publish() {
	      var _this2 = this;
	
	      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	      debug('[publish]');
	      this._options.streamName = streamName || this._options.streamName;
	      var p = promise || new _promise.DeferredPromise();
	      var socketPromise = new _promise.DeferredPromise();
	      var socketurl = endpointFromOptions(this._options);
	      this._trickleEndFuture = this._getTrickleEnd();
	      this._socketHelper.setUp(socketurl, socketPromise);
	      // 0. Establish socket connection.
	      socketPromise.promise
	      // 1. Wait for stream attach
	      .then(function () {
	        _this2.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_SUCCESS, _this2));
	        return _this2._getMediaStream();
	      })
	      // 2. Request available stream to publish on
	      .then(function (mediaStream) {
	        _this2._mediaStream = mediaStream;
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.MEDIA_STREAM_AVAILABLE, _this2, mediaStream));
	        return _this2.requestAvailability(_this2._options.streamName, _this2._options.streamType);
	      })
	      // 3. Create Peer Connection
	      .then(function () {
	        return _this2.createPeerConnection(_this2._options.iceServers);
	      })
	      // 4. Make Offer on Peer Connection
	      .then(function (connection) {
	        connection.addStream(_this2._mediaStream);
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.PEER_CONNECTION_AVAILABLE, _this2, connection));
	        return _this2.createOffer(_this2._options.bandwidth);
	      })
	      // 5. Send Offer
	      .then(function (sessionDescription) {
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.OFFER_START, _this2, sessionDescription));
	        return _this2.sendOffer(sessionDescription, _this2._options.streamName);
	      })
	      // 6. Set the session description remotely
	      .then(function (sdp) {
	        return _this2.setRemoteDescription(sdp.sdp);
	      })
	      // 7. Wait until ice trickle end
	      .then(function (sdp) {
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.OFFER_END, _this2, sdp));
	        return _this2._getTrickleEnd().promise;
	      })
	      // 8. Request to publish stream
	      .then(function () {
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.ICE_TRICKLE_COMPLETE, _this2));
	        return _this2.requestPublish(_this2._options.streamName, _this2._options.streamMode);
	      })
	      // 9. Results in socket message of publish (see :onPublishStatus)
	      .then(function () {
	        p.resolve(_this2);
	        _this2.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_START, _this2));
	      }).catch(function (error) {
	        p.reject(error);
	        _this2.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, _this2, error));
	      });
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'unpublish',
	    value: function unpublish() {
	      var _this3 = this;
	
	      debug('[unpublish]');
	      var clearHelpers = function clearHelpers() {
	        if (_this3._socketHelper) {
	          _this3._socketHelper.tearDown();
	        }
	        if (_this3._peerHelper) {
	          _this3._peerHelper.tearDown();
	        }
	      };
	      this._availableFuture = undefined;
	      this._peerFuture = undefined;
	      this._offerFuture = undefined;
	      this._sendOfferFuture = undefined;
	      this._trickleEndFuture = undefined;
	      this._publishFuture = undefined;
	      var f = this.requestUnpublish(this._options.streamName);
	      f.then(function () {
	        _this3._unpublishFuture = undefined;
	        clearHelpers();
	        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.UNPUBLISH_SUCCESS, _this3));
	      });
	      return f;
	    }
	  }, {
	    key: 'mute',
	    value: function mute() {
	      this._socketHelper.post({
	        mute: true
	      });
	    }
	  }, {
	    key: 'unmute',
	    value: function unmute() {
	      this._socketHelper.post({
	        mute: false
	      });
	    }
	  }, {
	    key: 'send',
	    value: function send(methodName, data) {
	      this._socketHelper.post({
	        send: {
	          method: methodName,
	          data: typeof data === 'string' ? JSON.parse(data) : data
	        }
	      });
	    }
	  }, {
	    key: 'onStreamAvailable',
	    value: function onStreamAvailable(receipt) {
	      debug('[onstreamavailable]: ' + JSON.stringify(receipt, null, 2));
	      this._availableFuture = _promise.Future.createIfNotExist(this._availableFuture);
	      this._availableFuture.reject('Stream with name ' + this._options.streamName + ' already has a broadcast session.');
	      this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_INVALID_NAME, this));
	    }
	  }, {
	    key: 'onStreamUnavailable',
	    value: function onStreamUnavailable(receipt) {
	      // Being unavailable, is a good thing for allowing to publish using `options.streamName`
	      debug('Stream ' + this._options.streamName + ' does not exist.');
	      debug('[onstreamunavailable]: ' + JSON.stringify(receipt, null, 2));
	      this._availableFuture = _promise.Future.createIfNotExist(this._availableFuture);
	      this._availableFuture.resolve(true);
	    }
	  }, {
	    key: 'onSocketMessageError',
	    value: function onSocketMessageError(message) {
	      var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	      error('Error in stream playback: ' + message + '.\n[Optional detail]: ' + detail);
	      if (this._publishFuture) {
	        this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_FAIL, this));
	        this._publishFuture.reject(message);
	      }
	    }
	  }, {
	    key: 'onSDPSuccess',
	    value: function onSDPSuccess(receipt) {
	      var info = receipt ? ': ' + JSON.stringify(receipt, null, 2) : '';
	      debug('[onsdpsuccess]' + info);
	    }
	  }, {
	    key: 'onSDPError',
	    value: function onSDPError(receipt) {
	      this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_FAIL, this));
	      var error = receipt ? ': ' + JSON.stringify(receipt, null, 2) : '';
	      error('[onsdperror]' + error);
	    }
	  }, {
	    key: 'onSDPAnswer',
	    value: function onSDPAnswer(sdp) {
	      debug('[sdpanswer]:: ' + JSON.stringify(sdp, null, 2));
	      this._sendOfferFuture = _promise.Future.createIfNotExist(this._sendOfferFuture);
	      this._sendOfferFuture.resolve(sdp);
	    }
	  }, {
	    key: 'onAddIceCandidate',
	    value: function onAddIceCandidate(candidate) {
	      debug('[addicecandidate]');
	      this._peerHelper.addIceCandidate(candidate).then(function () {
	        debug('[addicecandidate:success]');
	      }).catch(function (err) {
	        warn('[addicecandidate:error] - ' + err);
	      });
	    }
	  }, {
	    key: 'onIceCandidate',
	    value: function onIceCandidate(candidate) {
	      debug('[icecandidatetrickle]');
	      this.sendCandidate(candidate, this._options.streamName);
	    }
	  }, {
	    key: 'onIceCandidateTrickleEnd',
	    value: function onIceCandidateTrickleEnd() {
	      debug('[icecandidatetrickle:end]');
	    }
	  }, {
	    key: 'onSocketIceCandidateEnd',
	    value: function onSocketIceCandidateEnd() {
	      debug('[socketicecandidate:end]');
	      this._getTrickleEnd().resolve();
	      // this._trickleEndFuture = undefined
	    }
	  }, {
	    key: 'onPublisherStatus',
	    value: function onPublisherStatus(status) {
	      debug('[publisherstatus] - ' + JSON.stringify(status, null, 2));
	      var stopResult = pubStopRegex.exec(status.message);
	      var startResult = pubStartRegex.exec(status.message);
	      if (stopResult && stopResult[1] === this._options.streamName) {
	        this._unpublishFuture.resolve();
	      } else if (startResult && startResult[1] === this._options.streamName) {
	        this._publishFuture.resolve();
	      } else {
	        warn('Publisher status received, but could not handle.');
	      }
	    }
	  }, {
	    key: 'overlayOptions',
	    value: function overlayOptions(newOptions) {
	      this._options = Object.assign(this._options, newOptions);
	    }
	  }, {
	    key: 'getConnection',
	    value: function getConnection() {
	      return this._socketHelper;
	    }
	  }, {
	    key: 'getPeerConnection',
	    value: function getPeerConnection() {
	      return this._peerHelper ? this._peerHelper.connection : undefined;
	    }
	  }, {
	    key: 'getMediaStream',
	    value: function getMediaStream() {
	      return this._mediaStream;
	    }
	  }, {
	    key: 'getOptions',
	    value: function getOptions() {
	      return this._options;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return _publish.PublishTypes.RTC.toUpperCase();
	    }
	  }]);
	
	  return RTCPublisher;
	}(_eventEmitter2.default);
	
	exports.default = RTCPublisher;

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _socketHelper = __webpack_require__(315);
	
	var _socketHelper2 = _interopRequireDefault(_socketHelper);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProPublisherSocket';
	
	var PublisherSocketHelper = function (_SocketHelper) {
	  _inherits(PublisherSocketHelper, _SocketHelper);
	
	  function PublisherSocketHelper(responder) {
	    _classCallCheck(this, PublisherSocketHelper);
	
	    return _possibleConstructorReturn(this, (PublisherSocketHelper.__proto__ || Object.getPrototypeOf(PublisherSocketHelper)).call(this, responder, NAME));
	  }
	
	  _createClass(PublisherSocketHelper, [{
	    key: 'respond',
	    value: function respond(message) {
	      if (message.data) {
	        var json = this.getJsonFromSocketMessage(message);
	        try {
	          if (!_get(PublisherSocketHelper.prototype.__proto__ || Object.getPrototypeOf(PublisherSocketHelper.prototype), 'respond', this).call(this, message)) {
	            if (json.data !== undefined) {
	              if (json.data.sdp !== undefined) {
	                if (json.data.sdp.type === 'answer') {
	                  this._responder.onSDPAnswer(json.data);
	                }
	              }
	              if (json.data.candidate !== undefined) {
	                this._responder.onAddIceCandidate(json.data.candidate);
	              }
	              if (json.data.type === 'status') {
	                if (json.data.code === 'NetConnection.ICE.TricleCompleted' || json.data.code === 'NetConnection.ICE.TrickleCompleted') {
	                  this._responder.onSocketIceCandidateEnd();
	                } else {
	                  this._responder.onPublisherStatus(json.data);
	                }
	              }
	            }
	          }
	        } catch (e) {
	          (0, _log.error)(NAME, '[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
	          this._responder.onSocketMessageError('[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
	        }
	      } else {
	        (0, _log.warn)(NAME, '[ws.onmessage] - No Message Data.');
	      }
	    }
	  }]);
	
	  return PublisherSocketHelper;
	}(_socketHelper2.default);
	
	exports.default = PublisherSocketHelper;

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _webrtc = __webpack_require__(318);
	
	var webrtc = _interopRequireWildcard(_webrtc);
	
	var _promise = __webpack_require__(310);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProPublishPeer';
	
	var PublisherPeerHelper = function () {
	  function PublisherPeerHelper(responder) {
	    _classCallCheck(this, PublisherPeerHelper);
	
	    this._responder = responder;
	    this._peerConnection = undefined;
	  }
	
	  _createClass(PublisherPeerHelper, [{
	    key: '_removeConnectionHandlers',
	    value: function _removeConnectionHandlers(connection) {
	      connection.onconnectionstatechange = undefined;
	      connection.onicecandidate = undefined;
	    }
	  }, {
	    key: '_addConnectionHandlers',
	    value: function _addConnectionHandlers(connection, promise) {
	      var _this = this;
	
	      connection.onconnectionstatechange = function () {
	        if (connection.connectionState === 'connected') {
	          (0, _log.debug)(NAME, '[peerconnection:open]');
	          if (promise) {
	            promise.resolve(_this);
	          }
	        } else if (connection.connectionState === 'failed' || connection.connectionState === 'disconnected') {
	          (0, _log.warn)(NAME, '[peerconnection:error]');
	          if (promise) {
	            promise.reject();
	          }
	        }
	      };
	
	      connection.onicecandidate = function (event) {
	        (0, _log.debug)(NAME, '[peer.onicecandidate] - Peer Candidate: ' + event.candidate);
	        if (event.candidate) {
	          _this._responder.onIceCandidate(event.candidate);
	        } else if (event.candidate === null) {
	          // null means they have finished sending candidates back and forth?
	          // Moved to notification from server on trickle end event.
	          // this._responder.onIceCandidateTrickleEnd()
	        }
	      };
	    }
	  }, {
	    key: 'createOffer',
	    value: function createOffer() {
	      var _this2 = this;
	
	      var bandwidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var offerPromise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	      (0, _log.debug)(NAME, '[createoffer]');
	      var p = offerPromise || new _promise.DeferredPromise();
	      this._peerConnection.createOffer().then(function (sessionDescription) {
	        _this2.setLocalDescription(sessionDescription, bandwidth).then(function () {
	          if (bandwidth) {
	            sessionDescription.sdp = webrtc.updateBandwidth(bandwidth, sessionDescription.sdp);
	          }
	          _this2._responder.onSDPSuccess();
	          p.resolve(sessionDescription);
	        }).catch(function (err) {
	          _this2._responder.onSDPError(err);
	          p.reject(err);
	        });
	      }).catch(function (err) {
	        (0, _log.debug)(NAME, '[createoffer:error]');
	        p.reject(err);
	      });
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'setLocalDescription',
	    value: function setLocalDescription(sessionDescription) {
	      var bandwidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      // eslint-disable-line no-unused-vars
	      (0, _log.debug)(NAME, '[setlocaldescription]');
	      return this._peerConnection.setLocalDescription(sessionDescription);
	    }
	  }, {
	    key: 'setRemoteDescription',
	    value: function setRemoteDescription(sdp) {
	      (0, _log.debug)(NAME, '[setremotedescription]');
	      return this._peerConnection.setRemoteDescription(new webrtc.RTCSessionDescription(sdp));
	    }
	  }, {
	    key: 'addIceCandidate',
	    value: function addIceCandidate(candidate) {
	      (0, _log.debug)(NAME, '[addcandidate]');
	      return this._peerConnection.addIceCandidate(candidate);
	    }
	  }, {
	    key: 'setUp',
	    value: function setUp(iceServers) {
	      var setUpPromise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	      this.tearDown();
	      (0, _log.debug)(NAME, '[setup]');
	      var p = setUpPromise || new _promise.DeferredPromise();
	      try {
	        var peer = new webrtc.RTCPeerConnection({
	          iceServers: iceServers,
	          rtcpMuxPolicy: 'negotiate'
	        }, {
	          optional: [{ DtlsSrtpKeyAgreement: true }, { RtpDataChannels: false }, { googCpuOveruseDetection: true }]
	        });
	        this._addConnectionHandlers(peer);
	        this._peerConnection = peer;
	        p.resolve(peer);
	      } catch (e) {
	        (0, _log.warn)(NAME, 'Could not establish a PeerConnection. ' + e.message);
	        p.reject(e.message);
	      }
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'tearDown',
	    value: function tearDown() {
	      (0, _log.debug)(NAME, '[teardown]');
	      if (this._peerConnection) {
	        this._removeConnectionHandlers(this._peerConnection);
	        try {
	          this._peerConnection.close();
	        } catch (e) {
	          (0, _log.warn)(NAME, '[peerconnection.close] error: ' + e.message);
	        }
	      }
	    }
	  }, {
	    key: 'connection',
	    get: function get() {
	      return this._peerConnection;
	    }
	  }]);
	
	  return PublisherPeerHelper;
	}();
	
	exports.default = PublisherPeerHelper;

/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Red5ProSharedObject = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _index = __webpack_require__(313);
	
	var _sharedobjectEvent = __webpack_require__(304);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'Red5ProSharedObject';
	var debug = function debug(soName, message) {
	  (0, _log.debug)([NAME, soName].join(':'), message);
	};
	var warn = function warn(soName, message) {
	  (0, _log.warn)([NAME, soName].join(':'), message);
	};
	var error = function error(soName, message) {
	  (0, _log.error)([NAME, soName].join(':'), message);
	};
	
	var SO_SUBTYPE_PROPERTY = 4;
	var SO_SUBTYPE_METHOD = 6;
	
	var decodeMessageIfJSONString = function decodeMessageIfJSONString(message) {
	  return typeof message === 'string' ? JSON.parse(message) : message;
	};
	
	var PropertyData = function () {
	  function PropertyData(key, value) {
	    _classCallCheck(this, PropertyData);
	
	    this.key = key;
	    this.value = value;
	  }
	
	  _createClass(PropertyData, [{
	    key: 'toObject',
	    value: function toObject() {
	      var obj = {};
	      obj[this.key] = this.value;
	      return obj;
	    }
	  }]);
	
	  return PropertyData;
	}();
	
	var MethodData = function () {
	  function MethodData(methodName, message) {
	    _classCallCheck(this, MethodData);
	
	    this.methodName = methodName;
	    var messageList = void 0;
	    if (Object.prototype.toString.call(message) === '[object Array]') {
	      var i = void 0;
	      var msg = void 0;
	      var length = message.length;
	      messageList = [];
	      for (i = 0; i < length; i++) {
	        msg = decodeMessageIfJSONString(message[i]);
	        if (Object.prototype.toString.call(message) === '[object Array]') {
	          messageList = messageList.concat(msg);
	        } else {
	          messageList.push(msg);
	        }
	      }
	    } else {
	      messageList = [decodeMessageIfJSONString(message)];
	    }
	    this.message = messageList.length === 1 ? messageList[0] : messageList;
	  }
	
	  _createClass(MethodData, [{
	    key: 'toObject',
	    value: function toObject() {
	      return {
	        methodName: this.methodName,
	        message: this.message
	      };
	    }
	  }]);
	
	  return MethodData;
	}();
	
	var Red5ProSharedObject = function (_EventEmitter) {
	  _inherits(Red5ProSharedObject, _EventEmitter);
	
	  function Red5ProSharedObject(name, connection) {
	    _classCallCheck(this, Red5ProSharedObject);
	
	    var _this = _possibleConstructorReturn(this, (Red5ProSharedObject.__proto__ || Object.getPrototypeOf(Red5ProSharedObject)).call(this));
	
	    _this._name = name;
	    _this._socket = connection.getConnection();
	    _this._socket.addSharedObjectResponseHandler(_this);
	    _this._onclose = _this.close.bind(_this);
	    try {
	      debug(_this._name, '[sharedobject:connect:attempt]');
	      _this._socket.getRemoteSharedObject(_this._name);
	      _browser2.default.addCloseHandler(_this._onclose, 0);
	    } catch (e) {
	      error(_this._name, '[sharedobject:connect:error]: ' + e.message);
	    }
	    return _this;
	  }
	
	  _createClass(Red5ProSharedObject, [{
	    key: 'getJsonFromSocketMessage',
	    value: function getJsonFromSocketMessage(message) {
	      try {
	        return typeof message.data === 'string' ? JSON.parse(message.data) : message.data;
	      } catch (e) {
	        warn(this._name, 'Could not parse message as JSON. Message= ' + message.data + '. Error= ' + e.message);
	      }
	      return null;
	    }
	  }, {
	    key: 'notifyOfPropertyValues',
	    value: function notifyOfPropertyValues(valueObject) {
	      if (Object.keys(valueObject).length === 0) {
	        this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.PROPERTY_UPDATE, this._name, {}));
	      } else {
	        var key = void 0;
	        for (key in valueObject) {
	          this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.PROPERTY_UPDATE, this._name, new PropertyData(key, valueObject[key]).toObject()));
	        }
	      }
	    }
	  }, {
	    key: 'notifyOfEvents',
	    value: function notifyOfEvents(events) {
	      var i = void 0,
	          event = void 0;
	      var length = events.length;
	      for (i = 0; i < length; i++) {
	        event = events[i];
	        switch (event.subtype) {
	          case SO_SUBTYPE_PROPERTY:
	            this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.PROPERTY_UPDATE, this._name, new PropertyData(event.attribute, event.value).toObject()));
	            return true;
	          case SO_SUBTYPE_METHOD:
	            this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.METHOD_UPDATE, this._name, new MethodData(event.method, event.value).toObject()));
	            return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: 'respond',
	    value: function respond(message) {
	      if (message.data) {
	        var json = this.getJsonFromSocketMessage(message);
	        if (json === null) {
	          warn(this._name, 'Determined websocket response not in correct format. Aborting message handle.');
	          return true;
	        }
	        if (json.data !== undefined) {
	          if (json.data.name === this._name) {
	            debug(this._name, '[sharedobject-response]: ' + JSON.stringify(json, null, 2));
	            if (json.data.status === 'SharedObject.Status.GetRemote' && json.data.message === 'Success') {
	              this._socket.connectToSharedObject(this._name);
	              return true;
	            } else if (json.data.status === 'SharedObject.Status.GetRemote' && json.data.message === 'Fail') {
	              this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.CONNECT_FAILURE, this._name));
	              return true;
	            } else if (json.data.status === 'SharedObject.Status.Connect' && json.data.message === 'Success') {
	              this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.CONNECT_SUCCESS, this._name));
	              return true;
	            } else if (json.data.status === 'SharedObject.Status.Connect' && json.data.message === 'Fail') {
	              this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.CONNECT_FAILURE, this._name));
	              return true;
	            } else if (json.data.type === 'sharedobject') {
	              if (json.data.hasOwnProperty('events')) {
	                return this.notifyOfEvents(json.data.events);
	              } else if (json.data.hasOwnProperty('value')) {
	                return this.notifyOfPropertyValues(json.data.value);
	              }
	            }
	          } else {
	            debug('Unhandled Socket exchange: ' + JSON.stringify(json, null, 2));
	          }
	        }
	      }
	      return false;
	    }
	  }, {
	    key: 'send',
	    value: function send(messageName, data) {
	      this._socket.sendToSharedObject(this._name, messageName, data);
	    }
	  }, {
	    key: 'sendProperty',
	    value: function sendProperty(key, value) {
	      this._socket.sendPropertyToSharedObject(this._name, key, value);
	    }
	  }, {
	    key: 'close',
	    value: function close() {
	      if (this._socket === undefined) {
	        warn('Socket no longer exist to close shared object properly.');
	      }
	      this._socket.closeSharedObject(this._name);
	      if (this._socket) {
	        this._socket.removeSharedObjectResponseHandler(this);
	      }
	      this._socket = undefined;
	      this._name = undefined;
	      _browser2.default.removeCloseHandler(this._onclose);
	    }
	  }, {
	    key: 'getName',
	    value: function getName() {
	      return this._name;
	    }
	  }]);
	
	  return Red5ProSharedObject;
	}(_eventEmitter2.default);
	
	exports.Red5ProSharedObject = Red5ProSharedObject;

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	'use script';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PlaybackView = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProPlaybackView';
	var playbackId = 'red5pro-subscriber';
	
	var PlaybackView = exports.PlaybackView = function () {
	  function PlaybackView() {
	    var elementId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : playbackId;
	
	    _classCallCheck(this, PlaybackView);
	
	    try {
	      // Target video element.
	      this._targetElement = _browser2.default.resolveElement(elementId);
	    } catch (e) {
	      (0, _log.error)(NAME, 'Could not instantiate a new instance of Red5ProSubscriber. Reason: ' + e.message);
	      throw e;
	    }
	  }
	
	  _createClass(PlaybackView, [{
	    key: 'attachSubscriber',
	    value: function attachSubscriber(subscriber) {
	      (0, _log.debug)(NAME, '[attachsubscriber]');
	      subscriber.setView(this, _browser2.default.getElementId(this._targetElement));
	    }
	  }, {
	    key: 'attachStream',
	    value: function attachStream(mediaStream) {
	      var autoplay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	      (0, _log.debug)(NAME, '[attachstream]: autoplay(' + autoplay + ')');
	      _browser2.default.setVideoSource(this._targetElement, mediaStream, autoplay);
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      (0, _log.debug)(NAME, '[stop]');
	      try {
	        this._targetElement.pause();
	      } catch (e) {
	        (0, _log.warn)(NAME, 'Could not stop video element: ' + e.message);
	      }
	    }
	  }, {
	    key: 'view',
	    get: function get() {
	      return this._targetElement;
	    }
	  }]);
	
	  return PlaybackView;
	}();
	
	exports.default = PlaybackView;

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProPublishView';
	
	var publisherId = 'red5pro-publisher';
	
	var PublishView = function () {
	  function PublishView() {
	    var elementId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : publisherId;
	
	    _classCallCheck(this, PublishView);
	
	    try {
	      this._targetElement = _browser2.default.resolveElement(elementId);
	    } catch (e) {
	      (0, _log.error)(NAME, 'Could not instantiate a new instance of Red5ProPublisher. Reason: ' + e.message);
	      throw e;
	    }
	  }
	
	  _createClass(PublishView, [{
	    key: 'attachPublisher',
	    value: function attachPublisher(publisher) {
	      (0, _log.debug)(NAME, '[attachpublisher]');
	      publisher.setView(this, _browser2.default.getElementId(this._targetElement));
	    }
	  }, {
	    key: 'preview',
	    value: function preview(mediaStream) {
	      var autoplay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	      (0, _log.debug)(NAME, '[preview]: autoplay(' + autoplay + ')');
	      _browser2.default.setVideoSource(this._targetElement, mediaStream, autoplay);
	    }
	  }, {
	    key: 'view',
	    get: function get() {
	      return this._targetElement;
	    }
	  }]);
	
	  return PublishView;
	}();
	
	exports.default = PublishView;

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBjOTExOWIwMTZiZjcwZGNlNTE0NyIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19rZXlvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2FtZS12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hLW51bWJlci12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2x6MzIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY29zaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1leHBtMS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5mcm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRydW5jLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5iaWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb3J0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19mbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstbWFwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1mb3JjZWQtcGFtLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaW11bGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgudW11bGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnRpYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovLy8uL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xvZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXItYnVueWFuL2xpYi9idW55YW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xvZy9idW55YW4td3JpdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9ldmVudC9wdWJsaXNoZXItZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2V2ZW50L3N1YnNjcmliZXItZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2V2ZW50L3NoYXJlZG9iamVjdC1ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZW51bS9wbGF5YmFjay5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3Vic2NyaWJlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29yZS9ldmVudC1lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRjLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9lbnYvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbC9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9leGNlcHRpb24vZXJyb3JzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9lbnYvbWV0YWRhdGEtdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZXZlbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2hlbHBlci9zb2NrZXQtaGVscGVyLXN1Yi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvaGVscGVyL3NvY2tldC1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2FkYXB0ZXIvd2Vic29ja2V0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9oZWxwZXIvd2VicnRjLWhlbHBlci1zdWIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2FkYXB0ZXIvd2VicnRjLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8taGxzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL3ZpZGVvanMtc291cmNlLWhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWwvb2JqZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRtcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3Vic2NyaWJlci9yZWQ1cHJvLXJ0bXAtdmlkZW9qcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3Vic2NyaWJlci9yZWQ1cHJvLXJ0bXAtbGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3Vic2NyaWJlci9saXZlLXNvdXJjZS1oYW5kbGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9lbnYvZW1iZWQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2hlbHBlci9zaGFyZWRvYmplY3QtaGVscGVyLXJ0bXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWwvaW1wbC1mYWN0b3J5LW9yZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9wdWJsaXNoZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3B1Ymxpc2hlci9yZWQ1cHJvLXJ0bXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2VudW0vcHVibGlzaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcHVibGlzaGVyL3B1Yi1zb3VyY2UtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcHVibGlzaGVyL3JlZDVwcm8tcnRjLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9oZWxwZXIvc29ja2V0LWhlbHBlci1wdWIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2hlbHBlci93ZWJydGMtaGVscGVyLXB1Yi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2hhcmVkb2JqZWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy92aWV3L3BsYXliYWNrLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy92aWV3L3B1Ymxpc2guanMiXSwibmFtZXMiOlsiTEVWRUxTIiwiZ2V0TG9nZ2VyIiwiY29tbW9uIiwicnRjIiwiZmFpbG92ZXIiLCJQbGF5YmFja0F1ZGlvRW5jb2RlciIsIlBsYXliYWNrVmlkZW9FbmNvZGVyIiwic3Vic2NyaWJlckxpYiIsInB1Ymxpc2hlckxpYiIsInNoYXJlZE9iamVjdExpYiIsIlJlZDVQcm9TdWJzY3JpYmVyIiwiUlRDU3Vic2NyaWJlciIsIkhMU1N1YnNjcmliZXIiLCJWaWRlb0pTU3Vic2NyaWJlciIsIlI1TGl2ZVN1YnNjcmliZXIiLCJSVE1QU3Vic2NyaWJlciIsIlBsYXliYWNrVmlldyIsIlJlZDVQcm9QdWJsaXNoZXIiLCJSVE1QUHVibGlzaGVyIiwiUlRDUHVibGlzaGVyIiwiUHVibGlzaGVyVmlldyIsIlJlZDVQcm9TaGFyZWRPYmplY3QiLCJERUJVRyIsImRlYnVnIiwic2V0TG9nTGV2ZWwiLCJsZXZlbCIsImhhc093blByb3BlcnR5IiwidG9VcHBlckNhc2UiLCJsb2dnZXIiLCJmb3JtYXRNZXNzYWdlIiwiZGlzcGF0Y2hlciIsIm1lc3NhZ2UiLCJkZWNvcmF0ZSIsInNvdXJjZSIsIlRSQUNFIiwiSU5GTyIsIldBUk4iLCJFUlJPUiIsIkZBVEFMIiwiZXN0YWJsaXNoTG9nZ2VyIiwic3RyZWFtTGlzdCIsInVuZGVmaW5lZCIsInN0cmVhbXMiLCJwdXNoIiwic3RyZWFtIiwidHlwZSIsImxpc3QiLCJtYXAiLCJpdGVtIiwiY29uY2F0IiwibmFtZSIsInRyYWNlIiwiaW5mbyIsIndhcm4iLCJlcnJvciIsImZhdGFsIiwiUmF3U3RyZWFtIiwicmVjIiwiY29uc29sZSIsImxvZyIsIm1zZyIsIk9iamVjdCIsImZyZWV6ZSIsIkNPTk5FQ1RfU1VDQ0VTUyIsIkNPTk5FQ1RfRkFJTFVSRSIsIlBVQkxJU0hfU1RBUlQiLCJQVUJMSVNIX0ZBSUwiLCJQVUJMSVNIX0lOVkFMSURfTkFNRSIsIlVOUFVCTElTSF9TVUNDRVNTIiwiUFVCTElTSF9NRVRBREFUQSIsIlBVQkxJU0hFUl9SRUpFQ1QiLCJQVUJMSVNIRVJfQUNDRVBUIiwiTUVESUFfU1RSRUFNX0FWQUlMQUJMRSIsIlBFRVJfQ09OTkVDVElPTl9BVkFJTEFCTEUiLCJPRkZFUl9TVEFSVCIsIk9GRkVSX0VORCIsIklDRV9UUklDS0xFX0NPTVBMRVRFIiwicnRtcCIsIkVNQkVEX1NVQ0NFU1MiLCJFTUJFRF9GQUlMVVJFIiwiU1VCU0NSSUJFX1NUQVJUIiwiU1VCU0NSSUJFX1NUT1AiLCJTVUJTQ1JJQkVfRkFJTCIsIlNVQlNDUklCRV9JTlZBTElEX05BTUUiLCJTVUJTQ1JJQkVfTUVUQURBVEEiLCJQTEFZX1VOUFVCTElTSCIsIkNPTk5FQ1RJT05fQ0xPU0VEIiwiU1VCU0NSSUJFUl9SRUpFQ1QiLCJTVUJTQ1JJQkVSX0FDQ0VQVCIsIkFOU1dFUl9TVEFSVCIsIkFOU1dFUl9FTkQiLCJDQU5ESURBVEVfU1RBUlQiLCJDQU5ESURBVEVfRU5EIiwiUFJPUEVSVFlfVVBEQVRFIiwiTUVUSE9EX1VQREFURSIsIlBsYXliYWNrVHlwZXMiLCJSVE1QIiwiUlRDIiwiSExTIiwiT1BVUyIsIlBDTVUiLCJQQ01BIiwiU1BFRVgiLCJOT05FIiwiVlA4IiwiSDI2NCIsIk5BTUUiLCJwbGF5YmFja0ZhY3RvcnkiLCJwbGF5YmFja0ltcGwiLCJNYXAiLCJzZXQiLCJfb3B0aW9ucyIsIl92aWV3IiwiX2N1cnJlbnRTdWJzY3JpYmVyIiwiX29yZGVyIiwiX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50IiwiYnViYmxlU3Vic2NyaWJlckV2ZW50IiwiYmluZCIsIm9yZGVyIiwidCIsImZpbHRlciIsImtleSIsInRvTG93ZXJDYXNlIiwiZW50cnkiLCJTZXQiLCJwbGF5YmFja1ZpZXciLCJvcHRpb25zIiwiY3JlYXRlIiwiZGVmZXJyZWQiLCJnZXRQbGF5YmFja0Zyb21PcmRlciIsInRoZW4iLCJzdWJzY3JpYmVyIiwiZ2V0VHlwZSIsIm9uIiwic2V0VmlldyIsInJlc29sdmUiLCJjYXRjaCIsImVyciIsInJlamVjdCIsInByb21pc2UiLCJzdG9wIiwib2ZmIiwic3Vic2NyaWJlckV2ZW50IiwidHJpZ2dlciIsImNhbGwiLCJXSUxEQ0FSRCIsIldJTERDQVJEX0tFWSIsIkV2ZW50RW1pdHRlciIsIl9jYWxsYmFja3MiLCJjYWxsYmFja3MiLCJldmVudCIsImkiLCJsZW5ndGgiLCJmbiIsImluZGV4T2YiLCJpbmRleCIsInNwbGljZSIsIl9ub3RpZnkiLCJ3ZWJydGMiLCJ3ZWJzb2NrZXQiLCJkZWZhdWx0T3B0aW9ucyIsInN0cmVhbVR5cGUiLCJnZW5lcmF0ZVN1YnNjcmlwdGlvbklkIiwiaWQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJ0b1N0cmluZyIsImVuZHBvaW50RnJvbU9wdGlvbnMiLCJwcm90b2NvbCIsIndzcHJvdG9jb2wiLCJwb3J0Iiwid3Nwb3J0IiwiYXBwRW5kcG9pbnQiLCJjb250ZXh0IiwiYXBwIiwiam9pbiIsImVuZHBvaW50IiwiaG9zdCIsInN1YnNjcmlwdGlvbklkIiwiY29ubmVjdGlvblBhcmFtcyIsInBhcmFtcyIsImtleXMiLCJmb3JFYWNoIiwiX3BlZXJIZWxwZXIiLCJfc29ja2V0SGVscGVyIiwiX29yaWVudGF0aW9uIiwiaXNTdXBwb3J0ZWQiLCJhc3NpZ24iLCJ2aWV3Iiwic3RyZWFtTmFtZSIsInBvc3QiLCJpc0F2YWlsYWJsZSIsInZFbmNvZGluZyIsImFFbmNvZGluZyIsIm9mZmVyIiwicmVxdWVzdE9mZmVyIiwicmVxdWVzdElkIiwidmlkZW9FbmNvZGluZyIsImF1ZGlvRW5jb2RpbmciLCJzZHAiLCJjcmVhdGVBbnN3ZXIiLCJiYW5kd2lkdGgiLCJzZXNzaW9uRGVzY3JpcHRpb24iLCJ1cGRhdGVCYW5kd2lkdGgiLCJzZW5kQW5zd2VyIiwib25TRFBFcnJvciIsImhhbmRsZUFuc3dlciIsImRhdGEiLCJjYW5kaWRhdGUiLCJoYW5kbGVDYW5kaWRhdGUiLCJzdWJzY3JpYmUiLCJyZWNlaXB0IiwiSlNPTiIsInN0cmluZ2lmeSIsIl9jb25uZWN0IiwiaWNlU2VydmVycyIsIl9kaXNjb25uZWN0IiwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIiwicmVxdWVzdEFuc3dlciIsInNlbmRDYW5kaWRhdGUiLCJhdHRhY2hTdHJlYW0iLCJhdXRvcGxheSIsImFkZEljZUNhbmRpZGF0ZSIsInNlbmRTdWJzY3JpYmUiLCJkZXRhaWwiLCJtZXRhZGF0YSIsIm9yaWVudGF0aW9uIiwiYXBwbHlPcmllbnRhdGlvbiIsInRlYXJEb3duIiwicCIsInNldFVwIiwic29ja2V0UHJvbWlzZSIsInNvY2tldHVybCIsInJlcXVlc3RBdmFpbGFiaWxpdHkiLCJVTlNVQlNDUklCRV9TVUNDRVNTIiwiY29ubmVjdGlvbiIsImNsb3NlSGFuZGxlcnMiLCJvbndpbmRvd2Nsb3NlIiwiZSIsImZsYXNoVmVyc2lvbiIsInZlcnNpb24iLCJ3aW5kb3ciLCJBY3RpdmVYT2JqZWN0IiwiR2V0VmFyaWFibGUiLCJyZXBsYWNlIiwibWF0Y2giLCJuYXZpZ2F0b3IiLCJtaW1lVHlwZXMiLCJlbmFibGVkUGx1Z2luIiwicGx1Z2lucyIsImRlc2NyaXB0aW9uIiwic3BsaXQiLCJpc01veiIsIm1vekdldFVzZXJNZWRpYSIsImdldFVzZXJNZWRpYSIsIndlYmtpdEdldFVzZXJNZWRpYSIsIm1zR2V0VXNlck1lZGlhIiwiZGVmYXVsdFVzZXJNZWRpYUF1ZGlvIiwibWFuZGl0b3J5IiwiZ29vZ0F1dG9HYWluQ29udHJvbCIsImdvb2dIaWdocGFzc0ZpbHRlciIsImdvb2dFY2hvQ2FuY2VsbGF0aW9uIiwiZ29vZ05vaXNlU3VwcHJlc3Npb24iLCJvcHRpb25hbCIsImVjaG9DYW5jZWxsYXRpb24iLCJkZWZhdWx0VXNlck1lZGlhVmlkZW8iLCJtYW5kYXRvcnkiLCJtaW5XaWR0aCIsIm1pbkhlaWdodCIsIm1pbkZyYW1lUmF0ZSIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwibWF4RnJhbWVSYXRlIiwib3JpZ2luIiwic3R5bGVzIiwidHJhbnNpdGlvbiIsInJvdGF0aW9uVHJhbnNsYXRpb25zIiwidHJhbnNmb3JtIiwic3VwcG9ydHNXZWJTb2NrZXQiLCJXZWJTb2NrZXQiLCJzdXBwb3J0c0ZsYXNoVmVyc2lvbiIsImRlbGltaXRlciIsInJlc29sdmVFbGVtZW50IiwiZWwiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiY3JlYXRlV2ViU29ja2V0IiwidXJsIiwic2V0VmlkZW9Tb3VyY2UiLCJ2aWRlb0VsZW1lbnQiLCJtZWRpYVN0cmVhbSIsInNyYyIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInBsYXkiLCJpbmplY3RTY3JpcHQiLCJkZmQiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50Iiwib25sb2FkIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiYXBwZW5kQ2hpbGQiLCJzZXRHbG9iYWwiLCJwcm9wIiwidmFsdWUiLCJnZXRTd2ZPYmplY3QiLCJzd2ZvYmplY3QiLCJnZXRFbWJlZE9iamVjdCIsImdldEVsZW1lbnRJZCIsImdldEF0dHJpYnV0ZSIsImdldFZpZGVvSnMiLCJ2aWRlb2pzIiwiYXVkaW8iLCJ2aWRlbyIsImdldERlZmF1bHRQdWJsaXNoQ29uc3RyYWludHMiLCJvZmZlclRvUmVjZWl2ZVZpZGVvIiwib2ZmZXJUb1JlY2VpdmVBdWRpbyIsImdldElzTW96IiwiYWRkQ2xvc2VIYW5kbGVyIiwiaGFuZGxlciIsImluc2VydFZhbHVlIiwic2xpY2UiLCJvbmJlZm9yZXVubG9hZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVDbG9zZUhhbmRsZXIiLCJvbk9yaWVudGF0aW9uTWV0YWRhdGEiLCJlbGVtZW50IiwidHJhbnNsYXRpb25zIiwic3R5bGUiLCJfRGVmZXJyZWRQcm9taXNlIiwiUHJvbWlzZSIsIl9GdXR1cmUiLCJjcmVhdGVJZk5vdEV4aXN0IiwiZGVmZXJyZWRJZkV4aXN0IiwiZiIsIkRlZmVycmVkUHJvbWlzZSIsIkZ1dHVyZSIsIk5vRWxlbWVudEZvdW5kRXJyb3IiLCJqc29uQXR0ciIsImpzb25WYWwiLCJyZWFkVVRGIiwic3RhcnQiLCJsZW4iLCJyZXN1bHQiLCJvZmZzZXQiLCJlbmQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJwYXJzZUpTT05Gb3JPcmllbnRhdGlvbiIsInRleHQiLCJwYXJzZSIsInBhcnNlSW50IiwiZXhlYyIsIm1hdGNoMiIsInBsYXllciIsImNhbGxiYWNrIiwidGV4dFRyYWNrcyIsImFkZFRleHRUcmFjayIsInRyYWNrIiwiYWRkVHJhY2tFdmVudCIsIm1vZGUiLCJjdWVzIiwiY3VlQ2hhbmdlRXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwiYWN0aXZlQ3VlcyIsInNpemUiLCJFdmVudCIsIl90eXBlIiwiX2RhdGEiLCJQdWJsaXNoZXJFdmVudCIsInB1Ymxpc2hlciIsIl9wdWJsaXNoZXIiLCJTdWJzY3JpYmVyRXZlbnQiLCJfc3Vic2NyaWJlciIsIlNoYXJlZE9iamVjdEV2ZW50Iiwic2hhcmVkT2JqZWN0TmFtZSIsIl9uYW1lIiwiU3Vic2NyaXB0aW9uU29ja2V0SGVscGVyIiwicmVzcG9uZGVyIiwianNvbiIsImdldEpzb25Gcm9tU29ja2V0TWVzc2FnZSIsIl9yZXNwb25kZXIiLCJvblNEUE9mZmVyIiwib25BZGRJY2VDYW5kaWRhdGUiLCJjb2RlIiwib25Tb2NrZXRJY2VDYW5kaWRhdGVFbmQiLCJvblVucHVibGlzaCIsIm9uQ29ubmVjdGlvbkNsb3NlZCIsInN0YXR1cyIsIm9uTWV0YWRhdGEiLCJvblNvY2tldE1lc3NhZ2VFcnJvciIsIlNvY2tldEhlbHBlciIsIl9wZW5kaW5nUG9zdFJlcXVlc3RzIiwiX3dlYnNvY2tldCIsIl9jb25uZWN0aW9uUHJvbWlzZSIsIl9yZXNwb25zZUhhbmRsZXJzIiwiX29uY2xvc2UiLCJ3cyIsIm9ub3BlbiIsIm9ubWVzc2FnZSIsIm9uZXJyb3IiLCJzaGlmdCIsInJlc3BvbmQiLCJzZXR1cFByb21pc2UiLCJfYWRkU29ja2V0SGFuZGxlcnMiLCJfcmVtb3ZlU29ja2V0SGFuZGxlcnMiLCJjbG9zZSIsInJIYW5kbGVyIiwic2VuZFJlcXVlc3QiLCJzZW5kIiwiaGFuZGxlZCIsImhhbmRsZU1lc3NhZ2VSZXNwb25zZSIsIm9uU3RyZWFtQXZhaWxhYmxlIiwib25TdHJlYW1VbmF2YWlsYWJsZSIsInNoYXJlZE9iamVjdEdldFJlbW90ZSIsInNoYXJlZE9iamVjdENvbm5lY3QiLCJjYWxsTmFtZSIsInNoYXJlZE9iamVjdFNlbmQiLCJzaGFyZWRPYmplY3RTZXRQcm9wZXJ0eSIsInNoYXJlZE9iamVjdENsb3NlIiwiU3Vic2NyaXB0aW9uUGVlckhlbHBlciIsIl9wZWVyQ29ubmVjdGlvbiIsIl9wZW5kaW5nTWVkaWFTdHJlYW0iLCJvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsIm9uaWNlY2FuZGlkYXRlIiwib25hZGRzdHJlYW0iLCJvbnRyYWNrIiwiY29ubmVjdGlvblN0YXRlIiwib25JY2VDYW5kaWRhdGUiLCJvbkljZUNhbmRpZGF0ZVRyaWNrbGVFbmQiLCJvbkFuc3dlck1lZGlhU3RyZWFtIiwic2V0VXBQcm9taXNlIiwicGVlciIsIlJUQ1BlZXJDb25uZWN0aW9uIiwicnRjcE11eFBvbGljeSIsIkR0bHNTcnRwS2V5QWdyZWVtZW50IiwiUnRwRGF0YUNoYW5uZWxzIiwiZ29vZ0NwdU92ZXJ1c2VEZXRlY3Rpb24iLCJfYWRkQ29ubmVjdGlvbkhhbmRsZXJzIiwiX3JlbW92ZUNvbm5lY3Rpb25IYW5kbGVycyIsInNldFJlbW90ZURlc2NyaXB0aW9uIiwib25TRFBTdWNjZXNzIiwic2V0TG9jYWxEZXNjcmlwdGlvbiIsImljZUNhbmRpZGF0ZSIsIlJUQ0ljZUNhbmRpZGF0ZSIsInNkcE1MaW5lSW5kZXgiLCJfUlRDUGVlckNvbm5lY3Rpb24iLCJtb3pSVENQZWVyQ29ubmVjdGlvbiIsIndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uIiwiX1JUQ0ljZUNhbmRpZGF0ZSIsIm1velJUQ0ljZUNhbmRpZGF0ZSIsIndlYmtpdFJUQ0ljZUNhbmRpZGF0ZSIsIl9SVENTZXNzaW9uRGVzY3JpcHRpb24iLCJtb3pSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJ3ZWJraXRSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJtaW1lVHlwZSIsInN3ZiIsIm9wdGlvbnNUb0hsc1VSTCIsImhsc3Byb3RvY29sIiwiaGxzcG9ydCIsIl92aWRlb2pzSGFuZGxlciIsIl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudHMiLCJidWJibGVTdWJzY3JpYmVyRXZlbnRzIiwiZGlzY29ubmVjdCIsInVybFJlZ2V4Iiwic3dmVVJMIiwicnRtcE1pbWVUeXBlIiwiYWRkU291cmNlIiwiZ2V0UGxheWVyIiwib3B0aW9uc1RvVVJMIiwiQmFzZUhhbmRsZXIiLCJwbGF5ZXJUeXBlIiwiY2xvbmUiLCJjbG9uZU5vZGUiLCJob2xkZXIiLCJwYXJlbnROb2RlIiwiaGFzQXNzaWduZWRFdmVudExpc3RlbmVycyIsIm9uVmlkZW9KU0Vycm9yIiwib25WaWRlb0pTTG9hZGVkRGF0YSIsIm9uVmlkZW9KU0xvYWRlZE1ldGFkYXRhIiwib25WaWRlb0pTVGltZVVwZGF0ZSIsIm9uVmlkZW9KU1VzZXJBY3RpdmUiLCJvblZpZGVvSlNVc2VySW5hY3RpdmUiLCJvblZpZGVvSlNWb2x1bWVDaGFuZ2UiLCJvblZpZGVvSlNFbmRlZCIsInJlbW92ZSIsInJlbW92ZVZpZGVvSlNFdmVudExpc3RlbmVycyIsImRpc3Bvc2UiLCJ2aWRlb0ltcGwiLCJzZWxmIiwiY3JlYXRlU291cmNlIiwiX3NyYyIsInNvdXJjZUVsIiwiaW5zZXJ0U291cmNlSW50byIsIl9wYXJlbnQiLCJmaXJzdENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwiY2xlYW51cCIsImNsZWFudXBWaWRlb0pTIiwic3JjVVJMIiwib3B0cyIsInRlY2hPcmRlciIsImFkZFZpZGVvSlNFdmVudExpc3RlbmVycyIsInBhdXNlIiwiZGVlcERlZmluZSIsIm9iamVjdCIsInBhdGhzIiwidGFpbCIsInBvcCIsInBhdGgiLCJSVE1QU3Vic2NyaWJlclByb3h5IiwiX2JvdW5kQnViYmxlU3ViSW1wbEV2ZW50IiwiaW1wbCIsInVzZVZpZGVvSlMiLCJpbml0IiwiZGVmYXVsdE1pbWVUeXBlIiwiZGVmYXVsdEZsYXNoVmVyc2lvbiIsImRlZmF1bHRTV0YiLCJvcHRpb25zVG9SdG1wVVJMIiwicnRtcHByb3RvY29sIiwicnRtcHBvcnQiLCJ3aWR0aCIsImhlaWdodCIsImVtYmVkV2lkdGgiLCJlbWJlZEhlaWdodCIsIm1pbkZsYXNoVmVyc2lvbiIsInN3Zm9iamVjdFVSTCIsInByb2R1Y3RJbnN0YWxsVXJsIiwiX3NvdXJjZUhhbmRsZXIiLCJfZWxlbWVudElkIiwiX3BsYXliYWNrUHJvbWlzZSIsImVsZW1lbnRJZCIsImludm9rZUZuIiwibGFiZWwiLCJfZXN0YWJsaXNoRXh0SW50SGFuZGxlcnMiLCJjYiIsImVtYmVkIiwidG9JbnQiLCJyb3VuZCIsIkxpdmVTb3VyY2VIYW5kbGVyIiwic29SZXNwb25kZXIiLCJfc3dmSWQiLCJfc29SZXNwb25kZXIiLCJzZXRTdWJzY3JpYmVySWQiLCJzdWNjZXNzSWQiLCJfdGVhckRvd25Jbml0Q2FsbGJhY2siLCJzZXRBY3RpdmVJZCIsInN3ZklkIiwic3dmVXJsIiwiX3NldFVwSW5pdENhbGxiYWNrIiwiZGVmaW5lRW1iZWRFbGVtZW50IiwiZmxhc2h2YXJzIiwiYnVmZmVyIiwiaXNOYU4iLCJOdW1iZXIiLCJhdXRvc2l6ZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImVtYmVkU3dmT2JqZWN0IiwiY29ubmVjdCIsImNsZWFuVXAiLCJhZGRSZXNwb25zZUhhbmRsZXIiLCJyZW1vdmVSZXNwb25zZUhhbmRsZXIiLCJzZW5kVG9TaGFyZWRPYmplY3QiLCJzZW5kUHJvcGVydHlUb1NoYXJlZE9iamVjdCIsImdldFJlbW90ZVNoYXJlZE9iamVjdCIsImNvbm5lY3RUb1NoYXJlZE9iamVjdCIsImNsb3NlU2hhcmVkT2JqZWN0IiwidGFyZ2V0RWxlbWVudCIsInRhcmdldFBhcmVudCIsIm5vZGVOYW1lIiwiZGl2IiwiaWROYW1lIiwicXVhbGl0eSIsImJnY29sb3IiLCJhbGxvd3NjcmlwdGFjY2VzcyIsImFsbG93ZnVsbHNjcmVlbiIsImF0dHJpYnV0ZXMiLCJhbGlnbiIsImhhc0ZsYXNoUGxheWVyVmVyc2lvbiIsImVtYmVkU1dGIiwicHJvZHVjdEluc3RhbGxVUkwiLCJSVE1QU2hhcmVkT2JqZWN0SGFuZGxlciIsIl9lbGVtZW50IiwiX2hhbmRsZVNoYXJlZE9iamVjdEV2ZW50IiwiaGFuZGxlU2hhcmVkT2JqZWN0RXZlbnQiLCJlbElkIiwiaGFuZGxlck5hbWUiLCJzZXRTaGFyZWRPYmplY3RSZXNwb25kZXIiLCJzaGFyZWRPYmplY3RTZW5kUHJvcGVydHkiLCJhc3NpZ25TaGFyZWRPYmplY3RSZXNwb25kZXIiLCJkaXNjb25uZWN0RnJvbVNoYXJlZE9iamVjdCIsIldlYWtNYXAiLCJwdnQiLCJjdHgiLCJoYXMiLCJnZXQiLCJJbXBsRmFjdG9yeU9yZGVyIiwibGlzdG9yZGVyIiwiZmluZCIsIml0ZXJhdG9yIiwiaW5pdEZuIiwibmV4dCIsIkltcGwiLCJjb25jcmV0ZSIsImRvbmUiLCJwdWJsaXNoRmFjdG9yeSIsInB1Ymxpc2hlckltcGwiLCJfY3VycmVudFB1Ymxpc2hlciIsIl9ib3VuZEJ1YmJsZVB1Ymxpc2hlckV2ZW50IiwiYnViYmxlUHVibGlzaGVyRXZlbnQiLCJwdWJsaXNoVmlldyIsImdldFB1Ymxpc2hlckZyb21PcmRlciIsInVucHVibGlzaCIsInB1Ymxpc2hlckV2ZW50Iiwic3RyZWFtTW9kZSIsIl9jb25uZWN0RnV0dXJlIiwiX3RlYXJEb3duQ29ubmVjdENhbGxiYWNrIiwiX3NldFVwQ29ubmVjdENhbGxiYWNrIiwicHVibGlzaE9wdGlvbnMiLCJzcmNIYW5kbGVyIiwiZ2V0RW1iZWRPcGVyYXRpb24iLCJjb3VudCIsImxpbWl0IiwidHJ5Q29ubmVjdCIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwibWV0aG9kTmFtZSIsInNldE1lZGlhUXVhbGl0eSIsIm5ld09wdGlvbnMiLCJQdWJsaXNoVHlwZXMiLCJQdWJsaXNoTW9kZVR5cGVzIiwiTElWRSIsIlJFQ09SRCIsIkFQUEVORCIsIlB1Ymxpc2hlclNvdXJjZUhhbmRsZXIiLCJwdWJsaXNoZXJUeXBlIiwiX2VtYmVkRnV0dXJlIiwiYXBwTmFtZSIsInJvb21OYW1lIiwidyIsImgiLCJ1cGRhdGVSZXNvbHV0aW9uIiwicHViU3RhcnRSZWdleCIsInB1YlN0b3BSZWdleCIsIl9tZWRpYVN0cmVhbSIsIl9zdHJlYW1GdXR1cmUiLCJfYXZhaWxhYmxlRnV0dXJlIiwiX3BlZXJGdXR1cmUiLCJfb2ZmZXJGdXR1cmUiLCJfc2VuZE9mZmVyRnV0dXJlIiwiX3RyaWNrbGVFbmRGdXR1cmUiLCJfcHVibGlzaEZ1dHVyZSIsIl91bnB1Ymxpc2hGdXR1cmUiLCJtZWRpYSIsImdldFRyYWNrcyIsInRyYWNrcyIsInRyYWNrTGVuZ3RoIiwiYnVuZGxlIiwiY3JlYXRlT2ZmZXIiLCJfc2VuZE9mZkZ1dHVyZSIsImhhbmRsZU9mZmVyIiwicHVibGlzaCIsIl9nZXRUcmlja2xlRW5kIiwiX2dldE1lZGlhU3RyZWFtIiwiY3JlYXRlUGVlckNvbm5lY3Rpb24iLCJhZGRTdHJlYW0iLCJzZW5kT2ZmZXIiLCJyZXF1ZXN0UHVibGlzaCIsImNsZWFySGVscGVycyIsInJlcXVlc3RVbnB1Ymxpc2giLCJtdXRlIiwibWV0aG9kIiwic3RvcFJlc3VsdCIsInN0YXJ0UmVzdWx0IiwiUHVibGlzaGVyU29ja2V0SGVscGVyIiwib25TRFBBbnN3ZXIiLCJvblB1Ymxpc2hlclN0YXR1cyIsIlB1Ymxpc2hlclBlZXJIZWxwZXIiLCJvZmZlclByb21pc2UiLCJzb05hbWUiLCJTT19TVUJUWVBFX1BST1BFUlRZIiwiU09fU1VCVFlQRV9NRVRIT0QiLCJkZWNvZGVNZXNzYWdlSWZKU09OU3RyaW5nIiwiUHJvcGVydHlEYXRhIiwib2JqIiwiTWV0aG9kRGF0YSIsIm1lc3NhZ2VMaXN0IiwicHJvdG90eXBlIiwiX3NvY2tldCIsImdldENvbm5lY3Rpb24iLCJhZGRTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIiLCJ2YWx1ZU9iamVjdCIsInRvT2JqZWN0IiwiZXZlbnRzIiwic3VidHlwZSIsImF0dHJpYnV0ZSIsIm5vdGlmeU9mRXZlbnRzIiwibm90aWZ5T2ZQcm9wZXJ0eVZhbHVlcyIsIm1lc3NhZ2VOYW1lIiwicmVtb3ZlU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyIiwicGxheWJhY2tJZCIsIl90YXJnZXRFbGVtZW50IiwicHVibGlzaGVySWQiLCJQdWJsaXNoVmlldyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7OztBQzNCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0IsMkJBQTBCO0FBQzFCLDJCQUEwQjtBQUMxQixzQkFBcUI7QUFDckI7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBNkQsT0FBTztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekIsc0JBQXFCO0FBQ3JCLDJCQUEwQjtBQUMxQixNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDZEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELHNDOzs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDVEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDVEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxlOzs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLGE7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVixFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUM3QkQsMEM7Ozs7OztBQ0FBLHVDOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDbEJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDUkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxHOzs7Ozs7QUNmQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLDZEQUE2RDtBQUN2RztBQUNBLEVBQUMsRTs7Ozs7O0FDWEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsYUFBYTtBQUN6RDtBQUNBLEVBQUMsRTs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsNkRBQTZEO0FBQ3ZHO0FBQ0EsRUFBQyxFOzs7Ozs7QUNYRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUMsRTs7Ozs7O0FDakJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsRUFBQyxFOzs7Ozs7QUNqQkQ7QUFDQTs7QUFFQSx3Q0FBdUMsd0NBQWdELEU7Ozs7OztBQ0h2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDUkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ05BO0FBQ0E7O0FBRUEsd0NBQXVDLHdDQUFnRCxFOzs7Ozs7QUNIdkY7QUFDQTs7QUFFQSwrQkFBOEIsK0JBQTZCLEU7Ozs7OztBQ0gzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNmRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDZkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0EsR0FBRSxFOzs7Ozs7QUNQRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBc0QsZ0JBQWdCLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFLEU7Ozs7OztBQ2RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0EsR0FBRSxFOzs7Ozs7QUNoQkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0EsR0FBRSxFOzs7Ozs7QUNsQkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0E7QUFDQSxHQUFFLEU7Ozs7OztBQ1JGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWM7QUFDZDtBQUNBLEdBQUUsRTs7Ozs7O0FDUEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUEsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzcEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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T0FBbkY7QUFDQSxhQUFNZ04sQ0FBTjtBQUNEO0FBQ0Y7Ozs7cUNBRWdCc0ksUyxFQUFXO0FBQzFCLHVCQUFNM1EsSUFBTixFQUFZLG1CQUFaO0FBQ0EyUSxpQkFBVS9PLE9BQVYsQ0FBa0IsSUFBbEIsRUFBd0Isa0JBQVlpTCxZQUFaLENBQXlCLEtBQUswWSxjQUE5QixDQUF4QjtBQUNEOzs7NkJBRVE5WixXLEVBQStCO0FBQUEsV0FBbEJyRSxRQUFrQix1RUFBUCxLQUFPOztBQUN0Qyx1QkFBTXBILElBQU4sMkJBQW1Db0gsUUFBbkM7QUFDQSx5QkFBWW1FLGNBQVosQ0FBMkIsS0FBS2dhLGNBQWhDLEVBQWdEOVosV0FBaEQsRUFBNkRyRSxRQUE3RDtBQUNEOzs7eUJBRVc7QUFDVixjQUFPLEtBQUttZSxjQUFaO0FBQ0Q7Ozs7OzttQkFJWUUsVyIsImZpbGUiOiJyZWQ1cHJvLXNkay5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInJlZDVwcm9zZGtcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicmVkNXByb3Nka1wiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvblxuICoqLyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgYzkxMTliMDE2YmY3MGRjZTUxNDdcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcImNvcmUtanMvc2hpbVwiKTtcblxucmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZVwiKTtcblxucmVxdWlyZShcImNvcmUtanMvZm4vcmVnZXhwL2VzY2FwZVwiKTtcblxuaWYgKGdsb2JhbC5fYmFiZWxQb2x5ZmlsbCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IG9uZSBpbnN0YW5jZSBvZiBiYWJlbC1wb2x5ZmlsbCBpcyBhbGxvd2VkXCIpO1xufVxuZ2xvYmFsLl9iYWJlbFBvbHlmaWxsID0gdHJ1ZTtcblxudmFyIERFRklORV9QUk9QRVJUWSA9IFwiZGVmaW5lUHJvcGVydHlcIjtcbmZ1bmN0aW9uIGRlZmluZShPLCBrZXksIHZhbHVlKSB7XG4gIE9ba2V5XSB8fCBPYmplY3RbREVGSU5FX1BST1BFUlRZXShPLCBrZXksIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuXG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRMZWZ0XCIsIFwiXCIucGFkU3RhcnQpO1xuZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIFwicGFkUmlnaHRcIiwgXCJcIi5wYWRFbmQpO1xuXG5cInBvcCxyZXZlcnNlLHNoaWZ0LGtleXMsdmFsdWVzLGVudHJpZXMsaW5kZXhPZixldmVyeSxzb21lLGZvckVhY2gsbWFwLGZpbHRlcixmaW5kLGZpbmRJbmRleCxpbmNsdWRlcyxqb2luLHNsaWNlLGNvbmNhdCxwdXNoLHNwbGljZSx1bnNoaWZ0LHNvcnQsbGFzdEluZGV4T2YscmVkdWNlLHJlZHVjZVJpZ2h0LGNvcHlXaXRoaW4sZmlsbFwiLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgW11ba2V5XSAmJiBkZWZpbmUoQXJyYXksIGtleSwgRnVuY3Rpb24uY2FsbC5iaW5kKFtdW2tleV0pKTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYWNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hc2luaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2JydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNsejMyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5pbXVsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2luaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50cnVuYycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yYXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJpZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5saW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdWInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1cCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLm5vdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuam9pbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zbGljZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb3J0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29tZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLW1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLXNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmhhcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pYWRkaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC51bXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hc2FwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9ic2VydmFibGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIudGltZXJzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmltbWVkaWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2R1bGVzL19jb3JlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9zaGltLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxudmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIE1FVEEgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWVxuICAsICRmYWlscyAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNoYXJlZCAgICAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCB1aWQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgd2tzICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgd2tzRGVmaW5lICAgICAgPSByZXF1aXJlKCcuL193a3MtZGVmaW5lJylcbiAgLCBrZXlPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2tleW9mJylcbiAgLCBlbnVtS2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpXG4gICwgaXNBcnJheSAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgX2NyZWF0ZSAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBnT1BORXh0ICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpXG4gICwgJEdPUEQgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJERQICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRrZXlzICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUEQgICAgICAgICAgID0gJEdPUEQuZlxuICAsIGRQICAgICAgICAgICAgID0gJERQLmZcbiAgLCBnT1BOICAgICAgICAgICA9IGdPUE5FeHQuZlxuICAsICRTeW1ib2wgICAgICAgID0gZ2xvYmFsLlN5bWJvbFxuICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cbiAgLCBfc3RyaW5naWZ5ICAgICA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeVxuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG4gICwgVE9fUFJJTUlUSVZFICAgPSB3a3MoJ3RvUHJpbWl0aXZlJylcbiAgLCBpc0VudW0gICAgICAgICA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICwgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpXG4gICwgQWxsU3ltYm9scyAgICAgPSBzaGFyZWQoJ3N5bWJvbHMnKVxuICAsIE9QU3ltYm9scyAgICAgID0gc2hhcmVkKCdvcC1zeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvKSRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkpKXtcbiAgICBpZighRC5lbnVtZXJhYmxlKXtcbiAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSlpdFtISURERU5dW2tleV0gPSBmYWxzZTtcbiAgICAgIEQgPSBfY3JlYXRlKEQsIHtlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKX0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApe1xuICBhbk9iamVjdChpdCk7XG4gIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcbiAgICAsIGkgICAgPSAwXG4gICAgLCBsID0ga2V5cy5sZW5ndGhcbiAgICAsIGtleTtcbiAgd2hpbGUobCA+IGkpJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCl7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KXtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIGl0ICA9IHRvSU9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKUQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICB2YXIgbmFtZXMgID0gZ09QTih0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG4gIHZhciBJU19PUCAgPSBpdCA9PT0gT2JqZWN0UHJvdG9cbiAgICAsIG5hbWVzICA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKVxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGkgICAgICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSl7XG4gICAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYoIVVTRV9OQVRJVkUpe1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG4gICAgaWYodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZih0aGlzID09PSBPYmplY3RQcm90bykkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKXNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0fSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2hhcy5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmUgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pXG4gICAgLCBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYodGFyZ2V0KXJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmKGV4cG9ydHNba2V5XSAhPSBvdXQpaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faGlkZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgU1JDICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpXG4gICwgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR11cbiAgLCBUUEwgICAgICAgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywga2V5LCB2YWwsIHNhZmUpe1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmKE9ba2V5XSA9PT0gdmFsKXJldHVybjtcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYoTyA9PT0gZ2xvYmFsKXtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaWYoIXNhZmUpe1xuICAgICAgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihPW2tleV0pT1trZXldID0gdmFsO1xuICAgICAgZWxzZSBoaWRlKE8sIGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL191aWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2N0eC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIE1FVEEgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKVxuICAsIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBoYXMgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgc2V0RGVzYyAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaWQgICAgICAgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24oaXQpe1xuICBzZXREZXNjKGl0LCBNRVRBLCB7dmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9fSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZighaXNPYmplY3QoaXQpKXJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmKCFoYXMoaXQsIE1FVEEpKXtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIGlmKCFoYXMoaXQsIE1FVEEpKXtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKXNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiAgICAgIE1FVEEsXG4gIE5FRUQ6ICAgICBmYWxzZSxcbiAgZmFzdEtleTogIGZhc3RLZXksXG4gIGdldFdlYWs6ICBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzXG4gKiogbW9kdWxlIGlkID0gMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL193a3MuanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSlkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7dmFsdWU6IHdrc0V4dC5mKG5hbWUpfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBlbCl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGtleTtcbiAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19rZXlvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXMgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHRvSU9iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgSUVfUFJPVE8gICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xuICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBrZXk7XG4gIGZvcihrZXkgaW4gTylpZihrZXkgIT0gSUVfUFJPVE8paGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSl7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXG4gKiogbW9kdWxlIGlkID0gMzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fY29mLmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHRvSW5kZXggICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKElTX0lOQ0xVREVTKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCR0aGlzLCBlbCwgZnJvbUluZGV4KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KCR0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gdG9JbmRleChmcm9tSW5kZXgsIGxlbmd0aClcbiAgICAgICwgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIGlmKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKXdoaWxlKGxlbmd0aCA+IGluZGV4KXtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIGlmKHZhbHVlICE9IHZhbHVlKXJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I3RvSW5kZXggaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKylpZihJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKXtcbiAgICAgIGlmKE9baW5kZXhdID09PSBlbClyZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8taW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciByZXN1bHQgICAgID0gZ2V0S2V5cyhpdClcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmKGdldFN5bWJvbHMpe1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcbiAgICAgICwgaXNFbnVtICA9IHBJRS5mXG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShzeW1ib2xzLmxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZFBzICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKVxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXG4gICwgRW1wdHkgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XG4gICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKVxuICAgICwgaSAgICAgID0gZW51bUJ1Z0tleXMubGVuZ3RoXG4gICAgLCBsdCAgICAgPSAnPCdcbiAgICAsIGd0ICAgICA9ICc+J1xuICAgICwgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKXtcbiAgdmFyIHJlc3VsdDtcbiAgaWYoTyAhPT0gbnVsbCl7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcyl7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgPSAwXG4gICAgLCBQO1xuICB3aGlsZShsZW5ndGggPiBpKWRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanNcbiAqKiBtb2R1bGUgaWQgPSA0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19odG1sLmpzXG4gKiogbW9kdWxlIGlkID0gNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BOICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCB0b1N0cmluZyAgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbiAqKiBtb2R1bGUgaWQgPSA1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSA1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydGllczogcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb3JlICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgZXhlYyl7XG4gIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cbiAgICAsIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qc1xuICoqIG1vZHVsZSBpZCA9IDU2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCl7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSA1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXG4gICwgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanNcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRrZXlzICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpe1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpLmY7XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzXG4gKiogbW9kdWxlIGlkID0gNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi41IE9iamVjdC5mcmVlemUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgbWV0YSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZnJlZXplJywgZnVuY3Rpb24oJGZyZWV6ZSl7XG4gIHJldHVybiBmdW5jdGlvbiBmcmVlemUoaXQpe1xuICAgIHJldHVybiAkZnJlZXplICYmIGlzT2JqZWN0KGl0KSA/ICRmcmVlemUobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUuanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjE3IE9iamVjdC5zZWFsKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIG1ldGEgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpLm9uRnJlZXplO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ3NlYWwnLCBmdW5jdGlvbigkc2VhbCl7XG4gIHJldHVybiBmdW5jdGlvbiBzZWFsKGl0KXtcbiAgICByZXR1cm4gJHNlYWwgJiYgaXNPYmplY3QoaXQpID8gJHNlYWwobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsLmpzXG4gKiogbW9kdWxlIGlkID0gNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgbWV0YSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgncHJldmVudEV4dGVuc2lvbnMnLCBmdW5jdGlvbigkcHJldmVudEV4dGVuc2lvbnMpe1xuICByZXR1cm4gZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnMoaXQpe1xuICAgIHJldHVybiAkcHJldmVudEV4dGVuc2lvbnMgJiYgaXNPYmplY3QoaXQpID8gJHByZXZlbnRFeHRlbnNpb25zKG1ldGEoaXQpKSA6IGl0O1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xMiBPYmplY3QuaXNGcm96ZW4oTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRnJvemVuJywgZnVuY3Rpb24oJGlzRnJvemVuKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzRnJvemVuKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRnJvemVuID8gJGlzRnJvemVuKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qc1xuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMTMgT2JqZWN0LmlzU2VhbGVkKE8pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdpc1NlYWxlZCcsIGZ1bmN0aW9uKCRpc1NlYWxlZCl7XG4gIHJldHVybiBmdW5jdGlvbiBpc1NlYWxlZChpdCl7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/ICRpc1NlYWxlZCA/ICRpc1NlYWxlZChpdCkgOiBmYWxzZSA6IHRydWU7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjExIE9iamVjdC5pc0V4dGVuc2libGUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRXh0ZW5zaWJsZScsIGZ1bmN0aW9uKCRpc0V4dGVuc2libGUpe1xuICByZXR1cm4gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZSA6IGZhbHNlO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7YXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSA2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgJGFzc2lnbiAgPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgQSA9IHt9XG4gICAgLCBCID0ge31cbiAgICAsIFMgPSBTeW1ib2woKVxuICAgICwgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUICAgICA9IHRvT2JqZWN0KHRhcmdldClcbiAgICAsIGFMZW4gID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgaW5kZXggPSAxXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mXG4gICAgLCBpc0VudW0gICAgID0gcElFLmY7XG4gIHdoaWxlKGFMZW4gPiBpbmRleCl7XG4gICAgdmFyIFMgICAgICA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKVxuICAgICAgLCBrZXlzICAgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGogICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGopaWYoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSlUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanNcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtpczogcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMuanNcbiAqKiBtb2R1bGUgaWQgPSA3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KXtcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc2FtZS12YWx1ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge3NldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qc1xuICoqIG1vZHVsZSBpZCA9IDczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgdGVzdCAgICA9IHt9O1xudGVzdFtyZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKV0gPSAneic7XG5pZih0ZXN0ICsgJycgIT0gJ1tvYmplY3Qgel0nKXtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShPYmplY3QucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKVxuICAvLyBFUzMgd3JvbmcgaGVyZVxuICAsIEFSRyA9IGNvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUcpKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzXG4gKiogbW9kdWxlIGlkID0gNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7YmluZDogcmVxdWlyZSgnLi9fYmluZCcpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kLmpzXG4gKiogbW9kdWxlIGlkID0gNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaW52b2tlICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgYXJyYXlTbGljZSA9IFtdLnNsaWNlXG4gICwgZmFjdG9yaWVzICA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24oRiwgbGVuLCBhcmdzKXtcbiAgaWYoIShsZW4gaW4gZmFjdG9yaWVzKSl7XG4gICAgZm9yKHZhciBuID0gW10sIGkgPSAwOyBpIDwgbGVuOyBpKyspbltpXSA9ICdhWycgKyBpICsgJ10nO1xuICAgIGZhY3Rvcmllc1tsZW5dID0gRnVuY3Rpb24oJ0YsYScsICdyZXR1cm4gbmV3IEYoJyArIG4uam9pbignLCcpICsgJyknKTtcbiAgfSByZXR1cm4gZmFjdG9yaWVzW2xlbl0oRiwgYXJncyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLmJpbmQgfHwgZnVuY3Rpb24gYmluZCh0aGF0IC8qLCBhcmdzLi4uICovKXtcbiAgdmFyIGZuICAgICAgID0gYUZ1bmN0aW9uKHRoaXMpXG4gICAgLCBwYXJ0QXJncyA9IGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgYm91bmQgPSBmdW5jdGlvbigvKiBhcmdzLi4uICovKXtcbiAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IGNvbnN0cnVjdChmbiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbiAgaWYoaXNPYmplY3QoZm4ucHJvdG90eXBlKSlib3VuZC5wcm90b3R5cGUgPSBmbi5wcm90b3R5cGU7XG4gIHJldHVybiBib3VuZDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzXG4gKiogbW9kdWxlIGlkID0gNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgYXJncywgdGhhdCl7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICBjYXNlIDA6IHJldHVybiB1biA/IGZuKClcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCk7XG4gICAgY2FzZSAxOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgY2FzZSA0OiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgfSByZXR1cm4gICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgaGFzICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgRlByb3RvICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZVxuICAsIG5hbWVSRSAgICAgPSAvXlxccypmdW5jdGlvbiAoW14gKF0qKS9cbiAgLCBOQU1FICAgICAgID0gJ25hbWUnO1xuXG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpe1xuICAgIHRyeSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICAgLCBuYW1lID0gKCcnICsgdGhhdCkubWF0Y2gobmFtZVJFKVsxXTtcbiAgICAgIGhhcyh0aGF0LCBOQU1FKSB8fCAhaXNFeHRlbnNpYmxlKHRoYXQpIHx8IGRQKHRoYXQsIE5BTUUsIGNyZWF0ZURlc2MoNSwgbmFtZSkpO1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qc1xuICoqIG1vZHVsZSBpZCA9IDc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSEFTX0lOU1RBTkNFICAgPSByZXF1aXJlKCcuL193a3MnKSgnaGFzSW5zdGFuY2UnKVxuICAsIEZ1bmN0aW9uUHJvdG8gID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gMTkuMi4zLjYgRnVuY3Rpb24ucHJvdG90eXBlW0BAaGFzSW5zdGFuY2VdKFYpXG5pZighKEhBU19JTlNUQU5DRSBpbiBGdW5jdGlvblByb3RvKSlyZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKEZ1bmN0aW9uUHJvdG8sIEhBU19JTlNUQU5DRSwge3ZhbHVlOiBmdW5jdGlvbihPKXtcbiAgaWYodHlwZW9mIHRoaXMgIT0gJ2Z1bmN0aW9uJyB8fCAhaXNPYmplY3QoTykpcmV0dXJuIGZhbHNlO1xuICBpZighaXNPYmplY3QodGhpcy5wcm90b3R5cGUpKXJldHVybiBPIGluc3RhbmNlb2YgdGhpcztcbiAgLy8gZm9yIGVudmlyb25tZW50IHcvbyBuYXRpdmUgYEBAaGFzSW5zdGFuY2VgIGxvZ2ljIGVub3VnaCBgaW5zdGFuY2VvZmAsIGJ1dCBhZGQgdGhpczpcbiAgd2hpbGUoTyA9IGdldFByb3RvdHlwZU9mKE8pKWlmKHRoaXMucHJvdG90eXBlID09PSBPKXJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanNcbiAqKiBtb2R1bGUgaWQgPSA4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAxOC4yLjUgcGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlSW50ICE9ICRwYXJzZUludCksIHtwYXJzZUludDogJHBhcnNlSW50fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1pbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlSW50XG4gICwgJHRyaW0gICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltXG4gICwgd3MgICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJylcbiAgLCBoZXggICAgICAgPSAvXltcXC0rXT8wW3hYXS87XG5cbm1vZHVsZS5leHBvcnRzID0gJHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50KHdzICsgJzB4MTYnKSAhPT0gMjIgPyBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KXtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgcmV0dXJuICRwYXJzZUludChzdHJpbmcsIChyYWRpeCA+Pj4gMCkgfHwgKGhleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzXG4gKiogbW9kdWxlIGlkID0gODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzcGFjZXMgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJylcbiAgLCBzcGFjZSAgID0gJ1snICsgc3BhY2VzICsgJ10nXG4gICwgbm9uICAgICA9ICdcXHUyMDBiXFx1MDA4NSdcbiAgLCBsdHJpbSAgID0gUmVnRXhwKCdeJyArIHNwYWNlICsgc3BhY2UgKyAnKicpXG4gICwgcnRyaW0gICA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uKEtFWSwgZXhlYywgQUxJQVMpe1xuICB2YXIgZXhwICAgPSB7fTtcbiAgdmFyIEZPUkNFID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gISFzcGFjZXNbS0VZXSgpIHx8IG5vbltLRVldKCkgIT0gbm9uO1xuICB9KTtcbiAgdmFyIGZuID0gZXhwW0tFWV0gPSBGT1JDRSA/IGV4ZWModHJpbSkgOiBzcGFjZXNbS0VZXTtcbiAgaWYoQUxJQVMpZXhwW0FMSUFTXSA9IGZuO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFLCAnU3RyaW5nJywgZXhwKTtcbn07XG5cbi8vIDEgLT4gU3RyaW5nI3RyaW1MZWZ0XG4vLyAyIC0+IFN0cmluZyN0cmltUmlnaHRcbi8vIDMgLT4gU3RyaW5nI3RyaW1cbnZhciB0cmltID0gZXhwb3J0ZXIudHJpbSA9IGZ1bmN0aW9uKHN0cmluZywgVFlQRSl7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZihUWVBFICYgMSlzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICBpZihUWVBFICYgMilzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICByZXR1cm4gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlcjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzXG4gKiogbW9kdWxlIGlkID0gODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gJ1xceDA5XFx4MEFcXHgwQlxceDBDXFx4MERcXHgyMFxceEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzJyArXG4gICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qc1xuICoqIG1vZHVsZSBpZCA9IDg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDE4LjIuNCBwYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCB7cGFyc2VGbG9hdDogJHBhcnNlRmxvYXR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWZsb2F0LmpzXG4gKiogbW9kdWxlIGlkID0gODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlRmxvYXRcbiAgLCAkdHJpbSAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcblxubW9kdWxlLmV4cG9ydHMgPSAxIC8gJHBhcnNlRmxvYXQocmVxdWlyZSgnLi9fc3RyaW5nLXdzJykgKyAnLTAnKSAhPT0gLUluZmluaXR5ID8gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHIpe1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpXG4gICAgLCByZXN1bHQgPSAkcGFyc2VGbG9hdChzdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBjb2YgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZmFpbHMgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZ09QTiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBnT1BEICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZlxuICAsIGRQICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsICR0cmltICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltXG4gICwgTlVNQkVSICAgICAgICAgICAgPSAnTnVtYmVyJ1xuICAsICROdW1iZXIgICAgICAgICAgID0gZ2xvYmFsW05VTUJFUl1cbiAgLCBCYXNlICAgICAgICAgICAgICA9ICROdW1iZXJcbiAgLCBwcm90byAgICAgICAgICAgICA9ICROdW1iZXIucHJvdG90eXBlXG4gIC8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xuICAsIEJST0tFTl9DT0YgICAgICAgID0gY29mKHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKShwcm90bykpID09IE5VTUJFUlxuICAsIFRSSU0gICAgICAgICAgICAgID0gJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGU7XG5cbi8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24oYXJndW1lbnQpe1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpO1xuICBpZih0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMil7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMClcbiAgICAgICwgdGhpcmQsIHJhZGl4LCBtYXhDb2RlO1xuICAgIGlmKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpe1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZihmaXJzdCA9PT0gNDgpe1xuICAgICAgc3dpdGNoKGl0LmNoYXJDb2RlQXQoMSkpe1xuICAgICAgICBjYXNlIDY2IDogY2FzZSA5OCAgOiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzkgOiBjYXNlIDExMSA6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQgOiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yKHZhciBkaWdpdHMgPSBpdC5zbGljZSgyKSwgaSA9IDAsIGwgPSBkaWdpdHMubGVuZ3RoLCBjb2RlOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKXJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbmlmKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSl7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpe1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlXG4gICAgICAsIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uKCl7IHByb3RvLnZhbHVlT2YuY2FsbCh0aGF0KTsgfSkgOiBjb2YodGhhdCkgIT0gTlVNQkVSKVxuICAgICAgICA/IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKHRvTnVtYmVyKGl0KSksIHRoYXQsICROdW1iZXIpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICBmb3IodmFyIGtleXMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspe1xuICAgIGlmKGhhcyhCYXNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKCROdW1iZXIsIGtleSkpe1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCBOVU1CRVIsICROdW1iZXIpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIHRhcmdldCwgQyl7XG4gIHZhciBQLCBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICBpZihTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKXtcbiAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTtcbiAgfSByZXR1cm4gdGhhdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pbmhlcml0LWlmLXJlcXVpcmVkLmpzXG4gKiogbW9kdWxlIGlkID0gODhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSW50ZWdlciAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJylcbiAgLCByZXBlYXQgICAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0JylcbiAgLCAkdG9GaXhlZCAgICAgPSAxLi50b0ZpeGVkXG4gICwgZmxvb3IgICAgICAgID0gTWF0aC5mbG9vclxuICAsIGRhdGEgICAgICAgICA9IFswLCAwLCAwLCAwLCAwLCAwXVxuICAsIEVSUk9SICAgICAgICA9ICdOdW1iZXIudG9GaXhlZDogaW5jb3JyZWN0IGludm9jYXRpb24hJ1xuICAsIFpFUk8gICAgICAgICA9ICcwJztcblxudmFyIG11bHRpcGx5ID0gZnVuY3Rpb24obiwgYyl7XG4gIHZhciBpICA9IC0xXG4gICAgLCBjMiA9IGM7XG4gIHdoaWxlKCsraSA8IDYpe1xuICAgIGMyICs9IG4gKiBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBjMiAlIDFlNztcbiAgICBjMiA9IGZsb29yKGMyIC8gMWU3KTtcbiAgfVxufTtcbnZhciBkaXZpZGUgPSBmdW5jdGlvbihuKXtcbiAgdmFyIGkgPSA2XG4gICAgLCBjID0gMDtcbiAgd2hpbGUoLS1pID49IDApe1xuICAgIGMgKz0gZGF0YVtpXTtcbiAgICBkYXRhW2ldID0gZmxvb3IoYyAvIG4pO1xuICAgIGMgPSAoYyAlIG4pICogMWU3O1xuICB9XG59O1xudmFyIG51bVRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgdmFyIGkgPSA2XG4gICAgLCBzID0gJyc7XG4gIHdoaWxlKC0taSA+PSAwKXtcbiAgICBpZihzICE9PSAnJyB8fCBpID09PSAwIHx8IGRhdGFbaV0gIT09IDApe1xuICAgICAgdmFyIHQgPSBTdHJpbmcoZGF0YVtpXSk7XG4gICAgICBzID0gcyA9PT0gJycgPyB0IDogcyArIHJlcGVhdC5jYWxsKFpFUk8sIDcgLSB0Lmxlbmd0aCkgKyB0O1xuICAgIH1cbiAgfSByZXR1cm4gcztcbn07XG52YXIgcG93ID0gZnVuY3Rpb24oeCwgbiwgYWNjKXtcbiAgcmV0dXJuIG4gPT09IDAgPyBhY2MgOiBuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpO1xufTtcbnZhciBsb2cgPSBmdW5jdGlvbih4KXtcbiAgdmFyIG4gID0gMFxuICAgICwgeDIgPSB4O1xuICB3aGlsZSh4MiA+PSA0MDk2KXtcbiAgICBuICs9IDEyO1xuICAgIHgyIC89IDQwOTY7XG4gIH1cbiAgd2hpbGUoeDIgPj0gMil7XG4gICAgbiAgKz0gMTtcbiAgICB4MiAvPSAyO1xuICB9IHJldHVybiBuO1xufTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoISEkdG9GaXhlZCAmJiAoXG4gIDAuMDAwMDgudG9GaXhlZCgzKSAhPT0gJzAuMDAwJyB8fFxuICAwLjkudG9GaXhlZCgwKSAhPT0gJzEnIHx8XG4gIDEuMjU1LnRvRml4ZWQoMikgIT09ICcxLjI1JyB8fFxuICAxMDAwMDAwMDAwMDAwMDAwMTI4Li50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbikgfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvRml4ZWQuY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvRml4ZWQ6IGZ1bmN0aW9uIHRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpe1xuICAgIHZhciB4ID0gYU51bWJlclZhbHVlKHRoaXMsIEVSUk9SKVxuICAgICAgLCBmID0gdG9JbnRlZ2VyKGZyYWN0aW9uRGlnaXRzKVxuICAgICAgLCBzID0gJydcbiAgICAgICwgbSA9IFpFUk9cbiAgICAgICwgZSwgeiwgaiwgaztcbiAgICBpZihmIDwgMCB8fCBmID4gMjApdGhyb3cgUmFuZ2VFcnJvcihFUlJPUik7XG4gICAgaWYoeCAhPSB4KXJldHVybiAnTmFOJztcbiAgICBpZih4IDw9IC0xZTIxIHx8IHggPj0gMWUyMSlyZXR1cm4gU3RyaW5nKHgpO1xuICAgIGlmKHggPCAwKXtcbiAgICAgIHMgPSAnLSc7XG4gICAgICB4ID0gLXg7XG4gICAgfVxuICAgIGlmKHggPiAxZS0yMSl7XG4gICAgICBlID0gbG9nKHggKiBwb3coMiwgNjksIDEpKSAtIDY5O1xuICAgICAgeiA9IGUgPCAwID8geCAqIHBvdygyLCAtZSwgMSkgOiB4IC8gcG93KDIsIGUsIDEpO1xuICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwO1xuICAgICAgZSA9IDUyIC0gZTtcbiAgICAgIGlmKGUgPiAwKXtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIGogPSBmO1xuICAgICAgICB3aGlsZShqID49IDcpe1xuICAgICAgICAgIG11bHRpcGx5KDFlNywgMCk7XG4gICAgICAgICAgaiAtPSA3O1xuICAgICAgICB9XG4gICAgICAgIG11bHRpcGx5KHBvdygxMCwgaiwgMSksIDApO1xuICAgICAgICBqID0gZSAtIDE7XG4gICAgICAgIHdoaWxlKGogPj0gMjMpe1xuICAgICAgICAgIGRpdmlkZSgxIDw8IDIzKTtcbiAgICAgICAgICBqIC09IDIzO1xuICAgICAgICB9XG4gICAgICAgIGRpdmlkZSgxIDw8IGopO1xuICAgICAgICBtdWx0aXBseSgxLCAxKTtcbiAgICAgICAgZGl2aWRlKDIpO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11bHRpcGx5KDAsIHopO1xuICAgICAgICBtdWx0aXBseSgxIDw8IC1lLCAwKTtcbiAgICAgICAgbSA9IG51bVRvU3RyaW5nKCkgKyByZXBlYXQuY2FsbChaRVJPLCBmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoZiA+IDApe1xuICAgICAgayA9IG0ubGVuZ3RoO1xuICAgICAgbSA9IHMgKyAoayA8PSBmID8gJzAuJyArIHJlcGVhdC5jYWxsKFpFUk8sIGYgLSBrKSArIG0gOiBtLnNsaWNlKDAsIGsgLSBmKSArICcuJyArIG0uc2xpY2UoayAtIGYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHMgKyBtO1xuICAgIH0gcmV0dXJuIG07XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIG1zZyl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnbnVtYmVyJyAmJiBjb2YoaXQpICE9ICdOdW1iZXInKXRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2EtbnVtYmVyLXZhbHVlLmpzXG4gKiogbW9kdWxlIGlkID0gOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwZWF0KGNvdW50KXtcbiAgdmFyIHN0ciA9IFN0cmluZyhkZWZpbmVkKHRoaXMpKVxuICAgICwgcmVzID0gJydcbiAgICAsIG4gICA9IHRvSW50ZWdlcihjb3VudCk7XG4gIGlmKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xuICBmb3IoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSlpZihuICYgMSlyZXMgKz0gc3RyO1xuICByZXR1cm4gcmVzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1yZXBlYXQuanNcbiAqKiBtb2R1bGUgaWQgPSA5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZhaWxzICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJylcbiAgLCAkdG9QcmVjaXNpb24gPSAxLi50b1ByZWNpc2lvbjtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIElFNy1cbiAgcmV0dXJuICR0b1ByZWNpc2lvbi5jYWxsKDEsIHVuZGVmaW5lZCkgIT09ICcxJztcbn0pIHx8ICEkZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvUHJlY2lzaW9uLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b1ByZWNpc2lvbjogZnVuY3Rpb24gdG9QcmVjaXNpb24ocHJlY2lzaW9uKXtcbiAgICB2YXIgdGhhdCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCAnTnVtYmVyI3RvUHJlY2lzaW9uOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgICByZXR1cm4gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyAkdG9QcmVjaXNpb24uY2FsbCh0aGF0KSA6ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQsIHByZWNpc2lvbik7IFxuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMS4yLjEgTnVtYmVyLkVQU0lMT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge0VQU0lMT046IE1hdGgucG93KDIsIC01Mil9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzXG4gKiogbW9kdWxlIGlkID0gOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjEuMi4yIE51bWJlci5pc0Zpbml0ZShudW1iZXIpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBfaXNGaW5pdGUgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5pc0Zpbml0ZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzRmluaXRlOiBmdW5jdGlvbiBpc0Zpbml0ZShpdCl7XG4gICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBfaXNGaW5pdGUoaXQpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtpc0ludGVnZXI6IHJlcXVpcmUoJy4vX2lzLWludGVnZXInKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMS4yLjMgTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGZsb29yICAgID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KXtcbiAgcmV0dXJuICFpc09iamVjdChpdCkgJiYgaXNGaW5pdGUoaXQpICYmIGZsb29yKGl0KSA9PT0gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtaW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpe1xuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1uYW4uanNcbiAqKiBtb2R1bGUgaWQgPSA5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMS4yLjUgTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpXG4gICwgYWJzICAgICAgID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge1xuICBpc1NhZmVJbnRlZ2VyOiBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKG51bWJlcil7XG4gICAgcmV0dXJuIGlzSW50ZWdlcihudW1iZXIpICYmIGFicyhudW1iZXIpIDw9IDB4MWZmZmZmZmZmZmZmZmY7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLXNhZmUtaW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4xLjIuNiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7TUFYX1NBRkVfSU5URUdFUjogMHgxZmZmZmZmZmZmZmZmZn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMS4yLjEwIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtNSU5fU0FGRV9JTlRFR0VSOiAtMHgxZmZmZmZmZmZmZmZmZn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMjAuMS4yLjEyIE51bWJlci5wYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUZsb2F0ICE9ICRwYXJzZUZsb2F0KSwgJ051bWJlcicsIHtwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdH0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzXG4gKiogbW9kdWxlIGlkID0gMTAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDIwLjEuMi4xMyBOdW1iZXIucGFyc2VJbnQoc3RyaW5nLCByYWRpeClcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE51bWJlci5wYXJzZUludCAhPSAkcGFyc2VJbnQpLCAnTnVtYmVyJywge3BhcnNlSW50OiAkcGFyc2VJbnR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4zIE1hdGguYWNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBsb2cxcCAgID0gcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpXG4gICwgc3FydCAgICA9IE1hdGguc3FydFxuICAsICRhY29zaCAgPSBNYXRoLmFjb3NoO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFjb3NoXG4gIC8vIFY4IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDlcbiAgJiYgTWF0aC5mbG9vcigkYWNvc2goTnVtYmVyLk1BWF9WQUxVRSkpID09IDcxMFxuICAvLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYWNvc2goSW5maW5pdHkpIC0+IE5hTiBcbiAgJiYgJGFjb3NoKEluZmluaXR5KSA9PSBJbmZpbml0eVxuKSwgJ01hdGgnLCB7XG4gIGFjb3NoOiBmdW5jdGlvbiBhY29zaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPCAxID8gTmFOIDogeCA+IDk0OTA2MjY1LjYyNDI1MTU2XG4gICAgICA/IE1hdGgubG9nKHgpICsgTWF0aC5MTjJcbiAgICAgIDogbG9nMXAoeCAtIDEgKyBzcXJ0KHggLSAxKSAqIHNxcnQoeCArIDEpKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoLmpzXG4gKiogbW9kdWxlIGlkID0gMTAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLmxvZzFwIHx8IGZ1bmN0aW9uIGxvZzFwKHgpe1xuICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBNYXRoLmxvZygxICsgeCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjUgTWF0aC5hc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRhc2luaCAgPSBNYXRoLmFzaW5oO1xuXG5mdW5jdGlvbiBhc2luaCh4KXtcbiAgcmV0dXJuICFpc0Zpbml0ZSh4ID0gK3gpIHx8IHggPT0gMCA/IHggOiB4IDwgMCA/IC1hc2luaCgteCkgOiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpO1xufVxuXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTAgXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoJGFzaW5oICYmIDEgLyAkYXNpbmgoMCkgPiAwKSwgJ01hdGgnLCB7YXNpbmg6IGFzaW5ofSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oLmpzXG4gKiogbW9kdWxlIGlkID0gMTA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0YW5oICA9IE1hdGguYXRhbmg7XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hdGFuaCgtMCkgLT4gMCBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXRhbmggJiYgMSAvICRhdGFuaCgtMCkgPCAwKSwgJ01hdGgnLCB7XG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanNcbiAqKiBtb2R1bGUgaWQgPSAxMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi45IE1hdGguY2JydCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNpZ24gICAgPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjYnJ0OiBmdW5jdGlvbiBjYnJ0KHgpe1xuICAgIHJldHVybiBzaWduKHggPSAreCkgKiBNYXRoLnBvdyhNYXRoLmFicyh4KSwgMSAvIDMpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2JydC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gc2lnbih4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX21hdGgtc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2x6MzI6IGZ1bmN0aW9uIGNsejMyKHgpe1xuICAgIHJldHVybiAoeCA+Pj49IDApID8gMzEgLSBNYXRoLmZsb29yKE1hdGgubG9nKHggKyAwLjUpICogTWF0aC5MT0cyRSkgOiAzMjtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzXG4gKiogbW9kdWxlIGlkID0gMTA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMTIgTWF0aC5jb3NoKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwICAgICA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNvc2g6IGZ1bmN0aW9uIGNvc2goeCl7XG4gICAgcmV0dXJuIChleHAoeCA9ICt4KSArIGV4cCgteCkpIC8gMjtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNvc2guanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGV4cG0xICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoJGV4cG0xICE9IE1hdGguZXhwbTEpLCAnTWF0aCcsIHtleHBtMTogJGV4cG0xfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xLmpzXG4gKiogbW9kdWxlIGlkID0gMTExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMTQgTWF0aC5leHBtMSh4KVxudmFyICRleHBtMSA9IE1hdGguZXhwbTE7XG5tb2R1bGUuZXhwb3J0cyA9ICghJGV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgJGV4cG0xKDEwKSA+IDIyMDI1LjQ2NTc5NDgwNjcxOSB8fCAkZXhwbTEoMTApIDwgMjIwMjUuNDY1Nzk0ODA2NzE2NTE2OFxuICAvLyBUb3IgQnJvd3NlciBidWdcbiAgfHwgJGV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCl7XG4gIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IHggPiAtMWUtNiAmJiB4IDwgMWUtNiA/IHggKyB4ICogeCAvIDIgOiBNYXRoLmV4cCh4KSAtIDE7XG59IDogJGV4cG0xO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1leHBtMS5qc1xuICoqIG1vZHVsZSBpZCA9IDExMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzaWduICAgICAgPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKVxuICAsIHBvdyAgICAgICA9IE1hdGgucG93XG4gICwgRVBTSUxPTiAgID0gcG93KDIsIC01MilcbiAgLCBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKVxuICAsIE1BWDMyICAgICA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpXG4gICwgTUlOMzIgICAgID0gcG93KDIsIC0xMjYpO1xuXG52YXIgcm91bmRUaWVzVG9FdmVuID0gZnVuY3Rpb24obil7XG4gIHJldHVybiBuICsgMSAvIEVQU0lMT04gLSAxIC8gRVBTSUxPTjtcbn07XG5cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBmcm91bmQ6IGZ1bmN0aW9uIGZyb3VuZCh4KXtcbiAgICB2YXIgJGFicyAgPSBNYXRoLmFicyh4KVxuICAgICAgLCAkc2lnbiA9IHNpZ24oeClcbiAgICAgICwgYSwgcmVzdWx0O1xuICAgIGlmKCRhYnMgPCBNSU4zMilyZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICAgIGEgPSAoMSArIEVQU0lMT04zMiAvIEVQU0lMT04pICogJGFicztcbiAgICByZXN1bHQgPSBhIC0gKGEgLSAkYWJzKTtcbiAgICBpZihyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KXJldHVybiAkc2lnbiAqIEluZmluaXR5O1xuICAgIHJldHVybiAkc2lnbiAqIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmZyb3VuZC5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYWJzICAgICA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMil7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3VtICA9IDBcbiAgICAgICwgaSAgICA9IDBcbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgbGFyZyA9IDBcbiAgICAgICwgYXJnLCBkaXY7XG4gICAgd2hpbGUoaSA8IGFMZW4pe1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgIGlmKGxhcmcgPCBhcmcpe1xuICAgICAgICBkaXYgID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtICA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYoYXJnID4gMCl7XG4gICAgICAgIGRpdiAgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIE1hdGguc3FydChzdW0pO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4xOCBNYXRoLmltdWwoeCwgeSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW11bCAgID0gTWF0aC5pbXVsO1xuXG4vLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAkaW11bCgweGZmZmZmZmZmLCA1KSAhPSAtNSB8fCAkaW11bC5sZW5ndGggIT0gMjtcbn0pLCAnTWF0aCcsIHtcbiAgaW11bDogZnVuY3Rpb24gaW11bCh4LCB5KXtcbiAgICB2YXIgVUlOVDE2ID0gMHhmZmZmXG4gICAgICAsIHhuID0gK3hcbiAgICAgICwgeW4gPSAreVxuICAgICAgLCB4bCA9IFVJTlQxNiAmIHhuXG4gICAgICAsIHlsID0gVUlOVDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSU5UMTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSU5UMTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmltdWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KXtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qc1xuICoqIG1vZHVsZSBpZCA9IDExNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtsb2cxcDogcmVxdWlyZSgnLi9fbWF0aC1sb2cxcCcpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzXG4gKiogbW9kdWxlIGlkID0gMTE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMjIgTWF0aC5sb2cyKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzI6IGZ1bmN0aW9uIGxvZzIoeCl7XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjI7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzXG4gKiogbW9kdWxlIGlkID0gMTE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7c2lnbjogcmVxdWlyZSgnLi9fbWF0aC1zaWduJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDExOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cG0xICAgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJylcbiAgLCBleHAgICAgID0gTWF0aC5leHA7XG5cbi8vIFY4IG5lYXIgQ2hyb21pdW0gMzggaGFzIGEgcHJvYmxlbSB3aXRoIHZlcnkgc21hbGwgbnVtYmVyc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhTWF0aC5zaW5oKC0yZS0xNykgIT0gLTJlLTE3O1xufSksICdNYXRoJywge1xuICBzaW5oOiBmdW5jdGlvbiBzaW5oKHgpe1xuICAgIHJldHVybiBNYXRoLmFicyh4ID0gK3gpIDwgMVxuICAgICAgPyAoZXhwbTEoeCkgLSBleHBtMSgteCkpIC8gMlxuICAgICAgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChNYXRoLkUgLyAyKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpbmguanNcbiAqKiBtb2R1bGUgaWQgPSAxMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4zMyBNYXRoLnRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBleHBtMSAgID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpXG4gICwgZXhwICAgICA9IE1hdGguZXhwO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRhbmg6IGZ1bmN0aW9uIHRhbmgoeCl7XG4gICAgdmFyIGEgPSBleHBtMSh4ID0gK3gpXG4gICAgICAsIGIgPSBleHBtMSgteCk7XG4gICAgcmV0dXJuIGEgPT0gSW5maW5pdHkgPyAxIDogYiA9PSBJbmZpbml0eSA/IC0xIDogKGEgLSBiKSAvIChleHAoeCkgKyBleHAoLXgpKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRhbmguanNcbiAqKiBtb2R1bGUgaWQgPSAxMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4zNCBNYXRoLnRydW5jKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhpdCl7XG4gICAgcmV0dXJuIChpdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsKShpdCk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0luZGV4ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCBmcm9tQ2hhckNvZGUgICA9IFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgLCAkZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuXG4vLyBsZW5ndGggc2hvdWxkIGJlIDEsIG9sZCBGRiBwcm9ibGVtXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcbiAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciByZXMgID0gW11cbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgaSAgICA9IDBcbiAgICAgICwgY29kZTtcbiAgICB3aGlsZShhTGVuID4gaSl7XG4gICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xuICAgICAgaWYodG9JbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMFxuICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhkODAwLCBjb2RlICUgMHg0MDAgKyAweGRjMDApXG4gICAgICApO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMi40IFN0cmluZy5yYXcoY2FsbFNpdGUsIC4uLnN1YnN0aXR1dGlvbnMpXG4gIHJhdzogZnVuY3Rpb24gcmF3KGNhbGxTaXRlKXtcbiAgICB2YXIgdHBsICA9IHRvSU9iamVjdChjYWxsU2l0ZS5yYXcpXG4gICAgICAsIGxlbiAgPSB0b0xlbmd0aCh0cGwubGVuZ3RoKVxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXMgID0gW11cbiAgICAgICwgaSAgICA9IDA7XG4gICAgd2hpbGUobGVuID4gaSl7XG4gICAgICByZXMucHVzaChTdHJpbmcodHBsW2krK10pKTtcbiAgICAgIGlmKGkgPCBhTGVuKXJlcy5wdXNoKFN0cmluZyhhcmd1bWVudHNbaV0pKTtcbiAgICB9IHJldHVybiByZXMuam9pbignJyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMS4zLjI1IFN0cmluZy5wcm90b3R5cGUudHJpbSgpXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltJywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbSgpe1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAzKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0uanNcbiAqKiBtb2R1bGUgaWQgPSAxMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBpbmRleCA9IHRoaXMuX2lcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWF0LmpzXG4gKiogbW9kdWxlIGlkID0gMTI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsICRpdGVyQ3JlYXRlICAgID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgSVRFUkFUT1IgICAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsICRlbnRyaWVzICAgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkXG4gICAgLCAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZVxuICAgICwgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkYW55TmF0aXZlKXtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSkpO1xuICAgIGlmKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKXtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZighTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gID0gcmV0dXJuVGhpcztcbiAgaWYoREVGQVVMVCl7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogIERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuICAgICAgaWYoIShrZXkgaW4gcHJvdG8pKXJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRhdCAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKShmYWxzZSk7XG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjMgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdChwb3MpXG4gIGNvZGVQb2ludEF0OiBmdW5jdGlvbiBjb2RlUG9pbnRBdChwb3Mpe1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjEuMS4zLjYgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aChzZWFyY2hTdHJpbmcgWywgZW5kUG9zaXRpb25dKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjb250ZXh0ICAgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpXG4gICwgRU5EU19XSVRIID0gJ2VuZHNXaXRoJ1xuICAsICRlbmRzV2l0aCA9ICcnW0VORFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoRU5EU19XSVRIKSwgJ1N0cmluZycsIHtcbiAgZW5kc1dpdGg6IGZ1bmN0aW9uIGVuZHNXaXRoKHNlYXJjaFN0cmluZyAvKiwgZW5kUG9zaXRpb24gPSBAbGVuZ3RoICovKXtcbiAgICB2YXIgdGhhdCA9IGNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBFTkRTX1dJVEgpXG4gICAgICAsIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbGVuICAgID0gdG9MZW5ndGgodGhhdC5sZW5ndGgpXG4gICAgICAsIGVuZCAgICA9IGVuZFBvc2l0aW9uID09PSB1bmRlZmluZWQgPyBsZW4gOiBNYXRoLm1pbih0b0xlbmd0aChlbmRQb3NpdGlvbiksIGxlbilcbiAgICAgICwgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuICRlbmRzV2l0aFxuICAgICAgPyAkZW5kc1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGVuZClcbiAgICAgIDogdGhhdC5zbGljZShlbmQgLSBzZWFyY2gubGVuZ3RoLCBlbmQpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgZGVmaW5lZCAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKXtcbiAgaWYoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSl0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZyMnICsgTkFNRSArIFwiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVwiKTtcbiAgcmV0dXJuIFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctY29udGV4dC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGNvZiAgICAgID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBNQVRDSCAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiAoKGlzUmVnRXhwID0gaXRbTUFUQ0hdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIE1BVENIID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciByZSA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tLRVldKHJlKTtcbiAgfSBjYXRjaChlKXtcbiAgICB0cnkge1xuICAgICAgcmVbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gIScvLi8nW0tFWV0ocmUpO1xuICAgIH0gY2F0Y2goZil7IC8qIGVtcHR5ICovIH1cbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19mYWlscy1pcy1yZWdleHAuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIxLjEuMy43IFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMoc2VhcmNoU3RyaW5nLCBwb3NpdGlvbiA9IDApXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvbnRleHQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIElOQ0xVREVTID0gJ2luY2x1ZGVzJztcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShJTkNMVURFUyksICdTdHJpbmcnLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyosIHBvc2l0aW9uID0gMCAqLyl7XG4gICAgcmV0dXJuICEhfmNvbnRleHQodGhpcywgc2VhcmNoU3RyaW5nLCBJTkNMVURFUylcbiAgICAgIC5pbmRleE9mKHNlYXJjaFN0cmluZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIC8vIDIxLjEuMy4xMyBTdHJpbmcucHJvdG90eXBlLnJlcGVhdChjb3VudClcbiAgcmVwZWF0OiByZXF1aXJlKCcuL19zdHJpbmctcmVwZWF0Jylcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjEuMS4zLjE4IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcgWywgcG9zaXRpb24gXSlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNvbnRleHQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWNvbnRleHQnKVxuICAsIFNUQVJUU19XSVRIID0gJ3N0YXJ0c1dpdGgnXG4gICwgJHN0YXJ0c1dpdGggPSAnJ1tTVEFSVFNfV0lUSF07XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMtaXMtcmVnZXhwJykoU1RBUlRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBzdGFydHNXaXRoOiBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaFN0cmluZyAvKiwgcG9zaXRpb24gPSAwICovKXtcbiAgICB2YXIgdGhhdCAgID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIFNUQVJUU19XSVRIKVxuICAgICAgLCBpbmRleCAgPSB0b0xlbmd0aChNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgdGhhdC5sZW5ndGgpKVxuICAgICAgLCBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJHN0YXJ0c1dpdGhcbiAgICAgID8gJHN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoLmpzXG4gKiogbW9kdWxlIGlkID0gMTM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4yIFN0cmluZy5wcm90b3R5cGUuYW5jaG9yKG5hbWUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdhbmNob3InLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFuY2hvcihuYW1lKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICduYW1lJywgbmFtZSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qc1xuICoqIG1vZHVsZSBpZCA9IDEzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIHF1b3QgICAgPSAvXCIvZztcbi8vIEIuMi4zLjIuMSBDcmVhdGVIVE1MKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKVxudmFyIGNyZWF0ZUhUTUwgPSBmdW5jdGlvbihzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSkge1xuICB2YXIgUyAgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKVxuICAgICwgcDEgPSAnPCcgKyB0YWc7XG4gIGlmKGF0dHJpYnV0ZSAhPT0gJycpcDEgKz0gJyAnICsgYXR0cmlidXRlICsgJz1cIicgKyBTdHJpbmcodmFsdWUpLnJlcGxhY2UocXVvdCwgJyZxdW90OycpICsgJ1wiJztcbiAgcmV0dXJuIHAxICsgJz4nICsgUyArICc8LycgKyB0YWcgKyAnPic7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCBleGVjKXtcbiAgdmFyIE8gPSB7fTtcbiAgT1tOQU1FXSA9IGV4ZWMoY3JlYXRlSFRNTCk7XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXtcbiAgICB2YXIgdGVzdCA9ICcnW05BTUVdKCdcIicpO1xuICAgIHJldHVybiB0ZXN0ICE9PSB0ZXN0LnRvTG93ZXJDYXNlKCkgfHwgdGVzdC5zcGxpdCgnXCInKS5sZW5ndGggPiAzO1xuICB9KSwgJ1N0cmluZycsIE8pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1odG1sLmpzXG4gKiogbW9kdWxlIGlkID0gMTQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4zIFN0cmluZy5wcm90b3R5cGUuYmlnKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JpZycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYmlnKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JpZycsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNCBTdHJpbmcucHJvdG90eXBlLmJsaW5rKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JsaW5rJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBibGluaygpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdibGluaycsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJsaW5rLmpzXG4gKiogbW9kdWxlIGlkID0gMTQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy41IFN0cmluZy5wcm90b3R5cGUuYm9sZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdib2xkJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBib2xkKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2InLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzXG4gKiogbW9kdWxlIGlkID0gMTQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy42IFN0cmluZy5wcm90b3R5cGUuZml4ZWQoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZml4ZWQnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZpeGVkKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3R0JywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjcgU3RyaW5nLnByb3RvdHlwZS5mb250Y29sb3IoY29sb3IpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250Y29sb3InLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRjb2xvcihjb2xvcil7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnY29sb3InLCBjb2xvcik7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOCBTdHJpbmcucHJvdG90eXBlLmZvbnRzaXplKHNpemUpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250c2l6ZScsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZm9udHNpemUoc2l6ZSl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnc2l6ZScsIHNpemUpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuOSBTdHJpbmcucHJvdG90eXBlLml0YWxpY3MoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnaXRhbGljcycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gaXRhbGljcygpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdpJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTAgU3RyaW5nLnByb3RvdHlwZS5saW5rKHVybClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2xpbmsnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbmsodXJsKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICdocmVmJywgdXJsKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcubGluay5qc1xuICoqIG1vZHVsZSBpZCA9IDE0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5zbWFsbCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzbWFsbCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc21hbGwoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc21hbGwnLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTIgU3RyaW5nLnByb3RvdHlwZS5zdHJpa2UoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3RyaWtlJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzdHJpa2UoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3RyaWtlJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzXG4gKiogbW9kdWxlIGlkID0gMTUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMyBTdHJpbmcucHJvdG90eXBlLnN1YigpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdWInLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN1Yigpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdWInLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdWIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjE0IFN0cmluZy5wcm90b3R5cGUuc3VwKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1cCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc3VwKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1cCcsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMy4zLjEgLyAxNS45LjQuNCBEYXRlLm5vdygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0RhdGUnLCB7bm93OiBmdW5jdGlvbigpeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH19KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUubm93LmpzXG4gKiogbW9kdWxlIGlkID0gMTUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5ldyBEYXRlKE5hTikudG9KU09OKCkgIT09IG51bGwgfHwgRGF0ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoe3RvSVNPU3RyaW5nOiBmdW5jdGlvbigpeyByZXR1cm4gMTsgfX0pICE9PSAxO1xufSksICdEYXRlJywge1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTihrZXkpe1xuICAgIHZhciBPICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIHB2ID0gdG9QcmltaXRpdmUoTyk7XG4gICAgcmV0dXJuIHR5cGVvZiBwdiA9PSAnbnVtYmVyJyAmJiAhaXNGaW5pdGUocHYpID8gbnVsbCA6IE8udG9JU09TdHJpbmcoKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIwLjMuNC4zNiAvIDE1LjkuNS40MyBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBnZXRUaW1lID0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZTtcblxudmFyIGx6ID0gZnVuY3Rpb24obnVtKXtcbiAgcmV0dXJuIG51bSA+IDkgPyBudW0gOiAnMCcgKyBudW07XG59O1xuXG4vLyBQaGFudG9tSlMgLyBvbGQgV2ViS2l0IGhhcyBhIGJyb2tlbiBpbXBsZW1lbnRhdGlvbnNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBuZXcgRGF0ZSgtNWUxMyAtIDEpLnRvSVNPU3RyaW5nKCkgIT0gJzAzODUtMDctMjVUMDc6MDY6MzkuOTk5Wic7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgbmV3IERhdGUoTmFOKS50b0lTT1N0cmluZygpO1xufSkpLCAnRGF0ZScsIHtcbiAgdG9JU09TdHJpbmc6IGZ1bmN0aW9uIHRvSVNPU3RyaW5nKCl7XG4gICAgaWYoIWlzRmluaXRlKGdldFRpbWUuY2FsbCh0aGlzKSkpdGhyb3cgUmFuZ2VFcnJvcignSW52YWxpZCB0aW1lIHZhbHVlJyk7XG4gICAgdmFyIGQgPSB0aGlzXG4gICAgICAsIHkgPSBkLmdldFVUQ0Z1bGxZZWFyKClcbiAgICAgICwgbSA9IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKClcbiAgICAgICwgcyA9IHkgPCAwID8gJy0nIDogeSA+IDk5OTkgPyAnKycgOiAnJztcbiAgICByZXR1cm4gcyArICgnMDAwMDAnICsgTWF0aC5hYnMoeSkpLnNsaWNlKHMgPyAtNiA6IC00KSArXG4gICAgICAnLScgKyBseihkLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArIGx6KGQuZ2V0VVRDRGF0ZSgpKSArXG4gICAgICAnVCcgKyBseihkLmdldFVUQ0hvdXJzKCkpICsgJzonICsgbHooZC5nZXRVVENNaW51dGVzKCkpICtcbiAgICAgICc6JyArIGx6KGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChtID4gOTkgPyBtIDogJzAnICsgbHoobSkpICsgJ1onO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8taXNvLXN0cmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIERhdGVQcm90byAgICA9IERhdGUucHJvdG90eXBlXG4gICwgSU5WQUxJRF9EQVRFID0gJ0ludmFsaWQgRGF0ZSdcbiAgLCBUT19TVFJJTkcgICAgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nICAgID0gRGF0ZVByb3RvW1RPX1NUUklOR11cbiAgLCBnZXRUaW1lICAgICAgPSBEYXRlUHJvdG8uZ2V0VGltZTtcbmlmKG5ldyBEYXRlKE5hTikgKyAnJyAhPSBJTlZBTElEX0RBVEUpe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKERhdGVQcm90bywgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHZhciB2YWx1ZSA9IGdldFRpbWUuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gJHRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBUT19QUklNSVRJVkUgPSByZXF1aXJlKCcuL193a3MnKSgndG9QcmltaXRpdmUnKVxuICAsIHByb3RvICAgICAgICA9IERhdGUucHJvdG90eXBlO1xuXG5pZighKFRPX1BSSU1JVElWRSBpbiBwcm90bykpcmVxdWlyZSgnLi9faGlkZScpKHByb3RvLCBUT19QUklNSVRJVkUsIHJlcXVpcmUoJy4vX2RhdGUtdG8tcHJpbWl0aXZlJykpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIE5VTUJFUiAgICAgID0gJ251bWJlcic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaGludCl7XG4gIGlmKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09IE5VTUJFUiAmJiBoaW50ICE9PSAnZGVmYXVsdCcpdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaGludCcpO1xuICByZXR1cm4gdG9QcmltaXRpdmUoYW5PYmplY3QodGhpcyksIGhpbnQgIT0gTlVNQkVSKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19kYXRlLXRvLXByaW1pdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjIuMS4yLjIgLyAxNS40LjMuMiBBcnJheS5pc0FycmF5KGFyZylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnQXJyYXknLCB7aXNBcnJheTogcmVxdWlyZSgnLi9faXMtYXJyYXknKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBjYWxsICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgLCB0b0xlbmd0aCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKVxuICAsIGdldEl0ZXJGbiAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZS8qLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCovKXtcbiAgICB2YXIgTyAgICAgICA9IHRvT2JqZWN0KGFycmF5TGlrZSlcbiAgICAgICwgQyAgICAgICA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXlcbiAgICAgICwgYUxlbiAgICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgbWFwZm4gICA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgICAsIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICAsIGluZGV4ICAgPSAwXG4gICAgICAsIGl0ZXJGbiAgPSBnZXRJdGVyRm4oTylcbiAgICAgICwgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKG1hcHBpbmcpbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZihpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSl7XG4gICAgICBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEM7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKyl7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpe1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2goZSl7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZihyZXQgIT09IHVuZGVmaW5lZClhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBpbmRleCwgdmFsdWUpe1xuICBpZihpbmRleCBpbiBvYmplY3QpJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ICE9IHVuZGVmaW5lZClyZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHtkb25lOiBzYWZlID0gdHJ1ZX07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4vLyBXZWJLaXQgQXJyYXkub2YgaXNuJ3QgZ2VuZXJpY1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIGZ1bmN0aW9uIEYoKXt9XG4gIHJldHVybiAhKEFycmF5Lm9mLmNhbGwoRikgaW5zdGFuY2VvZiBGKTtcbn0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4zIEFycmF5Lm9mKCAuLi5pdGVtcylcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGFMZW4gICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gbmV3ICh0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nID8gdGhpcyA6IEFycmF5KShhTGVuKTtcbiAgICB3aGlsZShhTGVuID4gaW5kZXgpY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICByZXN1bHQubGVuZ3RoID0gYUxlbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm9mLmpzXG4gKiogbW9kdWxlIGlkID0gMTY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmpvaW4oc2VwYXJhdG9yKVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlKb2luID0gW10uam9pbjtcblxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIHN0cmluZ3NcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKHJlcXVpcmUoJy4vX2lvYmplY3QnKSAhPSBPYmplY3QgfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShhcnJheUpvaW4pKSwgJ0FycmF5Jywge1xuICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcil7XG4gICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRvSU9iamVjdCh0aGlzKSwgc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnLCcgOiBzZXBhcmF0b3IpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0aG9kLCBhcmcpe1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBhcmcgPyBtZXRob2QuY2FsbChudWxsLCBmdW5jdGlvbigpe30sIDEpIDogbWV0aG9kLmNhbGwobnVsbCk7XG4gIH0pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBodG1sICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY29mICAgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgdG9JbmRleCAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2U7XG5cbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICBpZihodG1sKWFycmF5U2xpY2UuY2FsbChodG1sKTtcbn0pLCAnQXJyYXknLCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKXtcbiAgICB2YXIgbGVuICAgPSB0b0xlbmd0aCh0aGlzLmxlbmd0aClcbiAgICAgICwga2xhc3MgPSBjb2YodGhpcyk7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQ7XG4gICAgaWYoa2xhc3MgPT0gJ0FycmF5JylyZXR1cm4gYXJyYXlTbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHZhciBzdGFydCAgPSB0b0luZGV4KGJlZ2luLCBsZW4pXG4gICAgICAsIHVwVG8gICA9IHRvSW5kZXgoZW5kLCBsZW4pXG4gICAgICAsIHNpemUgICA9IHRvTGVuZ3RoKHVwVG8gLSBzdGFydClcbiAgICAgICwgY2xvbmVkID0gQXJyYXkoc2l6ZSlcbiAgICAgICwgaSAgICAgID0gMDtcbiAgICBmb3IoOyBpIDwgc2l6ZTsgaSsrKWNsb25lZFtpXSA9IGtsYXNzID09ICdTdHJpbmcnXG4gICAgICA/IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSlcbiAgICAgIDogdGhpc1tzdGFydCArIGldO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc2xpY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIHRvT2JqZWN0ICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgZmFpbHMgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsICRzb3J0ICAgICA9IFtdLnNvcnRcbiAgLCB0ZXN0ICAgICAgPSBbMSwgMiwgM107XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIElFOC1cbiAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XG59KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gVjggYnVnXG4gIHRlc3Quc29ydChudWxsKTtcbiAgLy8gT2xkIFdlYktpdFxufSkgfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkc29ydCkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yNSBBcnJheS5wcm90b3R5cGUuc29ydChjb21wYXJlZm4pXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoY29tcGFyZWZuKXtcbiAgICByZXR1cm4gY29tcGFyZWZuID09PSB1bmRlZmluZWRcbiAgICAgID8gJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSlcbiAgICAgIDogJHNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSwgYUZ1bmN0aW9uKGNvbXBhcmVmbikpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZvckVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMClcbiAgLCBTVFJJQ1QgICA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgYXNjICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUWVBFLCAkY3JlYXRlKXtcbiAgdmFyIElTX01BUCAgICAgICAgPSBUWVBFID09IDFcbiAgICAsIElTX0ZJTFRFUiAgICAgPSBUWVBFID09IDJcbiAgICAsIElTX1NPTUUgICAgICAgPSBUWVBFID09IDNcbiAgICAsIElTX0VWRVJZICAgICAgPSBUWVBFID09IDRcbiAgICAsIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDZcbiAgICAsIE5PX0hPTEVTICAgICAgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWFxuICAgICwgY3JlYXRlICAgICAgICA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpe1xuICAgIHZhciBPICAgICAgPSB0b09iamVjdCgkdGhpcylcbiAgICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICAgLCBmICAgICAgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IDBcbiAgICAgICwgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZFxuICAgICAgLCB2YWwsIHJlcztcbiAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpe1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYoVFlQRSl7XG4gICAgICAgIGlmKElTX01BUClyZXN1bHRbaW5kZXhdID0gcmVzOyAgICAgICAgICAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmKHJlcylzd2l0Y2goVFlQRSl7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZihJU19FVkVSWSlyZXR1cm4gZmFsc2U7ICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCwgbGVuZ3RoKXtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBpc0FycmF5ICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5JylcbiAgLCBTUEVDSUVTICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWwpe1xuICB2YXIgQztcbiAgaWYoaXNBcnJheShvcmlnaW5hbCkpe1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSlDID0gdW5kZWZpbmVkO1xuICAgIGlmKGlzT2JqZWN0KEMpKXtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYoQyA9PT0gbnVsbClDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkbWFwICAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDEpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ubWFwLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTUgLyAxNS40LjQuMTkgQXJyYXkucHJvdG90eXBlLm1hcChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBtYXA6IGZ1bmN0aW9uIG1hcChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZmlsdGVyLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNyAvIDE1LjQuNC4yMCBBcnJheS5wcm90b3R5cGUuZmlsdGVyKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRzb21lICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5zb21lLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMjMgLyAxNS40LjQuMTcgQXJyYXkucHJvdG90eXBlLnNvbWUoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRzb21lKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRldmVyeSAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNCk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5ldmVyeSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjUgLyAxNS40LjQuMTYgQXJyYXkucHJvdG90eXBlLmV2ZXJ5KGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRldmVyeSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gMTc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTggLyAxNS40LjQuMjEgQXJyYXkucHJvdG90eXBlLnJlZHVjZShjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pe1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgZmFsc2UpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIHRvT2JqZWN0ICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSU9iamVjdCAgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgY2FsbGJhY2tmbiwgYUxlbiwgbWVtbywgaXNSaWdodCl7XG4gIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgdmFyIE8gICAgICA9IHRvT2JqZWN0KHRoYXQpXG4gICAgLCBzZWxmICAgPSBJT2JqZWN0KE8pXG4gICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAsIGluZGV4ICA9IGlzUmlnaHQgPyBsZW5ndGggLSAxIDogMFxuICAgICwgaSAgICAgID0gaXNSaWdodCA/IC0xIDogMTtcbiAgaWYoYUxlbiA8IDIpZm9yKDs7KXtcbiAgICBpZihpbmRleCBpbiBzZWxmKXtcbiAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXggKz0gaTtcbiAgICBpZihpc1JpZ2h0ID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KXtcbiAgICAgIHRocm93IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIH1cbiAgfVxuICBmb3IoO2lzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpaWYoaW5kZXggaW4gc2VsZil7XG4gICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgfVxuICByZXR1cm4gbWVtbztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2VSaWdodCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE5IC8gMTUuNC40LjIyIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodChjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKXtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIHRydWUpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbmRleE9mICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsICRuYXRpdmUgICAgICAgPSBbXS5pbmRleE9mXG4gICwgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTEgLyAxNS40LjQuMTQgQXJyYXkucHJvdG90eXBlLmluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiBORUdBVElWRV9aRVJPXG4gICAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgICA/ICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwXG4gICAgICA6ICRpbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9JbnRlZ2VyICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIHRvTGVuZ3RoICAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsICRuYXRpdmUgICAgICAgPSBbXS5sYXN0SW5kZXhPZlxuICAsIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5sYXN0SW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNCAvIDE1LjQuNC4xNSBBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCBbLCBmcm9tSW5kZXhdKVxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ID0gQFsqLTFdICovKXtcbiAgICAvLyBjb252ZXJ0IC0wIHRvICswXG4gICAgaWYoTkVHQVRJVkVfWkVSTylyZXR1cm4gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDA7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCh0aGlzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gbGVuZ3RoIC0gMTtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSlpbmRleCA9IE1hdGgubWluKGluZGV4LCB0b0ludGVnZXIoYXJndW1lbnRzWzFdKSk7XG4gICAgaWYoaW5kZXggPCAwKWluZGV4ID0gbGVuZ3RoICsgaW5kZXg7XG4gICAgZm9yKDtpbmRleCA+PSAwOyBpbmRleC0tKWlmKGluZGV4IGluIE8paWYoT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpcmV0dXJuIGluZGV4IHx8IDA7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIyLjEuMy4zIEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluKHRhcmdldCwgc3RhcnQsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtjb3B5V2l0aGluOiByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdjb3B5V2l0aGluJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG4ndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvSW5kZXggID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gW10uY29weVdpdGhpbiB8fCBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldC8qPSAwKi8sIHN0YXJ0Lyo9IDAsIGVuZCA9IEBsZW5ndGgqLyl7XG4gIHZhciBPICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgLCBsZW4gICA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgdG8gICAgPSB0b0luZGV4KHRhcmdldCwgbGVuKVxuICAgICwgZnJvbSAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXG4gICAgLCBlbmQgICA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkXG4gICAgLCBjb3VudCA9IE1hdGgubWluKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvSW5kZXgoZW5kLCBsZW4pKSAtIGZyb20sIGxlbiAtIHRvKVxuICAgICwgaW5jICAgPSAxO1xuICBpZihmcm9tIDwgdG8gJiYgdG8gPCBmcm9tICsgY291bnQpe1xuICAgIGluYyAgPSAtMTtcbiAgICBmcm9tICs9IGNvdW50IC0gMTtcbiAgICB0byAgICs9IGNvdW50IC0gMTtcbiAgfVxuICB3aGlsZShjb3VudC0tID4gMCl7XG4gICAgaWYoZnJvbSBpbiBPKU9bdG9dID0gT1tmcm9tXTtcbiAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICB0byAgICs9IGluYztcbiAgICBmcm9tICs9IGluYztcbiAgfSByZXR1cm4gTztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJylcbiAgLCBBcnJheVByb3RvICA9IEFycmF5LnByb3RvdHlwZTtcbmlmKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZClyZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7ZmlsbDogcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpfSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdmaWxsJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9JbmRleCAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKXtcbiAgdmFyIE8gICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAsIGFMZW4gICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IHRvSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aClcbiAgICAsIGVuZCAgICA9IGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkXG4gICAgLCBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW5kZXgoZW5kLCBsZW5ndGgpO1xuICB3aGlsZShlbmRQb3MgPiBpbmRleClPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZpbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAxODhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy44IEFycmF5LnByb3RvdHlwZS5maW5kKHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmluZCAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDUpXG4gICwgS0VZICAgICA9ICdmaW5kJ1xuICAsIGZvcmNlZCAgPSB0cnVlO1xuLy8gU2hvdWxkbid0IHNraXAgaG9sZXNcbmlmKEtFWSBpbiBbXSlBcnJheSgxKVtLRVldKGZ1bmN0aW9uKCl7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbi8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzXG4gKiogbW9kdWxlIGlkID0gMTg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmluZCAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDYpXG4gICwgS0VZICAgICA9ICdmaW5kSW5kZXgnXG4gICwgZm9yY2VkICA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYoS0VZIGluIFtdKUFycmF5KDEpW0tFWV0oZnVuY3Rpb24oKXsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmbi8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdBcnJheScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgU1BFQ0lFUyAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSl7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pZFAuZihDLCBTUEVDSUVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJylcbiAgLCBzdGVwICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB0b0lPYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xuXG4vLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpXG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKVxuLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKVxuICAsIGRQICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGdPUE4gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgaXNSZWdFeHAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAsICRmbGFncyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmxhZ3MnKVxuICAsICRSZWdFeHAgICAgICAgICAgID0gZ2xvYmFsLlJlZ0V4cFxuICAsIEJhc2UgICAgICAgICAgICAgID0gJFJlZ0V4cFxuICAsIHByb3RvICAgICAgICAgICAgID0gJFJlZ0V4cC5wcm90b3R5cGVcbiAgLCByZTEgICAgICAgICAgICAgICA9IC9hL2dcbiAgLCByZTIgICAgICAgICAgICAgICA9IC9hL2dcbiAgLy8gXCJuZXdcIiBjcmVhdGVzIGEgbmV3IG9iamVjdCwgb2xkIHdlYmtpdCBidWdneSBoZXJlXG4gICwgQ09SUkVDVF9ORVcgICAgICAgPSBuZXcgJFJlZ0V4cChyZTEpICE9PSByZTE7XG5cbmlmKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgKCFDT1JSRUNUX05FVyB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJlMltyZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKV0gPSBmYWxzZTtcbiAgLy8gUmVnRXhwIGNvbnN0cnVjdG9yIGNhbiBhbHRlciBmbGFncyBhbmQgSXNSZWdFeHAgd29ya3MgY29ycmVjdCB3aXRoIEBAbWF0Y2hcbiAgcmV0dXJuICRSZWdFeHAocmUxKSAhPSByZTEgfHwgJFJlZ0V4cChyZTIpID09IHJlMiB8fCAkUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG59KSkpe1xuICAkUmVnRXhwID0gZnVuY3Rpb24gUmVnRXhwKHAsIGYpe1xuICAgIHZhciB0aVJFID0gdGhpcyBpbnN0YW5jZW9mICRSZWdFeHBcbiAgICAgICwgcGlSRSA9IGlzUmVnRXhwKHApXG4gICAgICAsIGZpVSAgPSBmID09PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuICF0aVJFICYmIHBpUkUgJiYgcC5jb25zdHJ1Y3RvciA9PT0gJFJlZ0V4cCAmJiBmaVUgPyBwXG4gICAgICA6IGluaGVyaXRJZlJlcXVpcmVkKENPUlJFQ1RfTkVXXG4gICAgICAgID8gbmV3IEJhc2UocGlSRSAmJiAhZmlVID8gcC5zb3VyY2UgOiBwLCBmKVxuICAgICAgICA6IEJhc2UoKHBpUkUgPSBwIGluc3RhbmNlb2YgJFJlZ0V4cCkgPyBwLnNvdXJjZSA6IHAsIHBpUkUgJiYgZmlVID8gJGZsYWdzLmNhbGwocCkgOiBmKVxuICAgICAgLCB0aVJFID8gdGhpcyA6IHByb3RvLCAkUmVnRXhwKTtcbiAgfTtcbiAgdmFyIHByb3h5ID0gZnVuY3Rpb24oa2V5KXtcbiAgICBrZXkgaW4gJFJlZ0V4cCB8fCBkUCgkUmVnRXhwLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIEJhc2Vba2V5XTsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oaXQpeyBCYXNlW2tleV0gPSBpdDsgfVxuICAgIH0pO1xuICB9O1xuICBmb3IodmFyIGtleXMgPSBnT1BOKEJhc2UpLCBpID0gMDsga2V5cy5sZW5ndGggPiBpOyApcHJveHkoa2V5c1tpKytdKTtcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkUmVnRXhwO1xuICAkUmVnRXhwLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgJ1JlZ0V4cCcsICRSZWdFeHApO1xufVxuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdSZWdFeHAnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuICB2YXIgdGhhdCAgID0gYW5PYmplY3QodGhpcylcbiAgICAsIHJlc3VsdCA9ICcnO1xuICBpZih0aGF0Lmdsb2JhbCkgICAgIHJlc3VsdCArPSAnZyc7XG4gIGlmKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYodGhhdC5tdWx0aWxpbmUpICByZXN1bHQgKz0gJ20nO1xuICBpZih0aGF0LnVuaWNvZGUpICAgIHJlc3VsdCArPSAndSc7XG4gIGlmKHRoYXQuc3RpY2t5KSAgICAgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19mbGFncy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi9lczYucmVnZXhwLmZsYWdzJyk7XG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsICRmbGFncyAgICAgID0gcmVxdWlyZSgnLi9fZmxhZ3MnKVxuICAsIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIFRPX1NUUklORyAgID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyAgID0gLy4vW1RPX1NUUklOR107XG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbihmbil7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoUmVnRXhwLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmbiwgdHJ1ZSk7XG59O1xuXG4vLyAyMS4yLjUuMTQgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZygpXG5pZihyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7IHJldHVybiAkdG9TdHJpbmcuY2FsbCh7c291cmNlOiAnYScsIGZsYWdzOiAnYid9KSAhPSAnL2EvYic7IH0pKXtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgICByZXR1cm4gJy8nLmNvbmNhdChSLnNvdXJjZSwgJy8nLFxuICAgICAgJ2ZsYWdzJyBpbiBSID8gUi5mbGFncyA6ICFERVNDUklQVE9SUyAmJiBSIGluc3RhbmNlb2YgUmVnRXhwID8gJGZsYWdzLmNhbGwoUikgOiB1bmRlZmluZWQpO1xuICB9KTtcbi8vIEZGNDQtIFJlZ0V4cCN0b1N0cmluZyBoYXMgYSB3cm9uZyBuYW1lXG59IGVsc2UgaWYoJHRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HKXtcbiAgZGVmaW5lKGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuICR0b1N0cmluZy5jYWxsKHRoaXMpO1xuICB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAxOTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzKClcbmlmKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgLy4vZy5mbGFncyAhPSAnZycpcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZihSZWdFeHAucHJvdG90eXBlLCAnZmxhZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiByZXF1aXJlKCcuL19mbGFncycpXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQEBtYXRjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uKGRlZmluZWQsIE1BVENILCAkbWF0Y2gpe1xuICAvLyAyMS4xLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5tYXRjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gbWF0Y2gocmVnZXhwKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICB9LCAkbWF0Y2hdO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanNcbiAqKiBtb2R1bGUgaWQgPSAxOTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBoaWRlICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGZhaWxzICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgd2tzICAgICAgPSByZXF1aXJlKCcuL193a3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGxlbmd0aCwgZXhlYyl7XG4gIHZhciBTWU1CT0wgICA9IHdrcyhLRVkpXG4gICAgLCBmbnMgICAgICA9IGV4ZWMoZGVmaW5lZCwgU1lNQk9MLCAnJ1tLRVldKVxuICAgICwgc3RyZm4gICAgPSBmbnNbMF1cbiAgICAsIHJ4Zm4gICAgID0gZm5zWzFdO1xuICBpZihmYWlscyhmdW5jdGlvbigpe1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSkpe1xuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24oc3RyaW5nLCBhcmcpeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uKHN0cmluZyl7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19maXgtcmUtd2tzLmpzXG4gKiogbW9kdWxlIGlkID0gMjAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBAQHJlcGxhY2UgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgncmVwbGFjZScsIDIsIGZ1bmN0aW9uKGRlZmluZWQsIFJFUExBQ0UsICRyZXBsYWNlKXtcbiAgLy8gMjEuMS4zLjE0IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKVxuICByZXR1cm4gW2Z1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPICA9IGRlZmluZWQodGhpcylcbiAgICAgICwgZm4gPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgPyBmbi5jYWxsKHNlYXJjaFZhbHVlLCBPLCByZXBsYWNlVmFsdWUpXG4gICAgICA6ICRyZXBsYWNlLmNhbGwoU3RyaW5nKE8pLCBzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKTtcbiAgfSwgJHJlcGxhY2VdO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gQEBzZWFyY2ggbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc2VhcmNoJywgMSwgZnVuY3Rpb24oZGVmaW5lZCwgU0VBUkNILCAkc2VhcmNoKXtcbiAgLy8gMjEuMS4zLjE1IFN0cmluZy5wcm90b3R5cGUuc2VhcmNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBzZWFyY2gocmVnZXhwKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbU0VBUkNIXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwocmVnZXhwLCBPKSA6IG5ldyBSZWdFeHAocmVnZXhwKVtTRUFSQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRzZWFyY2hdO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzXG4gKiogbW9kdWxlIGlkID0gMjAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBAQHNwbGl0IGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NwbGl0JywgMiwgZnVuY3Rpb24oZGVmaW5lZCwgU1BMSVQsICRzcGxpdCl7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIGlzUmVnRXhwICAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAgICwgX3NwbGl0ICAgICA9ICRzcGxpdFxuICAgICwgJHB1c2ggICAgICA9IFtdLnB1c2hcbiAgICAsICRTUExJVCAgICAgPSAnc3BsaXQnXG4gICAgLCBMRU5HVEggICAgID0gJ2xlbmd0aCdcbiAgICAsIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcbiAgaWYoXG4gICAgJ2FiYmMnWyRTUExJVF0oLyhiKSovKVsxXSA9PSAnYycgfHxcbiAgICAndGVzdCdbJFNQTElUXSgvKD86KS8sIC0xKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnYWInWyRTUExJVF0oLyg/OmFiKSovKVtMRU5HVEhdICE9IDIgfHxcbiAgICAnLidbJFNQTElUXSgvKC4/KSguPykvKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnLidbJFNQTElUXSgvKCkoKS8pW0xFTkdUSF0gPiAxIHx8XG4gICAgJydbJFNQTElUXSgvLj8vKVtMRU5HVEhdXG4gICl7XG4gICAgdmFyIE5QQ0cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHVuZGVmaW5lZDsgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICAkc3BsaXQgPSBmdW5jdGlvbihzZXBhcmF0b3IsIGxpbWl0KXtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZihzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMClyZXR1cm4gW107XG4gICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgaWYoIWlzUmVnRXhwKHNlcGFyYXRvcikpcmV0dXJuIF9zcGxpdC5jYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIHNwbGl0TGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gNDI5NDk2NzI5NSA6IGxpbWl0ID4+PiAwO1xuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aCwgaTtcbiAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgaWYoIU5QQ0cpc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yQ29weS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgIHdoaWxlKG1hdGNoID0gc2VwYXJhdG9yQ29weS5leGVjKHN0cmluZykpe1xuICAgICAgICAvLyBgc2VwYXJhdG9yQ29weS5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgaWYobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCl7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yIE5QQ0dcbiAgICAgICAgICBpZighTlBDRyAmJiBtYXRjaFtMRU5HVEhdID4gMSltYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBmb3IoaSA9IDE7IGkgPCBhcmd1bWVudHNbTEVOR1RIXSAtIDI7IGkrKylpZihhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCltYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZihtYXRjaFtMRU5HVEhdID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZ1tMRU5HVEhdKSRwdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgaWYob3V0cHV0W0xFTkdUSF0gPj0gc3BsaXRMaW1pdClicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZihzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdID09PSBtYXRjaC5pbmRleClzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdKys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZ1tMRU5HVEhdKXtcbiAgICAgICAgaWYobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yQ29weS50ZXN0KCcnKSlvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9IGVsc2Ugb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiBvdXRwdXRbTEVOR1RIXSA+IHNwbGl0TGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgc3BsaXRMaW1pdCkgOiBvdXRwdXQ7XG4gICAgfTtcbiAgLy8gQ2hha3JhLCBWOFxuICB9IGVsc2UgaWYoJzAnWyRTUExJVF0odW5kZWZpbmVkLCAwKVtMRU5HVEhdKXtcbiAgICAkc3BsaXQgPSBmdW5jdGlvbihzZXBhcmF0b3IsIGxpbWl0KXtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfVxuICAvLyAyMS4xLjMuMTcgU3RyaW5nLnByb3RvdHlwZS5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KVxuICByZXR1cm4gW2Z1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpe1xuICAgIHZhciBPICA9IGRlZmluZWQodGhpcylcbiAgICAgICwgZm4gPSBzZXBhcmF0b3IgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VwYXJhdG9yW1NQTElUXTtcbiAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZCA/IGZuLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdCkgOiAkc3BsaXQuY2FsbChTdHJpbmcoTyksIHNlcGFyYXRvciwgbGltaXQpO1xuICB9LCAkc3BsaXRdO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2xhc3NvZiAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuSW5zdGFuY2UgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBmb3JPZiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKVxuICAsIHRhc2sgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBtaWNyb3Rhc2sgICAgICAgICAgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgUFJPTUlTRSAgICAgICAgICAgID0gJ1Byb21pc2UnXG4gICwgVHlwZUVycm9yICAgICAgICAgID0gZ2xvYmFsLlR5cGVFcnJvclxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgJFByb21pc2UgICAgICAgICAgID0gZ2xvYmFsW1BST01JU0VdXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgICAgICAgICAgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJ1xuICAsIGVtcHR5ICAgICAgICAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBJbnRlcm5hbCwgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xuXG52YXIgVVNFX05BVElWRSA9ICEhZnVuY3Rpb24oKXtcbiAgdHJ5IHtcbiAgICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgICB2YXIgcHJvbWlzZSAgICAgPSAkUHJvbWlzZS5yZXNvbHZlKDEpXG4gICAgICAsIEZha2VQcm9taXNlID0gKHByb21pc2UuY29uc3RydWN0b3IgPSB7fSlbcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbihleGVjKXsgZXhlYyhlbXB0eSwgZW1wdHkpOyB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgc2FtZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24oYSwgYil7XG4gIC8vIHdpdGggbGlicmFyeSB3cmFwcGVyIHNwZWNpYWwgY2FzZVxuICByZXR1cm4gYSA9PT0gYiB8fCBhID09PSAkUHJvbWlzZSAmJiBiID09PSBXcmFwcGVyO1xufTtcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICByZXR1cm4gc2FtZUNvbnN0cnVjdG9yKCRQcm9taXNlLCBDKVxuICAgID8gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgOiBuZXcgR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbnZhciBQcm9taXNlQ2FwYWJpbGl0eSA9IEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKEMpe1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbigkJHJlc29sdmUsICQkcmVqZWN0KXtcbiAgICBpZihyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ICA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCAgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn07XG52YXIgcGVyZm9ybSA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIGV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4ge2Vycm9yOiBlfTtcbiAgfVxufTtcbnZhciBub3RpZnkgPSBmdW5jdGlvbihwcm9taXNlLCBpc1JlamVjdCl7XG4gIGlmKHByb21pc2UuX24pcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBvayAgICA9IHByb21pc2UuX3MgPT0gMVxuICAgICAgLCBpICAgICA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uKHJlYWN0aW9uKXtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWxcbiAgICAgICAgLCByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZVxuICAgICAgICAsIHJlamVjdCAgPSByZWFjdGlvbi5yZWplY3RcbiAgICAgICAgLCBkb21haW4gID0gcmVhY3Rpb24uZG9tYWluXG4gICAgICAgICwgcmVzdWx0LCB0aGVuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgaWYoIW9rKXtcbiAgICAgICAgICAgIGlmKHByb21pc2UuX2ggPT0gMilvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihoYW5kbGVyID09PSB0cnVlKXJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYoZG9tYWluKWRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKXtcbiAgICAgICAgICAgIHJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpe1xuICAgICAgICAgICAgdGhlbi5jYWxsKHJlc3VsdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2UgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpcnVuKGNoYWluW2krK10pOyAvLyB2YXJpYWJsZSBsZW5ndGggLSBjYW4ndCB1c2UgZm9yRWFjaFxuICAgIHByb21pc2UuX2MgPSBbXTtcbiAgICBwcm9taXNlLl9uID0gZmFsc2U7XG4gICAgaWYoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3ZcbiAgICAgICwgYWJydXB0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmKGlzVW5oYW5kbGVkKHByb21pc2UpKXtcbiAgICAgIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoaXNOb2RlKXtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub251bmhhbmRsZWRyZWplY3Rpb24pe1xuICAgICAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWV9KTtcbiAgICAgICAgfSBlbHNlIGlmKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3Ipe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgcHJvbWlzZS5faCA9IGlzTm9kZSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZihhYnJ1cHQpdGhyb3cgYWJydXB0LmVycm9yO1xuICB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgaWYocHJvbWlzZS5faCA9PSAxKXJldHVybiBmYWxzZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYSB8fCBwcm9taXNlLl9jXG4gICAgLCBpICAgICA9IDBcbiAgICAsIHJlYWN0aW9uO1xuICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXtcbiAgICByZWFjdGlvbiA9IGNoYWluW2krK107XG4gICAgaWYocmVhY3Rpb24uZmFpbCB8fCAhaXNVbmhhbmRsZWQocmVhY3Rpb24ucHJvbWlzZSkpcmV0dXJuIGZhbHNlO1xuICB9IHJldHVybiB0cnVlO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbigpe1xuICAgIHZhciBoYW5kbGVyO1xuICAgIGlmKGlzTm9kZSl7XG4gICAgICBwcm9jZXNzLmVtaXQoJ3JlamVjdGlvbkhhbmRsZWQnLCBwcm9taXNlKTtcbiAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnJlamVjdGlvbmhhbmRsZWQpe1xuICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92fSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgJHJlamVjdCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZihwcm9taXNlLl9kKXJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZighcHJvbWlzZS5fYSlwcm9taXNlLl9hID0gcHJvbWlzZS5fYy5zbGljZSgpO1xuICBub3RpZnkocHJvbWlzZSwgdHJ1ZSk7XG59O1xudmFyICRyZXNvbHZlID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXNcbiAgICAsIHRoZW47XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYocHJvbWlzZSA9PT0gdmFsdWUpdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYodGhlbiA9IGlzVGhlbmFibGUodmFsdWUpKXtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICB2YXIgd3JhcHBlciA9IHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAkcmVqZWN0LmNhbGwod3JhcHBlciwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLl92ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zID0gMTtcbiAgICAgIG5vdGlmeShwcm9taXNlLCBmYWxzZSk7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgICRyZWplY3QuY2FsbCh7X3c6IHByb21pc2UsIF9kOiBmYWxzZX0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZighVVNFX05BVElWRSl7XG4gIC8vIDI1LjQuMy4xIFByb21pc2UoZXhlY3V0b3IpXG4gICRQcm9taXNlID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcil7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICB0aGlzLl9jID0gW107ICAgICAgICAgICAgIC8vIDwtIGF3YWl0aW5nIHJlYWN0aW9uc1xuICAgIHRoaXMuX2EgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gY2hlY2tlZCBpbiBpc1VuaGFuZGxlZCByZWFjdGlvbnNcbiAgICB0aGlzLl9zID0gMDsgICAgICAgICAgICAgIC8vIDwtIHN0YXRlXG4gICAgdGhpcy5fZCA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBkb25lXG4gICAgdGhpcy5fdiA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSB2YWx1ZVxuICAgIHRoaXMuX2ggPSAwOyAgICAgICAgICAgICAgLy8gPC0gcmVqZWN0aW9uIHN0YXRlLCAwIC0gZGVmYXVsdCwgMSAtIGhhbmRsZWQsIDIgLSB1bmhhbmRsZWRcbiAgICB0aGlzLl9uID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIG5vdGlmeVxuICB9O1xuICBJbnRlcm5hbC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKSgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpe1xuICAgICAgdmFyIHJlYWN0aW9uICAgID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRQcm9taXNlKSk7XG4gICAgICByZWFjdGlvbi5vayAgICAgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgICA9IHR5cGVvZiBvblJlamVjdGVkID09ICdmdW5jdGlvbicgJiYgb25SZWplY3RlZDtcbiAgICAgIHJlYWN0aW9uLmRvbWFpbiA9IGlzTm9kZSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX2EpdGhpcy5fYS5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmKHRoaXMuX3Mpbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGVkKXtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBQcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHByb21pc2UgID0gbmV3IEludGVybmFsO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gY3R4KCRyZXNvbHZlLCBwcm9taXNlLCAxKTtcbiAgICB0aGlzLnJlamVjdCAgPSBjdHgoJHJlamVjdCwgcHJvbWlzZSwgMSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtQcm9taXNlOiAkUHJvbWlzZX0pO1xucmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKSgkUHJvbWlzZSwgUFJPTUlTRSk7XG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKFBST01JU0UpO1xuV3JhcHBlciA9IHJlcXVpcmUoJy4vX2NvcmUnKVtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNSBQcm9taXNlLnJlamVjdChyKVxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKXtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVqZWN0ICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICAkJHJlamVjdChyKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKExJQlJBUlkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpe1xuICAgIC8vIGluc3RhbmNlb2YgaW5zdGVhZCBvZiBpbnRlcm5hbCBzbG90IGNoZWNrIGJlY2F1c2Ugd2Ugc2hvdWxkIGZpeCBpdCB3aXRob3V0IHJlcGxhY2VtZW50IG5hdGl2ZSBQcm9taXNlIGNvcmVcbiAgICBpZih4IGluc3RhbmNlb2YgJFByb21pc2UgJiYgc2FtZUNvbnN0cnVjdG9yKHguY29uc3RydWN0b3IsIHRoaXMpKXJldHVybiB4O1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZXNvbHZlICA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICAkJHJlc29sdmUoeCk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEoVVNFX05BVElWRSAmJiByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpe1xuICAkUHJvbWlzZS5hbGwoaXRlcilbJ2NhdGNoJ10oZW1wdHkpO1xufSkpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC4xIFByb21pc2UuYWxsKGl0ZXJhYmxlKVxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSB0aGlzXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZXNvbHZlICAgID0gY2FwYWJpbGl0eS5yZXNvbHZlXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgdmFyIHZhbHVlcyAgICA9IFtdXG4gICAgICAgICwgaW5kZXggICAgID0gMFxuICAgICAgICAsIHJlbWFpbmluZyA9IDE7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICB2YXIgJGluZGV4ICAgICAgICA9IGluZGV4KytcbiAgICAgICAgICAsIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICBpZihhbHJlYWR5Q2FsbGVkKXJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkICA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlamVjdCAgICAgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpe1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzXG4gKiogbW9kdWxlIGlkID0gMjA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGNhbGwgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgZ2V0SXRlckZuICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpXG4gICwgQlJFQUsgICAgICAgPSB7fVxuICAsIFJFVFVSTiAgICAgID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUil7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSlcbiAgICAsIGYgICAgICA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKVxuICAgICwgaW5kZXggID0gMFxuICAgICwgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZihpc0FycmF5SXRlcihpdGVyRm4pKWZvcihsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKyl7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyApe1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2Zvci1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDIwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBTUEVDSUVTICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBEKXtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvciwgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanNcbiAqKiBtb2R1bGUgaWQgPSAyMDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKXBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUoaGVhZCl7XG4gICAgICBmbiAgID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgaWYoaGVhZClub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZihpc05vZGUpe1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZVxuICAgICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKXtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmbil7XG4gICAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWR9O1xuICAgIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZighaGVhZCl7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fbWljcm90YXNrLmpzXG4gKiogbW9kdWxlIGlkID0gMjA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0YXJnZXQsIHNyYywgc2FmZSl7XG4gIGZvcih2YXIga2V5IGluIHNyYylyZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjEgTWFwIE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdNYXAnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gTWFwKCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4xLjMuNiBNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHRoaXMsIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nLCB0cnVlKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hcC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGNyZWF0ZSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBhbkluc3RhbmNlICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBkZWZpbmVkICAgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZvck9mICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJylcbiAgLCBzdGVwICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgc2V0U3BlY2llcyAgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgZmFzdEtleSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleVxuICAsIFNJWkUgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbih0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT09ICdGJylyZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0Ll9mID09IGVudHJ5KXRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXQuX2wgPT0gZW50cnkpdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsICdmb3JFYWNoJyk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKVxuICAgICAgICAgICwgZW50cnk7XG4gICAgICAgIHdoaWxlKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZil7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZihERVNDUklQVE9SUylkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBkZWZpbmVkKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXQuX2YpdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICB0aGlzLl90ID0gaXRlcmF0ZWQ7ICAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgLCBraW5kICA9IHRoYXQuX2tcbiAgICAgICAgLCBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgJGV4cG9ydCAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIHJlZGVmaW5lQWxsICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBtZXRhICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKVxuICAsIGZvck9mICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBhbkluc3RhbmNlICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBpc09iamVjdCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZmFpbHMgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgJGl0ZXJEZXRlY3QgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgICAgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspe1xuICB2YXIgQmFzZSAgPSBnbG9iYWxbTkFNRV1cbiAgICAsIEMgICAgID0gQmFzZVxuICAgICwgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnXG4gICAgLCBwcm90byA9IEMgJiYgQy5wcm90b3R5cGVcbiAgICAsIE8gICAgID0ge307XG4gIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbihLRVkpe1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uKGEpe1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoYSl7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKXtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gdW5kZWZpbmVkIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZChhKXsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpOyByZXR1cm4gdGhpczsgfVxuICAgICAgICA6IGZ1bmN0aW9uIHNldChhLCBiKXsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmKHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpe1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gICAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5zdGFuY2UgICAgICAgICAgICAgPSBuZXcgQ1xuICAgICAgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xuICAgICAgLCBIQVNOVF9DSEFJTklORyAgICAgICA9IGluc3RhbmNlW0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSkgIT0gaW5zdGFuY2VcbiAgICAgIC8vIFY4IH4gIENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxuICAgICAgLCBUSFJPV1NfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uKCl7IGluc3RhbmNlLmhhcygxKTsgfSlcbiAgICAgIC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcbiAgICAgICwgQUNDRVBUX0lURVJBQkxFUyAgICAgPSAkaXRlckRldGVjdChmdW5jdGlvbihpdGVyKXsgbmV3IEMoaXRlcik7IH0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICAvLyBmb3IgZWFybHkgaW1wbGVtZW50YXRpb25zIC0wIGFuZCArMCBub3QgdGhlIHNhbWVcbiAgICAgICwgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIFY4IH4gQ2hyb21pdW0gNDItIGZhaWxzIG9ubHkgd2l0aCA1KyBlbGVtZW50c1xuICAgICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKVxuICAgICAgICAgICwgaW5kZXggICAgID0gNTtcbiAgICAgICAgd2hpbGUoaW5kZXgtLSkkaW5zdGFuY2VbQURERVJdKGluZGV4LCBpbmRleCk7XG4gICAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XG4gICAgICB9KTtcbiAgICBpZighQUNDRVBUX0lURVJBQkxFUyl7IFxuICAgICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCBpdGVyYWJsZSl7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSwgdGFyZ2V0LCBDKTtcbiAgICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIEMucHJvdG90eXBlID0gcHJvdG87XG4gICAgICBwcm90by5jb25zdHJ1Y3RvciA9IEM7XG4gICAgfVxuICAgIGlmKFRIUk9XU19PTl9QUklNSVRJVkVTIHx8IEJVR0dZX1pFUk8pe1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYoQlVHR1lfWkVSTyB8fCBIQVNOVF9DSEFJTklORylmaXhNZXRob2QoQURERVIpO1xuICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgc2hvdWxkIG5vdCBjb250YWlucyAuY2xlYXIgbWV0aG9kXG4gICAgaWYoSVNfV0VBSyAmJiBwcm90by5jbGVhcilkZWxldGUgcHJvdG8uY2xlYXI7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQyAhPSBCYXNlKSwgTyk7XG5cbiAgaWYoIUlTX1dFQUspY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBlYWNoICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMClcbiAgLCByZWRlZmluZSAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgbWV0YSAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpXG4gICwgYXNzaWduICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpXG4gICwgd2VhayAgICAgICAgID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJylcbiAgLCBpc09iamVjdCAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGdldFdlYWsgICAgICA9IG1ldGEuZ2V0V2Vha1xuICAsIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGVcbiAgLCB1bmNhdWdodEZyb3plblN0b3JlID0gd2Vhay51ZnN0b3JlXG4gICwgdG1wICAgICAgICAgID0ge31cbiAgLCBJbnRlcm5hbE1hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpe1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgaWYoaXNPYmplY3Qoa2V5KSl7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgIGlmKGRhdGEgPT09IHRydWUpcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhpcykuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gZGF0YSA/IGRhdGFbdGhpcy5faV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSl7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHRoaXMsIGtleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xudmFyICRXZWFrTWFwID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ1dlYWtNYXAnLCB3cmFwcGVyLCBtZXRob2RzLCB3ZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYobmV3ICRXZWFrTWFwKCkuc2V0KChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkodG1wKSwgNykuZ2V0KHRtcCkgIT0gNyl7XG4gIEludGVybmFsTWFwID0gd2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyKTtcbiAgYXNzaWduKEludGVybmFsTWFwLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIG1ldGEuTkVFRCA9IHRydWU7XG4gIGVhY2goWydkZWxldGUnLCAnaGFzJywgJ2dldCcsICdzZXQnXSwgZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgcHJvdG8gID0gJFdlYWtNYXAucHJvdG90eXBlXG4gICAgICAsIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBpbnRlcm5hbCB3ZWFrbWFwIHNoaW1cbiAgICAgIGlmKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpe1xuICAgICAgICBpZighdGhpcy5fZil0aGlzLl9mID0gbmV3IEludGVybmFsTWFwO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZltrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZUFsbCAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgZ2V0V2VhayAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuZ2V0V2Vha1xuICAsIGFuT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZm9yT2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpXG4gICwgJGhhcyAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIGFycmF5RmluZCAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNSlcbiAgLCBhcnJheUZpbmRJbmRleCAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpXG4gICwgaWQgICAgICAgICAgICAgICAgPSAwO1xuXG4vLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24odGhhdCl7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUpO1xufTtcbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hID0gW107XG59O1xudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uKHN0b3JlLCBrZXkpe1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uKGl0KXtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZihlbnRyeSlyZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZihlbnRyeSllbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kSW5kZXgodGhpcy5hLCBmdW5jdGlvbihpdCl7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZih+aW5kZXgpdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpe1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBpdGVyYWJsZSl7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgaWYoIWlzT2JqZWN0KGtleSkpcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbih0aGF0LCBrZXksIHZhbHVlKXtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgaWYoZGF0YSA9PT0gdHJ1ZSl1bmNhdWdodEZyb3plblN0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICBlbHNlIGRhdGFbdGhhdC5faV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgdWZzdG9yZTogdW5jYXVnaHRGcm96ZW5TdG9yZVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcblxuLy8gMjMuNCBXZWFrU2V0IE9iamVjdHNcbnJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnV2Vha1NldCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gd2Vhay5kZWYodGhpcywgdmFsdWUsIHRydWUpO1xuICB9XG59LCB3ZWFrLCBmYWxzZSwgdHJ1ZSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLXNldC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHR5cGVkICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQnKVxuICAsIGJ1ZmZlciAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpXG4gICwgYW5PYmplY3QgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0luZGV4ICAgICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBpc09iamVjdCAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIEFycmF5QnVmZmVyICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLkFycmF5QnVmZmVyXG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgJEFycmF5QnVmZmVyID0gYnVmZmVyLkFycmF5QnVmZmVyXG4gICwgJERhdGFWaWV3ICAgID0gYnVmZmVyLkRhdGFWaWV3XG4gICwgJGlzVmlldyAgICAgID0gJHR5cGVkLkFCViAmJiBBcnJheUJ1ZmZlci5pc1ZpZXdcbiAgLCAkc2xpY2UgICAgICAgPSAkQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlXG4gICwgVklFVyAgICAgICAgID0gJHR5cGVkLlZJRVdcbiAgLCBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChBcnJheUJ1ZmZlciAhPT0gJEFycmF5QnVmZmVyKSwge0FycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXJ9KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhJHR5cGVkLkNPTlNUUiwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuMy4xIEFycmF5QnVmZmVyLmlzVmlldyhhcmcpXG4gIGlzVmlldzogZnVuY3Rpb24gaXNWaWV3KGl0KXtcbiAgICByZXR1cm4gJGlzVmlldyAmJiAkaXNWaWV3KGl0KSB8fCBpc09iamVjdChpdCkgJiYgVklFVyBpbiBpdDtcbiAgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5VICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gIW5ldyAkQXJyYXlCdWZmZXIoMikuc2xpY2UoMSwgdW5kZWZpbmVkKS5ieXRlTGVuZ3RoO1xufSksIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjQuMyBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2Uoc3RhcnQsIGVuZClcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpe1xuICAgIGlmKCRzbGljZSAhPT0gdW5kZWZpbmVkICYmIGVuZCA9PT0gdW5kZWZpbmVkKXJldHVybiAkc2xpY2UuY2FsbChhbk9iamVjdCh0aGlzKSwgc3RhcnQpOyAvLyBGRiBmaXhcbiAgICB2YXIgbGVuICAgID0gYW5PYmplY3QodGhpcykuYnl0ZUxlbmd0aFxuICAgICAgLCBmaXJzdCAgPSB0b0luZGV4KHN0YXJ0LCBsZW4pXG4gICAgICAsIGZpbmFsICA9IHRvSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiBlbmQsIGxlbilcbiAgICAgICwgcmVzdWx0ID0gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJEFycmF5QnVmZmVyKSkodG9MZW5ndGgoZmluYWwgLSBmaXJzdCkpXG4gICAgICAsIHZpZXdTICA9IG5ldyAkRGF0YVZpZXcodGhpcylcbiAgICAgICwgdmlld1QgID0gbmV3ICREYXRhVmlldyhyZXN1bHQpXG4gICAgICAsIGluZGV4ICA9IDA7XG4gICAgd2hpbGUoZmlyc3QgPCBmaW5hbCl7XG4gICAgICB2aWV3VC5zZXRVaW50OChpbmRleCsrLCB2aWV3Uy5nZXRVaW50OChmaXJzdCsrKSk7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShBUlJBWV9CVUZGRVIpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuYXJyYXktYnVmZmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCB1aWQgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFRZUEVEICA9IHVpZCgndHlwZWRfYXJyYXknKVxuICAsIFZJRVcgICA9IHVpZCgndmlldycpXG4gICwgQUJWICAgID0gISEoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGdsb2JhbC5EYXRhVmlldylcbiAgLCBDT05TVFIgPSBBQlZcbiAgLCBpID0gMCwgbCA9IDksIFR5cGVkO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9ycyA9IChcbiAgJ0ludDhBcnJheSxVaW50OEFycmF5LFVpbnQ4Q2xhbXBlZEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5J1xuKS5zcGxpdCgnLCcpO1xuXG53aGlsZShpIDwgbCl7XG4gIGlmKFR5cGVkID0gZ2xvYmFsW1R5cGVkQXJyYXlDb25zdHJ1Y3RvcnNbaSsrXV0pe1xuICAgIGhpZGUoVHlwZWQucHJvdG90eXBlLCBUWVBFRCwgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICB9IGVsc2UgQ09OU1RSID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBQlY6ICAgIEFCVixcbiAgQ09OU1RSOiBDT05TVFIsXG4gIFRZUEVEOiAgVFlQRUQsXG4gIFZJRVc6ICAgVklFV1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzXG4gKiogbW9kdWxlIGlkID0gMjE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJHR5cGVkICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZUFsbCAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgZmFpbHMgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgYW5JbnN0YW5jZSAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgdG9JbnRlZ2VyICAgICAgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCB0b0xlbmd0aCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgZ09QTiAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBkUCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBhcnJheUZpbGwgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEFSUkFZX0JVRkZFUiAgID0gJ0FycmF5QnVmZmVyJ1xuICAsIERBVEFfVklFVyAgICAgID0gJ0RhdGFWaWV3J1xuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBXUk9OR19MRU5HVEggICA9ICdXcm9uZyBsZW5ndGghJ1xuICAsIFdST05HX0lOREVYICAgID0gJ1dyb25nIGluZGV4ISdcbiAgLCAkQXJyYXlCdWZmZXIgICA9IGdsb2JhbFtBUlJBWV9CVUZGRVJdXG4gICwgJERhdGFWaWV3ICAgICAgPSBnbG9iYWxbREFUQV9WSUVXXVxuICAsIE1hdGggICAgICAgICAgID0gZ2xvYmFsLk1hdGhcbiAgLCBSYW5nZUVycm9yICAgICA9IGdsb2JhbC5SYW5nZUVycm9yXG4gICwgSW5maW5pdHkgICAgICAgPSBnbG9iYWwuSW5maW5pdHlcbiAgLCBCYXNlQnVmZmVyICAgICA9ICRBcnJheUJ1ZmZlclxuICAsIGFicyAgICAgICAgICAgID0gTWF0aC5hYnNcbiAgLCBwb3cgICAgICAgICAgICA9IE1hdGgucG93XG4gICwgZmxvb3IgICAgICAgICAgPSBNYXRoLmZsb29yXG4gICwgbG9nICAgICAgICAgICAgPSBNYXRoLmxvZ1xuICAsIExOMiAgICAgICAgICAgID0gTWF0aC5MTjJcbiAgLCBCVUZGRVIgICAgICAgICA9ICdidWZmZXInXG4gICwgQllURV9MRU5HVEggICAgPSAnYnl0ZUxlbmd0aCdcbiAgLCBCWVRFX09GRlNFVCAgICA9ICdieXRlT2Zmc2V0J1xuICAsICRCVUZGRVIgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX2InIDogQlVGRkVSXG4gICwgJExFTkdUSCAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfbCcgOiBCWVRFX0xFTkdUSFxuICAsICRPRkZTRVQgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX28nIDogQllURV9PRkZTRVQ7XG5cbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG52YXIgcGFja0lFRUU3NTQgPSBmdW5jdGlvbih2YWx1ZSwgbUxlbiwgbkJ5dGVzKXtcbiAgdmFyIGJ1ZmZlciA9IEFycmF5KG5CeXRlcylcbiAgICAsIGVMZW4gICA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICAgICwgZU1heCAgID0gKDEgPDwgZUxlbikgLSAxXG4gICAgLCBlQmlhcyAgPSBlTWF4ID4+IDFcbiAgICAsIHJ0ICAgICA9IG1MZW4gPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDBcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHMgICAgICA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDBcbiAgICAsIGUsIG0sIGM7XG4gIHZhbHVlID0gYWJzKHZhbHVlKVxuICBpZih2YWx1ZSAhPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpe1xuICAgIG0gPSB2YWx1ZSAhPSB2YWx1ZSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBmbG9vcihsb2codmFsdWUpIC8gTE4yKTtcbiAgICBpZih2YWx1ZSAqIChjID0gcG93KDIsIC1lKSkgPCAxKXtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYoZSArIGVCaWFzID49IDEpe1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZih2YWx1ZSAqIGMgPj0gMil7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmKGUgKyBlQmlhcyA+PSBlTWF4KXtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmKGUgKyBlQmlhcyA+PSAxKXtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuICBmb3IoOyBtTGVuID49IDg7IGJ1ZmZlcltpKytdID0gbSAmIDI1NSwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG4gIGUgPSBlIDw8IG1MZW4gfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvcig7IGVMZW4gPiAwOyBidWZmZXJbaSsrXSA9IGUgJiAyNTUsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuICBidWZmZXJbLS1pXSB8PSBzICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufTtcbnZhciB1bnBhY2tJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBtTGVuLCBuQnl0ZXMpe1xuICB2YXIgZUxlbiAgPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgICAsIGVNYXggID0gKDEgPDwgZUxlbikgLSAxXG4gICAgLCBlQmlhcyA9IGVNYXggPj4gMVxuICAgICwgbkJpdHMgPSBlTGVuIC0gN1xuICAgICwgaSAgICAgPSBuQnl0ZXMgLSAxXG4gICAgLCBzICAgICA9IGJ1ZmZlcltpLS1dXG4gICAgLCBlICAgICA9IHMgJiAxMjdcbiAgICAsIG07XG4gIHMgPj49IDc7XG4gIGZvcig7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGUgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgaWYoZSA9PT0gMCl7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmKGUgPT09IGVNYXgpe1xuICAgIHJldHVybiBtID8gTmFOIDogcyA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgcG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH0gcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBwb3coMiwgZSAtIG1MZW4pO1xufTtcblxudmFyIHVucGFja0kzMiA9IGZ1bmN0aW9uKGJ5dGVzKXtcbiAgcmV0dXJuIGJ5dGVzWzNdIDw8IDI0IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG59O1xudmFyIHBhY2tJOCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmZdO1xufTtcbnZhciBwYWNrSTE2ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmZdO1xufTtcbnZhciBwYWNrSTMyID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmYsIGl0ID4+IDE2ICYgMHhmZiwgaXQgPj4gMjQgJiAweGZmXTtcbn07XG52YXIgcGFja0Y2NCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCA1MiwgOCk7XG59O1xudmFyIHBhY2tGMzIgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgMjMsIDQpO1xufTtcblxudmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uKEMsIGtleSwgaW50ZXJuYWwpe1xuICBkUChDW1BST1RPVFlQRV0sIGtleSwge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXNbaW50ZXJuYWxdOyB9fSk7XG59O1xuXG52YXIgZ2V0ID0gZnVuY3Rpb24odmlldywgYnl0ZXMsIGluZGV4LCBpc0xpdHRsZUVuZGlhbil7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleFxuICAgICwgaW50SW5kZXggPSB0b0ludGVnZXIobnVtSW5kZXgpO1xuICBpZihudW1JbmRleCAhPSBpbnRJbmRleCB8fCBpbnRJbmRleCA8IDAgfHwgaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2JcbiAgICAsIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdXG4gICAgLCBwYWNrICA9IHN0b3JlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xufTtcbnZhciBzZXQgPSBmdW5jdGlvbih2aWV3LCBieXRlcywgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbil7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleFxuICAgICwgaW50SW5kZXggPSB0b0ludGVnZXIobnVtSW5kZXgpO1xuICBpZihudW1JbmRleCAhPSBpbnRJbmRleCB8fCBpbnRJbmRleCA8IDAgfHwgaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2JcbiAgICAsIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdXG4gICAgLCBwYWNrICA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspc3RvcmVbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogYnl0ZXMgLSBpIC0gMV07XG59O1xuXG52YXIgdmFsaWRhdGVBcnJheUJ1ZmZlckFyZ3VtZW50cyA9IGZ1bmN0aW9uKHRoYXQsIGxlbmd0aCl7XG4gIGFuSW5zdGFuY2UodGhhdCwgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuICB2YXIgbnVtYmVyTGVuZ3RoID0gK2xlbmd0aFxuICAgICwgYnl0ZUxlbmd0aCAgID0gdG9MZW5ndGgobnVtYmVyTGVuZ3RoKTtcbiAgaWYobnVtYmVyTGVuZ3RoICE9IGJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICByZXR1cm4gYnl0ZUxlbmd0aDtcbn07XG5cbmlmKCEkdHlwZWQuQUJWKXtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKXtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHModGhpcywgbGVuZ3RoKTtcbiAgICB0aGlzLl9iICAgICAgID0gYXJyYXlGaWxsLmNhbGwoQXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCl7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkRGF0YVZpZXcsIERBVEFfVklFVyk7XG4gICAgYW5JbnN0YW5jZShidWZmZXIsICRBcnJheUJ1ZmZlciwgREFUQV9WSUVXKTtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyWyRMRU5HVEhdXG4gICAgICAsIG9mZnNldCAgICAgICA9IHRvSW50ZWdlcihieXRlT2Zmc2V0KTtcbiAgICBpZihvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHRoaXNbJEJVRkZFUl0gPSBidWZmZXI7XG4gICAgdGhpc1skT0ZGU0VUXSA9IG9mZnNldDtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBpZihERVNDUklQVE9SUyl7XG4gICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJVRkZFUiwgJ19iJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfT0ZGU0VULCAnX28nKTtcbiAgfVxuXG4gIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgZ2V0SW50ODogZnVuY3Rpb24gZ2V0SW50OChieXRlT2Zmc2V0KXtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCl7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDIzLCA0KTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1MiwgOCk7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKXtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRjMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Y2NCwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmKCFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyAkQXJyYXlCdWZmZXI7ICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgJEFycmF5QnVmZmVyKC41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkpe1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCl7XG4gICAgICByZXR1cm4gbmV3IEJhc2VCdWZmZXIodmFsaWRhdGVBcnJheUJ1ZmZlckFyZ3VtZW50cyh0aGlzLCBsZW5ndGgpKTtcbiAgICB9O1xuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBCYXNlQnVmZmVyW1BST1RPVFlQRV07XG4gICAgZm9yKHZhciBrZXlzID0gZ09QTihCYXNlQnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyApe1xuICAgICAgaWYoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKWhpZGUoJEFycmF5QnVmZmVyLCBrZXksIEJhc2VCdWZmZXJba2V5XSk7XG4gICAgfTtcbiAgICBpZighTElCUkFSWSlBcnJheUJ1ZmZlclByb3RvLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9XG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSlcbiAgICAsICRzZXRJbnQ4ID0gJERhdGFWaWV3W1BST1RPVFlQRV0uc2V0SW50ODtcbiAgdmlldy5zZXRJbnQ4KDAsIDIxNDc0ODM2NDgpO1xuICB2aWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmKHZpZXcuZ2V0SW50OCgwKSB8fCAhdmlldy5nZXRJbnQ4KDEpKXJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuaGlkZSgkRGF0YVZpZXdbUFJPVE9UWVBFXSwgJHR5cGVkLlZJRVcsIHRydWUpO1xuZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuZXhwb3J0c1tEQVRBX1ZJRVddID0gJERhdGFWaWV3O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYnVmZmVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fdHlwZWQnKS5BQlYsIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpLkRhdGFWaWV3XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qc1xuICoqIG1vZHVsZSBpZCA9IDIyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSl7XG4gIHZhciBMSUJSQVJZICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICAgLCBnbG9iYWwgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgICAsIGZhaWxzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICAgLCAkZXhwb3J0ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgICAsICR0eXBlZCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICAgLCAkYnVmZmVyICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJylcbiAgICAsIGN0eCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAgICwgYW5JbnN0YW5jZSAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgICAsIHByb3BlcnR5RGVzYyAgICAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgICAsIGhpZGUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgICAsIHJlZGVmaW5lQWxsICAgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAgICwgdG9JbnRlZ2VyICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAgICwgdG9MZW5ndGggICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICAgLCB0b0luZGV4ICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAgICwgdG9QcmltaXRpdmUgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICAgLCBoYXMgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgICAsIHNhbWUgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19zYW1lLXZhbHVlJylcbiAgICAsIGNsYXNzb2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgICAsIGlzT2JqZWN0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAgICwgdG9PYmplY3QgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICAgLCBpc0FycmF5SXRlciAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICAgLCBjcmVhdGUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICAgLCBnZXRQcm90b3R5cGVPZiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICAgLCBnT1BOICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICAgLCBnZXRJdGVyRm4gICAgICAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAgICwgdWlkICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICAgLCB3a3MgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgICAsIGNyZWF0ZUFycmF5TWV0aG9kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJylcbiAgICAsIGNyZWF0ZUFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpXG4gICAgLCBzcGVjaWVzQ29uc3RydWN0b3IgID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICAgLCBBcnJheUl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKVxuICAgICwgSXRlcmF0b3JzICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICAgLCAkaXRlckRldGVjdCAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKVxuICAgICwgc2V0U3BlY2llcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJylcbiAgICAsIGFycmF5RmlsbCAgICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1maWxsJylcbiAgICAsIGFycmF5Q29weVdpdGhpbiAgICAgPSByZXF1aXJlKCcuL19hcnJheS1jb3B5LXdpdGhpbicpXG4gICAgLCAkRFAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgICAsICRHT1BEICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICAgLCBkUCAgICAgICAgICAgICAgICAgID0gJERQLmZcbiAgICAsIGdPUEQgICAgICAgICAgICAgICAgPSAkR09QRC5mXG4gICAgLCBSYW5nZUVycm9yICAgICAgICAgID0gZ2xvYmFsLlJhbmdlRXJyb3JcbiAgICAsIFR5cGVFcnJvciAgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICAgLCBVaW50OEFycmF5ICAgICAgICAgID0gZ2xvYmFsLlVpbnQ4QXJyYXlcbiAgICAsIEFSUkFZX0JVRkZFUiAgICAgICAgPSAnQXJyYXlCdWZmZXInXG4gICAgLCBTSEFSRURfQlVGRkVSICAgICAgID0gJ1NoYXJlZCcgKyBBUlJBWV9CVUZGRVJcbiAgICAsIEJZVEVTX1BFUl9FTEVNRU5UICAgPSAnQllURVNfUEVSX0VMRU1FTlQnXG4gICAgLCBQUk9UT1RZUEUgICAgICAgICAgID0gJ3Byb3RvdHlwZSdcbiAgICAsIEFycmF5UHJvdG8gICAgICAgICAgPSBBcnJheVtQUk9UT1RZUEVdXG4gICAgLCAkQXJyYXlCdWZmZXIgICAgICAgID0gJGJ1ZmZlci5BcnJheUJ1ZmZlclxuICAgICwgJERhdGFWaWV3ICAgICAgICAgICA9ICRidWZmZXIuRGF0YVZpZXdcbiAgICAsIGFycmF5Rm9yRWFjaCAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCgwKVxuICAgICwgYXJyYXlGaWx0ZXIgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDIpXG4gICAgLCBhcnJheVNvbWUgICAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoMylcbiAgICAsIGFycmF5RXZlcnkgICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg0KVxuICAgICwgYXJyYXlGaW5kICAgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpXG4gICAgLCBhcnJheUZpbmRJbmRleCAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNilcbiAgICAsIGFycmF5SW5jbHVkZXMgICAgICAgPSBjcmVhdGVBcnJheUluY2x1ZGVzKHRydWUpXG4gICAgLCBhcnJheUluZGV4T2YgICAgICAgID0gY3JlYXRlQXJyYXlJbmNsdWRlcyhmYWxzZSlcbiAgICAsIGFycmF5VmFsdWVzICAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy52YWx1ZXNcbiAgICAsIGFycmF5S2V5cyAgICAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy5rZXlzXG4gICAgLCBhcnJheUVudHJpZXMgICAgICAgID0gQXJyYXlJdGVyYXRvcnMuZW50cmllc1xuICAgICwgYXJyYXlMYXN0SW5kZXhPZiAgICA9IEFycmF5UHJvdG8ubGFzdEluZGV4T2ZcbiAgICAsIGFycmF5UmVkdWNlICAgICAgICAgPSBBcnJheVByb3RvLnJlZHVjZVxuICAgICwgYXJyYXlSZWR1Y2VSaWdodCAgICA9IEFycmF5UHJvdG8ucmVkdWNlUmlnaHRcbiAgICAsIGFycmF5Sm9pbiAgICAgICAgICAgPSBBcnJheVByb3RvLmpvaW5cbiAgICAsIGFycmF5U29ydCAgICAgICAgICAgPSBBcnJheVByb3RvLnNvcnRcbiAgICAsIGFycmF5U2xpY2UgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlXG4gICAgLCBhcnJheVRvU3RyaW5nICAgICAgID0gQXJyYXlQcm90by50b1N0cmluZ1xuICAgICwgYXJyYXlUb0xvY2FsZVN0cmluZyA9IEFycmF5UHJvdG8udG9Mb2NhbGVTdHJpbmdcbiAgICAsIElURVJBVE9SICAgICAgICAgICAgPSB3a3MoJ2l0ZXJhdG9yJylcbiAgICAsIFRBRyAgICAgICAgICAgICAgICAgPSB3a3MoJ3RvU3RyaW5nVGFnJylcbiAgICAsIFRZUEVEX0NPTlNUUlVDVE9SICAgPSB1aWQoJ3R5cGVkX2NvbnN0cnVjdG9yJylcbiAgICAsIERFRl9DT05TVFJVQ1RPUiAgICAgPSB1aWQoJ2RlZl9jb25zdHJ1Y3RvcicpXG4gICAgLCBBTExfQ09OU1RSVUNUT1JTICAgID0gJHR5cGVkLkNPTlNUUlxuICAgICwgVFlQRURfQVJSQVkgICAgICAgICA9ICR0eXBlZC5UWVBFRFxuICAgICwgVklFVyAgICAgICAgICAgICAgICA9ICR0eXBlZC5WSUVXXG4gICAgLCBXUk9OR19MRU5HVEggICAgICAgID0gJ1dyb25nIGxlbmd0aCEnO1xuXG4gIHZhciAkbWFwID0gY3JlYXRlQXJyYXlNZXRob2QoMSwgZnVuY3Rpb24oTywgbGVuZ3RoKXtcbiAgICByZXR1cm4gYWxsb2NhdGUoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxlbmd0aCk7XG4gIH0pO1xuXG4gIHZhciBMSVRUTEVfRU5ESUFOID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KFsxXSkuYnVmZmVyKVswXSA9PT0gMTtcbiAgfSk7XG5cbiAgdmFyIEZPUkNFRF9TRVQgPSAhIVVpbnQ4QXJyYXkgJiYgISFVaW50OEFycmF5W1BST1RPVFlQRV0uc2V0ICYmIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3IFVpbnQ4QXJyYXkoMSkuc2V0KHt9KTtcbiAgfSk7XG5cbiAgdmFyIHN0cmljdFRvTGVuZ3RoID0gZnVuY3Rpb24oaXQsIFNBTUUpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdmFyIG51bWJlciA9ICtpdFxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChpdCk7XG4gICAgaWYoU0FNRSAmJiAhc2FtZShudW1iZXIsIGxlbmd0aCkpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH07XG5cbiAgdmFyIHRvT2Zmc2V0ID0gZnVuY3Rpb24oaXQsIEJZVEVTKXtcbiAgICB2YXIgb2Zmc2V0ID0gdG9JbnRlZ2VyKGl0KTtcbiAgICBpZihvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKXRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9O1xuXG4gIHZhciB2YWxpZGF0ZSA9IGZ1bmN0aW9uKGl0KXtcbiAgICBpZihpc09iamVjdChpdCkgJiYgVFlQRURfQVJSQVkgaW4gaXQpcmV0dXJuIGl0O1xuICAgIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkhJyk7XG4gIH07XG5cbiAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24oQywgbGVuZ3RoKXtcbiAgICBpZighKGlzT2JqZWN0KEMpICYmIFRZUEVEX0NPTlNUUlVDVE9SIGluIEMpKXtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSXQgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3IhJyk7XG4gICAgfSByZXR1cm4gbmV3IEMobGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgc3BlY2llc0Zyb21MaXN0ID0gZnVuY3Rpb24oTywgbGlzdCl7XG4gICAgcmV0dXJuIGZyb21MaXN0KHNwZWNpZXNDb25zdHJ1Y3RvcihPLCBPW0RFRl9DT05TVFJVQ1RPUl0pLCBsaXN0KTtcbiAgfTtcblxuICB2YXIgZnJvbUxpc3QgPSBmdW5jdGlvbihDLCBsaXN0KXtcbiAgICB2YXIgaW5kZXggID0gMFxuICAgICAgLCBsZW5ndGggPSBsaXN0Lmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBhbGxvY2F0ZShDLCBsZW5ndGgpO1xuICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uKGl0LCBrZXksIGludGVybmFsKXtcbiAgICBkUChpdCwga2V5LCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fZFtpbnRlcm5hbF07IH19KTtcbiAgfTtcblxuICB2YXIgJGZyb20gPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiwgbWFwZm4sIHRoaXNBcmcgKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3Qoc291cmNlKVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBpLCBsZW5ndGgsIHZhbHVlcywgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZihpdGVyRm4gIT0gdW5kZWZpbmVkICYmICFpc0FycmF5SXRlcihpdGVyRm4pKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCB2YWx1ZXMgPSBbXSwgaSA9IDA7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaSsrKXtcbiAgICAgICAgdmFsdWVzLnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICB9IE8gPSB2YWx1ZXM7XG4gICAgfVxuICAgIGlmKG1hcHBpbmcgJiYgYUxlbiA+IDIpbWFwZm4gPSBjdHgobWFwZm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgZm9yKGkgPSAwLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCksIHJlc3VsdCA9IGFsbG9jYXRlKHRoaXMsIGxlbmd0aCk7IGxlbmd0aCA+IGk7IGkrKyl7XG4gICAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciAkb2YgPSBmdW5jdGlvbiBvZigvKi4uLml0ZW1zKi8pe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTtcbiAgICB3aGlsZShsZW5ndGggPiBpbmRleClyZXN1bHRbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gaU9TIFNhZmFyaSA2LnggZmFpbHMgaGVyZVxuICB2YXIgVE9fTE9DQUxFX0JVRyA9ICEhVWludDhBcnJheSAmJiBmYWlscyhmdW5jdGlvbigpeyBhcnJheVRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IFVpbnQ4QXJyYXkoMSkpOyB9KTtcblxuICB2YXIgJHRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9Mb2NhbGVTdHJpbmcoKXtcbiAgICByZXR1cm4gYXJyYXlUb0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfQlVHID8gYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpKSA6IHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHZhciBwcm90byA9IHtcbiAgICBjb3B5V2l0aGluOiBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyosIGVuZCAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlDb3B5V2l0aGluLmNhbGwodmFsaWRhdGUodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUV2ZXJ5KHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaWxsOiBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qLCBzdGFydCwgZW5kICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5RmlsbC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheUZpbHRlcih2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbixcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUZpbmQodmFsaWRhdGUodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiBhcnJheUZpbmRJbmRleCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgYXJyYXlGb3JFYWNoKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXtcbiAgICAgIHJldHVybiBhcnJheUluY2x1ZGVzKHZhbGlkYXRlKHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcil7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheUpvaW4uYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gbGFzdEluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5TGFzdEluZGV4T2YuYXBwbHkodmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gJG1hcCh2YWxpZGF0ZSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyosIGluaXRpYWxWYWx1ZSAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZS5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qLCBpbml0aWFsVmFsdWUgKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2VSaWdodC5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKXtcbiAgICAgIHZhciB0aGF0ICAgPSB0aGlzXG4gICAgICAgICwgbGVuZ3RoID0gdmFsaWRhdGUodGhhdCkubGVuZ3RoXG4gICAgICAgICwgbWlkZGxlID0gTWF0aC5mbG9vcihsZW5ndGggLyAyKVxuICAgICAgICAsIGluZGV4ICA9IDBcbiAgICAgICAgLCB2YWx1ZTtcbiAgICAgIHdoaWxlKGluZGV4IDwgbWlkZGxlKXtcbiAgICAgICAgdmFsdWUgICAgICAgICA9IHRoYXRbaW5kZXhdO1xuICAgICAgICB0aGF0W2luZGV4KytdID0gdGhhdFstLWxlbmd0aF07XG4gICAgICAgIHRoYXRbbGVuZ3RoXSAgPSB2YWx1ZTtcbiAgICAgIH0gcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5U29tZSh2YWxpZGF0ZSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pe1xuICAgICAgcmV0dXJuIGFycmF5U29ydC5jYWxsKHZhbGlkYXRlKHRoaXMpLCBjb21wYXJlZm4pO1xuICAgIH0sXG4gICAgc3ViYXJyYXk6IGZ1bmN0aW9uIHN1YmFycmF5KGJlZ2luLCBlbmQpe1xuICAgICAgdmFyIE8gICAgICA9IHZhbGlkYXRlKHRoaXMpXG4gICAgICAgICwgbGVuZ3RoID0gTy5sZW5ndGhcbiAgICAgICAgLCAkYmVnaW4gPSB0b0luZGV4KGJlZ2luLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSkpKFxuICAgICAgICBPLmJ1ZmZlcixcbiAgICAgICAgTy5ieXRlT2Zmc2V0ICsgJGJlZ2luICogTy5CWVRFU19QRVJfRUxFTUVOVCxcbiAgICAgICAgdG9MZW5ndGgoKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbmRleChlbmQsIGxlbmd0aCkpIC0gJGJlZ2luKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyICRzbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpe1xuICAgIHJldHVybiBzcGVjaWVzRnJvbUxpc3QodGhpcywgYXJyYXlTbGljZS5jYWxsKHZhbGlkYXRlKHRoaXMpLCBzdGFydCwgZW5kKSk7XG4gIH07XG5cbiAgdmFyICRzZXQgPSBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qLCBvZmZzZXQgKi8pe1xuICAgIHZhbGlkYXRlKHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0b09mZnNldChhcmd1bWVudHNbMV0sIDEpXG4gICAgICAsIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgICAsIHNyYyAgICA9IHRvT2JqZWN0KGFycmF5TGlrZSlcbiAgICAgICwgbGVuICAgID0gdG9MZW5ndGgoc3JjLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMDtcbiAgICBpZihsZW4gKyBvZmZzZXQgPiBsZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHdoaWxlKGluZGV4IDwgbGVuKXRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xuICB9O1xuXG4gIHZhciAkaXRlcmF0b3JzID0ge1xuICAgIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoKXtcbiAgICAgIHJldHVybiBhcnJheUVudHJpZXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICBrZXlzOiBmdW5jdGlvbiBrZXlzKCl7XG4gICAgICByZXR1cm4gYXJyYXlLZXlzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH0sXG4gICAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKXtcbiAgICAgIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzVEFJbmRleCA9IGZ1bmN0aW9uKHRhcmdldCwga2V5KXtcbiAgICByZXR1cm4gaXNPYmplY3QodGFyZ2V0KVxuICAgICAgJiYgdGFyZ2V0W1RZUEVEX0FSUkFZXVxuICAgICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICAgJiYga2V5IGluIHRhcmdldFxuICAgICAgJiYgU3RyaW5nKCtrZXkpID09IFN0cmluZyhrZXkpO1xuICB9O1xuICB2YXIgJGdldERlc2MgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpe1xuICAgIHJldHVybiBpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgPyBwcm9wZXJ0eURlc2MoMiwgdGFyZ2V0W2tleV0pXG4gICAgICA6IGdPUEQodGFyZ2V0LCBrZXkpO1xuICB9O1xuICB2YXIgJHNldERlc2MgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzYyl7XG4gICAgaWYoaXNUQUluZGV4KHRhcmdldCwga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSlcbiAgICAgICYmIGlzT2JqZWN0KGRlc2MpXG4gICAgICAmJiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICAgICYmICFoYXMoZGVzYywgJ2dldCcpXG4gICAgICAmJiAhaGFzKGRlc2MsICdzZXQnKVxuICAgICAgLy8gVE9ETzogYWRkIHZhbGlkYXRpb24gZGVzY3JpcHRvciB3L28gY2FsbGluZyBhY2Nlc3NvcnNcbiAgICAgICYmICFkZXNjLmNvbmZpZ3VyYWJsZVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ3dyaXRhYmxlJykgfHwgZGVzYy53cml0YWJsZSlcbiAgICAgICYmICghaGFzKGRlc2MsICdlbnVtZXJhYmxlJykgfHwgZGVzYy5lbnVtZXJhYmxlKVxuICAgICl7XG4gICAgICB0YXJnZXRba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gZWxzZSByZXR1cm4gZFAodGFyZ2V0LCBrZXksIGRlc2MpO1xuICB9O1xuXG4gIGlmKCFBTExfQ09OU1RSVUNUT1JTKXtcbiAgICAkR09QRC5mID0gJGdldERlc2M7XG4gICAgJERQLmYgICA9ICRzZXREZXNjO1xuICB9XG5cbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhQUxMX0NPTlNUUlVDVE9SUywgJ09iamVjdCcsIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXREZXNjLFxuICAgIGRlZmluZVByb3BlcnR5OiAgICAgICAgICAgJHNldERlc2NcbiAgfSk7XG5cbiAgaWYoZmFpbHMoZnVuY3Rpb24oKXsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpe1xuICAgIGFycmF5VG9TdHJpbmcgPSBhcnJheVRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgJFR5cGVkQXJyYXlQcm90b3R5cGUkID0gcmVkZWZpbmVBbGwoe30sIHByb3RvKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAkaXRlcmF0b3JzKTtcbiAgaGlkZSgkVHlwZWRBcnJheVByb3RvdHlwZSQsIElURVJBVE9SLCAkaXRlcmF0b3JzLnZhbHVlcyk7XG4gIHJlZGVmaW5lQWxsKCRUeXBlZEFycmF5UHJvdG90eXBlJCwge1xuICAgIHNsaWNlOiAgICAgICAgICAkc2xpY2UsXG4gICAgc2V0OiAgICAgICAgICAgICRzZXQsXG4gICAgY29uc3RydWN0b3I6ICAgIGZ1bmN0aW9uKCl7IC8qIG5vb3AgKi8gfSxcbiAgICB0b1N0cmluZzogICAgICAgYXJyYXlUb1N0cmluZyxcbiAgICB0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nXG4gIH0pO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnVmZmVyJywgJ2InKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2J5dGVPZmZzZXQnLCAnbycpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZUxlbmd0aCcsICdsJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdsZW5ndGgnLCAnZScpO1xuICBkUCgkVHlwZWRBcnJheVByb3RvdHlwZSQsIFRBRywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXNbVFlQRURfQVJSQVldOyB9XG4gIH0pO1xuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBCWVRFUywgd3JhcHBlciwgQ0xBTVBFRCl7XG4gICAgQ0xBTVBFRCA9ICEhQ0xBTVBFRDtcbiAgICB2YXIgTkFNRSAgICAgICA9IEtFWSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5J1xuICAgICAgLCBJU05UX1VJTlQ4ID0gTkFNRSAhPSAnVWludDhBcnJheSdcbiAgICAgICwgR0VUVEVSICAgICA9ICdnZXQnICsgS0VZXG4gICAgICAsIFNFVFRFUiAgICAgPSAnc2V0JyArIEtFWVxuICAgICAgLCBUeXBlZEFycmF5ID0gZ2xvYmFsW05BTUVdXG4gICAgICAsIEJhc2UgICAgICAgPSBUeXBlZEFycmF5IHx8IHt9XG4gICAgICAsIFRBQyAgICAgICAgPSBUeXBlZEFycmF5ICYmIGdldFByb3RvdHlwZU9mKFR5cGVkQXJyYXkpXG4gICAgICAsIEZPUkNFRCAgICAgPSAhVHlwZWRBcnJheSB8fCAhJHR5cGVkLkFCVlxuICAgICAgLCBPICAgICAgICAgID0ge31cbiAgICAgICwgVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkgJiYgVHlwZWRBcnJheVtQUk9UT1RZUEVdO1xuICAgIHZhciBnZXR0ZXIgPSBmdW5jdGlvbih0aGF0LCBpbmRleCl7XG4gICAgICB2YXIgZGF0YSA9IHRoYXQuX2Q7XG4gICAgICByZXR1cm4gZGF0YS52W0dFVFRFUl0oaW5kZXggKiBCWVRFUyArIGRhdGEubywgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24odGhhdCwgaW5kZXgsIHZhbHVlKXtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIGlmKENMQU1QRUQpdmFsdWUgPSAodmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKSkgPCAwID8gMCA6IHZhbHVlID4gMHhmZiA/IDB4ZmYgOiB2YWx1ZSAmIDB4ZmY7XG4gICAgICBkYXRhLnZbU0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCB2YWx1ZSwgTElUVExFX0VORElBTik7XG4gICAgfTtcbiAgICB2YXIgYWRkRWxlbWVudCA9IGZ1bmN0aW9uKHRoYXQsIGluZGV4KXtcbiAgICAgIGRQKHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gZ2V0dGVyKHRoaXMsIGluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgcmV0dXJuIHNldHRlcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGlmKEZPUkNFRCl7XG4gICAgICBUeXBlZEFycmF5ID0gd3JhcHBlcihmdW5jdGlvbih0aGF0LCBkYXRhLCAkb2Zmc2V0LCAkbGVuZ3RoKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGF0LCBUeXBlZEFycmF5LCBOQU1FLCAnX2QnKTtcbiAgICAgICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICAgICAsIG9mZnNldCA9IDBcbiAgICAgICAgICAsIGJ1ZmZlciwgYnl0ZUxlbmd0aCwgbGVuZ3RoLCBrbGFzcztcbiAgICAgICAgaWYoIWlzT2JqZWN0KGRhdGEpKXtcbiAgICAgICAgICBsZW5ndGggICAgID0gc3RyaWN0VG9MZW5ndGgoZGF0YSwgdHJ1ZSlcbiAgICAgICAgICBieXRlTGVuZ3RoID0gbGVuZ3RoICogQllURVM7XG4gICAgICAgICAgYnVmZmVyICAgICA9IG5ldyAkQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZihkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKXtcbiAgICAgICAgICBidWZmZXIgPSBkYXRhO1xuICAgICAgICAgIG9mZnNldCA9IHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZigkbGVuZ3RoID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgaWYoJGxlbiAlIEJZVEVTKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gb2Zmc2V0O1xuICAgICAgICAgICAgaWYoYnl0ZUxlbmd0aCA8IDApdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmKGJ5dGVMZW5ndGggKyBvZmZzZXQgPiAkbGVuKXRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYoVFlQRURfQVJSQVkgaW4gZGF0YSl7XG4gICAgICAgICAgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGUodGhhdCwgJ19kJywge1xuICAgICAgICAgIGI6IGJ1ZmZlcixcbiAgICAgICAgICBvOiBvZmZzZXQsXG4gICAgICAgICAgbDogYnl0ZUxlbmd0aCxcbiAgICAgICAgICBlOiBsZW5ndGgsXG4gICAgICAgICAgdjogbmV3ICREYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZShpbmRleCA8IGxlbmd0aClhZGRFbGVtZW50KHRoYXQsIGluZGV4KyspO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheVtQUk9UT1RZUEVdID0gY3JlYXRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCk7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIFR5cGVkQXJyYXkpO1xuICAgIH0gZWxzZSBpZighJGl0ZXJEZXRlY3QoZnVuY3Rpb24oaXRlcil7XG4gICAgICAvLyBWOCB3b3JrcyB3aXRoIGl0ZXJhdG9ycywgYnV0IGZhaWxzIGluIG1hbnkgb3RoZXIgY2FzZXNcbiAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00NTUyXG4gICAgICBuZXcgVHlwZWRBcnJheShudWxsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIG5ldyBUeXBlZEFycmF5KGl0ZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIH0sIHRydWUpKXtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpe1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUpO1xuICAgICAgICB2YXIga2xhc3M7XG4gICAgICAgIC8vIGB3c2AgbW9kdWxlIGJ1ZywgdGVtcG9yYXJpbHkgcmVtb3ZlIHZhbGlkYXRpb24gbGVuZ3RoIGZvciBVaW50OEFycmF5XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL3B1bGwvNjQ1XG4gICAgICAgIGlmKCFpc09iamVjdChkYXRhKSlyZXR1cm4gbmV3IEJhc2Uoc3RyaWN0VG9MZW5ndGgoZGF0YSwgSVNOVF9VSU5UOCkpO1xuICAgICAgICBpZihkYXRhIGluc3RhbmNlb2YgJEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoZGF0YSkpID09IEFSUkFZX0JVRkZFUiB8fCBrbGFzcyA9PSBTSEFSRURfQlVGRkVSKXtcbiAgICAgICAgICByZXR1cm4gJGxlbmd0aCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IG5ldyBCYXNlKGRhdGEsIHRvT2Zmc2V0KCRvZmZzZXQsIEJZVEVTKSwgJGxlbmd0aClcbiAgICAgICAgICAgIDogJG9mZnNldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgICA6IG5ldyBCYXNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmKFRZUEVEX0FSUkFZIGluIGRhdGEpcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgICByZXR1cm4gJGZyb20uY2FsbChUeXBlZEFycmF5LCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgYXJyYXlGb3JFYWNoKFRBQyAhPT0gRnVuY3Rpb24ucHJvdG90eXBlID8gZ09QTihCYXNlKS5jb25jYXQoZ09QTihUQUMpKSA6IGdPUE4oQmFzZSksIGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIGlmKCEoa2V5IGluIFR5cGVkQXJyYXkpKWhpZGUoVHlwZWRBcnJheSwga2V5LCBCYXNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgICBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBUeXBlZEFycmF5UHJvdG90eXBlO1xuICAgICAgaWYoIUxJQlJBUlkpVHlwZWRBcnJheVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXk7XG4gICAgfVxuICAgIHZhciAkbmF0aXZlSXRlcmF0b3IgICA9IFR5cGVkQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgICAsIENPUlJFQ1RfSVRFUl9OQU1FID0gISEkbmF0aXZlSXRlcmF0b3IgJiYgKCRuYXRpdmVJdGVyYXRvci5uYW1lID09ICd2YWx1ZXMnIHx8ICRuYXRpdmVJdGVyYXRvci5uYW1lID09IHVuZGVmaW5lZClcbiAgICAgICwgJGl0ZXJhdG9yICAgICAgICAgPSAkaXRlcmF0b3JzLnZhbHVlcztcbiAgICBoaWRlKFR5cGVkQXJyYXksIFRZUEVEX0NPTlNUUlVDVE9SLCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRZUEVEX0FSUkFZLCBOQU1FKTtcbiAgICBoaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIFZJRVcsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgREVGX0NPTlNUUlVDVE9SLCBUeXBlZEFycmF5KTtcblxuICAgIGlmKENMQU1QRUQgPyBuZXcgVHlwZWRBcnJheSgxKVtUQUddICE9IE5BTUUgOiAhKFRBRyBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSl7XG4gICAgICBkUChUeXBlZEFycmF5UHJvdG90eXBlLCBUQUcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gTkFNRTsgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgT1tOQU1FXSA9IFR5cGVkQXJyYXk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChUeXBlZEFycmF5ICE9IEJhc2UpLCBPKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5TLCBOQU1FLCB7XG4gICAgICBCWVRFU19QRVJfRUxFTUVOVDogQllURVMsXG4gICAgICBmcm9tOiAkZnJvbSxcbiAgICAgIG9mOiAkb2ZcbiAgICB9KTtcblxuICAgIGlmKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheVByb3RvdHlwZSkpaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAsIE5BTUUsIHByb3RvKTtcblxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFRF9TRVQsIE5BTUUsIHtzZXQ6ICRzZXR9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIUNPUlJFQ1RfSVRFUl9OQU1FLCBOQU1FLCAkaXRlcmF0b3JzKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXlQcm90b3R5cGUudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZyksIE5BTUUsIHt0b1N0cmluZzogYXJyYXlUb1N0cmluZ30pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpe1xuICAgICAgbmV3IFR5cGVkQXJyYXkoMSkuc2xpY2UoKTtcbiAgICB9KSwgTkFNRSwge3NsaWNlOiAkc2xpY2V9KTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gWzEsIDJdLnRvTG9jYWxlU3RyaW5nKCkgIT0gbmV3IFR5cGVkQXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpXG4gICAgfSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICBUeXBlZEFycmF5UHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nLmNhbGwoWzEsIDJdKTtcbiAgICB9KSksIE5BTUUsIHt0b0xvY2FsZVN0cmluZzogJHRvTG9jYWxlU3RyaW5nfSk7XG5cbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBDT1JSRUNUX0lURVJfTkFNRSA/ICRuYXRpdmVJdGVyYXRvciA6ICRpdGVyYXRvcjtcbiAgICBpZighTElCUkFSWSAmJiAhQ09SUkVDVF9JVEVSX05BTUUpaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBJVEVSQVRPUiwgJGl0ZXJhdG9yKTtcbiAgfTtcbn0gZWxzZSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0sIHRydWUpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MTYnLCAyLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDE2JywgMiwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnSW50MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDMyJywgNCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQzMi1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQzMicsIDQsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQ2NCcsIDgsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQ2NEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS4xIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3QpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHJBcHBseSAgICA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5hcHBseVxuICAsIGZBcHBseSAgICA9IEZ1bmN0aW9uLmFwcGx5O1xuLy8gTVMgRWRnZSBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJBcHBseShmdW5jdGlvbigpe30pO1xufSksICdSZWZsZWN0Jywge1xuICBhcHBseTogZnVuY3Rpb24gYXBwbHkodGFyZ2V0LCB0aGlzQXJndW1lbnQsIGFyZ3VtZW50c0xpc3Qpe1xuICAgIHZhciBUID0gYUZ1bmN0aW9uKHRhcmdldClcbiAgICAgICwgTCA9IGFuT2JqZWN0KGFyZ3VtZW50c0xpc3QpO1xuICAgIHJldHVybiByQXBwbHkgPyByQXBwbHkoVCwgdGhpc0FyZ3VtZW50LCBMKSA6IGZBcHBseS5jYWxsKFQsIHRoaXNBcmd1bWVudCwgTCk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5hcHBseS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxudmFyICRleHBvcnQgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNyZWF0ZSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBhRnVuY3Rpb24gID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZmFpbHMgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBiaW5kICAgICAgID0gcmVxdWlyZSgnLi9fYmluZCcpXG4gICwgckNvbnN0cnVjdCA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5jb25zdHJ1Y3Q7XG5cbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gRigpe31cbiAgcmV0dXJuICEockNvbnN0cnVjdChmdW5jdGlvbigpe30sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG52YXIgQVJHU19CVUcgPSAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgckNvbnN0cnVjdChmdW5jdGlvbigpe30pO1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHKSwgJ1JlZmxlY3QnLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJncyAvKiwgbmV3VGFyZ2V0Ki8pe1xuICAgIGFGdW5jdGlvbihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFGdW5jdGlvbihhcmd1bWVudHNbMl0pO1xuICAgIGlmKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRylyZXR1cm4gckNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgaWYoVGFyZ2V0ID09IG5ld1RhcmdldCl7XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldDtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpO1xuICAgIH1cbiAgICAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcbiAgICB2YXIgcHJvdG8gICAgPSBuZXdUYXJnZXQucHJvdG90eXBlXG4gICAgICAsIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSlcbiAgICAgICwgcmVzdWx0ICAgPSBGdW5jdGlvbi5hcHBseS5jYWxsKFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXG52YXIgZFAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuLy8gTVMgRWRnZSBoYXMgYnJva2VuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgLSB0aHJvd2luZyBpbnN0ZWFkIG9mIHJldHVybmluZyBmYWxzZVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoZFAuZih7fSwgMSwge3ZhbHVlOiAxfSksIDEsIHt2YWx1ZTogMn0pO1xufSksICdSZWZsZWN0Jywge1xuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyl7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICBwcm9wZXJ0eUtleSA9IHRvUHJpbWl0aXZlKHByb3BlcnR5S2V5LCB0cnVlKTtcbiAgICBhbk9iamVjdChhdHRyaWJ1dGVzKTtcbiAgICB0cnkge1xuICAgICAgZFAuZih0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMjM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnT1BEICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZlxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlbGV0ZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlKHRhcmdldClcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBFbnVtZXJhdGUgPSBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBhbk9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHZhciBrZXlzID0gdGhpcy5fayA9IFtdICAgICAgIC8vIGtleXNcbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBpdGVyYXRlZClrZXlzLnB1c2goa2V5KTtcbn07XG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKEVudW1lcmF0ZSwgJ09iamVjdCcsIGZ1bmN0aW9uKCl7XG4gIHZhciB0aGF0ID0gdGhpc1xuICAgICwga2V5cyA9IHRoYXQuX2tcbiAgICAsIGtleTtcbiAgZG8ge1xuICAgIGlmKHRoYXQuX2kgPj0ga2V5cy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgfSB3aGlsZSghKChrZXkgPSBrZXlzW3RoYXQuX2krK10pIGluIHRoYXQuX3QpKTtcbiAgcmV0dXJuIHt2YWx1ZToga2V5LCBkb25lOiBmYWxzZX07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBlbnVtZXJhdGU6IGZ1bmN0aW9uIGVudW1lcmF0ZSh0YXJnZXQpe1xuICAgIHJldHVybiBuZXcgRW51bWVyYXRlKHRhcmdldCk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcbnZhciBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5LyosIHJlY2VpdmVyKi8pe1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXVxuICAgICwgZGVzYywgcHJvdG87XG4gIGlmKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKXJldHVybiB0YXJnZXRbcHJvcGVydHlLZXldO1xuICBpZihkZXNjID0gZ09QRC5mKHRhcmdldCwgcHJvcGVydHlLZXkpKXJldHVybiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICA/IGRlc2MudmFsdWVcbiAgICA6IGRlc2MuZ2V0ICE9PSB1bmRlZmluZWRcbiAgICAgID8gZGVzYy5nZXQuY2FsbChyZWNlaXZlcilcbiAgICAgIDogdW5kZWZpbmVkO1xuICBpZihpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKXJldHVybiBnZXQocHJvdG8sIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtnZXQ6IGdldH0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyIGdPUEQgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMjM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGdldFByb3RvID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KXtcbiAgICByZXR1cm4gZ2V0UHJvdG8oYW5PYmplY3QodGFyZ2V0KSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gMjM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjkgUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wZXJ0eUtleSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaGFzOiBmdW5jdGlvbiBoYXModGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgcmV0dXJuIHByb3BlcnR5S2V5IGluIHRhcmdldDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lmhhcy5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS4xMCBSZWZsZWN0LmlzRXh0ZW5zaWJsZSh0YXJnZXQpXG52YXIgJGV4cG9ydCAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgaXNFeHRlbnNpYmxlOiBmdW5jdGlvbiBpc0V4dGVuc2libGUodGFyZ2V0KXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHJldHVybiAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZSh0YXJnZXQpIDogdHJ1ZTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuMTEgUmVmbGVjdC5vd25LZXlzKHRhcmdldClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtvd25LZXlzOiByZXF1aXJlKCcuL19vd24ta2V5cycpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMjQyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG52YXIgZ09QTiAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpXG4gICwgZ09QUyAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIFJlZmxlY3QgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuUmVmbGVjdDtcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdCAmJiBSZWZsZWN0Lm93bktleXMgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCl7XG4gIHZhciBrZXlzICAgICAgID0gZ09QTi5mKGFuT2JqZWN0KGl0KSlcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHJldHVybiBnZXRTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vd24ta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDI0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS4xMiBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zKHRhcmdldClcbnZhciAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJHByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHByZXZlbnRFeHRlbnNpb25zOiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmKCRwcmV2ZW50RXh0ZW5zaW9ucykkcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjEzIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYgWywgcmVjZWl2ZXJdKVxudmFyIGRQICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcblxuZnVuY3Rpb24gc2V0KHRhcmdldCwgcHJvcGVydHlLZXksIFYvKiwgcmVjZWl2ZXIqLyl7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdXG4gICAgLCBvd25EZXNjICA9IGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSlcbiAgICAsIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG87XG4gIGlmKCFvd25EZXNjKXtcbiAgICBpZihpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKXtcbiAgICAgIHJldHVybiBzZXQocHJvdG8sIHByb3BlcnR5S2V5LCBWLCByZWNlaXZlcik7XG4gICAgfVxuICAgIG93bkRlc2MgPSBjcmVhdGVEZXNjKDApO1xuICB9XG4gIGlmKGhhcyhvd25EZXNjLCAndmFsdWUnKSl7XG4gICAgaWYob3duRGVzYy53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSlyZXR1cm4gZmFsc2U7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yID0gZ09QRC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSkgfHwgY3JlYXRlRGVzYygwKTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IudmFsdWUgPSBWO1xuICAgIGRQLmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5LCBleGlzdGluZ0Rlc2NyaXB0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBvd25EZXNjLnNldCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAob3duRGVzYy5zZXQuY2FsbChyZWNlaXZlciwgViksIHRydWUpO1xufVxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7c2V0OiBzZXR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjE0IFJlZmxlY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bylcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2V0UHJvdG8gPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKTtcblxuaWYoc2V0UHJvdG8pJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90byl7XG4gICAgc2V0UHJvdG8uY2hlY2sodGFyZ2V0LCBwcm90byk7XG4gICAgdHJ5IHtcbiAgICAgIHNldFByb3RvLnNldCh0YXJnZXQsIHByb3RvKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDI0NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyosIGZyb21JbmRleCA9IDAgKi8pe1xuICAgIHJldHVybiAkaW5jbHVkZXModGhpcywgZWwsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKCdpbmNsdWRlcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXQgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBhdDogZnVuY3Rpb24gYXQocG9zKXtcbiAgICByZXR1cm4gJGF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYWQgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRTdGFydDogZnVuY3Rpb24gcGFkU3RhcnQobWF4TGVuZ3RoIC8qLCBmaWxsU3RyaW5nID0gJyAnICovKXtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLXN0YXJ0LmpzXG4gKiogbW9kdWxlIGlkID0gMjQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCByZXBlYXQgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIG1heExlbmd0aCwgZmlsbFN0cmluZywgbGVmdCl7XG4gIHZhciBTICAgICAgICAgICAgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAsIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoXG4gICAgLCBmaWxsU3RyICAgICAgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZylcbiAgICAsIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7XG4gIGlmKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGggfHwgZmlsbFN0ciA9PSAnJylyZXR1cm4gUztcbiAgdmFyIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGhcbiAgICAsIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIE1hdGguY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTtcbiAgaWYoc3RyaW5nRmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4pc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gbGVmdCA/IHN0cmluZ0ZpbGxlciArIFMgOiBTICsgc3RyaW5nRmlsbGVyO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFkICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgcGFkRW5kOiBmdW5jdGlvbiBwYWRFbmQobWF4TGVuZ3RoIC8qLCBmaWxsU3RyaW5nID0gJyAnICovKXtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBmYWxzZSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1MZWZ0JywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbUxlZnQoKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMSk7XG4gIH07XG59LCAndHJpbVN0YXJ0Jyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0LmpzXG4gKiogbW9kdWxlIGlkID0gMjUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltUmlnaHQnLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltUmlnaHQoKXtcbiAgICByZXR1cm4gJHRyaW0odGhpcywgMik7XG4gIH07XG59LCAndHJpbUVuZCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tcmlnaHQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vU3RyaW5nLnByb3RvdHlwZS5tYXRjaEFsbC9cbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZGVmaW5lZCAgICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgaXNSZWdFeHAgICAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAsIGdldEZsYWdzICAgID0gcmVxdWlyZSgnLi9fZmxhZ3MnKVxuICAsIFJlZ0V4cFByb3RvID0gUmVnRXhwLnByb3RvdHlwZTtcblxudmFyICRSZWdFeHBTdHJpbmdJdGVyYXRvciA9IGZ1bmN0aW9uKHJlZ2V4cCwgc3RyaW5nKXtcbiAgdGhpcy5fciA9IHJlZ2V4cDtcbiAgdGhpcy5fcyA9IHN0cmluZztcbn07XG5cbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yLCAnUmVnRXhwIFN0cmluZycsIGZ1bmN0aW9uIG5leHQoKXtcbiAgdmFyIG1hdGNoID0gdGhpcy5fci5leGVjKHRoaXMuX3MpO1xuICByZXR1cm4ge3ZhbHVlOiBtYXRjaCwgZG9uZTogbWF0Y2ggPT09IG51bGx9O1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBtYXRjaEFsbDogZnVuY3Rpb24gbWF0Y2hBbGwocmVnZXhwKXtcbiAgICBkZWZpbmVkKHRoaXMpO1xuICAgIGlmKCFpc1JlZ0V4cChyZWdleHApKXRocm93IFR5cGVFcnJvcihyZWdleHAgKyAnIGlzIG5vdCBhIHJlZ2V4cCEnKTtcbiAgICB2YXIgUyAgICAgPSBTdHJpbmcodGhpcylcbiAgICAgICwgZmxhZ3MgPSAnZmxhZ3MnIGluIFJlZ0V4cFByb3RvID8gU3RyaW5nKHJlZ2V4cC5mbGFncykgOiBnZXRGbGFncy5jYWxsKHJlZ2V4cClcbiAgICAgICwgcnggICAgPSBuZXcgUmVnRXhwKHJlZ2V4cC5zb3VyY2UsIH5mbGFncy5pbmRleE9mKCdnJykgPyBmbGFncyA6ICdnJyArIGZsYWdzKTtcbiAgICByeC5sYXN0SW5kZXggPSB0b0xlbmd0aChyZWdleHAubGFzdEluZGV4KTtcbiAgICByZXR1cm4gbmV3ICRSZWdFeHBTdHJpbmdJdGVyYXRvcihyeCwgUyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG52YXIgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIG93bktleXMgICAgICAgID0gcmVxdWlyZSgnLi9fb3duLWtleXMnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QRCAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KXtcbiAgICB2YXIgTyAgICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgICAsIGdldERlc2MgPSBnT1BELmZcbiAgICAgICwga2V5cyAgICA9IG93bktleXMoTylcbiAgICAgICwgcmVzdWx0ICA9IHt9XG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShrZXlzLmxlbmd0aCA+IGkpY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXkgPSBrZXlzW2krK10sIGdldERlc2MoTywga2V5KSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDI1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LXZhbHVlcy1lbnRyaWVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHZhbHVlcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKGZhbHNlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKGl0KXtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDI1OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdldEtleXMgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBpc0VudW0gICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNFbnRyaWVzKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKGl0KXtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KGl0KVxuICAgICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGkgICAgICA9IDBcbiAgICAgICwgcmVzdWx0ID0gW11cbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGkpaWYoaXNFbnVtLmNhbGwoTywga2V5ID0ga2V5c1tpKytdKSl7XG4gICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGVudHJpZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoaXQpe1xuICAgIHJldHVybiAkZW50cmllcyhpdCk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbi8vIEIuMi4yLjIgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKFAsIGdldHRlcilcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2RlZmluZUdldHRlcl9fOiBmdW5jdGlvbiBfX2RlZmluZUdldHRlcl9fKFAsIGdldHRlcil7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHtnZXQ6IGFGdW5jdGlvbihnZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9KTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gRm9yY2VkIHJlcGxhY2VtZW50IHByb3RvdHlwZSBhY2Nlc3NvcnMgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyl8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgSyA9IE1hdGgucmFuZG9tKCk7XG4gIC8vIEluIEZGIHRocm93cyBvbmx5IGRlZmluZSBtZXRob2RzXG4gIF9fZGVmaW5lU2V0dGVyX18uY2FsbChudWxsLCBLLCBmdW5jdGlvbigpeyAvKiBlbXB0eSAqL30pO1xuICBkZWxldGUgcmVxdWlyZSgnLi9fZ2xvYmFsJylbS107XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1mb3JjZWQtcGFtLmpzXG4gKiogbW9kdWxlIGlkID0gMjYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xuXG4vLyBCLjIuMi4zIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19kZWZpbmVTZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVTZXR0ZXJfXyhQLCBzZXR0ZXIpe1xuICAgICRkZWZpbmVQcm9wZXJ0eS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7c2V0OiBhRnVuY3Rpb24oc2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbi8vIEIuMi4yLjQgT2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cEdldHRlcl9fKFApXG5yZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICRleHBvcnQoJGV4cG9ydC5QICsgcmVxdWlyZSgnLi9fb2JqZWN0LWZvcmNlZC1wYW0nKSwgJ09iamVjdCcsIHtcbiAgX19sb29rdXBHZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBHZXR0ZXJfXyhQKXtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpXG4gICAgICAsIEsgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKVxuICAgICAgLCBEO1xuICAgIGRvIHtcbiAgICAgIGlmKEQgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgSykpcmV0dXJuIEQuZ2V0O1xuICAgIH0gd2hpbGUoTyA9IGdldFByb3RvdHlwZU9mKE8pKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QubG9va3VwLWdldHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNSBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cFNldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cFNldHRlcl9fKFApe1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpXG4gICAgICAsIEQ7XG4gICAgZG8ge1xuICAgICAgaWYoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSlyZXR1cm4gRC5zZXQ7XG4gICAgfSB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdNYXAnLCB7dG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnTWFwJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC50by1qc29uLmpzXG4gKiogbW9kdWxlIGlkID0gMjY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIGZyb20gICAgPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUpe1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCl7XG4gICAgaWYoY2xhc3NvZih0aGlzKSAhPSBOQU1FKXRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzXG4gKiogbW9kdWxlIGlkID0gMjY3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyLCBJVEVSQVRPUil7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1NldCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyNjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvcHJvcG9zYWwtZ2xvYmFsXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N5c3RlbScsIHtnbG9iYWw6IHJlcXVpcmUoJy4vX2dsb2JhbCcpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeXN0ZW0uZ2xvYmFsLmpzXG4gKiogbW9kdWxlIGlkID0gMjcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL3Byb3Bvc2FsLWlzLWVycm9yXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29mICAgICA9IHJlcXVpcmUoJy4vX2NvZicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0Vycm9yJywge1xuICBpc0Vycm9yOiBmdW5jdGlvbiBpc0Vycm9yKGl0KXtcbiAgICByZXR1cm4gY29mKGl0KSA9PT0gJ0Vycm9yJztcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvci5qc1xuICoqIG1vZHVsZSBpZCA9IDI3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaWFkZGg6IGZ1bmN0aW9uIGlhZGRoKHgwLCB4MSwgeTAsIHkxKXtcbiAgICB2YXIgJHgwID0geDAgPj4+IDBcbiAgICAgICwgJHgxID0geDEgPj4+IDBcbiAgICAgICwgJHkwID0geTAgPj4+IDA7XG4gICAgcmV0dXJuICR4MSArICh5MSA+Pj4gMCkgKyAoKCR4MCAmICR5MCB8ICgkeDAgfCAkeTApICYgfigkeDAgKyAkeTAgPj4+IDApKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoLmpzXG4gKiogbW9kdWxlIGlkID0gMjcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpc3ViaDogZnVuY3Rpb24gaXN1YmgoeDAsIHgxLCB5MCwgeTEpe1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMFxuICAgICAgLCAkeDEgPSB4MSA+Pj4gMFxuICAgICAgLCAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxIC0gKHkxID4+PiAwKSAtICgofiR4MCAmICR5MCB8IH4oJHgwIF4gJHkwKSAmICR4MCAtICR5MCA+Pj4gMCkgPj4+IDMxKSB8IDA7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaW11bGg6IGZ1bmN0aW9uIGltdWxoKHUsIHYpe1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmZcbiAgICAgICwgJHUgPSArdVxuICAgICAgLCAkdiA9ICt2XG4gICAgICAsIHUwID0gJHUgJiBVSU5UMTZcbiAgICAgICwgdjAgPSAkdiAmIFVJTlQxNlxuICAgICAgLCB1MSA9ICR1ID4+IDE2XG4gICAgICAsIHYxID0gJHYgPj4gMTZcbiAgICAgICwgdCAgPSAodTEgKiB2MCA+Pj4gMCkgKyAodTAgKiB2MCA+Pj4gMTYpO1xuICAgIHJldHVybiB1MSAqIHYxICsgKHQgPj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+PiAxNik7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pbXVsaC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdW11bGg6IGZ1bmN0aW9uIHVtdWxoKHUsIHYpe1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmZcbiAgICAgICwgJHUgPSArdVxuICAgICAgLCAkdiA9ICt2XG4gICAgICAsIHUwID0gJHUgJiBVSU5UMTZcbiAgICAgICwgdjAgPSAkdiAmIFVJTlQxNlxuICAgICAgLCB1MSA9ICR1ID4+PiAxNlxuICAgICAgLCB2MSA9ICR2ID4+PiAxNlxuICAgICAgLCB0ICA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+Pj4gMTYpICsgKCh1MCAqIHYxID4+PiAwKSArICh0ICYgVUlOVDE2KSA+Pj4gMTYpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgudW11bGguanNcbiAqKiBtb2R1bGUgaWQgPSAyNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xuXG5tZXRhZGF0YS5leHAoe2RlZmluZU1ldGFkYXRhOiBmdW5jdGlvbiBkZWZpbmVNZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSwgdGFyZ2V0LCB0YXJnZXRLZXkpe1xuICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCBhbk9iamVjdCh0YXJnZXQpLCB0b01ldGFLZXkodGFyZ2V0S2V5KSk7XG59fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIE1hcCAgICAgPSByZXF1aXJlKCcuL2VzNi5tYXAnKVxuICAsICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNoYXJlZCAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnbWV0YWRhdGEnKVxuICAsIHN0b3JlICAgPSBzaGFyZWQuc3RvcmUgfHwgKHNoYXJlZC5zdG9yZSA9IG5ldyAocmVxdWlyZSgnLi9lczYud2Vhay1tYXAnKSkpO1xuXG52YXIgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0S2V5LCBjcmVhdGUpe1xuICB2YXIgdGFyZ2V0TWV0YWRhdGEgPSBzdG9yZS5nZXQodGFyZ2V0KTtcbiAgaWYoIXRhcmdldE1ldGFkYXRhKXtcbiAgICBpZighY3JlYXRlKXJldHVybiB1bmRlZmluZWQ7XG4gICAgc3RvcmUuc2V0KHRhcmdldCwgdGFyZ2V0TWV0YWRhdGEgPSBuZXcgTWFwKTtcbiAgfVxuICB2YXIga2V5TWV0YWRhdGEgPSB0YXJnZXRNZXRhZGF0YS5nZXQodGFyZ2V0S2V5KTtcbiAgaWYoIWtleU1ldGFkYXRhKXtcbiAgICBpZighY3JlYXRlKXJldHVybiB1bmRlZmluZWQ7XG4gICAgdGFyZ2V0TWV0YWRhdGEuc2V0KHRhcmdldEtleSwga2V5TWV0YWRhdGEgPSBuZXcgTWFwKTtcbiAgfSByZXR1cm4ga2V5TWV0YWRhdGE7XG59O1xudmFyIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogbWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KTtcbn07XG52YXIgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbWV0YWRhdGFNYXAuZ2V0KE1ldGFkYXRhS2V5KTtcbn07XG52YXIgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKXtcbiAgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCB0cnVlKS5zZXQoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUpO1xufTtcbnZhciBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0S2V5KXtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCh0YXJnZXQsIHRhcmdldEtleSwgZmFsc2UpXG4gICAgLCBrZXlzICAgICAgICA9IFtdO1xuICBpZihtZXRhZGF0YU1hcCltZXRhZGF0YU1hcC5mb3JFYWNoKGZ1bmN0aW9uKF8sIGtleSl7IGtleXMucHVzaChrZXkpOyB9KTtcbiAgcmV0dXJuIGtleXM7XG59O1xudmFyIHRvTWV0YUtleSA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcbnZhciBleHAgPSBmdW5jdGlvbihPKXtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0JywgTyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RvcmU6IHN0b3JlLFxuICBtYXA6IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAsXG4gIGhhczogb3JkaW5hcnlIYXNPd25NZXRhZGF0YSxcbiAgZ2V0OiBvcmRpbmFyeUdldE93bk1ldGFkYXRhLFxuICBzZXQ6IG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEsXG4gIGtleXM6IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzLFxuICBrZXk6IHRvTWV0YUtleSxcbiAgZXhwOiBleHBcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19tZXRhZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleVxuICAsIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBtZXRhZGF0YS5tYXBcbiAgLCBzdG9yZSAgICAgICAgICAgICAgICAgID0gbWV0YWRhdGEuc3RvcmU7XG5cbm1ldGFkYXRhLmV4cCh7ZGVsZXRlTWV0YWRhdGE6IGZ1bmN0aW9uIGRlbGV0ZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHZhciB0YXJnZXRLZXkgICA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSlcbiAgICAsIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChhbk9iamVjdCh0YXJnZXQpLCB0YXJnZXRLZXksIGZhbHNlKTtcbiAgaWYobWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCB8fCAhbWV0YWRhdGFNYXBbJ2RlbGV0ZSddKG1ldGFkYXRhS2V5KSlyZXR1cm4gZmFsc2U7XG4gIGlmKG1ldGFkYXRhTWFwLnNpemUpcmV0dXJuIHRydWU7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICB0YXJnZXRNZXRhZGF0YVsnZGVsZXRlJ10odGFyZ2V0S2V5KTtcbiAgcmV0dXJuICEhdGFyZ2V0TWV0YWRhdGEuc2l6ZSB8fCBzdG9yZVsnZGVsZXRlJ10odGFyZ2V0KTtcbn19KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gMjc4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhc1xuICAsIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBtZXRhZGF0YS5nZXRcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlHZXRNZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIGhhc093biA9IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICBpZihoYXNPd24pcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogdW5kZWZpbmVkO1xufTtcblxubWV0YWRhdGEuZXhwKHtnZXRNZXRhZGF0YTogZnVuY3Rpb24gZ2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0TWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBTZXQgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vZXM2LnNldCcpXG4gICwgZnJvbSAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJylcbiAgLCBtZXRhZGF0YSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5TWV0YWRhdGFLZXlzID0gZnVuY3Rpb24oTywgUCl7XG4gIHZhciBvS2V5cyAgPSBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKVxuICAgICwgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIGlmKHBhcmVudCA9PT0gbnVsbClyZXR1cm4gb0tleXM7XG4gIHZhciBwS2V5cyAgPSBvcmRpbmFyeU1ldGFkYXRhS2V5cyhwYXJlbnQsIFApO1xuICByZXR1cm4gcEtleXMubGVuZ3RoID8gb0tleXMubGVuZ3RoID8gZnJvbShuZXcgU2V0KG9LZXlzLmNvbmNhdChwS2V5cykpKSA6IHBLZXlzIDogb0tleXM7XG59O1xuXG5tZXRhZGF0YS5leHAoe2dldE1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0TWV0YWRhdGFLZXlzKHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5TWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDI4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldFxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7Z2V0T3duTWV0YWRhdGE6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUdldE93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHtnZXRPd25NZXRhZGF0YUtleXM6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhS2V5cyh0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbn19KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMjgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhc1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUhhc01ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmKGhhc093bilyZXR1cm4gdHJ1ZTtcbiAgdmFyIHBhcmVudCA9IGdldFByb3RvdHlwZU9mKE8pO1xuICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gb3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKSA6IGZhbHNlO1xufTtcblxubWV0YWRhdGEuZXhwKHtoYXNNZXRhZGF0YTogZnVuY3Rpb24gaGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5SGFzTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtbWV0YWRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSAyODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5SGFzT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5oYXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2hhc093bk1ldGFkYXRhOiBmdW5jdGlvbiBoYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KVxuICAgICwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSAyODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5XG4gICwgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSA9IG1ldGFkYXRhLnNldDtcblxubWV0YWRhdGEuZXhwKHttZXRhZGF0YTogZnVuY3Rpb24gbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpe1xuICByZXR1cm4gZnVuY3Rpb24gZGVjb3JhdG9yKHRhcmdldCwgdGFyZ2V0S2V5KXtcbiAgICBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKFxuICAgICAgbWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsXG4gICAgICAodGFyZ2V0S2V5ICE9PSB1bmRlZmluZWQgPyBhbk9iamVjdCA6IGFGdW5jdGlvbikodGFyZ2V0KSxcbiAgICAgIHRvTWV0YUtleSh0YXJnZXRLZXkpXG4gICAgKTtcbiAgfTtcbn19KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QubWV0YWRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSAyODVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yd2FsZHJvbi90YzM5LW5vdGVzL2Jsb2IvbWFzdGVyL2VzNi8yMDE0LTA5L3NlcHQtMjUubWQjNTEwLWdsb2JhbGFzYXAtZm9yLWVucXVldWluZy1hLW1pY3JvdGFza1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKVxuICAsIHByb2Nlc3MgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnByb2Nlc3NcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbiRleHBvcnQoJGV4cG9ydC5HLCB7XG4gIGFzYXA6IGZ1bmN0aW9uIGFzYXAoZm4pe1xuICAgIHZhciBkb21haW4gPSBpc05vZGUgJiYgcHJvY2Vzcy5kb21haW47XG4gICAgbWljcm90YXNrKGRvbWFpbiA/IGRvbWFpbi5iaW5kKGZuKSA6IGZuKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzXG4gKiogbW9kdWxlIGlkID0gMjg2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIG1pY3JvdGFzayAgID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKVxuICAsIE9CU0VSVkFCTEUgID0gcmVxdWlyZSgnLi9fd2tzJykoJ29ic2VydmFibGUnKVxuICAsIGFGdW5jdGlvbiAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFuSW5zdGFuY2UgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBoaWRlICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGZvck9mICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBSRVRVUk4gICAgICA9IGZvck9mLlJFVFVSTjtcblxudmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGZuKXtcbiAgcmV0dXJuIGZuID09IG51bGwgPyB1bmRlZmluZWQgOiBhRnVuY3Rpb24oZm4pO1xufTtcblxudmFyIGNsZWFudXBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fYztcbiAgaWYoY2xlYW51cCl7XG4gICAgc3Vic2NyaXB0aW9uLl9jID0gdW5kZWZpbmVkO1xuICAgIGNsZWFudXAoKTtcbiAgfVxufTtcblxudmFyIHN1YnNjcmlwdGlvbkNsb3NlZCA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIHJldHVybiBzdWJzY3JpcHRpb24uX28gPT09IHVuZGVmaW5lZDtcbn07XG5cbnZhciBjbG9zZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIGlmKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSl7XG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgfVxufTtcblxudmFyIFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uKG9ic2VydmVyLCBzdWJzY3JpYmVyKXtcbiAgYW5PYmplY3Qob2JzZXJ2ZXIpO1xuICB0aGlzLl9jID0gdW5kZWZpbmVkO1xuICB0aGlzLl9vID0gb2JzZXJ2ZXI7XG4gIG9ic2VydmVyID0gbmV3IFN1YnNjcmlwdGlvbk9ic2VydmVyKHRoaXMpO1xuICB0cnkge1xuICAgIHZhciBjbGVhbnVwICAgICAgPSBzdWJzY3JpYmVyKG9ic2VydmVyKVxuICAgICAgLCBzdWJzY3JpcHRpb24gPSBjbGVhbnVwO1xuICAgIGlmKGNsZWFudXAgIT0gbnVsbCl7XG4gICAgICBpZih0eXBlb2YgY2xlYW51cC51bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJyljbGVhbnVwID0gZnVuY3Rpb24oKXsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICBlbHNlIGFGdW5jdGlvbihjbGVhbnVwKTtcbiAgICAgIHRoaXMuX2MgPSBjbGVhbnVwO1xuICAgIH1cbiAgfSBjYXRjaChlKXtcbiAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICByZXR1cm47XG4gIH0gaWYoc3Vic2NyaXB0aW9uQ2xvc2VkKHRoaXMpKWNsZWFudXBTdWJzY3JpcHRpb24odGhpcyk7XG59O1xuXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcbiAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCl7IGNsb3NlU3Vic2NyaXB0aW9uKHRoaXMpOyB9XG59KTtcblxudmFyIFN1YnNjcmlwdGlvbk9ic2VydmVyID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgdGhpcy5fcyA9IHN1YnNjcmlwdGlvbjtcbn07XG5cblN1YnNjcmlwdGlvbk9ic2VydmVyLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQodmFsdWUpe1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSl7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5uZXh0KTtcbiAgICAgICAgaWYobSlyZXR1cm4gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsb3NlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKHZhbHVlKXtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZihzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSl0aHJvdyB2YWx1ZTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5lcnJvcik7XG4gICAgICBpZighbSl0aHJvdyB2YWx1ZTtcbiAgICAgIHZhbHVlID0gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUodmFsdWUpe1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSl7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5jb21wbGV0ZSk7XG4gICAgICAgIHZhbHVlID0gbSA/IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpIDogdW5kZWZpbmVkO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59KTtcblxudmFyICRPYnNlcnZhYmxlID0gZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmVyKXtcbiAgYW5JbnN0YW5jZSh0aGlzLCAkT2JzZXJ2YWJsZSwgJ09ic2VydmFibGUnLCAnX2YnKS5fZiA9IGFGdW5jdGlvbihzdWJzY3JpYmVyKTtcbn07XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwge1xuICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcil7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb24ob2JzZXJ2ZXIsIHRoaXMuX2YpO1xuICB9LFxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZuKXtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyAoY29yZS5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgYUZ1bmN0aW9uKGZuKTtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGF0LnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQgOiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbih2YWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IHJlamVjdCxcbiAgICAgICAgY29tcGxldGU6IHJlc29sdmVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59KTtcblxucmVkZWZpbmVBbGwoJE9ic2VydmFibGUsIHtcbiAgZnJvbTogZnVuY3Rpb24gZnJvbSh4KXtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlO1xuICAgIHZhciBtZXRob2QgPSBnZXRNZXRob2QoYW5PYmplY3QoeClbT0JTRVJWQUJMRV0pO1xuICAgIGlmKG1ldGhvZCl7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IGFuT2JqZWN0KG1ldGhvZC5jYWxsKHgpKTtcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlLmNvbnN0cnVjdG9yID09PSBDID8gb2JzZXJ2YWJsZSA6IG5ldyBDKGZ1bmN0aW9uKG9ic2VydmVyKXtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICBpZighZG9uZSl7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmKGZvck9mKHgsIGZhbHNlLCBmdW5jdGlvbihpdCl7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXQpO1xuICAgICAgICAgICAgICBpZihkb25lKXJldHVybiBSRVRVUk47XG4gICAgICAgICAgICB9KSA9PT0gUkVUVVJOKXJldHVybjtcbiAgICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgaWYoZG9uZSl0aHJvdyBlO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfSxcbiAgb2Y6IGZ1bmN0aW9uIG9mKCl7XG4gICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gQXJyYXkobCk7IGkgPCBsOylpdGVtc1tpXSA9IGFyZ3VtZW50c1tpKytdO1xuICAgIHJldHVybiBuZXcgKHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlKShmdW5jdGlvbihvYnNlcnZlcil7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCFkb25lKXtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdGVtc1tpXSk7XG4gICAgICAgICAgICBpZihkb25lKXJldHVybjtcbiAgICAgICAgICB9IG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7IGRvbmUgPSB0cnVlOyB9O1xuICAgIH0pO1xuICB9XG59KTtcblxuaGlkZSgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIE9CU0VSVkFCTEUsIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHtPYnNlcnZhYmxlOiAkT2JzZXJ2YWJsZX0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdPYnNlcnZhYmxlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMjg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBpZTktIHNldFRpbWVvdXQgJiBzZXRJbnRlcnZhbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG52YXIgZ2xvYmFsICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgJGV4cG9ydCAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaW52b2tlICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgcGFydGlhbCAgICA9IHJlcXVpcmUoJy4vX3BhcnRpYWwnKVxuICAsIG5hdmlnYXRvciAgPSBnbG9iYWwubmF2aWdhdG9yXG4gICwgTVNJRSAgICAgICA9ICEhbmF2aWdhdG9yICYmIC9NU0lFIC5cXC4vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIDwtIGRpcnR5IGllOS0gY2hlY2tcbnZhciB3cmFwID0gZnVuY3Rpb24oc2V0KXtcbiAgcmV0dXJuIE1TSUUgPyBmdW5jdGlvbihmbiwgdGltZSAvKiwgLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIHNldChpbnZva2UoXG4gICAgICBwYXJ0aWFsLFxuICAgICAgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgdHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKVxuICAgICksIHRpbWUpO1xuICB9IDogc2V0O1xufTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CICsgJGV4cG9ydC5GICogTVNJRSwge1xuICBzZXRUaW1lb3V0OiAgd3JhcChnbG9iYWwuc2V0VGltZW91dCksXG4gIHNldEludGVydmFsOiB3cmFwKGdsb2JhbC5zZXRJbnRlcnZhbClcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzXG4gKiogbW9kdWxlIGlkID0gMjg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgcGF0aCAgICAgID0gcmVxdWlyZSgnLi9fcGF0aCcpXG4gICwgaW52b2tlICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKC8qIC4uLnBhcmdzICovKXtcbiAgdmFyIGZuICAgICA9IGFGdW5jdGlvbih0aGlzKVxuICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgcGFyZ3MgID0gQXJyYXkobGVuZ3RoKVxuICAgICwgaSAgICAgID0gMFxuICAgICwgXyAgICAgID0gcGF0aC5fXG4gICAgLCBob2xkZXIgPSBmYWxzZTtcbiAgd2hpbGUobGVuZ3RoID4gaSlpZigocGFyZ3NbaV0gPSBhcmd1bWVudHNbaSsrXSkgPT09IF8paG9sZGVyID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBqID0gMCwgayA9IDAsIGFyZ3M7XG4gICAgaWYoIWhvbGRlciAmJiAhYUxlbilyZXR1cm4gaW52b2tlKGZuLCBwYXJncywgdGhhdCk7XG4gICAgYXJncyA9IHBhcmdzLnNsaWNlKCk7XG4gICAgaWYoaG9sZGVyKWZvcig7bGVuZ3RoID4gajsgaisrKWlmKGFyZ3Nbal0gPT09IF8pYXJnc1tqXSA9IGFyZ3VtZW50c1trKytdO1xuICAgIHdoaWxlKGFMZW4gPiBrKWFyZ3MucHVzaChhcmd1bWVudHNbaysrXSk7XG4gICAgcmV0dXJuIGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFydGlhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDI4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3BhdGguanNcbiAqKiBtb2R1bGUgaWQgPSAyOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdGFzayAgID0gcmVxdWlyZSgnLi9fdGFzaycpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIsIHtcbiAgc2V0SW1tZWRpYXRlOiAgICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRpdGVyYXRvcnMgICAgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpXG4gICwgcmVkZWZpbmUgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBnbG9iYWwgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoaWRlICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgSXRlcmF0b3JzICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgd2tzICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICwgSVRFUkFUT1IgICAgICA9IHdrcygnaXRlcmF0b3InKVxuICAsIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJylcbiAgLCBBcnJheVZhbHVlcyAgID0gSXRlcmF0b3JzLkFycmF5O1xuXG5mb3IodmFyIGNvbGxlY3Rpb25zID0gWydOb2RlTGlzdCcsICdET01Ub2tlbkxpc3QnLCAnTWVkaWFMaXN0JywgJ1N0eWxlU2hlZXRMaXN0JywgJ0NTU1J1bGVMaXN0J10sIGkgPSAwOyBpIDwgNTsgaSsrKXtcbiAgdmFyIE5BTUUgICAgICAgPSBjb2xsZWN0aW9uc1tpXVxuICAgICwgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXVxuICAgICwgcHJvdG8gICAgICA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGVcbiAgICAsIGtleTtcbiAgaWYocHJvdG8pe1xuICAgIGlmKCFwcm90b1tJVEVSQVRPUl0paGlkZShwcm90bywgSVRFUkFUT1IsIEFycmF5VmFsdWVzKTtcbiAgICBpZighcHJvdG9bVE9fU1RSSU5HX1RBR10paGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgZm9yKGtleSBpbiAkaXRlcmF0b3JzKWlmKCFwcm90b1trZXldKXJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogaHR0cHM6Ly9yYXcuZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9tYXN0ZXIvTElDRU5TRSBmaWxlLiBBblxuICogYWRkaXRpb25hbCBncmFudCBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluXG4gKiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUoKG91dGVyRm4gfHwgR2VuZXJhdG9yKS5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9IEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudGAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuIFNvbWUgbWF5IGNvbnNpZGVyIHRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIHRvb1xuICAvLyBjdXRlc3ksIGJ1dCB0aGV5IGFyZSBjdXJtdWRnZW9ucy5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBuZXcgQXdhaXRBcmd1bWVudChhcmcpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF3YWl0QXJndW1lbnQoYXJnKSB7XG4gICAgdGhpcy5hcmcgPSBhcmc7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0QXJndW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLmFyZykudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzLmRvbWFpbikge1xuICAgICAgaW52b2tlID0gcHJvY2Vzcy5kb21haW4uYmluZChpbnZva2UpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiIHx8XG4gICAgICAgICAgICAgIChtZXRob2QgPT09IFwidGhyb3dcIiAmJiBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAvLyBBIHJldHVybiBvciB0aHJvdyAod2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIHRocm93XG4gICAgICAgICAgICAvLyBtZXRob2QpIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgICB2YXIgcmV0dXJuTWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl07XG4gICAgICAgICAgICBpZiAocmV0dXJuTWV0aG9kKSB7XG4gICAgICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChyZXR1cm5NZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBhcmcpO1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXR1cm4gbWV0aG9kIHRocmV3IGFuIGV4Y2VwdGlvbiwgbGV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHRpb24gcHJldmFpbCBvdmVyIHRoZSBvcmlnaW5hbCByZXR1cm4gb3IgdGhyb3cuXG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIHRoZSBvdXRlciByZXR1cm4sIG5vdyB0aGF0IHRoZSBkZWxlZ2F0ZVxuICAgICAgICAgICAgICAvLyBpdGVyYXRvciBoYXMgYmVlbiB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2RdLFxuICAgICAgICAgICAgZGVsZWdhdGUuaXRlcmF0b3IsXG4gICAgICAgICAgICBhcmdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBMaWtlIHJldHVybmluZyBnZW5lcmF0b3IudGhyb3codW5jYXVnaHQpLCBidXQgd2l0aG91dCB0aGVcbiAgICAgICAgICAgIC8vIG92ZXJoZWFkIG9mIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRGVsZWdhdGUgZ2VuZXJhdG9yIHJhbiBhbmQgaGFuZGxlZCBpdHMgb3duIGV4Y2VwdGlvbnMgc29cbiAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoYXQgdGhlIG1ldGhvZCB3YXMsIHdlIGNvbnRpbnVlIGFzIGlmIGl0IGlzXG4gICAgICAgICAgLy8gXCJuZXh0XCIgd2l0aCBhbiB1bmRlZmluZWQgYXJnLlxuICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgICAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBhcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQuZGVsZWdhdGUgJiYgbWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgICAgICAgIGFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBhcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBBbW9uZyB0aGUgdmFyaW91cyB0cmlja3MgZm9yIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsXG4gIC8vIG9iamVjdCwgdGhpcyBzZWVtcyB0byBiZSB0aGUgbW9zdCByZWxpYWJsZSB0ZWNobmlxdWUgdGhhdCBkb2VzIG5vdFxuICAvLyB1c2UgaW5kaXJlY3QgZXZhbCAod2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kpLlxuICB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDpcbiAgdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiA/IHdpbmRvdyA6XG4gIHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHRoaXNcbik7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAyOTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlJlZ0V4cC5lc2NhcGU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlLmpzXG4gKiogbW9kdWxlIGlkID0gMjk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vYmVuamFtaW5nci9SZXhFeHAuZXNjYXBlXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHJlICAgICA9IHJlcXVpcmUoJy4vX3JlcGxhY2VyJykoL1tcXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVnRXhwJywge2VzY2FwZTogZnVuY3Rpb24gZXNjYXBlKGl0KXsgcmV0dXJuICRyZShpdCk7IH19KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9jb3JlLnJlZ2V4cC5lc2NhcGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVnRXhwLCByZXBsYWNlKXtcbiAgdmFyIHJlcGxhY2VyID0gcmVwbGFjZSA9PT0gT2JqZWN0KHJlcGxhY2UpID8gZnVuY3Rpb24ocGFydCl7XG4gICAgcmV0dXJuIHJlcGxhY2VbcGFydF07XG4gIH0gOiByZXBsYWNlO1xuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBTdHJpbmcoaXQpLnJlcGxhY2UocmVnRXhwLCByZXBsYWNlcik7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVwbGFjZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyOTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFNES19WRVJTSU9OLCBMT0dfTEVWRUwgaW5qZWN0ZWQgZnJvbSB3ZWJwYWNrIGJ1aWxkLlxuXG5pbXBvcnQgeyBMRVZFTFMsIGVzdGFibGlzaExvZ2dlciwgZ2V0TG9nZ2VyIH0gZnJvbSAnLi9sb2cnXG5leHBvcnQgeyBMRVZFTFMgYXMgTG9nTGV2ZWxzIH0gZnJvbSAnLi9sb2cnXG5leHBvcnQgeyBnZXRMb2dnZXIgYXMgZ2V0TG9nZ2VyIH0gZnJvbSAnLi9sb2cnXG5cbmltcG9ydCAqIGFzIHN1YnNjcmliZXJMaWIgZnJvbSAnLi9zdWJzY3JpYmVyL2luZGV4J1xuaW1wb3J0ICogYXMgcHVibGlzaGVyTGliIGZyb20gJy4vcHVibGlzaGVyL2luZGV4J1xuaW1wb3J0ICogYXMgc2hhcmVkT2JqZWN0TGliIGZyb20gJy4vc2hhcmVkb2JqZWN0L2luZGV4J1xuaW1wb3J0IFBsYXliYWNrVmlldyBmcm9tICcuL3ZpZXcvcGxheWJhY2snXG5pbXBvcnQgUHVibGlzaGVyVmlldyBmcm9tICcuL3ZpZXcvcHVibGlzaCdcblxuLyoqXG4gKiBTdWJzY3JpcHRpb24gcmVsYXRlZCByZWZlcmVuY2VzLlxuKi9cbmV4cG9ydCBjb25zdCBSZWQ1UHJvU3Vic2NyaWJlciA9IHN1YnNjcmliZXJMaWIuUmVkNVByb1N1YnNjcmliZXJcbmV4cG9ydCBjb25zdCBSVENTdWJzY3JpYmVyID0gc3Vic2NyaWJlckxpYi5SVENTdWJzY3JpYmVyXG5leHBvcnQgY29uc3QgSExTU3Vic2NyaWJlciA9IHN1YnNjcmliZXJMaWIuSExTU3Vic2NyaWJlclxuZXhwb3J0IGNvbnN0IFZpZGVvSlNTdWJzY3JpYmVyID0gc3Vic2NyaWJlckxpYi5WaWRlb0pTU3Vic2NyaWJlclxuZXhwb3J0IGNvbnN0IFI1TGl2ZVN1YnNjcmliZXIgPSBzdWJzY3JpYmVyTGliLlI1TGl2ZVN1YnNjcmliZXJcbmV4cG9ydCBjb25zdCBSVE1QU3Vic2NyaWJlciA9IHN1YnNjcmliZXJMaWIuUlRNUFN1YnNjcmliZXJcbmV4cG9ydCB7IFBsYXliYWNrVmlldyB9XG5cbi8qKlxuICogQnJvYWRjYXN0IHJlbGF0ZWQgcmVmZXJlbmNlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IFJlZDVQcm9QdWJsaXNoZXIgPSBwdWJsaXNoZXJMaWIuUmVkNVByb1B1Ymxpc2hlclxuZXhwb3J0IGNvbnN0IFJUTVBQdWJsaXNoZXIgPSBwdWJsaXNoZXJMaWIuUlRNUFB1Ymxpc2hlclxuZXhwb3J0IGNvbnN0IFJUQ1B1Ymxpc2hlciA9IHB1Ymxpc2hlckxpYi5SVENQdWJsaXNoZXJcbmV4cG9ydCB7IFB1Ymxpc2hlclZpZXcgfVxuXG4vKipcbiAqIFNoYXJlZCBPYmplY3QgcmVmZXJlbmNlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IFJlZDVQcm9TaGFyZWRPYmplY3QgPSBzaGFyZWRPYmplY3RMaWIuUmVkNVByb1NoYXJlZE9iamVjdFxuXG4vKipcbiAqIEV2ZW50c1xuICovXG5leHBvcnQgeyBjb21tb24gYXMgUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vZXZlbnQvcHVibGlzaGVyLWV2ZW50J1xuZXhwb3J0IHsgcnRjIGFzIFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMgfSBmcm9tICcuL2V2ZW50L3B1Ymxpc2hlci1ldmVudCdcbmV4cG9ydCB7IGZhaWxvdmVyIGFzIEZhaWxvdmVyUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vZXZlbnQvcHVibGlzaGVyLWV2ZW50J1xuZXhwb3J0IHsgY29tbW9uIGFzIFN1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9ldmVudC9zdWJzY3JpYmVyLWV2ZW50J1xuZXhwb3J0IHsgcnRjIGFzIFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9ldmVudC9zdWJzY3JpYmVyLWV2ZW50J1xuZXhwb3J0IHsgZmFpbG92ZXIgYXMgRmFpbG92ZXJTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4vZXZlbnQvc3Vic2NyaWJlci1ldmVudCdcbmV4cG9ydCB7IGNvbW1vbiBhcyBTaGFyZWRPYmplY3RFdmVudFR5cGVzIH0gZnJvbSAnLi9ldmVudC9zaGFyZWRvYmplY3QtZXZlbnQnXG5cbi8qXG4gKiBFbnVtc1xuKi9cbmV4cG9ydCB7IFBsYXliYWNrQXVkaW9FbmNvZGVyIGFzIFBsYXliYWNrQXVkaW9FbmNvZGVyIH0gZnJvbSAnLi9lbnVtL3BsYXliYWNrJ1xuZXhwb3J0IHsgUGxheWJhY2tWaWRlb0VuY29kZXIgYXMgUGxheWJhY2tWaWRlb0VuY29kZXIgfSBmcm9tICcuL2VudW0vcGxheWJhY2snXG5cbmVzdGFibGlzaExvZ2dlcihgJHtMT0dfTEVWRUx9YCB8fCBMRVZFTFMuREVCVUcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbmdldExvZ2dlcigpLmRlYnVnKGBSZWQ1IFBybyBTREsgVmVyc2lvbiAke1NES19WRVJTSU9OfWApIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuZXhwb3J0IGNvbnN0IHNldExvZ0xldmVsID0gKGxldmVsKSA9PiB7XG4gIGlmIChMRVZFTFMuaGFzT3duUHJvcGVydHkobGV2ZWwudG9VcHBlckNhc2UoKSkpIHtcbiAgICBlc3RhYmxpc2hMb2dnZXIobGV2ZWwpXG4gIH1cbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgY3JlYXRlTG9nZ2VyIH0gZnJvbSAnYnJvd3Nlci1idW55YW4nXG5pbXBvcnQgeyBSYXdTdHJlYW0gfSBmcm9tICcuL2J1bnlhbi13cml0ZXInXG5cbmxldCBsb2dnZXJcbmNvbnN0IGZvcm1hdE1lc3NhZ2UgPSAoZGlzcGF0Y2hlcikgPT4ge1xuICByZXR1cm4gbWVzc2FnZSA9PiB7XG4gICAgcmV0dXJuIGAoJHtkaXNwYXRjaGVyfSkgJHttZXNzYWdlfWBcbiAgfVxufVxuY29uc3QgZGVjb3JhdGUgPSAobGV2ZWwpID0+IHtcbiAgcmV0dXJuIChzb3VyY2UsIG1lc3NhZ2UpID0+IHtcbiAgICBsb2dnZXJbbGV2ZWxdKGZvcm1hdE1lc3NhZ2Uoc291cmNlKShtZXNzYWdlKSlcbiAgfVxufVxuZXhwb3J0IGNvbnN0IExFVkVMUyA9IHtcbiAgVFJBQ0U6ICd0cmFjZScsXG4gIElORk86ICdpbmZvJyxcbiAgREVCVUc6ICdkZWJ1ZycsXG4gIFdBUk46ICd3YXJuJyxcbiAgRVJST1I6ICdlcnJvcicsXG4gIEZBVEFMOiAnZmF0YWwnXG59XG5cblxuZXhwb3J0IGNvbnN0IGVzdGFibGlzaExvZ2dlciA9IChsZXZlbCwgc3RyZWFtTGlzdCA9IHVuZGVmaW5lZCkgPT4ge1xuICBsZXQgc3RyZWFtcyA9IFtdXG4gIHN0cmVhbXMucHVzaCh7XG4gICAgbGV2ZWw6IGxldmVsLFxuICAgIHN0cmVhbTogbmV3IFJhd1N0cmVhbSgpLFxuICAgIHR5cGU6ICdyYXcnXG4gIH0pXG4gIGlmIChzdHJlYW1MaXN0KSB7XG4gICAgY29uc3QgbGlzdCA9IHN0cmVhbUxpc3QubWFwKGl0ZW0gPT4ge1xuICAgICAgaXRlbS5sZXZlbCA9IGxldmVsXG4gICAgfSlcbiAgICBzdHJlYW1zID0gc3RyZWFtcy5jb25jYXQobGlzdClcbiAgfVxuICBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgIGxldmVsOiBsZXZlbCxcbiAgICBuYW1lOiAncmVkNXByby1zZGsnLFxuICAgIHN0cmVhbXM6IHN0cmVhbXNcbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldExvZ2dlciA9ICgpID0+IHtcbiAgcmV0dXJuIGxvZ2dlclxufVxuXG5leHBvcnQgY29uc3QgdHJhY2UgPSBkZWNvcmF0ZShMRVZFTFMuVFJBQ0UpXG5leHBvcnQgY29uc3QgaW5mbyA9IGRlY29yYXRlKExFVkVMUy5JTkZPKVxuZXhwb3J0IGNvbnN0IGRlYnVnID0gZGVjb3JhdGUoTEVWRUxTLkRFQlVHKVxuZXhwb3J0IGNvbnN0IHdhcm4gPSBkZWNvcmF0ZShMRVZFTFMuV0FSTilcbmV4cG9ydCBjb25zdCBlcnJvciA9IGRlY29yYXRlKExFVkVMUy5FUlJPUilcbmV4cG9ydCBjb25zdCBmYXRhbCA9IGRlY29yYXRlKExFVkVMUy5GQVRBTClcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvbG9nL2luZGV4LmpzXG4gKiovIiwiLyoqXG4gKiAhVGhpcyBpcyBhIHN0cmlwcGVkIGRvd24gdmVyc2lvbiBvZiBCdW55YW4gdGFyZ2V0ZWQgc3BlY2lmaWNhbGx5IGZvciB0aGUgYnJvd3NlclxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgVHJlbnQgTWljay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIENvcHlyaWdodCAoYykgMjAxNCBKb3llbnQgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoZSBidW55YW4gbG9nZ2luZyBsaWJyYXJ5IGZvciBub2RlLmpzLlxuICpcbiAqIC0qLSBtb2RlOiBqcyAtKi1cbiAqIHZpbTogZXhwYW5kdGFiOnRzPTQ6c3c9NFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZFUlNJT04gPSAnMC4yLjMnO1xuXG4vLyBCdW55YW4gbG9nIGZvcm1hdCB2ZXJzaW9uLiBUaGlzIGJlY29tZXMgdGhlICd2JyBmaWVsZCBvbiBhbGwgbG9nIHJlY29yZHMuXG4vLyBgMGAgaXMgdW50aWwgSSByZWxlYXNlIGEgdmVyc2lvbiAnMS4wLjAnIG9mIG5vZGUtYnVueWFuLiBUaGVyZWFmdGVyLFxuLy8gc3RhcnRpbmcgd2l0aCBgMWAsIHRoaXMgd2lsbCBiZSBpbmNyZW1lbnRlZCBpZiB0aGVyZSBpcyBhbnkgYmFja3dhcmRcbi8vIGluY29tcGF0aWJsZSBjaGFuZ2UgdG8gdGhlIGxvZyByZWNvcmQgZm9ybWF0LiBEZXRhaWxzIHdpbGwgYmUgaW5cbi8vICdDSEFOR0VTLm1kJyAodGhlIGNoYW5nZSBsb2cpLlxudmFyIExPR19WRVJTSU9OID0gMDtcblxuLy8tLS0tIEludGVybmFsIHN1cHBvcnQgc3R1ZmZcblxuLyoqXG4gKiBBIHNoYWxsb3cgY29weSBvZiBhbiBvYmplY3QuIEJ1bnlhbiBsb2dnaW5nIGF0dGVtcHRzIHRvIG5ldmVyIGNhdXNlXG4gKiBleGNlcHRpb25zLCBzbyB0aGlzIGZ1bmN0aW9uIGF0dGVtcHRzIHRvIGhhbmRsZSBub24tb2JqZWN0cyBncmFjZWZ1bGx5LlxuICovXG5mdW5jdGlvbiBvYmpDb3B5KG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyB8fCBvYmogPT09IG51bGwpIHsgIC8vIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIChvYmopID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgY29weSA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGNvcHlba10gPSBvYmpba107XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbn1cblxudmFyIGZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcblxuICAgIGlmKGYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG5cbiAgICBpZih0eXBlb2YgZiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGYudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5cbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICAgIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHggPT09ICclJScpIHtcbiAgICAgICAgICAgIHJldHVybiAnJSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICAgICAgICBjYXNlICclaic6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogR2F0aGVyIHNvbWUgY2FsbGVyIGluZm8gMyBzdGFjayBsZXZlbHMgdXAuXG4gKiBTZWUgPGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC93aWtpL0phdmFTY3JpcHRTdGFja1RyYWNlQXBpPi5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FsbGVyM0luZm8oKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBzYXZlTGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgdmFyIHNhdmVQcmVwYXJlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMztcbiAgICAvL0Vycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGdldENhbGxlcjNJbmZvKTtcblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKF8sIHN0YWNrKSB7XG4gICAgICAgIHZhciBjYWxsZXIgPSBzdGFja1syXTtcbiAgICAgICAgb2JqLmZpbGUgPSBjYWxsZXIuZ2V0RmlsZU5hbWUoKTtcbiAgICAgICAgb2JqLmxpbmUgPSBjYWxsZXIuZ2V0TGluZU51bWJlcigpO1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxlci5nZXRGdW5jdGlvbk5hbWUoKTtcbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgIG9iai5mdW5jID0gZnVuYztcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc2F2ZUxpbWl0O1xuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gc2F2ZVByZXBhcmU7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG5mdW5jdGlvbiBfaW5kZW50KHMsIGluZGVudCkge1xuICAgIGlmICghaW5kZW50KSB7XG4gICAgICAgIGluZGVudCA9ICcgICAgJztcbiAgICB9XG4gICAgdmFyIGxpbmVzID0gcy5zcGxpdCgvXFxyP1xcbi9nKTtcbiAgICByZXR1cm4gaW5kZW50ICsgbGluZXMuam9pbignXFxuJyArIGluZGVudCk7XG59XG5cblxuLyoqXG4gKiBXYXJuIGFib3V0IGFuIGJ1bnlhbiBwcm9jZXNzaW5nIGVycm9yLlxuICpcbiAqIEBwYXJhbSBtc2cge1N0cmluZ30gTWVzc2FnZSB3aXRoIHdoaWNoIHRvIHdhcm4uXG4gKiBAcGFyYW0gZGVkdXBLZXkge1N0cmluZ30gT3B0aW9uYWwuIEEgc2hvcnQgc3RyaW5nIGtleSBmb3IgdGhpcyB3YXJuaW5nIHRvXG4gKiAgICAgIGhhdmUgaXRzIHdhcm5pbmcgb25seSBwcmludGVkIG9uY2UuXG4gKi9cbmZ1bmN0aW9uIF93YXJuKG1zZywgZGVkdXBLZXkpIHtcbiAgICBpZiAoZGVkdXBLZXkpIHtcbiAgICAgICAgaWYgKF93YXJuZWRbZGVkdXBLZXldKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX3dhcm5lZFtkZWR1cEtleV0gPSB0cnVlO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKG1zZyArICdcXG4nKTtcbn1cbmZ1bmN0aW9uIF9oYXZlV2FybmVkKGRlZHVwS2V5KSB7XG4gICAgcmV0dXJuIF93YXJuZWRbZGVkdXBLZXldO1xufVxudmFyIF93YXJuZWQgPSB7fTtcblxuXG5mdW5jdGlvbiBDb25zb2xlUmF3U3RyZWFtKCkge1xufVxuQ29uc29sZVJhd1N0cmVhbS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocmVjKSB7XG4gICAgaWYgKHJlYy5sZXZlbCA8IElORk8pIHtcbiAgICAgICAgY29uc29sZS5sb2cocmVjKTtcbiAgICB9IGVsc2UgaWYgKHJlYy5sZXZlbCA8IFdBUk4pIHtcbiAgICAgICAgY29uc29sZS5pbmZvKHJlYyk7XG4gICAgfSBlbHNlIGlmIChyZWMubGV2ZWwgPCBFUlJPUikge1xuICAgICAgICBjb25zb2xlLndhcm4ocmVjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKHJlYyk7XG4gICAgfVxuXG4gICAgaWYocmVjLmVyciAmJiByZWMuZXJyLnN0YWNrKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IocmVjLmVyci5zdGFjayk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gQ29uc29sZUZvcm1hdHRlZFN0cmVhbSgpIHt9XG5Db25zb2xlRm9ybWF0dGVkU3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChyZWMpIHtcblxuICAgIHZhciBsZXZlbENzcywgZGVmYXVsdENzcyA9ICdjb2xvcjogRGltR3JheScsIG1zZ0NzcyA9ICdjb2xvcjogU3RlZWxCbHVlJztcblxuICAgIGlmIChyZWMubGV2ZWwgPCBERUJVRykge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogRGVlcFBpbmsnO1xuICAgIH0gZWxzZSBpZiAocmVjLmxldmVsIDwgSU5GTykge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogR29sZGVuUm9kJztcbiAgICB9IGVsc2UgaWYgKHJlYy5sZXZlbCA8IFdBUk4pIHtcbiAgICAgICAgbGV2ZWxDc3MgPSAnY29sb3I6IERhcmtUdXJxdW9pc2UnO1xuICAgIH0gZWxzZSBpZiAocmVjLmxldmVsIDwgRVJST1IpIHtcbiAgICAgICAgbGV2ZWxDc3MgPSAnY29sb3I6IFB1cnBsZSc7XG4gICAgfSBlbHNlIGlmIChyZWMubGV2ZWwgPCBGQVRBTCkge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogQ3JpbXNvbic7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxDc3MgPSAnY29sb3I6IEJsYWNrJztcbiAgICB9XG5cbiAgICB2YXIgbG9nZ2VyTmFtZSA9IHJlYy5jaGlsZE5hbWUgPyByZWMubmFtZSArICcvJyArIHJlYy5jaGlsZE5hbWUgOiByZWMubmFtZTtcblxuICAgIC8vZ2V0IGxldmVsIG5hbWUgYW5kIHBhZCBzdGFydCB3aXRoIHNwYWNzXG4gICAgdmFyIGxldmVsTmFtZSA9IG5hbWVGcm9tTGV2ZWxbcmVjLmxldmVsXS50b1VwcGVyQ2FzZSgpO1xuICAgIGxldmVsTmFtZSA9IEFycmF5KDYgLSBsZXZlbE5hbWUubGVuZ3RoKS5qb2luKCcgJykgKyBsZXZlbE5hbWU7XG5cbiAgICBmdW5jdGlvbiBwYWRaZXJvcyhudW1iZXIsIGxlbikge1xuICAgICAgICByZXR1cm4gQXJyYXkoKGxlbiArIDEpIC0gKG51bWJlciArICcnKS5sZW5ndGgpLmpvaW4oJzAnKSArIG51bWJlcjtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnWyVzOiVzOiVzOiVzXSAlYyVzJWM6ICVzOiAlYyVzJyxcbiAgICAgICAgcGFkWmVyb3MocmVjLnRpbWUuZ2V0SG91cnMoKSwgMiksIHBhZFplcm9zKHJlYy50aW1lLmdldE1pbnV0ZXMoKSwgMiksXG4gICAgICAgIHBhZFplcm9zKHJlYy50aW1lLmdldFNlY29uZHMoKSwgMiksIHBhZFplcm9zKHJlYy50aW1lLmdldE1pbGxpc2Vjb25kcygpLCA0KSxcbiAgICAgICAgbGV2ZWxDc3MsIGxldmVsTmFtZSxcbiAgICAgICAgZGVmYXVsdENzcywgbG9nZ2VyTmFtZSxcbiAgICAgICAgbXNnQ3NzLCByZWMubXNnKTtcbiAgICBpZihyZWMuZXJyICYmIHJlYy5lcnIuc3RhY2spIHtcbiAgICAgICAgY29uc29sZS5sb2coJyVjJXMsJywgbGV2ZWxDc3MsIHJlYy5lcnIuc3RhY2spO1xuICAgIH1cbn07XG5cbi8vLS0tLSBMZXZlbHNcblxudmFyIFRSQUNFID0gMTA7XG52YXIgREVCVUcgPSAyMDtcbnZhciBJTkZPID0gMzA7XG52YXIgV0FSTiA9IDQwO1xudmFyIEVSUk9SID0gNTA7XG52YXIgRkFUQUwgPSA2MDtcblxudmFyIGxldmVsRnJvbU5hbWUgPSB7XG4gICAgJ3RyYWNlJzogVFJBQ0UsXG4gICAgJ2RlYnVnJzogREVCVUcsXG4gICAgJ2luZm8nOiBJTkZPLFxuICAgICd3YXJuJzogV0FSTixcbiAgICAnZXJyb3InOiBFUlJPUixcbiAgICAnZmF0YWwnOiBGQVRBTFxufTtcbnZhciBuYW1lRnJvbUxldmVsID0ge307XG5PYmplY3Qua2V5cyhsZXZlbEZyb21OYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgbmFtZUZyb21MZXZlbFtsZXZlbEZyb21OYW1lW25hbWVdXSA9IG5hbWU7XG59KTtcblxuXG4vKipcbiAqIFJlc29sdmUgYSBsZXZlbCBudW1iZXIsIG5hbWUgKHVwcGVyIG9yIGxvd2VyY2FzZSkgdG8gYSBsZXZlbCBudW1iZXIgdmFsdWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUxldmVsKG5hbWVPck51bSkge1xuICAgIHZhciBsZXZlbCA9ICh0eXBlb2YgKG5hbWVPck51bSkgPT09ICdzdHJpbmcnID8gbGV2ZWxGcm9tTmFtZVtuYW1lT3JOdW0udG9Mb3dlckNhc2UoKV0gOiBuYW1lT3JOdW0pO1xuICAgIHJldHVybiBsZXZlbDtcbn1cblxuXG4vLy0tLS0gTG9nZ2VyIGNsYXNzXG5cbi8qKlxuICogQ3JlYXRlIGEgTG9nZ2VyIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IFNlZSBkb2N1bWVudGF0aW9uIGZvciBmdWxsIGRldGFpbHMuIEF0IG1pbmltdW1cbiAqICAgIHRoaXMgbXVzdCBpbmNsdWRlIGEgJ25hbWUnIHN0cmluZyBrZXkuIENvbmZpZ3VyYXRpb24ga2V5czpcbiAqICAgICAgLSBgc3RyZWFtc2A6IHNwZWNpZnkgdGhlIGxvZ2dlciBvdXRwdXQgc3RyZWFtcy4gVGhpcyBpcyBhbiBhcnJheSBvZlxuICogICAgICAgIG9iamVjdHMgd2l0aCB0aGVzZSBmaWVsZHM6XG4gKiAgICAgICAgICAtIGB0eXBlYDogVGhlIHN0cmVhbSB0eXBlLiBTZWUgUkVBRE1FLm1kIGZvciBmdWxsIGRldGFpbHMuXG4gKiAgICAgICAgICAgIE9mdGVuIHRoaXMgaXMgaW1wbGllZCBieSB0aGUgb3RoZXIgZmllbGRzLiBFeGFtcGxlcyBhcmVcbiAqICAgICAgICAgICAgJ2ZpbGUnLCAnc3RyZWFtJyBhbmQgXCJyYXdcIi5cbiAqICAgICAgICAgIC0gYGxldmVsYDogRGVmYXVsdHMgdG8gJ2luZm8nLlxuICogICAgICAgICAgLSBgcGF0aGAgb3IgYHN0cmVhbWA6IFRoZSBzcGVjaWZ5IHRoZSBmaWxlIHBhdGggb3Igd3JpdGVhYmxlXG4gKiAgICAgICAgICAgIHN0cmVhbSB0byB3aGljaCBsb2cgcmVjb3JkcyBhcmUgd3JpdHRlbi4gRS5nLlxuICogICAgICAgICAgICBgc3RyZWFtOiBwcm9jZXNzLnN0ZG91dGAuXG4gKiAgICAgICAgICAtIGBjbG9zZU9uRXhpdGAgKGJvb2xlYW4pOiBPcHRpb25hbC4gRGVmYXVsdCBpcyB0cnVlIGZvciBhXG4gKiAgICAgICAgICAgICdmaWxlJyBzdHJlYW0gd2hlbiBgcGF0aGAgaXMgZ2l2ZW4sIGZhbHNlIG90aGVyd2lzZS5cbiAqICAgICAgICBTZWUgUkVBRE1FLm1kIGZvciBmdWxsIGRldGFpbHMuXG4gKiAgICAgIC0gYGxldmVsYDogc2V0IHRoZSBsZXZlbCBmb3IgYSBzaW5nbGUgb3V0cHV0IHN0cmVhbSAoY2Fubm90IGJlIHVzZWRcbiAqICAgICAgICB3aXRoIGBzdHJlYW1zYClcbiAqICAgICAgLSBgc3RyZWFtYDogdGhlIG91dHB1dCBzdHJlYW0gZm9yIGEgbG9nZ2VyIHdpdGgganVzdCBvbmUsIGUuZy5cbiAqICAgICAgICBgcHJvY2Vzcy5zdGRvdXRgIChjYW5ub3QgYmUgdXNlZCB3aXRoIGBzdHJlYW1zYClcbiAqICAgICAgLSBgc2VyaWFsaXplcnNgOiBvYmplY3QgbWFwcGluZyBsb2cgcmVjb3JkIGZpZWxkIG5hbWVzIHRvXG4gKiAgICAgICAgc2VyaWFsaXppbmcgZnVuY3Rpb25zLiBTZWUgUkVBRE1FLm1kIGZvciBkZXRhaWxzLlxuICogICAgICAtIGBzcmNgOiBCb29sZWFuIChkZWZhdWx0IGZhbHNlKS4gU2V0IHRydWUgdG8gZW5hYmxlICdzcmMnIGF1dG9tYXRpY1xuICogICAgICAgIGZpZWxkIHdpdGggbG9nIGNhbGwgc291cmNlIGluZm8uXG4gKiAgICBBbGwgb3RoZXIga2V5cyBhcmUgbG9nIHJlY29yZCBmaWVsZHMuXG4gKlxuICogQW4gYWx0ZXJuYXRpdmUgKmludGVybmFsKiBjYWxsIHNpZ25hdHVyZSBpcyB1c2VkIGZvciBjcmVhdGluZyBhIGNoaWxkOlxuICogICAgbmV3IExvZ2dlcig8cGFyZW50IGxvZ2dlcj4sIDxjaGlsZCBvcHRpb25zPlssIDxjaGlsZCBvcHRzIGFyZSBzaW1wbGU+XSk7XG4gKlxuICogQHBhcmFtIF9jaGlsZFNpbXBsZSAoQm9vbGVhbikgQW4gYXNzZXJ0aW9uIHRoYXQgdGhlIGdpdmVuIGBfY2hpbGRPcHRpb25zYFxuICogICAgKGEpIG9ubHkgYWRkIGZpZWxkcyAobm8gY29uZmlnKSBhbmQgKGIpIG5vIHNlcmlhbGl6YXRpb24gaGFuZGxpbmcgaXNcbiAqICAgIHJlcXVpcmVkIGZvciB0aGVtLiBJT1csIHRoaXMgaXMgYSBmYXN0IHBhdGggZm9yIGZyZXF1ZW50IGNoaWxkXG4gKiAgICBjcmVhdGlvbi5cbiAqL1xuZnVuY3Rpb24gTG9nZ2VyKG9wdGlvbnMsIF9jaGlsZE9wdGlvbnMsIF9jaGlsZFNpbXBsZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMb2dnZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyKG9wdGlvbnMsIF9jaGlsZE9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIElucHV0IGFyZyB2YWxpZGF0aW9uLlxuICAgIHZhciBwYXJlbnQ7XG4gICAgaWYgKF9jaGlsZE9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJlbnQgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gX2NoaWxkT3B0aW9ucztcbiAgICAgICAgaWYgKCEocGFyZW50IGluc3RhbmNlb2YgTG9nZ2VyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBMb2dnZXIgY3JlYXRpb246IGRvIG5vdCBwYXNzIGEgc2Vjb25kIGFyZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIChvYmplY3QpIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm5hbWUgKHN0cmluZykgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgb3B0aW9ucy5uYW1lOiBjaGlsZCBjYW5ub3Qgc2V0IGxvZ2dlciBuYW1lJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RyZWFtICYmIG9wdGlvbnMuc3RyZWFtcykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgbWl4IFwic3RyZWFtc1wiIGFuZCBcInN0cmVhbVwiIG9wdGlvbnMnKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RyZWFtcyAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zLnN0cmVhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgb3B0aW9ucy5zdHJlYW1zOiBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNlcmlhbGl6ZXJzICYmICh0eXBlb2YgKG9wdGlvbnMuc2VyaWFsaXplcnMpICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMuc2VyaWFsaXplcnMpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIG9wdGlvbnMuc2VyaWFsaXplcnM6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgdmFyIGZpZWxkcywgbmFtZSwgaTtcblxuICAgIC8vIEZhc3QgcGF0aCBmb3Igc2ltcGxlIGNoaWxkIGNyZWF0aW9uLlxuICAgIGlmIChwYXJlbnQgJiYgX2NoaWxkU2ltcGxlKSB7XG4gICAgICAgIC8vIGBfaXNTaW1wbGVDaGlsZGAgaXMgYSBzaWduYWwgdG8gc3RyZWFtIGNsb3NlIGhhbmRsaW5nIHRoYXQgdGhpcyBjaGlsZFxuICAgICAgICAvLyBvd25zIG5vbmUgb2YgaXRzIHN0cmVhbXMuXG4gICAgICAgIHRoaXMuX2lzU2ltcGxlQ2hpbGQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX2xldmVsID0gcGFyZW50Ll9sZXZlbDtcbiAgICAgICAgdGhpcy5zdHJlYW1zID0gcGFyZW50LnN0cmVhbXM7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplcnMgPSBwYXJlbnQuc2VyaWFsaXplcnM7XG4gICAgICAgIHRoaXMuc3JjID0gcGFyZW50LnNyYztcbiAgICAgICAgZmllbGRzID0gdGhpcy5maWVsZHMgPSB7fTtcbiAgICAgICAgdmFyIHBhcmVudEZpZWxkTmFtZXMgPSBPYmplY3Qua2V5cyhwYXJlbnQuZmllbGRzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcmVudEZpZWxkTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5hbWUgPSBwYXJlbnRGaWVsZE5hbWVzW2ldO1xuICAgICAgICAgICAgZmllbGRzW25hbWVdID0gcGFyZW50LmZpZWxkc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOdWxsIHZhbHVlcy5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICB0aGlzLl9sZXZlbCA9IHBhcmVudC5fbGV2ZWw7XG4gICAgICAgIHRoaXMuc3RyZWFtcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyZW50LnN0cmVhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzID0gb2JqQ29weShwYXJlbnQuc3RyZWFtc1tpXSk7XG4gICAgICAgICAgICBzLmNsb3NlT25FeGl0ID0gZmFsc2U7IC8vIERvbid0IG93biBwYXJlbnQgc3RyZWFtLlxuICAgICAgICAgICAgdGhpcy5zdHJlYW1zLnB1c2gocyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJpYWxpemVycyA9IG9iakNvcHkocGFyZW50LnNlcmlhbGl6ZXJzKTtcbiAgICAgICAgdGhpcy5zcmMgPSBwYXJlbnQuc3JjO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IG9iakNvcHkocGFyZW50LmZpZWxkcyk7XG4gICAgICAgIGlmIChvcHRpb25zLmxldmVsKSB7XG4gICAgICAgICAgICB0aGlzLmxldmVsKG9wdGlvbnMubGV2ZWwpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHRoaXMuc3RyZWFtcyA9IFtdO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zcmMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maWVsZHMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgKmNvbmZpZyogb3B0aW9ucyAoaS5lLiBvcHRpb25zIHRoYXQgYXJlIG5vdCBqdXN0IHBsYWluIGRhdGFcbiAgICAvLyBmb3IgbG9nIHJlY29yZHMpLlxuICAgIGlmIChvcHRpb25zLnN0cmVhbSkge1xuICAgICAgICBzZWxmLmFkZFN0cmVhbSh7XG4gICAgICAgICAgICB0eXBlOiAnc3RyZWFtJyxcbiAgICAgICAgICAgIHN0cmVhbTogb3B0aW9ucy5zdHJlYW0sXG4gICAgICAgICAgICBjbG9zZU9uRXhpdDogZmFsc2UsXG4gICAgICAgICAgICBsZXZlbDogb3B0aW9ucy5sZXZlbFxuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3RyZWFtcykge1xuICAgICAgICBvcHRpb25zLnN0cmVhbXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgc2VsZi5hZGRTdHJlYW0ocywgb3B0aW9ucy5sZXZlbCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFyZW50ICYmIG9wdGlvbnMubGV2ZWwpIHtcbiAgICAgICAgdGhpcy5sZXZlbChvcHRpb25zLmxldmVsKTtcbiAgICB9IGVsc2UgaWYgKCFwYXJlbnQpIHtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBJbiB0aGUgYnJvd3NlciB3ZSdsbCBiZSBlbWl0dGluZyB0byBjb25zb2xlLmxvZyBieSBkZWZhdWx0LlxuICAgICAgICAgKiBBbnkgY29uc29sZS5sb2cgd29ydGggaXRzIHNhbHQgdGhlc2UgZGF5cyBjYW4gbmljZWx5IHJlbmRlclxuICAgICAgICAgKiBhbmQgaW50cm9zcGVjdCBvYmplY3RzIChlLmcuIHRoZSBGaXJlZm94IGFuZCBDaHJvbWUgY29uc29sZSlcbiAgICAgICAgICogc28gbGV0J3MgZW1pdCB0aGUgcmF3IGxvZyByZWNvcmQuIEFyZSB0aGVyZSBicm93c2VycyBmb3Igd2hpY2hcbiAgICAgICAgICogdGhhdCBicmVha3MgdGhpbmdzP1xuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5hZGRTdHJlYW0oe1xuICAgICAgICAgICAgdHlwZTogJ3JhdycsXG4gICAgICAgICAgICBzdHJlYW06IG5ldyBDb25zb2xlUmF3U3RyZWFtKCksXG4gICAgICAgICAgICBjbG9zZU9uRXhpdDogZmFsc2UsXG4gICAgICAgICAgICBsZXZlbDogb3B0aW9ucy5sZXZlbFxuICAgICAgICB9KTtcblxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zZXJpYWxpemVycykge1xuICAgICAgICBzZWxmLmFkZFNlcmlhbGl6ZXJzKG9wdGlvbnMuc2VyaWFsaXplcnMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zcmMpIHtcbiAgICAgICAgdGhpcy5zcmMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZpZWxkcy5cbiAgICAvLyBUaGVzZSBhcmUgdGhlIGRlZmF1bHQgZmllbGRzIGZvciBsb2cgcmVjb3JkcyAobWludXMgdGhlIGF0dHJpYnV0ZXNcbiAgICAvLyByZW1vdmVkIGluIHRoaXMgY29uc3RydWN0b3IpLiBUbyBhbGxvdyBzdG9yaW5nIHJhdyBsb2cgcmVjb3Jkc1xuICAgIC8vICh1bnJlbmRlcmVkKSwgYHRoaXMuZmllbGRzYCBtdXN0IG5ldmVyIGJlIG11dGF0ZWQuIENyZWF0ZSBhIGNvcHkgZm9yXG4gICAgLy8gYW55IGNoYW5nZXMuXG4gICAgZmllbGRzID0gb2JqQ29weShvcHRpb25zKTtcbiAgICBkZWxldGUgZmllbGRzLnN0cmVhbTtcbiAgICBkZWxldGUgZmllbGRzLmxldmVsO1xuICAgIGRlbGV0ZSBmaWVsZHMuc3RyZWFtcztcbiAgICBkZWxldGUgZmllbGRzLnNlcmlhbGl6ZXJzO1xuICAgIGRlbGV0ZSBmaWVsZHMuc3JjO1xuICAgIGlmICh0aGlzLnNlcmlhbGl6ZXJzKSB7XG4gICAgICAgIHRoaXMuX2FwcGx5U2VyaWFsaXplcnMoZmllbGRzKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoZmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHNlbGYuZmllbGRzW2tdID0gZmllbGRzW2tdO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEFkZCBhIHN0cmVhbVxuICpcbiAqIEBwYXJhbSBzdHJlYW0ge09iamVjdH0uIE9iamVjdCB3aXRoIHRoZXNlIGZpZWxkczpcbiAqICAgIC0gYHR5cGVgOiBUaGUgc3RyZWFtIHR5cGUuIFNlZSBSRUFETUUubWQgZm9yIGZ1bGwgZGV0YWlscy5cbiAqICAgICAgT2Z0ZW4gdGhpcyBpcyBpbXBsaWVkIGJ5IHRoZSBvdGhlciBmaWVsZHMuIEV4YW1wbGVzIGFyZVxuICogICAgICAnZmlsZScsICdzdHJlYW0nIGFuZCBcInJhd1wiLlxuICogICAgLSBgcGF0aGAgb3IgYHN0cmVhbWA6IFRoZSBzcGVjaWZ5IHRoZSBmaWxlIHBhdGggb3Igd3JpdGVhYmxlXG4gKiAgICAgIHN0cmVhbSB0byB3aGljaCBsb2cgcmVjb3JkcyBhcmUgd3JpdHRlbi4gRS5nLlxuICogICAgICBgc3RyZWFtOiBwcm9jZXNzLnN0ZG91dGAuXG4gKiAgICAtIGBsZXZlbGA6IE9wdGlvbmFsLiBGYWxscyBiYWNrIHRvIGBkZWZhdWx0TGV2ZWxgLlxuICogICAgLSBgY2xvc2VPbkV4aXRgIChib29sZWFuKTogT3B0aW9uYWwuIERlZmF1bHQgaXMgdHJ1ZSBmb3IgYVxuICogICAgICAnZmlsZScgc3RyZWFtIHdoZW4gYHBhdGhgIGlzIGdpdmVuLCBmYWxzZSBvdGhlcndpc2UuXG4gKiAgICBTZWUgUkVBRE1FLm1kIGZvciBmdWxsIGRldGFpbHMuXG4gKiBAcGFyYW0gZGVmYXVsdExldmVsIHtOdW1iZXJ8U3RyaW5nfSBPcHRpb25hbC4gQSBsZXZlbCB0byB1c2UgaWZcbiAqICAgICAgYHN0cmVhbS5sZXZlbGAgaXMgbm90IHNldC4gSWYgbmVpdGhlciBpcyBnaXZlbiwgdGhpcyBkZWZhdWx0cyB0byBJTkZPLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzLCBkZWZhdWx0TGV2ZWwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGRlZmF1bHRMZXZlbCA9PT0gbnVsbCB8fCBkZWZhdWx0TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZhdWx0TGV2ZWwgPSBJTkZPO1xuICAgIH1cblxuICAgIHMgPSBvYmpDb3B5KHMpO1xuXG4gICAgLy8gSW1wbGljaXQgJ3R5cGUnIGZyb20gb3RoZXIgYXJncy5cbiAgICBpZiAoIXMudHlwZSAmJiBzLnN0cmVhbSkge1xuICAgICAgICBzLnR5cGUgPSAncmF3JztcbiAgICB9XG4gICAgcy5yYXcgPSAocy50eXBlID09PSAncmF3Jyk7ICAvLyBQRVJGOiBBbGxvdyBmb3IgZmFzdGVyIGNoZWNrIGluIGBfZW1pdGAuXG5cbiAgICBpZiAocy5sZXZlbCkge1xuICAgICAgICBzLmxldmVsID0gcmVzb2x2ZUxldmVsKHMubGV2ZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHMubGV2ZWwgPSByZXNvbHZlTGV2ZWwoZGVmYXVsdExldmVsKTtcbiAgICB9XG4gICAgaWYgKHMubGV2ZWwgPCBzZWxmLl9sZXZlbCkge1xuICAgICAgICBzZWxmLl9sZXZlbCA9IHMubGV2ZWw7XG4gICAgfVxuXG4gICAgc3dpdGNoIChzLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgIGlmICghcy5jbG9zZU9uRXhpdCkge1xuICAgICAgICAgICAgICAgIHMuY2xvc2VPbkV4aXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyYXcnOlxuICAgICAgICAgICAgaWYgKCFzLmNsb3NlT25FeGl0KSB7XG4gICAgICAgICAgICAgICAgcy5jbG9zZU9uRXhpdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmtub3duIHN0cmVhbSB0eXBlIFwiJyArIHMudHlwZSArICdcIicpO1xuICAgIH1cblxuICAgIHNlbGYuc3RyZWFtcy5wdXNoKHMpO1xuICAgIGRlbGV0ZSBzZWxmLmhhdmVOb25SYXdTdHJlYW1zOyAgLy8gcmVzZXRcbn07XG5cblxuLyoqXG4gKiBBZGQgc2VyaWFsaXplcnNcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplcnMge09iamVjdH0gT3B0aW9uYWwuIE9iamVjdCBtYXBwaW5nIGxvZyByZWNvcmQgZmllbGQgbmFtZXNcbiAqICAgIHRvIHNlcmlhbGl6aW5nIGZ1bmN0aW9ucy4gU2VlIFJFQURNRS5tZCBmb3IgZGV0YWlscy5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5hZGRTZXJpYWxpemVycyA9IGZ1bmN0aW9uIGFkZFNlcmlhbGl6ZXJzKHNlcmlhbGl6ZXJzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCFzZWxmLnNlcmlhbGl6ZXJzKSB7XG4gICAgICAgIHNlbGYuc2VyaWFsaXplcnMgPSB7fTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoc2VyaWFsaXplcnMpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVyID0gc2VyaWFsaXplcnNbZmllbGRdO1xuICAgICAgICBpZiAodHlwZW9mIChzZXJpYWxpemVyKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmb3JtYXQoXG4gICAgICAgICAgICAgICAgJ2ludmFsaWQgc2VyaWFsaXplciBmb3IgXCIlc1wiIGZpZWxkOiBtdXN0IGJlIGEgZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIGZpZWxkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnNlcmlhbGl6ZXJzW2ZpZWxkXSA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBjaGlsZCBsb2dnZXIsIHR5cGljYWxseSB0byBhZGQgYSBmZXcgbG9nIHJlY29yZCBmaWVsZHMuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gcGFzc2luZyBhIGxvZ2dlciB0byBhIHN1Yi1jb21wb25lbnQsIGUuZy4gYVxuICogJ3d1enpsZScgY29tcG9uZW50IG9mIHlvdXIgc2VydmljZTpcbiAqXG4gKiAgICB2YXIgd3V6emxlTG9nID0gbG9nLmNoaWxkKHtjb21wb25lbnQ6ICd3dXp6bGUnfSlcbiAqICAgIHZhciB3dXp6bGUgPSBuZXcgV3V6emxlKHsuLi4sIGxvZzogd3V6emxlTG9nfSlcbiAqXG4gKiBUaGVuIGxvZyByZWNvcmRzIGZyb20gdGhlIHd1enpsZSBjb2RlIHdpbGwgaGF2ZSB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXNcbiAqIHRoZSBhcHAgbG9nLCAqcGx1cyB0aGUgY29tcG9uZW50PSd3dXp6bGUnIGZpZWxkKi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBPcHRpb25hbC4gU2V0IG9mIG9wdGlvbnMgdG8gYXBwbHkgdG8gdGhlIGNoaWxkLlxuICogICAgQWxsIG9mIHRoZSBzYW1lIG9wdGlvbnMgZm9yIGEgbmV3IExvZ2dlciBhcHBseSBoZXJlLiBOb3RlczpcbiAqICAgICAgLSBUaGUgcGFyZW50J3Mgc3RyZWFtcyBhcmUgaW5oZXJpdGVkIGFuZCBjYW5ub3QgYmUgcmVtb3ZlZCBpbiB0aGlzXG4gKiAgICAgICAgY2FsbC4gQW55IGdpdmVuIGBzdHJlYW1zYCBhcmUgKmFkZGVkKiB0byB0aGUgc2V0IGluaGVyaXRlZCBmcm9tXG4gKiAgICAgICAgdGhlIHBhcmVudC5cbiAqICAgICAgLSBUaGUgcGFyZW50J3Mgc2VyaWFsaXplcnMgYXJlIGluaGVyaXRlZCwgdGhvdWdoIGNhbiBlZmZlY3RpdmVseSBiZVxuICogICAgICAgIG92ZXJ3cml0dGVuIGJ5IHVzaW5nIGR1cGxpY2F0ZSBrZXlzLlxuICogICAgICAtIENhbiB1c2UgYGxldmVsYCB0byBzZXQgdGhlIGxldmVsIG9mIHRoZSBzdHJlYW1zIGluaGVyaXRlZCBmcm9tXG4gKiAgICAgICAgdGhlIHBhcmVudC4gVGhlIGxldmVsIGZvciB0aGUgcGFyZW50IGlzIE5PVCBhZmZlY3RlZC5cbiAqIEBwYXJhbSBzaW1wbGUge0Jvb2xlYW59IE9wdGlvbmFsLiBTZXQgdG8gdHJ1ZSB0byBhc3NlcnQgdGhhdCBgb3B0aW9uc2BcbiAqICAgIChhKSBvbmx5IGFkZCBmaWVsZHMgKG5vIGNvbmZpZykgYW5kIChiKSBubyBzZXJpYWxpemF0aW9uIGhhbmRsaW5nIGlzXG4gKiAgICByZXF1aXJlZCBmb3IgdGhlbS4gSU9XLCB0aGlzIGlzIGEgZmFzdCBwYXRoIGZvciBmcmVxdWVudCBjaGlsZFxuICogICAgY3JlYXRpb24uIFNlZSAndG9vbHMvdGltZWNoaWxkLmpzJyBmb3IgbnVtYmVycy5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzaW1wbGUpIHtcbiAgICByZXR1cm4gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKSh0aGlzLCBvcHRpb25zIHx8IHt9LCBzaW1wbGUpO1xufTtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBsZXZlbCBvZiBhbGwgc3RyZWFtcyBvbiB0aGlzIGxvZ2dlci5cbiAqXG4gKiBHZXQgVXNhZ2U6XG4gKiAgICAvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGxvZyBsZXZlbCAobG93ZXN0IGxldmVsIG9mIGFsbCBpdHMgc3RyZWFtcykuXG4gKiAgICBsb2cubGV2ZWwoKSAtPiBJTkZPXG4gKlxuICogU2V0IFVzYWdlOlxuICogICAgbG9nLmxldmVsKElORk8pICAgICAgIC8vIHNldCBhbGwgc3RyZWFtcyB0byBsZXZlbCBJTkZPXG4gKiAgICBsb2cubGV2ZWwoJ2luZm8nKSAgICAgLy8gY2FuIHVzZSAnaW5mbycgZXQgYWwgYWxpYXNlc1xuICovXG5Mb2dnZXIucHJvdG90eXBlLmxldmVsID0gZnVuY3Rpb24gbGV2ZWwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGV2ZWw7XG4gICAgfVxuICAgIHZhciBuZXdMZXZlbCA9IHJlc29sdmVMZXZlbCh2YWx1ZSk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc3RyZWFtcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLnN0cmVhbXNbaV0ubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB9XG4gICAgdGhpcy5fbGV2ZWwgPSBuZXdMZXZlbDtcbn07XG5cblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBsZXZlbCBvZiBhIHBhcnRpY3VsYXIgc3RyZWFtIG9uIHRoaXMgbG9nZ2VyLlxuICpcbiAqIEdldCBVc2FnZTpcbiAqICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGxldmVscyBvZiBlYWNoIHN0cmVhbS5cbiAqICAgIGxvZy5sZXZlbHMoKSAtPiBbVFJBQ0UsIElORk9dXG4gKlxuICogICAgLy8gUmV0dXJucyBhIGxldmVsIG9mIHRoZSBpZGVudGlmaWVkIHN0cmVhbS5cbiAqICAgIGxvZy5sZXZlbHMoMCkgLT4gVFJBQ0UgICAgICAvLyBsZXZlbCBvZiBzdHJlYW0gYXQgaW5kZXggMFxuICogICAgbG9nLmxldmVscygnZm9vJykgICAgICAgICAgIC8vIGxldmVsIG9mIHN0cmVhbSB3aXRoIG5hbWUgJ2ZvbydcbiAqXG4gKiBTZXQgVXNhZ2U6XG4gKiAgICBsb2cubGV2ZWxzKDAsIElORk8pICAgICAgICAgLy8gc2V0IGxldmVsIG9mIHN0cmVhbSAwIHRvIElORk9cbiAqICAgIGxvZy5sZXZlbHMoMCwgJ2luZm8nKSAgICAgICAvLyBjYW4gdXNlICdpbmZvJyBldCBhbCBhbGlhc2VzXG4gKiAgICBsb2cubGV2ZWxzKCdmb28nLCBXQVJOKSAgICAgLy8gc2V0IHN0cmVhbSBuYW1lZCAnZm9vJyB0byBXQVJOXG4gKlxuICogU3RyZWFtIG5hbWVzOiBXaGVuIHN0cmVhbXMgYXJlIGRlZmluZWQsIHRoZXkgY2FuIG9wdGlvbmFsbHkgYmUgZ2l2ZW5cbiAqIGEgbmFtZS4gRm9yIGV4YW1wbGUsXG4gKiAgICAgICBsb2cgPSBuZXcgTG9nZ2VyKHtcbiAqICAgICAgICAgc3RyZWFtczogW1xuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgIG5hbWU6ICdmb28nLFxuICogICAgICAgICAgICAgcGF0aDogJy92YXIvbG9nL215LXNlcnZpY2UvZm9vLmxvZydcbiAqICAgICAgICAgICAgIGxldmVsOiAndHJhY2UnXG4gKiAgICAgICAgICAgfSxcbiAqICAgICAgICAgLi4uXG4gKlxuICogQHBhcmFtIG5hbWUge1N0cmluZ3xOdW1iZXJ9IFRoZSBzdHJlYW0gaW5kZXggb3IgbmFtZS5cbiAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfFN0cmluZ30gVGhlIGxldmVsIHZhbHVlIChJTkZPKSBvciBhbGlhcyAoJ2luZm8nKS5cbiAqICAgIElmIG5vdCBnaXZlbiwgdGhpcyBpcyBhICdnZXQnIG9wZXJhdGlvbi5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBubyBzdHJlYW0gd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5sZXZlbHMgPSBmdW5jdGlvbiBsZXZlbHMobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbXMubWFwKFxuICAgICAgICAgICAgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcy5sZXZlbDtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgc3RyZWFtO1xuICAgIGlmICh0eXBlb2YgKG5hbWUpID09PSAnbnVtYmVyJykge1xuICAgICAgICBzdHJlYW0gPSB0aGlzLnN0cmVhbXNbbmFtZV07XG4gICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0cmVhbSBpbmRleDogJyArIG5hbWUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zdHJlYW1zW2ldO1xuICAgICAgICAgICAgaWYgKHMubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbSA9IHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXQoJ25vIHN0cmVhbSB3aXRoIG5hbWUgXCIlc1wiJywgbmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0ubGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5ld0xldmVsID0gcmVzb2x2ZUxldmVsKHZhbHVlKTtcbiAgICAgICAgc3RyZWFtLmxldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgIGlmIChuZXdMZXZlbCA8IHRoaXMuX2xldmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKipcbiAqIEFwcGx5IHJlZ2lzdGVyZWQgc2VyaWFsaXplcnMgdG8gdGhlIGFwcHJvcHJpYXRlIGtleXMgaW4gdGhlIGdpdmVuIGZpZWxkcy5cbiAqXG4gKiBQcmUtY29uZGl0aW9uOiBUaGlzIGlzIG9ubHkgY2FsbGVkIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBzZXJpYWxpemVyLlxuICpcbiAqIEBwYXJhbSBmaWVsZHMgKE9iamVjdCkgVGhlIGxvZyByZWNvcmQgZmllbGRzLlxuICogQHBhcmFtIGV4Y2x1ZGVGaWVsZHMgKE9iamVjdCkgT3B0aW9uYWwgbWFwcGluZyBvZiBrZXlzIHRvIGB0cnVlYCBmb3JcbiAqICAgIGtleXMgdG8gTk9UIGFwcGx5IGEgc2VyaWFsaXplci5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS5fYXBwbHlTZXJpYWxpemVycyA9IGZ1bmN0aW9uIChmaWVsZHMsIGV4Y2x1ZGVGaWVsZHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBDaGVjayBlYWNoIHNlcmlhbGl6ZXIgYWdhaW5zdCB0aGVzZSAocHJlc3VtaW5nIG51bWJlciBvZiBzZXJpYWxpemVyc1xuICAgIC8vIGlzIHR5cGljYWxseSBsZXNzIHRoYW4gbnVtYmVyIG9mIGZpZWxkcykuXG4gICAgT2JqZWN0LmtleXModGhpcy5zZXJpYWxpemVycykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoZmllbGRzW25hbWVdID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIChleGNsdWRlRmllbGRzICYmIGV4Y2x1ZGVGaWVsZHNbbmFtZV0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpZWxkc1tuYW1lXSA9IHNlbGYuc2VyaWFsaXplcnNbbmFtZV0oZmllbGRzW25hbWVdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfd2Fybihmb3JtYXQoJ2J1bnlhbjogRVJST1I6IEV4Y2VwdGlvbiB0aHJvd24gZnJvbSB0aGUgXCIlc1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAnQnVueWFuIHNlcmlhbGl6ZXIuIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gVGhpcyBpcyBhIGJ1ZycgK1xuICAgICAgICAgICAgICAgICAgICAnaW4gdGhhdCBzZXJpYWxpemVyIGZ1bmN0aW9uLlxcbiVzJyxcbiAgICAgICAgICAgICAgICBuYW1lLCBlcnIuc3RhY2sgfHwgZXJyKSk7XG4gICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSBmb3JtYXQoJyhFcnJvciBpbiBCdW55YW4gbG9nIFwiJXNcIiBzZXJpYWxpemVyIGJyb2tlIGZpZWxkLiBTZWUgc3RkZXJyIGZvciBkZXRhaWxzLiknLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIEVtaXQgYSBsb2cgcmVjb3JkLlxuICpcbiAqIEBwYXJhbSByZWMge2xvZyByZWNvcmR9XG4gKiBAcGFyYW0gbm9lbWl0IHtCb29sZWFufSBPcHRpb25hbC4gU2V0IHRvIHRydWUgdG8gc2tpcCBlbWlzc2lvblxuICogICAgICBhbmQganVzdCByZXR1cm4gdGhlIEpTT04gc3RyaW5nLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLl9lbWl0ID0gZnVuY3Rpb24gKHJlYywgbm9lbWl0KSB7XG4gICAgdmFyIGk7XG5cbiAgICAvLyBMYXppbHkgZGV0ZXJtaW5lIGlmIHRoaXMgTG9nZ2VyIGhhcyBub24tJ3Jhdycgc3RyZWFtcy4gSWYgdGhlcmUgYXJlXG4gICAgLy8gYW55LCB0aGVuIHdlIG5lZWQgdG8gc3RyaW5naWZ5IHRoZSBsb2cgcmVjb3JkLlxuICAgIGlmICh0aGlzLmhhdmVOb25SYXdTdHJlYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5oYXZlTm9uUmF3U3RyZWFtcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RyZWFtc1tpXS5yYXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhdmVOb25SYXdTdHJlYW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0cmluZ2lmeSB0aGUgb2JqZWN0LiBBdHRlbXB0IHRvIHdhcm4vcmVjb3ZlciBvbiBlcnJvci5cbiAgICB2YXIgc3RyO1xuICAgIGlmIChub2VtaXQgfHwgdGhpcy5oYXZlTm9uUmF3U3RyZWFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RyID0gSlNPTi5zdHJpbmdpZnkocmVjLCBzYWZlQ3ljbGVzKCkpICsgJ1xcbic7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBkZWR1cEtleSA9IGUuc3RhY2suc3BsaXQoL1xcbi9nLCAyKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIF93YXJuKCdidW55YW46IEVSUk9SOiBFeGNlcHRpb24gaW4gJyArXG4gICAgICAgICAgICAgICAgICAgICdgSlNPTi5zdHJpbmdpZnkocmVjKWAuIFlvdSBjYW4gaW5zdGFsbCB0aGUgJyArXG4gICAgICAgICAgICAgICAgICAgICdcInNhZmUtanNvbi1zdHJpbmdpZnlcIiBtb2R1bGUgdG8gaGF2ZSBCdW55YW4gZmFsbGJhY2sgJyArXG4gICAgICAgICAgICAgICAgICAgICd0byBzYWZlciBzdHJpbmdpZmljYXRpb24uIFJlY29yZDpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgX2luZGVudChmb3JtYXQoJyVzXFxuJXMnLCByZWMsIGUuc3RhY2spKSxcbiAgICAgICAgICAgICAgICBkZWR1cEtleSk7XG4gICAgICAgICAgICBzdHIgPSBmb3JtYXQoJyhFeGNlcHRpb24gaW4gSlNPTi5zdHJpbmdpZnkocmVjKTogJWouIFNlZSBzdGRlcnIgZm9yIGRldGFpbHMuKVxcbicsIGUubWVzc2FnZSk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2VtaXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cblxuICAgIHZhciBsZXZlbCA9IHJlYy5sZXZlbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5zdHJlYW1zW2ldO1xuICAgICAgICBpZiAocy5sZXZlbCA8PSBsZXZlbCkge1xuICAgICAgICAgICAgcy5zdHJlYW0ud3JpdGUocy5yYXcgPyByZWMgOiBzdHIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbn07XG5cblxuLyoqXG4gKiBCdWlsZCBhIGxvZyBlbWl0dGVyIGZ1bmN0aW9uIGZvciBsZXZlbCBtaW5MZXZlbC4gSS5lLiB0aGlzIGlzIHRoZVxuICogY3JlYXRvciBvZiBgbG9nLmluZm9gLCBgbG9nLmVycm9yYCwgZXRjLlxuICovXG5mdW5jdGlvbiBta0xvZ0VtaXR0ZXIobWluTGV2ZWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9nID0gdGhpcztcblxuICAgICAgICBmdW5jdGlvbiBta1JlY29yZChhcmdzKSB7XG4gICAgICAgICAgICB2YXIgZXhjbHVkZUZpZWxkcztcbiAgICAgICAgICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBgbG9nLjxsZXZlbD4oZXJyLCAuLi4pYFxuICAgICAgICAgICAgICAgIGZpZWxkcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoaXMgTG9nZ2VyJ3MgZXJyIHNlcmlhbGl6ZXIsIGlmIGRlZmluZWQuXG4gICAgICAgICAgICAgICAgICAgIGVycjogKGxvZy5zZXJpYWxpemVycyAmJiBsb2cuc2VyaWFsaXplcnMuZXJyID8gbG9nLnNlcmlhbGl6ZXJzLmVycihhcmdzWzBdKSA6IExvZ2dlci5zdGRTZXJpYWxpemVycy5lcnIoYXJnc1swXSkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBleGNsdWRlRmllbGRzID0ge2VycjogdHJ1ZX07XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZ0FyZ3MgPSBbZmllbGRzLmVyci5tZXNzYWdlXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtc2dBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKGFyZ3NbMF0pICE9PSAnb2JqZWN0JyAmJiBhcmdzWzBdICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgIC8vIGBsb2cuPGxldmVsPihtc2csIC4uLilgXG4gICAgICAgICAgICAgICAgZmllbGRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBtc2dBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgICAgICAgICB9IGVsc2UgeyAgLy8gYGxvZy48bGV2ZWw+KGZpZWxkcywgbXNnLCAuLi4pYFxuICAgICAgICAgICAgICAgIGZpZWxkcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgbXNnQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCdWlsZCB1cCB0aGUgcmVjb3JkIG9iamVjdC5cbiAgICAgICAgICAgIHZhciByZWMgPSBvYmpDb3B5KGxvZy5maWVsZHMpO1xuICAgICAgICAgICAgcmVjLmxldmVsID0gbWluTGV2ZWw7XG4gICAgICAgICAgICB2YXIgcmVjRmllbGRzID0gKGZpZWxkcyA/IG9iakNvcHkoZmllbGRzKSA6IG51bGwpO1xuICAgICAgICAgICAgaWYgKHJlY0ZpZWxkcykge1xuICAgICAgICAgICAgICAgIGlmIChsb2cuc2VyaWFsaXplcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLl9hcHBseVNlcmlhbGl6ZXJzKHJlY0ZpZWxkcywgZXhjbHVkZUZpZWxkcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlY0ZpZWxkcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgICAgICByZWNba10gPSByZWNGaWVsZHNba107XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWMubGV2ZWxOYW1lID0gbmFtZUZyb21MZXZlbFttaW5MZXZlbF07XG4gICAgICAgICAgICByZWMubXNnID0gZm9ybWF0LmFwcGx5KGxvZywgbXNnQXJncyk7XG4gICAgICAgICAgICBpZiAoIXJlYy50aW1lKSB7XG4gICAgICAgICAgICAgICAgcmVjLnRpbWUgPSAobmV3IERhdGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgY2FsbCBzb3VyY2UgaW5mb1xuICAgICAgICAgICAgaWYgKGxvZy5zcmMgJiYgIXJlYy5zcmMpIHtcbiAgICAgICAgICAgICAgICByZWMuc3JjID0gZ2V0Q2FsbGVyM0luZm8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYy52ID0gTE9HX1ZFUlNJT047XG5cbiAgICAgICAgICAgIHJldHVybiByZWM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmllbGRzID0gbnVsbDtcbiAgICAgICAgdmFyIG1zZ0FyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHZhciByZWMgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuX2VtaXQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBTaG93IHRoaXMgaW52YWxpZCBCdW55YW4gdXNhZ2Ugd2FybmluZyAqb25jZSouXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU2VlIDxodHRwczovL2dpdGh1Yi5jb20vdHJlbnRtL25vZGUtYnVueWFuL2lzc3Vlcy8xMDA+IGZvclxuICAgICAgICAgICAgICogYW4gZXhhbXBsZSBvZiBob3cgdGhpcyBjYW4gaGFwcGVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgZGVkdXBLZXkgPSAndW5ib3VuZCc7XG4gICAgICAgICAgICBpZiAoIV9oYXZlV2FybmVkW2RlZHVwS2V5XSkge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsZXIgPSBnZXRDYWxsZXIzSW5mbygpO1xuICAgICAgICAgICAgICAgIF93YXJuKGZvcm1hdCgnYnVueWFuIHVzYWdlIGVycm9yOiAlczolczogYXR0ZW1wdCB0byBsb2cgd2l0aCBhbiB1bmJvdW5kIGxvZyBtZXRob2Q6IGB0aGlzYCBpczogJXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVyLmZpbGUsIGNhbGxlci5saW5lLCB0aGlzLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgICAgICBkZWR1cEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgeyAgIC8vIGBsb2cuPGxldmVsPigpYFxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9sZXZlbCA8PSBtaW5MZXZlbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbGV2ZWwgPiBtaW5MZXZlbCkge1xuICAgICAgICAgICAgLyogcGFzcyB0aHJvdWdoICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWMgPSBta1JlY29yZChtc2dBcmdzKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQocmVjKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb25zIGJlbG93IGxvZyBhIHJlY29yZCBhdCBhIHNwZWNpZmljIGxldmVsLlxuICpcbiAqIFVzYWdlczpcbiAqICAgIGxvZy48bGV2ZWw+KCkgIC0+IGJvb2xlYW4gaXMtdHJhY2UtZW5hYmxlZFxuICogICAgbG9nLjxsZXZlbD4oPEVycm9yPiBlcnIsIFs8c3RyaW5nPiBtc2csIC4uLl0pXG4gKiAgICBsb2cuPGxldmVsPig8c3RyaW5nPiBtc2csIC4uLilcbiAqICAgIGxvZy48bGV2ZWw+KDxvYmplY3Q+IGZpZWxkcywgPHN0cmluZz4gbXNnLCAuLi4pXG4gKlxuICogd2hlcmUgPGxldmVsPiBpcyB0aGUgbG93ZXJjYXNlIHZlcnNpb24gb2YgdGhlIGxvZyBsZXZlbC4gRS5nLjpcbiAqXG4gKiAgICBsb2cuaW5mbygpXG4gKlxuICogQHBhcmFtcyBmaWVsZHMge09iamVjdH0gT3B0aW9uYWwgc2V0IG9mIGFkZGl0aW9uYWwgZmllbGRzIHRvIGxvZy5cbiAqIEBwYXJhbXMgbXNnIHtTdHJpbmd9IExvZyBtZXNzYWdlLiBUaGlzIGNhbiBiZSBmb2xsb3dlZCBieSBhZGRpdGlvbmFsXG4gKiAgICBhcmd1bWVudHMgdGhhdCBhcmUgaGFuZGxlZCBsaWtlXG4gKiAgICBbdXRpbC5mb3JtYXRdKGh0dHA6Ly9ub2RlanMub3JnL2RvY3MvbGF0ZXN0L2FwaS9hbGwuaHRtbCN1dGlsLmZvcm1hdCkuXG4gKi9cbkxvZ2dlci5wcm90b3R5cGUudHJhY2UgPSBta0xvZ0VtaXR0ZXIoVFJBQ0UpO1xuTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IG1rTG9nRW1pdHRlcihERUJVRyk7XG5Mb2dnZXIucHJvdG90eXBlLmluZm8gPSBta0xvZ0VtaXR0ZXIoSU5GTyk7XG5Mb2dnZXIucHJvdG90eXBlLndhcm4gPSBta0xvZ0VtaXR0ZXIoV0FSTik7XG5Mb2dnZXIucHJvdG90eXBlLmVycm9yID0gbWtMb2dFbWl0dGVyKEVSUk9SKTtcbkxvZ2dlci5wcm90b3R5cGUuZmF0YWwgPSBta0xvZ0VtaXR0ZXIoRkFUQUwpO1xuXG5cbi8vLS0tLSBTdGFuZGFyZCBzZXJpYWxpemVyc1xuLy8gQSBzZXJpYWxpemVyIGlzIGEgZnVuY3Rpb24gdGhhdCBzZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBvYmplY3QgdG8gYVxuLy8gSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgbG9nZ2luZy4gVGhlcmUgaXMgYSBzdGFuZGFyZCBzZXQgb2YgcHJlc3VtZWRcbi8vIGludGVyZXN0aW5nIG9iamVjdHMgaW4gbm9kZS5qcy1sYW5kLlxuXG5Mb2dnZXIuc3RkU2VyaWFsaXplcnMgPSB7fTtcblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gZHVtcHMgbG9uZyBzdGFjayB0cmFjZXMgZm9yIGV4Y2VwdGlvbnMgaGF2aW5nIGEgY2F1c2UoKVxuICogbWV0aG9kLiBUaGUgZXJyb3IgY2xhc3NlcyBmcm9tXG4gKiBbdmVycm9yXShodHRwczovL2dpdGh1Yi5jb20vZGF2ZXBhY2hlY28vbm9kZS12ZXJyb3IpIGFuZFxuICogW3Jlc3RpZnkgdjIuMF0oaHR0cHM6Ly9naXRodWIuY29tL21jYXZhZ2Uvbm9kZS1yZXN0aWZ5KSBhcmUgZXhhbXBsZXMuXG4gKlxuICogQmFzZWQgb24gYGR1bXBFeGNlcHRpb25gIGluXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGF2ZXBhY2hlY28vbm9kZS1leHRzcHJpbnRmL2Jsb2IvbWFzdGVyL2xpYi9leHRzcHJpbnRmLmpzXG4gKi9cbmZ1bmN0aW9uIGdldEZ1bGxFcnJvclN0YWNrKGV4KSB7XG4gICAgdmFyIHJldCA9IGV4LnN0YWNrIHx8IGV4LnRvU3RyaW5nKCk7XG4gICAgaWYgKGV4LmNhdXNlICYmIHR5cGVvZiAoZXguY2F1c2UpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjZXggPSBleC5jYXVzZSgpO1xuICAgICAgICBpZiAoY2V4KSB7XG4gICAgICAgICAgICByZXQgKz0gJ1xcbkNhdXNlZCBieTogJyArIGdldEZ1bGxFcnJvclN0YWNrKGNleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChyZXQpO1xufVxuXG4vLyBTZXJpYWxpemUgYW4gRXJyb3Igb2JqZWN0XG4vLyAoQ29yZSBlcnJvciBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlIGluIG5vZGUgMC40LCBub3QgaW4gMC42KS5cbkxvZ2dlci5zdGRTZXJpYWxpemVycy5lcnIgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoIWVyciB8fCAhZXJyLnN0YWNrKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgdmFyIG9iaiA9IHtcbiAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgIG5hbWU6IGVyci5uYW1lLFxuICAgICAgICBzdGFjazogZ2V0RnVsbEVycm9yU3RhY2soZXJyKSxcbiAgICAgICAgY29kZTogZXJyLmNvZGUsXG4gICAgICAgIHNpZ25hbDogZXJyLnNpZ25hbFxuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gQSBKU09OIHN0cmluZ2lmaWVyIHRoYXQgaGFuZGxlcyBjeWNsZXMgc2FmZWx5LlxuLy8gVXNhZ2U6IEpTT04uc3RyaW5naWZ5KG9iaiwgc2FmZUN5Y2xlcygpKVxuZnVuY3Rpb24gc2FmZUN5Y2xlcygpIHtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKCF2YWwgfHwgdHlwZW9mICh2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKHZhbCkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4ucHVzaCh2YWwpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG59XG5cbi8vLS0tLSBFeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0gTG9nZ2VyO1xuXG5tb2R1bGUuZXhwb3J0cy5UUkFDRSA9IFRSQUNFO1xubW9kdWxlLmV4cG9ydHMuREVCVUcgPSBERUJVRztcbm1vZHVsZS5leHBvcnRzLklORk8gPSBJTkZPO1xubW9kdWxlLmV4cG9ydHMuV0FSTiA9IFdBUk47XG5tb2R1bGUuZXhwb3J0cy5FUlJPUiA9IEVSUk9SO1xubW9kdWxlLmV4cG9ydHMuRkFUQUwgPSBGQVRBTDtcbm1vZHVsZS5leHBvcnRzLnJlc29sdmVMZXZlbCA9IHJlc29sdmVMZXZlbDtcbm1vZHVsZS5leHBvcnRzLmxldmVsRnJvbU5hbWUgPSBsZXZlbEZyb21OYW1lO1xubW9kdWxlLmV4cG9ydHMubmFtZUZyb21MZXZlbCA9IG5hbWVGcm9tTGV2ZWw7XG5cbm1vZHVsZS5leHBvcnRzLlZFUlNJT04gPSBWRVJTSU9OO1xubW9kdWxlLmV4cG9ydHMuTE9HX1ZFUlNJT04gPSBMT0dfVkVSU0lPTjtcblxubW9kdWxlLmV4cG9ydHMuY3JlYXRlTG9nZ2VyID0gZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IExvZ2dlcihvcHRpb25zKTtcbn07XG5cbi8vIFVzZWZ1bCBmb3IgY3VzdG9tIGB0eXBlID09ICdyYXcnYCBzdHJlYW1zIHRoYXQgbWF5IGRvIEpTT04gc3RyaW5naWZpY2F0aW9uXG4vLyBvZiBsb2cgcmVjb3JkcyB0aGVtc2VsdmVzLiBVc2FnZTpcbi8vICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShyZWMsIGJ1bnlhbi5zYWZlQ3ljbGVzKCkpO1xubW9kdWxlLmV4cG9ydHMuc2FmZUN5Y2xlcyA9IHNhZmVDeWNsZXM7XG5cbi8vc3RyZWFtc1xubW9kdWxlLmV4cG9ydHMuQ29uc29sZUZvcm1hdHRlZFN0cmVhbSA9IENvbnNvbGVGb3JtYXR0ZWRTdHJlYW07XG5tb2R1bGUuZXhwb3J0cy5Db25zb2xlUmF3U3RyZWFtID0gQ29uc29sZVJhd1N0cmVhbTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9icm93c2VyLWJ1bnlhbi9saWIvYnVueWFuLmpzXG4gKiogbW9kdWxlIGlkID0gMzAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgbmFtZUZyb21MZXZlbCB9IGZyb20gJ2Jyb3dzZXItYnVueWFuJ1xuXG5leHBvcnQgY2xhc3MgUmF3U3RyZWFtIHtcbiAgd3JpdGUgKHJlYykge1xuICAgIGNvbnNvbGUubG9nKCdbJXNdICVzOiAlcycsXG4gICAgICAvLyAgICAgICAgICAgICAgICByZWMudGltZS50b0lTT1N0cmluZygpLFxuICAgICAgcmVjLm5hbWUsXG4gICAgICBuYW1lRnJvbUxldmVsW3JlYy5sZXZlbF0sXG4gICAgICByZWMubXNnXG4gICAgKVxuICB9XG59XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2xvZy9idW55YW4td3JpdGVyLmpzXG4gKiovIiwiZXhwb3J0IGNvbnN0IGNvbW1vbiA9IE9iamVjdC5mcmVlemUoe1xuICBDT05ORUNUX1NVQ0NFU1M6ICdDb25uZWN0LlN1Y2Nlc3MnLFxuICBDT05ORUNUX0ZBSUxVUkU6ICdDb25uZWN0LkZhaWx1cmUnLFxuICBQVUJMSVNIX1NUQVJUOiAnUHVibGlzaC5TdGFydCcsXG4gIFBVQkxJU0hfRkFJTDogJ1B1Ymxpc2guRmFpbCcsXG4gIFBVQkxJU0hfSU5WQUxJRF9OQU1FOiAnUHVibGlzaC5JbnZhbGlkTmFtZScsXG4gIFVOUFVCTElTSF9TVUNDRVNTOiAnVW5wdWJsaXNoLlN1Y2Nlc3MnLFxuICBQVUJMSVNIX01FVEFEQVRBOiAnUHVibGlzaC5NZXRhZGF0YSdcbn0pXG5cbmV4cG9ydCBjb25zdCBmYWlsb3ZlciA9IE9iamVjdC5mcmVlemUoe1xuICBQVUJMSVNIRVJfUkVKRUNUOiAnUHVibGlzaGVyLlJlamVjdCcsXG4gIFBVQkxJU0hFUl9BQ0NFUFQ6ICdQdWJsaXNoZXIuQWNjZXB0J1xufSlcblxuZXhwb3J0IGNvbnN0IHJ0YyA9IE9iamVjdC5mcmVlemUoe1xuICBNRURJQV9TVFJFQU1fQVZBSUxBQkxFOiAnV2ViUlRDLk1lZGlhU3RyZWFtLkF2YWlsYWJsZScsXG4gIFBFRVJfQ09OTkVDVElPTl9BVkFJTEFCTEU6ICdXZWJSVEMuUGVlckNvbm5lY3Rpb24uQXZhaWxhYmxlJyxcbiAgT0ZGRVJfU1RBUlQ6ICdXZWJSVEMuT2ZmZXIuU3RhcnQnLFxuICBPRkZFUl9FTkQ6ICdXZWJSVEMuT2ZmZXIuRW5kJyxcbiAgSUNFX1RSSUNLTEVfQ09NUExFVEU6ICdXZWJSVEMuSWNlVHJpY2tsZS5Db21wbGV0ZSdcbn0pXG5cbmV4cG9ydCBjb25zdCBydG1wID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEVNQkVEX1NVQ0NFU1M6ICdGbGFzaFBsYXllci5FbWJlZC5TdWNjZXNzJyxcbiAgRU1CRURfRkFJTFVSRTogJ0ZsYXNoUGxheWVyLkVtYmVkLkZhaWx1cmUnXG59KVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvZXZlbnQvcHVibGlzaGVyLWV2ZW50LmpzXG4gKiovIiwiZXhwb3J0IGNvbnN0IGNvbW1vbiA9IE9iamVjdC5mcmVlemUoe1xuICBDT05ORUNUX1NVQ0NFU1M6ICdDb25uZWN0LlN1Y2Nlc3MnLFxuICBDT05ORUNUX0ZBSUxVUkU6ICdDb25uZWN0LkZhaWx1cmUnLFxuICBTVUJTQ1JJQkVfU1RBUlQ6ICdTdWJzY3JpYmUuU3RhcnQnLFxuICBTVUJTQ1JJQkVfU1RPUDogJ1N1YnNjcmliZS5TdG9wJyxcbiAgU1VCU0NSSUJFX0ZBSUw6ICdTdWJzY3JpYmUuRmFpbCcsXG4gIFNVQlNDUklCRV9JTlZBTElEX05BTUU6ICdTdWJzY3JpYmUuSW52YWxpZE5hbWUnLFxuICBTVUJTQ1JJQkVfTUVUQURBVEE6ICdTdWJzY3JpYmUuTWV0YWRhdGEnLFxuICBQTEFZX1VOUFVCTElTSDogJ1N1YnNjcmliZXIuUGxheS5VbnB1Ymxpc2gnLFxuICBDT05ORUNUSU9OX0NMT1NFRDogJ1N1YnNjcmliZXIuQ29ubmVjdGlvbi5DbG9zZWQnXG59KVxuXG5leHBvcnQgY29uc3QgZmFpbG92ZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgU1VCU0NSSUJFUl9SRUpFQ1Q6ICdTdWJzY3JpYmVyLlJlamVjdCcsXG4gIFNVQlNDUklCRVJfQUNDRVBUOiAnU3Vic2NyaWJlci5BY2NlcHQnXG59KVxuXG5leHBvcnQgY29uc3QgcnRjID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFBFRVJfQ09OTkVDVElPTl9BVkFJTEFCTEU6ICdXZWJSVEMuUGVlckNvbm5lY3Rpb24uQXZhaWxhYmxlJyxcbiAgT0ZGRVJfU1RBUlQ6ICdXZWJSVEMuT2ZmZXIuU3RhcnQnLFxuICBPRkZFUl9FTkQ6ICdXZWJSVEMuT2ZmZXIuRW5kJyxcbiAgQU5TV0VSX1NUQVJUOiAnV2ViUlRDLkFuc3dlci5TdGFydCcsXG4gIEFOU1dFUl9FTkQ6ICdXZWJSVEMuQW5zd2VyLkVuZCcsXG4gIENBTkRJREFURV9TVEFSVDogJ1dlYlJUQy5DYW5kaWRhdGUuU3RhcnQnLFxuICBDQU5ESURBVEVfRU5EOiAnV2ViUlRDLkNhbmRpZGF0ZS5FbmQnLFxuICBJQ0VfVFJJQ0tMRV9DT01QTEVURTogJ1dlYlJUQy5JY2VUcmlja2xlLkNvbXBsZXRlJ1xufSlcblxuZXhwb3J0IGNvbnN0IHJ0bXAgPSBPYmplY3QuZnJlZXplKHtcbiAgRU1CRURfU1VDQ0VTUzogJ0ZsYXNoUGxheWVyLkVtYmVkLlN1Y2Nlc3MnLFxuICBFTUJFRF9GQUlMVVJFOiAnRmxhc2hQbGF5ZXIuRW1iZWQuRmFpbHVyZSdcbn0pXG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2V2ZW50L3N1YnNjcmliZXItZXZlbnQuanNcbiAqKi8iLCJleHBvcnQgY29uc3QgY29tbW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENPTk5FQ1RfU1VDQ0VTUzogJ0Nvbm5lY3QuU3VjY2VzcycsXG4gIENPTk5FQ1RfRkFJTFVSRTogJ0Nvbm5lY3QuRmFpbHVyZScsXG4gIFBST1BFUlRZX1VQREFURTogJ1NoYXJlZE9iamVjdC5Qcm9wZXJ0eVVwZGF0ZScsXG4gIE1FVEhPRF9VUERBVEU6ICdTaGFyZWRPYmplY3QuTWV0aG9kVXBkYXRlJ1xufSlcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvZXZlbnQvc2hhcmVkb2JqZWN0LWV2ZW50LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydCBjb25zdCBQbGF5YmFja1R5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFJUTVA6ICdydG1wJyxcbiAgUlRDOiAncnRjJyxcbiAgSExTOiAnaGxzJ1xufSlcblxuZXhwb3J0IGNvbnN0IFBsYXliYWNrQXVkaW9FbmNvZGVyID0gT2JqZWN0LmZyZWV6ZSh7XG4gIE9QVVM6ICdPcHVzJyxcbiAgUENNVTogJ1BDTVUnLFxuICBQQ01BOiAnUENNQScsXG4gIFNQRUVYOiAnU3BlZXgnLFxuICBOT05FOiAnTk9ORSdcbn0pXG5cbmV4cG9ydCBjb25zdCBQbGF5YmFja1ZpZGVvRW5jb2RlciA9IE9iamVjdC5mcmVlemUoe1xuICBWUDg6ICdWUDgnLFxuICBIMjY0OiAnSDI2NCcsXG4gIE5PTkU6ICdOT05FJ1xufSlcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2VudW0vcGxheWJhY2suanNcbiAqKi8iLCIvKipcbiAqIE1haW4gZW50cnkgZm9yIGZhaWxvdmVyIHN1cHBvcnQgb2YgYWxsIHN1YnNjcmliZXIgaW1wbGVtZW50YXRpb25zLlxuICovXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgUlRDU3Vic2NyaWJlciBmcm9tICcuL3JlZDVwcm8tcnRjJ1xuaW1wb3J0IEhMU1N1YnNjcmliZXIgZnJvbSAnLi9yZWQ1cHJvLWhscydcbmltcG9ydCBSVE1QU3Vic2NyaWJlclByb3h5IGZyb20gJy4vcmVkNXByby1ydG1wJ1xuaW1wb3J0IFI1TGl2ZVN1YnNjcmliZXIgZnJvbSAnLi9yZWQ1cHJvLXJ0bXAtbGl2ZSdcbmltcG9ydCBWaWRlb0pTU3Vic2NyaWJlciBmcm9tICcuL3JlZDVwcm8tcnRtcC12aWRlb2pzJ1xuXG5pbXBvcnQgSW1wbEZhY3RvcnlPcmRlciBmcm9tICcuLi91dGlsL2ltcGwtZmFjdG9yeS1vcmRlcidcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IFBsYXliYWNrVHlwZXMgfSBmcm9tICcuLi9lbnVtL3BsYXliYWNrJ1xuaW1wb3J0IHsgZGVidWcsIHdhcm4gfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9TdWJzY3JpYmVyJ1xuY29uc3QgcGxheWJhY2tGYWN0b3J5ID0gbmV3IEltcGxGYWN0b3J5T3JkZXIoKVxuXG5jb25zdCBwbGF5YmFja0ltcGwgPSAoZnVuY3Rpb24gKCkge1xuICBsZXQgbWFwID0gbmV3IE1hcCgpXG4gIG1hcC5zZXQoUGxheWJhY2tUeXBlcy5SVE1QLCBSVE1QU3Vic2NyaWJlclByb3h5KVxuICBtYXAuc2V0KFBsYXliYWNrVHlwZXMuUlRDLCBSVENTdWJzY3JpYmVyKVxuICBtYXAuc2V0KFBsYXliYWNrVHlwZXMuSExTLCBITFNTdWJzY3JpYmVyKVxuICByZXR1cm4gbWFwXG59KCkpXG5cbmNsYXNzIFJlZDVQcm9TdWJzY3JpYmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIC8vIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICAvLyBUaGUgcGxheWJhY2sgdmlld1xuICAgIHRoaXMuX3ZpZXcgPSB1bmRlZmluZWRcbiAgICAvLyBTZWxlY3RlZCBmYWlsb3ZlciBzdWJzY3JpYmVyLlxuICAgIHRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyID0gdW5kZWZpbmVkXG4gICAgLy8gRGVmYXVsdCBvcmRlci5cbiAgICB0aGlzLl9vcmRlciA9IFtcbiAgICAgIFBsYXliYWNrVHlwZXMuUlRNUCxcbiAgICAgIFBsYXliYWNrVHlwZXMuUlRDLFxuICAgICAgUGxheWJhY2tUeXBlcy5ITFNcbiAgICBdXG4gICAgdGhpcy5fYm91bmRCdWJibGVTdWJzY3JpYmVyRXZlbnQgPSB0aGlzLmJ1YmJsZVN1YnNjcmliZXJFdmVudC5iaW5kKHRoaXMpXG4gIH1cblxuICBnZXRQbGF5YmFja09yZGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JkZXJcbiAgfVxuXG4gIHNldFBsYXliYWNrT3JkZXIgKG9yZGVyKSB7XG4gICAgLy8gQWxsb3cgZm9yIHN0cmluZyB2YWx1ZSB0byBkZWZpbmUgc2luZ2xlIGl0ZW0gaW4gb3JkZXIuXG4gICAgb3JkZXIgPSB0eXBlb2Ygb3JkZXIgPT09ICdzdHJpbmcnID8gW29yZGVyXSA6IG9yZGVyXG5cbiAgICAvLyBGaWx0ZXIgb3V0IHZhbHVlcyBub3QgYXZhaWxhYmxlIGluIGVudW1lcmF0aW9uIG9mIHBsYXliYWNrIHR5cGVzLlxuICAgIGNvbnN0IHQgPSBvcmRlci5maWx0ZXIoZW50cnkgPT4ge1xuICAgICAgbGV0IGtleVxuICAgICAgZm9yIChrZXkgaW4gUGxheWJhY2tUeXBlcykge1xuICAgICAgICBpZiAoUGxheWJhY2tUeXBlc1trZXldLnRvTG93ZXJDYXNlKCkgPT09IGVudHJ5LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9KS5tYXAoZW50cnkgPT4gZW50cnkudG9Mb3dlckNhc2UoKSlcblxuICAgIC8vIERlZmluZSBuZXcgb3JkZXIuXG4gICAgdGhpcy5fb3JkZXIgPSBbLi4ubmV3IFNldCh0KV1cbiAgICBkZWJ1ZyhOQU1FLCBgW29yZGVydXBkYXRlXTogJHt0aGlzLl9vcmRlcn1gKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzZXRWaWV3IChwbGF5YmFja1ZpZXcpIHtcbiAgICB0aGlzLl92aWV3ID0gcGxheWJhY2tWaWV3XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldFBsYXliYWNrRnJvbU9yZGVyIChvcmRlciwgb3B0aW9ucykge1xuICAgIHJldHVybiBwbGF5YmFja0ZhY3RvcnkuY3JlYXRlKG9yZGVyLCBwbGF5YmFja0ltcGwsIG9wdGlvbnMsICdpbml0JylcbiAgfVxuXG4gIGluaXQgKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgZGVidWcoTkFNRSwgJ1twbGF5XScpXG4gICAgdGhpcy5nZXRQbGF5YmFja0Zyb21PcmRlcih0aGlzLl9vcmRlciwgdGhpcy5fb3B0aW9ucylcbiAgICAgIC50aGVuKHN1YnNjcmliZXIgPT4ge1xuICAgICAgICBkZWJ1ZyhOQU1FLCBgW3BsYXlzdWNjZXNzXTogc3Vic2NyaWJlciBmb3VuZCAke3N1YnNjcmliZXIuZ2V0VHlwZSgpfWApXG4gICAgICAgIHN1YnNjcmliZXIub24oJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudClcbiAgICAgICAgdGhpcy5fY3VycmVudFN1YnNjcmliZXIgPSBzdWJzY3JpYmVyXG4gICAgICAgIGlmICh0aGlzLl92aWV3KSB7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFN1YnNjcmliZXIuc2V0Vmlldyh0aGlzLl92aWV3KVxuICAgICAgICB9XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodGhpcy5fY3VycmVudFN1YnNjcmliZXIpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHdhcm4oTkFNRSwgYFtwbGF5ZXJyb3JdOiBDb3VsZCBub3QgaW1wbGVtZW50IGEgc3Vic2NyaWJlcjogJHtlcnJ9YClcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycilcbiAgICAgIH0pXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIHN0b3AgKCkge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgaWYgKCF0aGlzLl9jdXJyZW50U3Vic2NyaWJlcikge1xuICAgICAgd2FybihOQU1FLCAnW3N0b3BdOiBDb3VsZCBub3QgaW52b2tlIHN0b3AoKSBvbiB1bmRlZmluZWQgc3Vic2NyaWJlci4nKVxuICAgICAgZGVmZXJyZWQucmVqZWN0KCdBIGN1cnJlbnQgc3Vic2NyaWJlciBpcyBub3QgYXZhaWxhYmxlIHRvIGlzc3VlIGEgOnN0b3AoKSBjb21tYW5kIHRvLicpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKE5BTUUsICdbc3RvcF06IEludm9raW5nIHN0b3Agb24gaGVsZCBzdWJzY3JpYmVyLicpXG4gICAgICB0aGlzLl9jdXJyZW50U3Vic2NyaWJlci5zdG9wKClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGRlYnVnKE5BTUUsICdbc3RvcHN1Y2Nlc3NdJylcbiAgICAgICAgICB0aGlzLl9jdXJyZW50U3Vic2NyaWJlci5vZmYoJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudClcbiAgICAgICAgICB0aGlzLl9jdXJyZW50U3Vic2NyaWJlciA9IHVuZGVmaW5lZFxuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBkZWJ1ZyhOQU1FLCBgW3N0b3BlcnJvcl06ICR7ZXJyfWApXG4gICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3Vic2NyaWJlci5vZmYoJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudClcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY3VycmVudFN1YnNjcmliZXIgPSB1bmRlZmluZWRcbiAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKVxuICAgICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgYnViYmxlU3Vic2NyaWJlckV2ZW50IChzdWJzY3JpYmVyRXZlbnQpIHtcbiAgICB0aGlzLnRyaWdnZXIuY2FsbCh0aGlzLCBzdWJzY3JpYmVyRXZlbnQpXG4gIH1cblxuICBnZXQgcGxheWJhY2tUeXBlcyAoKSB7XG4gICAgcmV0dXJuIFBsYXliYWNrVHlwZXNcbiAgfVxuXG4gIGdldCBjdXJyZW50U3Vic2NyaWJlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyXG4gIH1cblxufVxuXG5leHBvcnQgeyBSZWQ1UHJvU3Vic2NyaWJlciwgUlRDU3Vic2NyaWJlciwgSExTU3Vic2NyaWJlciwgVmlkZW9KU1N1YnNjcmliZXIsIFI1TGl2ZVN1YnNjcmliZXIgfVxuLyoqXG4gKiBVc2luZyB0aGUgUlRNUFN1YnNjcmliZXIgd2lsbCBkZXRlcm1pbmUgdGhlIFJUTVAtYmFzZWQgU3Vic2NyaWJlclxuICogdG8gYmUgdXNlZCBiYXNlZCBvbiBgb3B0aW9ucy51c2VWaWRlb0pTYCBwcm9wZXJ0eS5cbiAqXG4gKiBJZiBgb3B0aW9ucy51c2VWaWRlb0pTYCBpcyBsZWZ0IHVuZGVmaW5lZCwgaXQgd2lsbCBkZWZhdWx0IHRvIGB0cnVlYFxuICogSWYgYG9wdGlvbnMudXNlVmlkZW9Kc2AgaXMgZGVmaW5lZCwgaXQgaXMgcmVxdWlyZWQgdG8gYmUgYSBib29sZWFuIHZhbHVlXG4gKlxuICogdHJ1ZTogVmlkZW9KU1N1YnNjcmliZXIgLSB1dGlsaXplcyB0aGUgdmlkZW9qcyBsaWIgYW5kIGN1c3RvbSBTV0YuXG4gKiBmYWxzZTogUjVMaXZlU3Vic2NyaWJlciAtIHV0aWxpemVkIHRoZSBkZWZhdWx0IFwibGl2ZVwiIFNXRiBzaGlwcGVkIHdpdGggUmVkNSBQcm8gZXhhbXBsZXMuXG4qL1xuZXhwb3J0IGNvbnN0IFJUTVBTdWJzY3JpYmVyID0gUlRNUFN1YnNjcmliZXJQcm94eVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvc3Vic2NyaWJlci9pbmRleC5qc1xuICoqLyIsImNvbnN0IFdJTERDQVJEID0gJyonXG5jb25zdCBXSUxEQ0FSRF9LRVkgPSAnUkVENVBSTydcblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge31cbiAgICB0aGlzLl9jYWxsYmFja3NbV0lMRENBUkRfS0VZXSA9IFtdXG4gIH1cblxuICBfbm90aWZ5IChjYWxsYmFja3MsIGV2ZW50KSB7XG4gICAgICBsZXQgaSwgbGVuZ3RoID0gY2FsbGJhY2tzLmxlbmd0aFxuICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldKGV2ZW50KVxuICAgICAgfVxuICB9XG5cbiAgb24gKHR5cGUsIGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFdJTERDQVJEKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3NbV0lMRENBUkRfS0VZXS5wdXNoKGZuKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3NbdHlwZV0gPSBbXVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jYWxsYmFja3NbdHlwZV0uaW5kZXhPZihmbikgPT09IC0xKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3NbdHlwZV0ucHVzaChmbilcbiAgICB9XG4gIH1cblxuICBvZmYgKHR5cGUsIGZuKSB7XG4gICAgbGV0IG1hcCA9IHRoaXMuX2NhbGxiYWNrc1t0eXBlXVxuICAgIGlmICh0eXBlID09PSBXSUxEQ0FSRCkge1xuICAgICAgbWFwID0gdGhpcy5fY2FsbGJhY2tzW1dJTERDQVJEX0tFWV1cbiAgICB9XG4gICAgaWYgKG1hcCkge1xuICAgICAgY29uc3QgaW5kZXggPSBtYXAuaW5kZXhPZihmbilcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgbWFwLnNwbGljZShpbmRleCwgMSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0cmlnZ2VyIChldmVudCkge1xuICAgIGNvbnN0IHR5cGUgPSBldmVudC50eXBlXG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrc1t0eXBlXSkge1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2NhbGxiYWNrc1t0eXBlXSwgZXZlbnQpXG4gICAgfVxuICAgIHRoaXMuX25vdGlmeSh0aGlzLl9jYWxsYmFja3NbV0lMRENBUkRfS0VZXSwgZXZlbnQpXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXJcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvY29yZS9ldmVudC1lbWl0dGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IHsgU3Vic2NyaWJlckV2ZW50IH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgU3Vic2NyaXB0aW9uU29ja2V0SGVscGVyIGZyb20gJy4uL2hlbHBlci9zb2NrZXQtaGVscGVyLXN1YidcbmltcG9ydCBTdWJzY3JpcHRpb25QZWVySGVscGVyIGZyb20gJy4uL2hlbHBlci93ZWJydGMtaGVscGVyLXN1YidcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCAqIGFzIHdlYnJ0YyBmcm9tICcuLi9hZGFwdGVyL3dlYnJ0YydcbmltcG9ydCAqIGFzIHdlYnNvY2tldCBmcm9tICcuLi9hZGFwdGVyL3dlYnNvY2tldCdcbmltcG9ydCB7IFN1YnNjcmliZXJFdmVudFR5cGVzLCBSVENTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50J1xuXG5pbXBvcnQgeyBkZWJ1Zywgd2FybiwgZXJyb3IgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9SVENTdWJzY3JpYmVyJ1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHN0cmVhbVR5cGU6ICd3ZWJydGMnXG59XG5jb25zdCBnZW5lcmF0ZVN1YnNjcmlwdGlvbklkID0gKCkgPT4ge1xuICBjb25zdCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDApLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gYHN1YnNjcmliZXItJHtpZH1gXG59XG5jb25zdCBlbmRwb2ludEZyb21PcHRpb25zID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcHJvdG9jb2wgPSBvcHRpb25zLndzcHJvdG9jb2wgfHwgb3B0aW9ucy5wcm90b2NvbFxuICBjb25zdCBwb3J0ID0gb3B0aW9ucy53c3BvcnQgfHwgb3B0aW9ucy5wb3J0XG4gIGNvbnN0IGFwcEVuZHBvaW50ID0gb3B0aW9ucy5jb250ZXh0ID8gW29wdGlvbnMuYXBwLCBvcHRpb25zLmNvbnRleHRdLmpvaW4oJy8nKSA6IG9wdGlvbnMuYXBwXG4gIGxldCBlbmRwb2ludCA9IGAke3Byb3RvY29sfTovLyR7b3B0aW9ucy5ob3N0fToke3BvcnR9LyR7YXBwRW5kcG9pbnR9P2lkPSR7b3B0aW9ucy5zdWJzY3JpcHRpb25JZH1gXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5jb25uZWN0aW9uUGFyYW1zICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxldCBwYXJhbXMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zLmNvbm5lY3Rpb25QYXJhbXMpLmZvckVhY2goIChrZXksIGluZGV4KSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHBhcmFtcy5wdXNoKFtrZXksIG9wdGlvbnMuY29ubmVjdGlvblBhcmFtc1trZXldXS5qb2luKCc9JykpXG4gICAgfSlcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGVuZHBvaW50ICs9ICcmJyArIChwYXJhbXMuam9pbignJicpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kcG9pbnRcbn1cblxuY2xhc3MgUlRDU3Vic2NyaWJlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fb3B0aW9ucyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3BlZXJIZWxwZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9IDBcbiAgfVxuXG4gIGluaXQgKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGlmICghd2VicnRjLmlzU3VwcG9ydGVkKCkgfHwgIXdlYnNvY2tldC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoJ0Nhbm5vdCBjcmVhdGUgV2ViUlRDIHBsYXliYWNrIGluc3RhbmNlLiBZb3VyIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgV2ViUlRDIGFuZC9vciBXZWJTb2NrZXRzLicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcbiAgICAgIHRoaXMuX29wdGlvbnMuc3Vic2NyaXB0aW9uSWQgPSB0aGlzLl9vcHRpb25zLnN1YnNjcmlwdGlvbklkIHx8IGdlbmVyYXRlU3Vic2NyaXB0aW9uSWQoKVxuICAgICAgdGhpcy5fcGVlckhlbHBlciA9IG5ldyBTdWJzY3JpcHRpb25QZWVySGVscGVyKHRoaXMpXG4gICAgICB0aGlzLl9zb2NrZXRIZWxwZXIgPSBuZXcgU3Vic2NyaXB0aW9uU29ja2V0SGVscGVyKHRoaXMpXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMpXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBzZXRWaWV3ICh2aWV3KSB7XG4gICAgdGhpcy5fdmlldyA9IHZpZXdcbiAgICAvLyAgVE9ETzogTm9ybWFsaXplIHJldHVybnMgdG8gZWl0aGVyIGFsbCBiZSBjaGFpbmFibGUgb3Igbm90IGJlIGNoYWluYWJsZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZXF1ZXN0QXZhaWxhYmlsaXR5IChzdHJlYW1OYW1lLCB0eXBlKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tyZXF1ZXN0YXZhaWxhYmlsaXR5XScpXG4gICAgLy8gbWVzc2FnZSBvbiBzb2NrZXQgcmV0dXJucyAtPiBvblN0cmVhbShVbilBdmFpbGFibGVcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBpc0F2YWlsYWJsZTogc3RyZWFtTmFtZSxcbiAgICAgIHR5cGU6IHR5cGVcbiAgICB9KVxuICAgIC8vICBUT0RPOiBOb3JtYWxpemUgcmV0dXJucyB0byBlaXRoZXIgYWxsIGJlIGNoYWluYWJsZSBvciBub3QgYmUgY2hhaW5hYmxlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJlcXVlc3RPZmZlciAoc3RyZWFtTmFtZSwgc3Vic2NyaXB0aW9uSWQsIHZFbmNvZGluZyA9IHVuZGVmaW5lZCwgYUVuY29kaW5nID0gdW5kZWZpbmVkKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tyZXF1ZXN0b2ZmZXJdJylcbiAgICBsZXQgb2ZmZXIgPSB7XG4gICAgICByZXF1ZXN0T2ZmZXI6IHN0cmVhbU5hbWUsXG4gICAgICByZXF1ZXN0SWQ6IHN1YnNjcmlwdGlvbklkXG4gICAgfVxuICAgIGlmICh0eXBlb2YgdkVuY29kaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb2ZmZXIudmlkZW9FbmNvZGluZyA9IHZFbmNvZGluZztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhRW5jb2RpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvZmZlci5hdWRpb0VuY29kaW5nID0gYUVuY29kaW5nO1xuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5PRkZFUl9TVEFSVCwgdGhpcykpXG4gICAgLy8gbWVzc2FnZSBvbiBzb2NrZXQgcmV0dXJucyAtPiBvblNEUE9mZmVyXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qob2ZmZXIpXG4gIH1cblxuICByZXF1ZXN0QW5zd2VyIChzZHApIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3JlcXVlc3RhbnN3ZXJdJylcbiAgICAvLyBpbnZva2VzIC0+IHNlbmRBbnN3ZXJcbiAgICB0aGlzLl9wZWVySGVscGVyLmNyZWF0ZUFuc3dlcihzZHApXG4gICAgICAgIC50aGVuKHNlc3Npb25EZXNjcmlwdGlvbiA9PiB7XG4gICAgICAgICAgZGVidWcoTkFNRSwgJ1tvbmFuc3dlcmNyZWF0ZWRdJylcbiAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5iYW5kd2lkdGgpIHtcbiAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbi5zZHAgPSB3ZWJydGMudXBkYXRlQmFuZHdpZHRoKHRoaXMuX29wdGlvbnMuYmFuZHdpZHRoLCBzZXNzaW9uRGVzY3JpcHRpb24uc2RwKVxuICAgICAgICAgIH1cbiAgICAgICAgICBkZWJ1ZyhOQU1FLCAnWz4gc2VuZGFuc3dlcl0nKVxuICAgICAgICAgIHRoaXMuc2VuZEFuc3dlcih0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsIHRoaXMuX29wdGlvbnMuc3Vic2NyaXB0aW9uSWQsIHNlc3Npb25EZXNjcmlwdGlvbilcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICB0aGlzLm9uU0RQRXJyb3IoZXJyb3IpXG4gICAgICAgIH0pXG4gIH1cblxuICBzZW5kQW5zd2VyIChzdHJlYW1OYW1lLCBzdWJzY3JpcHRpb25JZCwgc2RwKSB7XG4gICAgZGVidWcoTkFNRSwgYFtzZW5kYW5zd2VyXTogc3RyZWFtbmFtZSgke3N0cmVhbU5hbWV9KSwgc3Vic2NyaXB0aW9uaWQoJHtzdWJzY3JpcHRpb25JZH0pYClcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5BTlNXRVJfU1RBUlQsIHRoaXMsIHNkcCkpXG4gICAgLy8gbWVzc2FnZSBvbiBzb2NrZXQgcmVzcG9uc2UgLT4gb25BZGRJY2VDYW5kaWRhdGVcbiAgICAvLyBtZXNzYWdlIG9uIHBlZXIgcmVzcG9uc2UgLT4gb25hZGRzdHJlYW1cbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBoYW5kbGVBbnN3ZXI6IHN0cmVhbU5hbWUsXG4gICAgICByZXF1ZXN0SWQ6IHN1YnNjcmlwdGlvbklkLFxuICAgICAgZGF0YToge1xuICAgICAgICBzZHA6IHNkcFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBzZW5kQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3NlbmRjYW5kaWRhdGVdJylcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5DQU5ESURBVEVfU1RBUlQsIHRoaXMsIGNhbmRpZGF0ZSkpXG4gICAgLy8gbWVzc2FnZSBvbiBwZWVyIHJlc3BvbnNlIC0+IG9uaWNlY2FuZGlkYXRlXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgaGFuZGxlQ2FuZGlkYXRlOiB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsXG4gICAgICByZXF1ZXN0SWQ6IHRoaXMuX29wdGlvbnMuc3Vic2NyaXB0aW9uSWQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNhbmRpZGF0ZTogY2FuZGlkYXRlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHNlbmRTdWJzY3JpYmUgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbc2VuZHN1YnNjcmliZV0nKVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIHN1YnNjcmliZTogdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lLFxuICAgICAgcmVxdWVzdElkOiB0aGlzLl9vcHRpb25zLnN1YnNjcmlwdGlvbklkXG4gICAgfSlcbiAgfVxuXG4gIG9uU3RyZWFtQXZhaWxhYmxlIChyZWNlaXB0KSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbnN0cmVhbWF2YWlsYWJsZV06ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgICB0aGlzLl9jb25uZWN0KHRoaXMuX29wdGlvbnMuaWNlU2VydmVycylcbiAgfVxuXG4gIG9uU3RyZWFtVW5hdmFpbGFibGUgKHJlY2VpcHQpIHtcbiAgICBkZWJ1ZyhOQU1FLCBgU3RyZWFtICR7dGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lfSBkb2VzIG5vdCBleGlzdC5gKVxuICAgIGRlYnVnKE5BTUUsICdbb25zdHJlYW11bmF2YWlsYWJsZV06ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfSU5WQUxJRF9OQU1FLCB0aGlzKSlcbiAgICB0aGlzLl9kaXNjb25uZWN0KClcbiAgfVxuXG4gIG9uU0RQU3VjY2VzcyAocmVjZWlwdCkge1xuICAgIGRlYnVnKE5BTUUsICdbb25zZHBzdWNjZXNzXTogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICB9XG5cbiAgb25TRFBPZmZlciAocmVjZWlwdCkge1xuICAgIGRlYnVnKE5BTUUsICdbb25zZHBvZmZlcl06ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgICBjb25zdCBzZHAgPSBuZXcgd2VicnRjLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbihyZWNlaXB0LnNkcClcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5PRkZFUl9FTkQsIHRoaXMpKVxuICAgIHRoaXMucmVxdWVzdEFuc3dlcihzZHApXG4gIH1cblxuICBvblNEUEVycm9yIChyZWNlaXB0KSB7XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX0ZBSUwsIHRoaXMsIHJlY2VpcHQpKVxuICAgIGVycm9yKE5BTUUsICdbb25zZHBlcnJvcl0nKVxuICAgIGVycm9yKHJlY2VpcHQpXG4gIH1cblxuICBvbkFuc3dlck1lZGlhU3RyZWFtIChzdHJlYW0gPSB1bmRlZmluZWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLkFOU1dFUl9FTkQsIHRoaXMpKVxuICB9XG5cbiAgb25JY2VDYW5kaWRhdGUgKGNhbmRpZGF0ZSkge1xuICAgIGRlYnVnKE5BTUUsICdbb25pY2VjYW5kaWRhdGVdJylcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5DQU5ESURBVEVfRU5ELCB0aGlzKSlcbiAgICB0aGlzLnNlbmRDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICB9XG5cbiAgb25JY2VDYW5kaWRhdGVUcmlja2xlRW5kIChzdHJlYW0pIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29uaWNldHJpY2tsZWVuZF0nKVxuICAgIHRoaXMuX3ZpZXcuYXR0YWNoU3RyZWFtKHN0cmVhbSwgdGhpcy5fb3B0aW9ucy5hdXRvcGxheSB8fCB0cnVlKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9TVEFSVCwgdGhpcykpXG4gIH1cblxuICBvbkFkZEljZUNhbmRpZGF0ZSAoY2FuZGlkYXRlKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbmFkZGljZWNhbmRpZGF0ZV0nKVxuICAgIHRoaXMuX3BlZXJIZWxwZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSlcbiAgfVxuXG4gIG9uU29ja2V0SWNlQ2FuZGlkYXRlRW5kICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29uc29ja2V0aWNlY2FuZGlkYXRlZW5kXScpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMuSUNFX1RSSUNLTEVfQ09NUExFVEUsIHRoaXMpKVxuICAgIHRoaXMuc2VuZFN1YnNjcmliZSgpXG4gIH1cblxuICBvblNvY2tldE1lc3NhZ2VFcnJvciAobWVzc2FnZSwgZGV0YWlsID0gdW5kZWZpbmVkKSB7XG4gICAgZXJyb3IoTkFNRSwgYEVycm9yIGluIHN0cmVhbSBzdWJzY3JpcHRpb246ICR7bWVzc2FnZX0uXFxuW09wdGlvbmFsIGRldGFpbF06ICR7ZGV0YWlsfWApXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX0ZBSUwsIHRoaXMsIG1lc3NhZ2UpKVxuICB9XG5cbiAgb25VbnB1Ymxpc2ggKCkge1xuICAgIGRlYnVnKE5BTUUsICdbb251bnB1Ymxpc2hdJylcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5QTEFZX1VOUFVCTElTSCwgdGhpcykpXG4gIH1cblxuICBvbkNvbm5lY3Rpb25DbG9zZWQgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbb25jb25uZWN0aW9uY2xvc2VkXScpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVElPTl9DTE9TRUQsIHRoaXMpKVxuICB9XG5cbiAgb25NZXRhZGF0YSAobWV0YWRhdGEpIHtcbiAgICBpZiAodHlwZW9mIG1ldGFkYXRhLm9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAmJiBtZXRhZGF0YS5vcmllbnRhdGlvbiAhPT0gdGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIGVudmlyb25tZW50LmFwcGx5T3JpZW50YXRpb24odGhpcy5fdmlldy52aWV3LCBtZXRhZGF0YS5vcmllbnRhdGlvbilcbiAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gbWV0YWRhdGEub3JpZW50YXRpb25cbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX01FVEFEQVRBLCB0aGlzLCBtZXRhZGF0YSkpXG4gIH1cblxuICBfZGlzY29ubmVjdCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tkaXNjb25uZWN0XScpXG4gICAgaWYgKHRoaXMuX3NvY2tldEhlbHBlcikge1xuICAgICAgdGhpcy5fc29ja2V0SGVscGVyLnRlYXJEb3duKClcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BlZXJIZWxwZXIpIHtcbiAgICAgIHRoaXMuX3BlZXJIZWxwZXIudGVhckRvd24oKVxuICAgIH1cbiAgfVxuXG4gIF9jb25uZWN0IChpY2VTZXJ2ZXJzKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjb25uZWN0XScpXG4gICAgdGhpcy5fb3B0aW9ucy5pY2VTZXJ2ZXJzID0gaWNlU2VydmVyc1xuICAgIGNvbnN0IHAgPSB0aGlzLl9wZWVySGVscGVyLnNldFVwKHRoaXMuX29wdGlvbnMuaWNlU2VydmVycylcbiAgICBwLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5yZXF1ZXN0T2ZmZXIodGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lLCB0aGlzLl9vcHRpb25zLnN1YnNjcmlwdGlvbklkLCB0aGlzLl9vcHRpb25zLnZpZGVvRW5jb2RpbmcsIHRoaXMuX29wdGlvbnMuYXVkaW9FbmNvZGluZylcbiAgICB9KVxuICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICB3YXJuKE5BTUUsICdDb3VsZCBub3QgZXN0YWJsaXNoIFJUQ1BlZXJDb25uZWN0aW9uLicpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMpKVxuICAgIH0pXG4gICAgLy8gIFRPRE86IE5vcm1hbGl6ZSByZXR1cm5zIHRvIGVpdGhlciBhbGwgYmUgY2hhaW5hYmxlIG9yIG5vdCBiZSBjaGFpbmFibGVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcGxheSAoc3RyZWFtTmFtZSA9IG51bGwsIHByb21pc2UgPSBudWxsKSB7XG4gICAgZGVidWcoTkFNRSwgJ1twbGF5XScpXG4gICAgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lID0gc3RyZWFtTmFtZSB8fCB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWVcbiAgICBjb25zdCBwID0gcHJvbWlzZSB8fCBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCBzb2NrZXRQcm9taXNlID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgY29uc3Qgc29ja2V0dXJsID0gZW5kcG9pbnRGcm9tT3B0aW9ucyh0aGlzLl9vcHRpb25zKVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5zZXRVcChzb2NrZXR1cmwsIHNvY2tldFByb21pc2UpXG4gICAgc29ja2V0UHJvbWlzZS5wcm9taXNlXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHAucmVzb2x2ZSh0aGlzKVxuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUX1NVQ0NFU1MsIHRoaXMpKVxuICAgICAgICB0aGlzLnJlcXVlc3RBdmFpbGFiaWxpdHkodGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lLCB0aGlzLl9vcHRpb25zLnN0cmVhbVR5cGUpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICBwLnJlamVjdChlcnJvcilcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzLCBlcnJvcikpXG4gICAgICB9KVxuICAgIHJldHVybiBwLmhhc093blByb3BlcnR5KCdwcm9taXNlJykgPyBwLnByb21pc2UgOiBwXG4gIH1cblxuICBzdG9wICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3N0b3BdJylcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRoaXMuX2Rpc2Nvbm5lY3QoKVxuICAgIHRoaXMuX3ZpZXcuc3RvcCgpXG4gICAgZGVmZXJyZWQucmVzb2x2ZSh0aGlzKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlVOU1VCU0NSSUJFX1NVQ0NFU1MsIHRoaXMpKVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBnZXRDb25uZWN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ja2V0SGVscGVyXG4gIH1cblxuICBnZXRQZWVyQ29ubmVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJIZWxwZXIgPyB0aGlzLl9wZWVySGVscGVyLmNvbm5lY3Rpb24gOiB1bmRlZmluZWRcbiAgfVxuXG4gIGdldE9wdGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zXG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gJ1JUQydcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJUQ1N1YnNjcmliZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3N1YnNjcmliZXIvcmVkNXByby1ydGMuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgTm9FbGVtZW50Rm91bmRFcnJvciB9IGZyb20gJy4uL2V4Y2VwdGlvbi9lcnJvcnMnXG5pbXBvcnQgeyBvbk9yaWVudGF0aW9uTWV0YWRhdGEgfSBmcm9tICcuL21ldGFkYXRhLXV0aWwnXG5cbmxldCBjbG9zZUhhbmRsZXJzID0gW11cbmZ1bmN0aW9uIG9ud2luZG93Y2xvc2UgKGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAvLyAgY2xvc2VIYW5kbGVycy5mb3JFYWNoKGggPT4gaCgpKVxuICBsZXQgaSwgbGVuZ3RoID0gY2xvc2VIYW5kbGVycy5sZW5ndGhcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY2xvc2VIYW5kbGVyc1tpXSgpXG4gIH1cbiAgLy8gUmV0dXJuaW5nIGEgc3RyaW5nIHZhbHVlIGZvcmNlcyBhIGxlYXZpbmcgY29uZmlybWF0aW9uIHBvcHVwIG9uIHRoZSBicm93c2VyLlxuICAvLyAgZS5yZXR1cm5WYWx1ZSA9ICdnb29kYnllJ1xuICAvLyAgcmV0dXJuICdnb29kYnllJ1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9ibG9iL21hc3Rlci9zcmMvanMvdGVjaC9mbGFzaC5qcyNMNDc2XG5jb25zdCBmbGFzaFZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gIGxldCB2ZXJzaW9uID0gJzAsMCwwJ1xuICAvLyBJRVxuICB0cnkge1xuICAgIHZlcnNpb24gPSBuZXcgd2luZG93LkFjdGl2ZVhPYmplY3QoJ1Nob2Nrd2F2ZUZsYXNoLlNob2Nrd2F2ZUZsYXNoJykuR2V0VmFyaWFibGUoJyR2ZXJzaW9uJykucmVwbGFjZSgvXFxEKy9nLCAnLCcpLm1hdGNoKC9eLD8oLispLD8kLylbMV1cblxuICAvLyBvdGhlciBicm93c2Vyc1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChuYXZpZ2F0b3IubWltZVR5cGVzWydhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCddLmVuYWJsZWRQbHVnaW4pIHtcbiAgICAgICAgdmVyc2lvbiA9IChuYXZpZ2F0b3IucGx1Z2luc1snU2hvY2t3YXZlIEZsYXNoIDIuMCddIHx8IG5hdmlnYXRvci5wbHVnaW5zWydTaG9ja3dhdmUgRmxhc2gnXSkuZGVzY3JpcHRpb24ucmVwbGFjZSgvXFxEKy9nLCAnLCcpLm1hdGNoKC9eLD8oLispLD8kLylbMV1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIG5hZGFcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZlcnNpb24uc3BsaXQoJywnKVxufVxuXG5jb25zdCBpc01veiA9ICEhbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYVxubmF2aWdhdG9yLmdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYVxuXG5jb25zdCBkZWZhdWx0VXNlck1lZGlhQXVkaW8gPSBpc01veiA/IHRydWUgOiB7XG4gIG1hbmRpdG9yeToge1xuICAgIGdvb2dBdXRvR2FpbkNvbnRyb2w6IHRydWUsXG4gICAgZ29vZ0hpZ2hwYXNzRmlsdGVyOiB0cnVlLFxuICAgIGdvb2dFY2hvQ2FuY2VsbGF0aW9uOiB0cnVlLFxuICAgIGdvb2dOb2lzZVN1cHByZXNzaW9uOiB0cnVlXG4gIH0sXG4gIG9wdGlvbmFsOiBbXG4gICAge1xuICAgICAgYmFuZHdpZHRoOiA1MFxuICAgIH0sXG4gICAge1xuICAgICAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZVxuICAgIH1cbiAgXVxufVxuY29uc3QgZGVmYXVsdFVzZXJNZWRpYVZpZGVvID0gaXNNb3ogPyB0cnVlIDoge1xuICBtYW5kYXRvcnk6IHtcbiAgICBtaW5XaWR0aDogMzIwLFxuICAgIG1pbkhlaWdodDogMjQwLFxuICAgIG1pbkZyYW1lUmF0ZTogNCxcbiAgICBtYXhXaWR0aDogNjQwLFxuICAgIG1heEhlaWdodDogNDgwLFxuICAgIG1heEZyYW1lUmF0ZTogMjRcbiAgfSxcbiAgb3B0aW9uYWw6IFtcbiAgICB7XG4gICAgICBiYW5kd2lkdGg6IDI1NlxuICAgIH1cbiAgXVxufVxuXG5jb25zdCBvcmlnaW4gPSBbXG4gICd3ZWJraXRUcmFuc2Zvcm1PcmlnaW4nLFxuICAnbW96VHJhbnNmb3JtT3JpZ2luJyxcbiAgJ21zVHJhbnNmb3JtT3JpZ2luJyxcbiAgJ29UcmFuc2Zvcm1PcmlnaW4nLFxuICAndHJhbnNmb3JtT3JpZ2luJ1xuXVxuY29uc3Qgc3R5bGVzID0gW1xuICAnd2Via2l0VHJhbnNmb3JtJyxcbiAgJ21velRyYW5zZm9ybScsXG4gICdtc1RyYW5zZm9ybScsXG4gICdvVHJhbnNmb3JtJyxcbiAgJ3RyYW5zZm9ybSdcbl1cbmNvbnN0IHRyYW5zaXRpb24gPSBbXG4gICd3ZWJraXRUcmFuc2l0aW9uJyxcbiAgJ21velRyYW5zaXRpb24nLFxuICAnbXNUcmFuc2l0aW9uJyxcbiAgJ29UcmFuc2l0aW9uJyxcbiAgJ3RyYW5zaXRpb24nXG5dXG5jb25zdCByb3RhdGlvblRyYW5zbGF0aW9ucyA9IHtcbiAgJzAnOiB7XG4gICAgb3JpZ2luOiAnY2VudGVyIGNlbnRlcicsXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKDBkZWcpJ1xuICB9LFxuICAnOTAnOiB7XG4gICAgb3JpZ2luOiAnbGVmdCB0b3AnLFxuICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSg5MGRlZykgdHJhbnNsYXRlWSgtMTAwJSknXG4gIH0sXG4gICcxODAnOiB7XG4gICAgb3JpZ2luOiAnY2VudGVyIGNlbnRlcicsXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKDE4MGRlZyknXG4gIH0sXG4gICcyNzAnOiB7XG4gICAgb3JpZ2luOiAndG9wIGxlZnQnLFxuICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgyNzBkZWcpIHRyYW5zbGF0ZVgoLTEwMCUpIHRyYW5zbGF0ZVkoMCUpJ1xuICB9LFxuICAnLTkwJzoge1xuICAgIG9yaWdpbjogJ2xlZnQgdG9wJyxcbiAgICB0cmFuc2Zvcm06ICdyb3RhdGUoLTkwZGVnKSB0cmFuc2xhdGVYKC0xMDAlKSdcbiAgfSxcbiAgJy0xODAnOiB7XG4gICAgb3JpZ2luOiAnY2VudGVyIGNlbnRlcicsXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKC0xODBkZWcpJ1xuICB9LFxuICAnLTI3MCc6IHtcbiAgICBvcmlnaW46ICd0b3AgbGVmdCcsXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKC0yNzBkZWcpIHRyYW5zbGF0ZVkoLTEwMCUpJ1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3VwcG9ydHNXZWJTb2NrZXQ6ICgpID0+IHtcbiAgICByZXR1cm4gISF3aW5kb3cuV2ViU29ja2V0XG4gIH0sXG5cbiAgc3VwcG9ydHNGbGFzaFZlcnNpb246ICh2ZXJzaW9uLCBkZWxpbWl0ZXIgPSAnLicpID0+IHtcbiAgICByZXR1cm4gZmxhc2hWZXJzaW9uKClbMF0gPj0gdmVyc2lvbi5zcGxpdChkZWxpbWl0ZXIpWzBdXG4gIH0sXG5cbiAgcmVzb2x2ZUVsZW1lbnQ6IChpZCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKVxuICAgICAgaWYgKCFlbCkge1xuICAgICAgICB0aHJvdyBuZXcgTm9FbGVtZW50Rm91bmRFcnJvcihgRWxlbWVudCB3aXRoIGlkKCR7aWR9KSBjb3VsZCBub3QgYmUgZm91bmQuYClcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBOb0VsZW1lbnRGb3VuZEVycm9yKGBFcnJvciBpbiBhY2Nlc3NpbmcgZWxlbWVudCB3aXRoIGlkKCR7aWR9KS4gJHtlLm1lc3NhZ2V9YClcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlV2ViU29ja2V0OiAodXJsKSA9PiB7XG4gICAgcmV0dXJuIG5ldyB3aW5kb3cuV2ViU29ja2V0KHVybClcbiAgfSxcblxuICBzZXRWaWRlb1NvdXJjZTogKHZpZGVvRWxlbWVudCwgbWVkaWFTdHJlYW0sIGF1dG9wbGF5ID0gZmFsc2UpID0+IHtcbiAgICBpZiAoaXNNb3opIHtcbiAgICAgIHZpZGVvRWxlbWVudFsnbW96U3JjT2JqZWN0J10gPSBtZWRpYVN0cmVhbVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb0VsZW1lbnQuc3JjID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwobWVkaWFTdHJlYW0pXG4gICAgfVxuICAgIGlmIChhdXRvcGxheSkge1xuICAgICAgdmlkZW9FbGVtZW50LnBsYXkoKVxuICAgIH1cbiAgfSxcblxuICBpbmplY3RTY3JpcHQ6ICh1cmwpID0+IHtcbiAgICBsZXQgZGZkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgbGV0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0J1xuICAgIHNjcmlwdC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBkZmQucmVzb2x2ZSgpXG4gICAgfVxuICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2NyaXB0LnJlYWR5U3RhdGUgPT09ICdsb2FkZWQnIHx8IHNjcmlwdC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsXG4gICAgICAgIGRmZC5yZXNvbHZlKClcbiAgICAgIH1cbiAgICB9XG4gICAgc2NyaXB0LnNyYyA9IHVybFxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc2NyaXB0KVxuICAgIHJldHVybiBkZmQucHJvbWlzZVxuICB9LFxuXG4gIHNldEdsb2JhbDogKHByb3AsIHZhbHVlKSA9PiB7XG4gICAgd2luZG93W3Byb3BdID0gdmFsdWVcbiAgfSxcblxuICBnZXRTd2ZPYmplY3Q6ICgpID0+IHtcbiAgICByZXR1cm4gd2luZG93LnN3Zm9iamVjdFxuICB9LFxuXG4gIGdldEVtYmVkT2JqZWN0OiAoaWQpID0+IHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpXG4gIH0sXG5cbiAgZ2V0RWxlbWVudElkOiAoZWwpID0+IHtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICB9LFxuXG4gIGdldFZpZGVvSnM6ICgpID0+IHtcbiAgICByZXR1cm4gd2luZG93LnZpZGVvanNcbiAgfSxcblxuICBnZXRVc2VyTWVkaWE6IChhdWRpbyA9IG51bGwsIHZpZGVvID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSh7XG4gICAgICBhdWRpbzogYXVkaW8gfHwgZGVmYXVsdFVzZXJNZWRpYUF1ZGlvLFxuICAgICAgdmlkZW86IHZpZGVvIHx8IGRlZmF1bHRVc2VyTWVkaWFWaWRlb1xuICAgIH0sIGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdClcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9LFxuXG4gIGdldERlZmF1bHRQdWJsaXNoQ29uc3RyYWludHM6IChhdWRpbyA9IGZhbHNlLCB2aWRlbyA9IGZhbHNlKSA9PiB7XG4gICAgaWYgKGlzTW96KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZlclRvUmVjZWl2ZVZpZGVvOiB2aWRlbyxcbiAgICAgICAgb2ZmZXJUb1JlY2VpdmVBdWRpbzogYXVkaW9cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hbmRhdG9yeToge1xuICAgICAgICBvZmZlclRvUmVjZWl2ZVZpZGVvOiB2aWRlbyxcbiAgICAgICAgb2ZmZXJUb1JlY2VpdmVBdWRpbzogYXVkaW9cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZ2V0SXNNb3o6ICgpID0+IHtcbiAgICByZXR1cm4gaXNNb3pcbiAgfSxcblxuICBhZGRDbG9zZUhhbmRsZXI6IChoYW5kbGVyLCBpbnNlcnRWYWx1ZSA9IC0xKSA9PiB7XG4gICAgY2xvc2VIYW5kbGVycy5zbGljZShpbnNlcnRWYWx1ZSA9PT0gLTEgPyBjbG9zZUhhbmRsZXJzLmxlbmd0aCA6IGluc2VydFZhbHVlLCAwLCBoYW5kbGVyKVxuICAgIGlmICh3aW5kb3cub25iZWZvcmV1bmxvYWQgIT09IG9ud2luZG93Y2xvc2UpIHtcbiAgICAgIHdpbmRvdy5vbmJlZm9yZXVubG9hZCA9IG9ud2luZG93Y2xvc2VcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmxvYWQnLCBvbndpbmRvd2Nsb3NlKVxuICAgIH1cbiAgfSxcblxuICByZW1vdmVDbG9zZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgbGV0IGkgPSBjbG9zZUhhbmRsZXJzLmxlbmd0aFxuICAgIHdoaWxlKCAtLWkgPiAtMSkge1xuICAgICAgaWYgKGNsb3NlSGFuZGxlcnNbaV0gPT09IGhhbmRsZXIpIHtcbiAgICAgICAgY2xvc2VIYW5kbGVycy5zbGljZShpLCAxKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBvbk9yaWVudGF0aW9uTWV0YWRhdGE6IG9uT3JpZW50YXRpb25NZXRhZGF0YSxcblxuICBhcHBseU9yaWVudGF0aW9uOiAoZWxlbWVudCwgdmFsdWUpID0+IHtcbiAgICBsZXQgaSwgbGVuZ3RoID0gc3R5bGVzLmxlbmd0aFxuICAgIHZhbHVlID0gdmFsdWUgJSAzNjBcbiAgICBjb25zdCB0cmFuc2xhdGlvbnMgPSByb3RhdGlvblRyYW5zbGF0aW9uc1t2YWx1ZS50b1N0cmluZygpXVxuICAgIGZvcihpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBlbGVtZW50LnN0eWxlW29yaWdpbltpXV0gPSB0cmFuc2xhdGlvbnMub3JpZ2luXG4gICAgICBlbGVtZW50LnN0eWxlW3N0eWxlc1tpXV0gPSB0cmFuc2xhdGlvbnMudHJhbnNmb3JtXG4gICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25baV1dID0gJ3RyYW5zZm9ybSAwLjBzIGxpbmVhcidcbiAgICB9XG4gIH1cblxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvZW52L2Jyb3dzZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuY2xhc3MgX0RlZmVycmVkUHJvbWlzZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLnJlc29sdmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLnJlamVjdCA9IHVuZGVmaW5lZFxuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0XG4gICAgfSlcbiAgfVxufVxuXG5jb25zdCBfRnV0dXJlID0ge1xuICBjcmVhdGVJZk5vdEV4aXN0OiAoZGVmZXJyZWRJZkV4aXN0KSA9PiB7XG4gICAgbGV0IGYgPSBkZWZlcnJlZElmRXhpc3RcbiAgICBpZiAoIWYpIHtcbiAgICAgIGYgPSBuZXcgX0RlZmVycmVkUHJvbWlzZSgpXG4gICAgfVxuICAgIHJldHVybiBmXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IERlZmVycmVkUHJvbWlzZSA9IF9EZWZlcnJlZFByb21pc2VcbmV4cG9ydCBjb25zdCBGdXR1cmUgPSBfRnV0dXJlXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy91dGlsL3Byb21pc2UuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0IGNsYXNzIE5vRWxlbWVudEZvdW5kRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHRoaXMubmFtZSA9ICdOb0VsZW1lbnRGb3VuZCdcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2V4Y2VwdGlvbi9lcnJvcnMuanNcbiAqKi8iLCJjb25zdCBqc29uQXR0ciA9IC9bJ1wiXSguKj8pWydcIl06L2dpXG5jb25zdCBqc29uVmFsID0gLzpbJ1wiXSguKj8pWydcIl0vZ2lcblxuZnVuY3Rpb24gcmVhZFVURiAoZGF0YSxzdGFydCxsZW4pIHtcbiAgbGV0IHJlc3VsdCA9ICcnLCBvZmZzZXQgPSBzdGFydCwgZW5kID0gc3RhcnQgKyBsZW5cbiAgZG8ge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbb2Zmc2V0KytdKVxuICB9XG4gIHdoaWxlKG9mZnNldCA8IGVuZClcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBwYXJzZUpTT05Gb3JPcmllbnRhdGlvbiAodGV4dCkge1xuICB0cnkge1xuICAgIGxldCB2YWx1ZSA9IEpTT04ucGFyc2UodGV4dClcbiAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ29yaWVudGF0aW9uJykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9yaWVudGF0aW9uOiBwYXJzZUludCh2YWx1ZS5vcmllbnRhdGlvbilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIGNhdGNoIChlKSB7XG4gICAgbGV0IG1hdGNoID0ganNvbkF0dHIuZXhlYyh0ZXh0KVxuICAgIGxldCBtYXRjaDJcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgbWF0Y2gyID0ganNvblZhbC5leGVjKHRleHQpXG4gICAgICBpZiAobWF0Y2hbMV0gPT09ICdvcmllbnRhdGlvbicgJiYgbWF0Y2gyICYmIG1hdGNoMi5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3JpZW50YXRpb246IHBhcnNlSW50KG1hdGNoMlsxXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG9uT3JpZW50YXRpb25NZXRhZGF0YSA9IChwbGF5ZXIsIGNhbGxiYWNrKSA9PiB7XG5cbiAgY29uc3QgdGV4dFRyYWNrcyA9IHR5cGVvZiBwbGF5ZXIudGV4dFRyYWNrcyA9PT0gJ2Z1bmN0aW9uJyA/IHBsYXllci50ZXh0VHJhY2tzKCkgOiBwbGF5ZXIudGV4dFRyYWNrc1xuXG4gIGlmICh0ZXh0VHJhY2tzKSB7XG5cbiAgICBwbGF5ZXIuYWRkVGV4dFRyYWNrKCdtZXRhZGF0YScpXG5cbiAgICB0ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgYWRkVHJhY2tFdmVudCA9PiB7XG5cbiAgICAgIGxldCB0cmFjayA9IGFkZFRyYWNrRXZlbnQudHJhY2tcbiAgICAgIHRyYWNrLm1vZGUgPSAnaGlkZGVuJ1xuICAgICAgLyoqXG4gICAgICB2YXIgY3VlID0gbmV3IFZUVEN1ZSgxLjAsIDAsICdUZXN0aW5nJylcbiAgICAgIGN1ZS5pZCA9IDFcbiAgICAgIGN1ZS5wYXVzZU9uRXhpdCA9IGZhbHNlXG4gICAgICB0cmFjay5hZGRDdWUoY3VlKVxuICAgICAgKi9cblxuICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgY3VlQ2hhbmdlRXZlbnQgPT4ge1xuICAgICAgICBsZXQgY3Vlc1xuICAgICAgICBsZXQgaVxuICAgICAgICAvLyBNb3N0bHkgQ2hyb21lLlxuICAgICAgICBpZiAoY3VlQ2hhbmdlRXZlbnQgJiYgY3VlQ2hhbmdlRXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgIGN1ZXMgPSBjdWVDaGFuZ2VFdmVudC5jdXJyZW50VGFyZ2V0LmN1ZXNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1bmRlZmluZWQgPT09IHRoaXMpIHtcbiAgICAgICAgICBjdWVzID0gdHJhY2suY3Vlc1xuICAgICAgICAgIGN1ZXMgPSBjdWVzICYmIGN1ZXMubGVuZ3RoID4gMCA/IGN1ZXMgOiB0cmFjay5hY3RpdmVDdWVzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5kZWZpbmVkICE9PSB0aGlzKSB7XG4gICAgICAgICAgLy8gTW9zdGx5IEZpcmVmb3ggJiBTYWZhcmkuXG4gICAgICAgICAgY3VlcyA9IGN1ZXMgJiYgY3Vlcy5sZW5ndGggPiAwID8gY3VlcyA6IHRoaXMuYWN0aXZlQ3Vlc1xuICAgICAgICB9XG4gICAgICAgIC8vIE1vc3RseSBmYWlsdXJlLlxuICAgICAgICBjdWVzID0gY3VlcyB8fCBbXVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY3Vlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBkYXRhID0gY3Vlc1tpXVxuICAgICAgICAgIGlmIChkYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IHR5cGVvZiBkYXRhLnZhbHVlLmRhdGEgPT09ICdzdHJpbmcnID8gZGF0YS52YWx1ZS5kYXRhIDogcmVhZFVURiggZGF0YS52YWx1ZS5kYXRhICwgMCAsIGRhdGEuc2l6ZSlcbiAgICAgICAgICAgIGxldCBvcmllbnRhdGlvbiA9IHBhcnNlSlNPTkZvck9yaWVudGF0aW9uKHRleHQpXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWVudGF0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBjYWxsYmFjayhvcmllbnRhdGlvbilcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICB9KVxuXG4gIH1cbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvZW52L21ldGFkYXRhLXV0aWwuanNcbiAqKi8iLCJjbGFzcyBFdmVudCB7XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIGRhdGEgPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl90eXBlID0gdHlwZVxuICAgIHRoaXMuX2RhdGEgPSBkYXRhXG4gIH1cblxuICBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3R5cGVcbiAgfVxuXG4gIGdldCBkYXRhICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVxuICB9XG5cbn1cblxuY2xhc3MgUHVibGlzaGVyRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIHB1Ymxpc2hlciwgZGF0YSkge1xuICAgIHN1cGVyKHR5cGUsIGRhdGEpXG4gICAgdGhpcy5fcHVibGlzaGVyID0gcHVibGlzaGVyXG4gIH1cblxuICBnZXQgcHVibGlzaGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVibGlzaGVyXG4gIH1cblxufVxuXG5jbGFzcyBTdWJzY3JpYmVyRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIHN1YnNjcmliZXIsIGRhdGEpIHtcbiAgICBzdXBlcih0eXBlLCBkYXRhKVxuICAgIHRoaXMuX3N1YnNjcmliZXIgPSBzdWJzY3JpYmVyXG4gIH1cblxuICBnZXQgc3Vic2NyaWJlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZXJcbiAgfVxuXG59XG5cbmNsYXNzIFNoYXJlZE9iamVjdEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBzaGFyZWRPYmplY3ROYW1lLCBkYXRhKSB7XG4gICAgc3VwZXIodHlwZSwgZGF0YSlcbiAgICB0aGlzLl9uYW1lID0gc2hhcmVkT2JqZWN0TmFtZVxuICB9XG5cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lXG4gIH1cblxufVxuXG5leHBvcnQgeyBQdWJsaXNoZXJFdmVudCBhcyBQdWJsaXNoZXJFdmVudCB9XG5leHBvcnQgeyBTdWJzY3JpYmVyRXZlbnQgYXMgU3Vic2NyaWJlckV2ZW50IH1cbmV4cG9ydCB7IFNoYXJlZE9iamVjdEV2ZW50IGFzIFNoYXJlZE9iamVjdEV2ZW50IH1cbmV4cG9ydCB7IGNvbW1vbiBhcyBQdWJsaXNoZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9wdWJsaXNoZXItZXZlbnQnXG5leHBvcnQgeyBydGMgYXMgUlRDUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vcHVibGlzaGVyLWV2ZW50J1xuZXhwb3J0IHsgcnRtcCBhcyBSVE1QUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vcHVibGlzaGVyLWV2ZW50J1xuZXhwb3J0IHsgZmFpbG92ZXIgYXMgRmFpbG92ZXJQdWJsaXNoZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9wdWJsaXNoZXItZXZlbnQnXG5leHBvcnQgeyBjb21tb24gYXMgU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBydGMgYXMgUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBydG1wIGFzIFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4vc3Vic2NyaWJlci1ldmVudCdcbmV4cG9ydCB7IGZhaWxvdmVyIGFzIEZhaWxvdmVyU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBjb21tb24gYXMgU2hhcmVkT2JqZWN0RXZlbnRUeXBlcyB9IGZyb20gJy4vc2hhcmVkb2JqZWN0LWV2ZW50J1xuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9ldmVudC9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgU29ja2V0SGVscGVyIGZyb20gJy4vc29ja2V0LWhlbHBlcidcbmltcG9ydCB7IHdhcm4sIGVycm9yIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvU3Vic2NyaXB0aW9uU29ja2V0J1xuXG5jbGFzcyBTdWJzY3JpcHRpb25Tb2NrZXRIZWxwZXIgZXh0ZW5kcyBTb2NrZXRIZWxwZXIge1xuXG4gIGNvbnN0cnVjdG9yIChyZXNwb25kZXIpIHtcbiAgICBzdXBlcihyZXNwb25kZXIsIE5BTUUpXG4gIH1cblxuICByZXNwb25kIChtZXNzYWdlKSB7XG4gICAgLy8gICAgY29uc29sZS5sb2cobWVzc2FnZSlcbiAgICBpZiAobWVzc2FnZS5kYXRhKSB7XG4gICAgICBsZXQganNvbiA9IHRoaXMuZ2V0SnNvbkZyb21Tb2NrZXRNZXNzYWdlKG1lc3NhZ2UpXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXN1cGVyLnJlc3BvbmQobWVzc2FnZSkpIHtcbiAgICAgICAgICBpZiAoanNvbi5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChqc29uLmRhdGEuc2RwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5zZHAudHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNEUE9mZmVyKGpzb24uZGF0YSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5jYW5kaWRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25BZGRJY2VDYW5kaWRhdGUoanNvbi5kYXRhLmNhbmRpZGF0ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uLmRhdGEudHlwZSA9PT0gJ3N0YXR1cycpIHtcbiAgICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5jb2RlID09PSAnTmV0Q29ubmVjdGlvbi5JQ0UuVHJpY2xlQ29tcGxldGVkJyB8fFxuICAgICAgICAgICAgICAgICBqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uSUNFLlRyaWNrbGVDb21wbGV0ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU29ja2V0SWNlQ2FuZGlkYXRlRW5kKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChqc29uLmRhdGEuY29kZSA9PT0gJ05ldFN0cmVhbS5QbGF5LlVucHVibGlzaE5vdGlmeScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25VbnB1Ymxpc2goKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGpzb24uZGF0YS5jb2RlID09PSAnTmV0Q29ubmVjdGlvbi5Db25uZWN0LkNsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25Db25uZWN0aW9uQ2xvc2VkKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5oYXNPd25Qcm9wZXJ0eSgnc3RhdHVzJykpIHtcbiAgICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5zdGF0dXMgPT09ICdOZXRTdHJlYW0uUGxheS5VbnB1Ymxpc2hOb3RpZnknKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uVW5wdWJsaXNoKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24udHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmIChqc29uLnR5cGUgPT09ICdtZXRhZGF0YScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25NZXRhZGF0YShqc29uLmRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGpzb24udHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoanNvbi50eXBlID09PSAnbWV0YWRhdGEnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbk1ldGFkYXRhKGpzb24ubWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcihOQU1FLCBgW3dzLm9ubWVzc2FnZV0gLSBFcnJvciBpbiBhY2Nlc3NpbmcgbWVzc2FnZSBkYXRhIGFzIEpTT04uICR7ZS5tZXNzYWdlfWApXG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldE1lc3NhZ2VFcnJvcihgW3dzLm9ubWVzc2FnZV0gLSBFcnJvciBpbiBhY2Nlc3NpbmcgbWVzc2FnZSBkYXRhIGFzIEpTT04uICR7ZS5tZXNzYWdlfWApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oTkFNRSwgJ1t3cy5vbm1lc3NhZ2VdIC0gTm8gTWVzc2FnZSBEYXRhLicpXG4gICAgfVxuICB9XG5cbn1cbmV4cG9ydCBkZWZhdWx0IFN1YnNjcmlwdGlvblNvY2tldEhlbHBlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvaGVscGVyL3NvY2tldC1oZWxwZXItc3ViLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5pbXBvcnQgKiBhcyB3ZWJzb2NrZXQgZnJvbSAnLi4vYWRhcHRlci93ZWJzb2NrZXQnXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBpbmZvLCBkZWJ1Zywgd2FybiB9IGZyb20gJy4uL2xvZydcblxuY2xhc3MgU29ja2V0SGVscGVyIHtcblxuICBjb25zdHJ1Y3RvciAocmVzcG9uZGVyLCBuYW1lKSB7XG4gICAgdGhpcy5fcmVzcG9uZGVyID0gcmVzcG9uZGVyXG4gICAgdGhpcy5fcGVuZGluZ1Bvc3RSZXF1ZXN0cyA9IFtdXG4gICAgdGhpcy5fd2Vic29ja2V0ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9uYW1lID0gbmFtZVxuICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMgPSBbXVxuICAgIHRoaXMuX29uY2xvc2UgPSB0aGlzLnRlYXJEb3duLmJpbmQodGhpcylcbiAgfVxuXG4gIF9yZW1vdmVTb2NrZXRIYW5kbGVycyAod3MpIHtcbiAgICB3cy5vbm9wZW4gPSB1bmRlZmluZWRcbiAgICB3cy5vbm1lc3NhZ2UgPSB1bmRlZmluZWRcbiAgICB3cy5vbmVycm9yID0gdW5kZWZpbmVkXG4gIH1cblxuICBfYWRkU29ja2V0SGFuZGxlcnMgKHdzLCBwcm9taXNlKSB7XG5cbiAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICBpbmZvKHRoaXMuX25hbWUsICdbd2Vic29ja2V0b3Blbl0nKVxuICAgICAgd2hpbGUgKHRoaXMuX3BlbmRpbmdQb3N0UmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnBvc3QodGhpcy5fcGVuZGluZ1Bvc3RSZXF1ZXN0cy5zaGlmdCgpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHdzLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMudGVhckRvd24oKVxuICAgICAgd2Fybih0aGlzLl9uYW1lLCBgW3dlYnNvY2tldGVycm9yXTogRXJyb3IgZnJvbSBXZWJTb2NrZXQuICR7ZXJyb3IudHlwZX1gKVxuICAgICAgcHJvbWlzZS5yZWplY3QoZXJyb3IpXG4gICAgfVxuXG4gICAgd3Mub25tZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgIHRoaXMucmVzcG9uZChtZXNzYWdlKVxuICAgIH1cblxuICB9XG5cbiAgc2V0VXAgKHVybCwgc2V0dXBQcm9taXNlKSB7XG4gICAgdGhpcy50ZWFyRG93bigpXG4gICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UgPSBzZXR1cFByb21pc2VcbiAgICBlbnZpcm9ubWVudC5hZGRDbG9zZUhhbmRsZXIodGhpcy5fb25jbG9zZSlcbiAgICB0aGlzLl93ZWJzb2NrZXQgPSB3ZWJzb2NrZXQuY3JlYXRlKHVybClcbiAgICB0aGlzLl9hZGRTb2NrZXRIYW5kbGVycyh0aGlzLl93ZWJzb2NrZXQsIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlKVxuICB9XG5cbiAgdGVhckRvd24gKCkge1xuICAgIHRoaXMuX3BlbmRpbmdQb3N0UmVxdWVzdHMubGVuZ3RoID0gMFxuICAgIGlmICh0eXBlb2YgdGhpcy5fd2Vic29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5fcmVtb3ZlU29ja2V0SGFuZGxlcnModGhpcy5fd2Vic29ja2V0KVxuICAgICAgdGhpcy5fd2Vic29ja2V0LmNsb3NlKClcbiAgICB9XG4gICAgdGhpcy5fd2Vic29ja2V0ID0gdW5kZWZpbmVkXG4gICAgd2hpbGUodGhpcy5fcmVzcG9uc2VIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLnNoaWZ0KClcbiAgICB9XG4gICAgZW52aXJvbm1lbnQucmVtb3ZlQ2xvc2VIYW5kbGVyKHRoaXMuX29uY2xvc2UpXG4gIH1cblxuICBnZXRKc29uRnJvbVNvY2tldE1lc3NhZ2UgKG1lc3NhZ2UpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlLmRhdGEgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpIDogbWVzc2FnZS5kYXRhXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB3YXJuKHRoaXMuX25hbWUsICdDb3VsZCBub3QgcGFyc2UgbWVzc2FnZSBhcyBKU09OLiBNZXNzYWdlPSAnICsgbWVzc2FnZS5kYXRhICsgJy4gRXJyb3I9ICcgKyBlLm1lc3NhZ2UpXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBhZGRTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLnB1c2goaGFuZGxlcilcbiAgfVxuXG4gIHJlbW92ZVNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIGxldCBpID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5sZW5ndGhcbiAgICBsZXQgckhhbmRsZXJcbiAgICB3aGlsZSgtLWkgPiAtMSkge1xuICAgICAgckhhbmRsZXIgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzW2ldXG4gICAgICBpZiAockhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5zcGxpY2UoaSwgMSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlTWVzc2FnZVJlc3BvbnNlIChtZXNzYWdlKSB7XG4gICAgbGV0IGksIGhhbmRsZXJcbiAgICBsZXQgbGVuZ3RoID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhbmRsZXIgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzW2ldXG4gICAgICBpZiAoaGFuZGxlci5yZXNwb25kKG1lc3NhZ2UpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcG9zdCAoc2VuZFJlcXVlc3QpIHtcbiAgICBpZiAodGhpcy5fd2Vic29ja2V0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fd2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IDEgLyogV2ViU29ja2V0Lk9QRU4gKi8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRlYnVnKHRoaXMuX25hbWUsICdbd2Vic29ja2V0LXBvc3RdOiAnICsgSlNPTi5zdHJpbmdpZnkoc2VuZFJlcXVlc3QsIG51bGwsIDIpKVxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShzZW5kUmVxdWVzdCkpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRlYnVnKHRoaXMuX25hbWUsIGBDb3VsZCBub3Qgc2VuZCByZXF1ZXN0OiAke3NlbmRSZXF1ZXN0fS4gJHtlfWApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdQb3N0UmVxdWVzdHMucHVzaChzZW5kUmVxdWVzdClcbiAgICB9XG4gIH1cblxuICByZXNwb25kIChtZXNzYWdlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBsZXQgaGFuZGxlZCA9IHRoaXMuaGFuZGxlTWVzc2FnZVJlc3BvbnNlKG1lc3NhZ2UpXG4gICAgaWYgKCFoYW5kbGVkICYmIG1lc3NhZ2UuZGF0YSkge1xuICAgICAgbGV0IGpzb24gPSB0aGlzLmdldEpzb25Gcm9tU29ja2V0TWVzc2FnZShtZXNzYWdlKVxuICAgICAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICAgICAgd2Fybih0aGlzLl9uYW1lLCAnRGV0ZXJtaW5lZCB3ZWJzb2NrZXQgcmVzcG9uc2Ugbm90IGluIGNvcnJlY3QgZm9ybWF0LiBBYm9ydGluZyBtZXNzYWdlIGhhbmRsZS4nKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGRlYnVnKHRoaXMuX25hbWUsICdbd2Vic29ja2V0LXJlc3BvbnNlXTogJyArIEpTT04uc3RyaW5naWZ5KGpzb24sIG51bGwsIDIpKVxuICAgICAgaWYgKGpzb24uaXNBdmFpbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uaXNBdmFpbGFibGUgPT09ICdib29sZWFuJyAmJiBqc29uLmlzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU3RyZWFtQXZhaWxhYmxlKGpzb24pXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TdHJlYW1VbmF2YWlsYWJsZShqc29uKVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoanNvbi5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGpzb24uZGF0YS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoanNvbi5kYXRhLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldE1lc3NhZ2VFcnJvcihqc29uLmRhdGEubWVzc2FnZSwganNvbi5kYXRhLmRldGFpbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24uZGF0YS50eXBlID09PSAnc3RhdHVzJykge1xuICAgICAgICAgIGlmIChqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uQ29ubmVjdC5TdWNjZXNzJykge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uQ29ubmVjdC5SZWplY3RlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlLnJlamVjdCgnTmV0Q29ubmVjdGlvbi5Db25uZWN0LlJlamVjdGVkJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24uZGF0YS50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgaWYgKGpzb24uZGF0YS5jb2RlID09PSAnTmV0Q29ubmVjdGlvbi5Db25uZWN0LlJlamVjdGVkJykge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UucmVqZWN0KCdOZXRDb25uZWN0aW9uLkNvbm5lY3QuUmVqZWN0ZWQnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZWRcbiAgfVxuXG4gIGdldFJlbW90ZVNoYXJlZE9iamVjdCAobmFtZSkge1xuICAgIHRoaXMucG9zdCh7XG4gICAgICBzaGFyZWRPYmplY3RHZXRSZW1vdGU6IHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjb25uZWN0VG9TaGFyZWRPYmplY3QgKG5hbWUpIHtcbiAgICB0aGlzLnBvc3Qoe1xuICAgICAgc2hhcmVkT2JqZWN0Q29ubmVjdDoge1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHNlbmRUb1NoYXJlZE9iamVjdCAobmFtZSwgY2FsbE5hbWUsIGRhdGEpIHtcbiAgICB0aGlzLnBvc3Qoe1xuICAgICAgc2hhcmVkT2JqZWN0U2VuZDoge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBjYWxsOiBjYWxsTmFtZSxcbiAgICAgICAgcGFyYW1zOiBbZGF0YV1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QgKG5hbWUsIGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnBvc3Qoe1xuICAgICAgc2hhcmVkT2JqZWN0U2V0UHJvcGVydHk6IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjbG9zZVNoYXJlZE9iamVjdCAobmFtZSkge1xuICAgIHRoaXMucG9zdCh7XG4gICAgICBzaGFyZWRPYmplY3RDbG9zZToge1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNvY2tldEhlbHBlclxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9oZWxwZXIvc29ja2V0LWhlbHBlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5cbmV4cG9ydCBjb25zdCBpc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGVudmlyb25tZW50LnN1cHBvcnRzV2ViU29ja2V0KClcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgcmV0dXJuIGVudmlyb25tZW50LmNyZWF0ZVdlYlNvY2tldCh1cmwpXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9hZGFwdGVyL3dlYnNvY2tldC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgKiBhcyB3ZWJydGMgZnJvbSAnLi4vYWRhcHRlci93ZWJydGMnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBkZWJ1Zywgd2FybiwgZXJyb3IgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9TdWJzY3JpcHRpb25QZWVyJ1xuXG5jbGFzcyBTdWJzY3JpcHRpb25QZWVySGVscGVyIHtcblxuICBjb25zdHJ1Y3RvciAocmVzcG9uZGVyKSB7XG4gICAgdGhpcy5fcmVzcG9uZGVyID0gcmVzcG9uZGVyXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24gPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZW5kaW5nTWVkaWFTdHJlYW0gPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9yZW1vdmVDb25uZWN0aW9uSGFuZGxlcnMgKGNvbm5lY3Rpb24pIHtcbiAgICBjb25uZWN0aW9uLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gdW5kZWZpbmVkXG4gICAgY29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IHVuZGVmaW5lZFxuICAgIGNvbm5lY3Rpb24ub25hZGRzdHJlYW0gPSB1bmRlZmluZWRcbiAgICBjb25uZWN0aW9uLm9udHJhY2sgPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9hZGRDb25uZWN0aW9uSGFuZGxlcnMgKGNvbm5lY3Rpb24sIHByb21pc2UpIHtcblxuICAgIGNvbm5lY3Rpb24ub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAoY29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgIGRlYnVnKE5BTUUsICdbcGVlcmNvbm5lY3Rpb246b3Blbl0nKVxuICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgIHByb21pc2UucmVzb2x2ZSh0aGlzKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJyB8fFxuICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgd2FybihOQU1FLCAnW3BlZXJjb25uZWN0aW9uOmVycm9yXScpXG4gICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZWplY3QoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgZGVidWcoTkFNRSwgYFtwZWVyLm9uaWNlY2FuZGlkYXRlXSAtIFBlZXIgQ2FuZGlkYXRlOiAke2V2ZW50LmNhbmRpZGF0ZX1gKVxuICAgICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSkge1xuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25JY2VDYW5kaWRhdGUoZXZlbnQuY2FuZGlkYXRlKVxuICAgICAgfSBlbHNlIGlmIChldmVudC5jYW5kaWRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gbnVsbCBtZWFucyB0aGV5IGhhdmUgZmluaXNoZWQgc2VuZGluZyBjYW5kaWRhdGVzIGJhY2sgYW5kIGZvcnRoP1xuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25JY2VDYW5kaWRhdGVUcmlja2xlRW5kKHRoaXMuX3BlbmRpbmdNZWRpYVN0cmVhbSlcbiAgICAgICAgdGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi5vbmFkZHN0cmVhbSA9IChldmVudCkgPT4ge1xuICAgICAgZGVidWcoTkFNRSwgYFBlZXIgQWRkIFN0cmVhbTogJHtldmVudC5zdHJlYW19YClcbiAgICAgIGlmIChldmVudC5zdHJlYW0pIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtID0gZXZlbnQuc3RyZWFtXG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkFuc3dlck1lZGlhU3RyZWFtKGV2ZW50LnN0cmVhbSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLm9udHJhY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgIGRlYnVnKE5BTUUsIGBQZWVyIEFkZCBTdHJlYW06ICR7ZXZlbnQuc3RyZWFtc31gKVxuICAgICAgaWYgKGV2ZW50LnN0cmVhbXMgJiYgZXZlbnQuc3RyZWFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdNZWRpYVN0cmVhbSA9IGV2ZW50LnN0cmVhbXNbMF1cbiAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHNldFVwIChpY2VTZXJ2ZXJzLCBzZXRVcFByb21pc2UpIHtcbiAgICB0aGlzLnRlYXJEb3duKClcbiAgICBkZWJ1ZyhOQU1FLCAnW3NldHVwXScpXG4gICAgY29uc3QgcCA9IHNldFVwUHJvbWlzZSB8fCBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0cnkge1xuICAgICAgbGV0IHBlZXIgPSBuZXcgd2VicnRjLlJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyxcbiAgICAgICAgcnRjcE11eFBvbGljeTogJ25lZ290aWF0ZSdcbiAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBvcHRpb25hbDogW1xuICAgICAgICAgICAge0R0bHNTcnRwS2V5QWdyZWVtZW50OiB0cnVlfSxcbiAgICAgICAgICAgIHtSdHBEYXRhQ2hhbm5lbHM6IGZhbHNlfSxcbiAgICAgICAgICAgIHtnb29nQ3B1T3ZlcnVzZURldGVjdGlvbjogdHJ1ZX1cbiAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbiA9IHBlZXJcbiAgICAgIHRoaXMuX2FkZENvbm5lY3Rpb25IYW5kbGVycyhwZWVyKVxuICAgICAgcC5yZXNvbHZlKClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKE5BTUUsIGBDb3VsZCBub3QgY3JlYXRlIGEgUlRDUGVlckNvbm5lY3Rpb24uIEVycm9yOiAke2UubWVzc2FnZX1gKVxuICAgICAgcC5yZWplY3QoZS5tZXNzYWdlKVxuICAgIH1cbiAgICByZXR1cm4gcC5oYXNPd25Qcm9wZXJ0eSgncHJvbWlzZScpID8gcC5wcm9taXNlIDogcFxuICB9XG5cbiAgdGVhckRvd24gKCkge1xuICAgIGRlYnVnKE5BTUUsICdbdGVhcmRvd25dJylcbiAgICBpZiAodGhpcy5fcGVlckNvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMuX3JlbW92ZUNvbm5lY3Rpb25IYW5kbGVycyh0aGlzLl9wZWVyQ29ubmVjdGlvbilcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLmNsb3NlKClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd2FybihOQU1FLCBgW3BlZXJjb25uZWN0aW9uLmNsb3NlXSBlcnJvcjogJHtlLm1lc3NhZ2V9YClcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24gPSB1bmRlZmluZWRcbiAgfVxuXG4gIGNyZWF0ZUFuc3dlciAoc2RwKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjcmVhdGVhbnN3ZXJdJylcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24oc2RwKVxuICAgICAgLnRoZW4odGhpcy5fcmVzcG9uZGVyLm9uU0RQU3VjY2VzcylcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNEUEVycm9yKGVycilcbiAgICAgIH0pXG5cbiAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKVxuICAgICAgLnRoZW4oc2Vzc2lvbkRlc2NyaXB0aW9uID0+IHtcbiAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihzZXNzaW9uRGVzY3JpcHRpb24pXG4gICAgICAgICAgLnRoZW4odGhpcy5fcmVzcG9uZGVyLm9uU0RQU3VjY2VzcylcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU0RQRXJyb3IoZXJyKVxuICAgICAgICAgIH0pXG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUoc2Vzc2lvbkRlc2NyaXB0aW9uKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChkZWZlcnJlZC5yZWplY3QpXG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgYWRkSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2FkZGljZWNhbmRpZGF0ZV0nKVxuICAgIGxldCBpY2VDYW5kaWRhdGUgPSBuZXcgd2VicnRjLlJUQ0ljZUNhbmRpZGF0ZSh7XG4gICAgICBzZHBNTGluZUluZGV4OiBjYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgIGNhbmRpZGF0ZTogY2FuZGlkYXRlLmNhbmRpZGF0ZVxuICAgIH0pXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKGljZUNhbmRpZGF0ZSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgLy8gbmFkYVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBlcnJvcihOQU1FLCBgRXJyb3IgaW4gYWRkIG9mIElDRSBDYW5kaWRpYXRlICsgJHtlcnJ9YClcbiAgICAgIH0pXG4gIH1cblxuICBnZXQgY29ubmVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJDb25uZWN0aW9uXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTdWJzY3JpcHRpb25QZWVySGVscGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9oZWxwZXIvd2VicnRjLWhlbHBlci1zdWIuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuXG4vKiogLS0gaGFuZGxlZCBieSBhZGFwdGVyLmpzIC0tICovXG5jb25zdCBfUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgKHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbiB8fCB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pXG5jb25zdCBfUlRDSWNlQ2FuZGlkYXRlID0gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCAod2luZG93Lm1velJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cud2Via2l0UlRDSWNlQ2FuZGlkYXRlKVxuY29uc3QgX1JUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24gfHwgKHdpbmRvdy5tb3pSVENTZXNzaW9uRGVzY3JpcHRpb24gfHwgd2luZG93LndlYmtpdFJUQ1Nlc3Npb25EZXNjcmlwdGlvbilcblxuZXhwb3J0IGNvbnN0IGlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX1JUQ1BlZXJDb25uZWN0aW9uICYmIF9SVENJY2VDYW5kaWRhdGUgJiYgX1JUQ1Nlc3Npb25EZXNjcmlwdGlvblxufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1dlYlJUQy1FeHBlcmltZW50L2Jsb2IvbWFzdGVyL1JUQ1BlZXJDb25uZWN0aW9uL1JUQ1BlZXJDb25uZWN0aW9uLXYxLjYuanMjTDE1OFxuLy8gTXVheiBLaGFuICAgICAtIGdpdGh1Yi5jb20vbXVhei1raGFuXG4vLyBNSVQgTGljZW5zZSAgIC0gd3d3LldlYlJUQy1FeHBlcmltZW50LmNvbS9saWNlbmNlXG4vLyBEb2N1bWVudGF0aW9uIC0gZ2l0aHViLmNvbS9tdWF6LWtoYW4vV2ViUlRDLUV4cGVyaW1lbnQvdHJlZS9tYXN0ZXIvUlRDUGVlckNvbm5lY3Rpb25cbmV4cG9ydCBjb25zdCB1cGRhdGVCYW5kd2lkdGggPSBmdW5jdGlvbiAob3B0aW9ucywgc2RwKSB7XG4gIGlmIChlbnZpcm9ubWVudC5nZXRJc01veigpKSB7XG4gICAgcmV0dXJuIHNkcFxuICB9XG4gIHNkcCA9IHNkcC5yZXBsYWNlKC9iPUFTKFteXFxyXFxuXStcXHJcXG4pL2csICcnKVxuICBpZiAob3B0aW9ucy5hdWRpbykge1xuICAgIHNkcCA9IHNkcC5yZXBsYWNlKC9hPW1pZDphdWRpb1xcclxcbi9nLCAnYT1taWQ6YXVkaW9cXHJcXG5iPUFTOicgKyBvcHRpb25zLmF1ZGlvICsgJ1xcclxcbicpXG4gIH1cbiAgaWYgKG9wdGlvbnMudmlkZW8pIHtcbiAgICBzZHAgPSBzZHAucmVwbGFjZSgvYT1taWQ6dmlkZW9cXHJcXG4vZywgJ2E9bWlkOnZpZGVvXFxyXFxuYj1BUzonICsgb3B0aW9ucy52aWRlbyArICdcXHJcXG4nKVxuICB9XG4gIHJldHVybiBzZHBcbn1cblxuZXhwb3J0IGNvbnN0IFJUQ1BlZXJDb25uZWN0aW9uID0gX1JUQ1BlZXJDb25uZWN0aW9uXG5leHBvcnQgY29uc3QgUlRDSWNlQ2FuZGlkYXRlID0gX1JUQ0ljZUNhbmRpZGF0ZVxuZXhwb3J0IGNvbnN0IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IF9SVENTZXNzaW9uRGVzY3JpcHRpb25cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvYWRhcHRlci93ZWJydGMuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnQgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IFN1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgVmlkZW9KU0hhbmRsZXIgZnJvbSAnLi92aWRlb2pzLXNvdXJjZS1oYW5kbGVyJ1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9ITFNTdWJzY3JpYmVyJ1xuY29uc3QgdmlkZW9qcyA9IGVudmlyb25tZW50LmdldFZpZGVvSnMoKVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHByb3RvY29sOiAnaHR0cHMnLFxuICBwb3J0OiA4MCxcbiAgbWltZVR5cGU6ICdhcHBsaWNhdGlvbi94LW1wZWdVUkwnLFxuICBzd2Y6ICdsaWIvcmVkNXByby9yZWQ1cHJvLXZpZGVvLWpzLnN3Zidcbn1cbmNvbnN0IG9wdGlvbnNUb0hsc1VSTCA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHByb3RvY29sID0gb3B0aW9ucy5obHNwcm90b2NvbCA/IG9wdGlvbnMuaGxzcHJvdG9jb2wgOiBvcHRpb25zLnByb3RvY29sXG4gIGNvbnN0IHBvcnQgPSBvcHRpb25zLmhsc3BvcnQgPyBvcHRpb25zLmhsc3BvcnQgOiBvcHRpb25zLnBvcnRcbiAgY29uc3QgYXBwRW5kcG9pbnQgPSBvcHRpb25zLmNvbnRleHQgPyBbb3B0aW9ucy5hcHAsIG9wdGlvbnMuY29udGV4dF0uam9pbignLycpIDogb3B0aW9ucy5hcHBcbiAgcmV0dXJuIGAke3Byb3RvY29sfTovLyR7b3B0aW9ucy5ob3N0fToke3BvcnR9LyR7YXBwRW5kcG9pbnR9LyR7b3B0aW9ucy5zdHJlYW1OYW1lfS5tM3U4YFxufVxuXG5jbGFzcyBITFNTdWJzY3JpYmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudHMgPSB0aGlzLmJ1YmJsZVN1YnNjcmliZXJFdmVudHMuYmluZCh0aGlzKVxuICB9XG5cbiAgYnViYmxlU3Vic2NyaWJlckV2ZW50cyAoZXZlbnQpIHtcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChldmVudC50eXBlLCB0aGlzLCBldmVudC5kYXRhKSlcbiAgfVxuXG5cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgaWYgKCFlbnZpcm9ubWVudC5nZXRWaWRlb0pzKCkpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdCgnQ291bGQgbm90IHJlc29sdmUgSExTU3Vic2NyaWJlci4gUmVxdWlyZXMgdmlkZW9qcyBsaWJyYXJ5LicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcbiAgICAgIGRlZmVycmVkLnJlc29sdmUodGhpcylcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIHNldFZpZXcgKHZpZXcpIHtcbiAgICB0aGlzLl92aWV3ID0gdmlld1xuICAgIGlmICh0aGlzLl92aWRlb2pzSGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl92aWRlb2pzSGFuZGxlci5vZmYoJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudHMpXG4gICAgICB0aGlzLl92aWRlb2pzSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyID0gbmV3IFZpZGVvSlNIYW5kbGVyKHRoaXMuX3ZpZXcudmlldywgdGhpcy5nZXRUeXBlKCkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHBsYXkgKHN0cmVhbU5hbWUgPSBudWxsLCBwcm9taXNlID0gbnVsbCkge1xuICAgIGNvbnN0IHAgPSBwcm9taXNlIHx8IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGNvbnN0IHVybFJlZ2V4ID0gL15odHRwKHxzKS4qXFwubTN1OC9nXG4gICAgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lID0gc3RyZWFtTmFtZSB8fCB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWVcbiAgICBsZXQgdXJsID0gdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lLm1hdGNoKHVybFJlZ2V4KSA/IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSA6IG9wdGlvbnNUb0hsc1VSTCh0aGlzLl9vcHRpb25zKVxuICAgIGxldCB0eXBlID0gdGhpcy5fb3B0aW9ucy5taW1lVHlwZVxuICAgIGxldCBzd2ZVUkwgPSB0aGlzLl9vcHRpb25zLnN3ZlxuICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHR5cGUgPSB0aGlzLl9vcHRpb25zLnJ0bXBNaW1lVHlwZSB8fCB0aGlzLl9vcHRpb25zLm1pbWVUeXBlXG4gICAgfVxuICAgIGRlYnVnKE5BTUUsIGBbcGxheV06IFVSTCgke3VybH0pLmApXG4gICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIub24oJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudHMpXG4gICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIuYWRkU291cmNlKHVybCwgdHlwZSwgdmlkZW9qcywgc3dmVVJMKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBwLnJlc29sdmUodGhpcylcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9TVUNDRVNTKSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBwLnJlamVjdChlcnJvcilcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFKSlcbiAgICAgIH0pXG4gICAgcmV0dXJuIHAuaGFzT3duUHJvcGVydHkoJ3Byb21pc2UnKSA/IHAucHJvbWlzZSA6IHBcbiAgfVxuXG4gIHN0b3AgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbc3RvcF0nKVxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyLm9mZignKicsIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50cylcbiAgICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyLmRpc2Nvbm5lY3QoKVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KGUubWVzc2FnZSlcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGdldE9wdGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zXG4gIH1cblxuICBnZXRQbGF5ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl92aWRlb2pzSGFuZGxlci5nZXRQbGF5ZXIoKVxuICB9XG5cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuICdITFMnXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBITFNTdWJzY3JpYmVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8taGxzLmpzXG4gKiovIiwiLyoqXG4gKiBCYXNlIGhhbmRsZXIgZm9yIHV0aWxpemluZyB0aGUgdmlkZW9qc1xuICogbGlicmFyeSB0byBpbnRlcmdhdGUgcGxheWJhY2sgb2YgbGl2ZSB2aWRlby5cbiAqXG4gKiBAc2VlIHJlZDVwcm8taGxzXG4gKiBAc2VlIHJlZDVwcm8tcnRtcFxuICovXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnQgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IFN1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgYnJvd3NlciBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IGRlZXBEZWZpbmUgfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IGRlYnVnLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb0Jhc2VWaWRlb0pTSGFuZGxlcidcblxuY29uc3QgdmlkZW9qcyA9IGJyb3dzZXIuZ2V0VmlkZW9KcygpXG5jb25zdCBtaW1lVHlwZSA9ICd2aWRlby93ZWJtJ1xuY29uc3Qgb3B0aW9uc1RvVVJMID0gKG9wdGlvbnMpID0+IHtcbiAgdmFyIGFwcEVuZHBvaW50ID0gb3B0aW9ucy5jb250ZXh0ID8gW29wdGlvbnMuYXBwLCBvcHRpb25zLmNvbnRleHRdLmpvaW4oJy8nKSA6IG9wdGlvbnMuYXBwXG4gIHJldHVybiBgJHtvcHRpb25zLnByb3RvY29sfTovLyR7b3B0aW9ucy5ob3N0fToke29wdGlvbnMucG9ydH0vJHthcHBFbmRwb2ludH0vJHtvcHRpb25zLnN0cmVhbU5hbWV9YFxufVxuXG5jbGFzcyBCYXNlSGFuZGxlciBleHRlbmRzIEV2ZW50RW1pdHRlcntcblxuICBjb25zdHJ1Y3RvciAodmlkZW8sIHBsYXllclR5cGUgPSBudWxsKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMudmlkZW8gPSB2aWRlb1xuICAgIHRoaXMuY2xvbmUgPSB0aGlzLnZpZGVvLmNsb25lTm9kZSh0cnVlKVxuICAgIHRoaXMuaG9sZGVyID0gdGhpcy52aWRlby5wYXJlbnROb2RlXG4gICAgdGhpcy52aWRlb2pzID0gbnVsbFxuICAgIHRoaXMuc291cmNlID0gbnVsbFxuICAgIHRoaXMucGxheWVyVHlwZSA9IHBsYXllclR5cGVcbiAgICB0aGlzLmhhc0Fzc2lnbmVkRXZlbnRMaXN0ZW5lcnMgPSBmYWxzZVxuXG4gICAgLy8gIFRPRE86IFRlbXBvcmFyeSBhZGp1c3RtZW50LiBCZXR0ZXIgdG8gcGFzcyB2aWRlb2pzIHVwIHRoZSBjaGFpbiBzbyBlbmQgdXNlcnMgY2FuIHNldCB0aGVpciBvd24gaGFuZGxlcnMuXG4gICAgdGhpcy5vblZpZGVvSlNFcnJvciA9IHRoaXMub25WaWRlb0pTRXJyb3IuYmluZCh0aGlzKVxuICAgIHRoaXMub25WaWRlb0pTTG9hZGVkRGF0YSA9IHRoaXMub25WaWRlb0pTTG9hZGVkRGF0YS5iaW5kKHRoaXMpXG4gICAgdGhpcy5vblZpZGVvSlNMb2FkZWRNZXRhZGF0YSA9IHRoaXMub25WaWRlb0pTTG9hZGVkTWV0YWRhdGEuYmluZCh0aGlzKVxuICAgIHRoaXMub25WaWRlb0pTVGltZVVwZGF0ZSA9IHRoaXMub25WaWRlb0pTVGltZVVwZGF0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5vblZpZGVvSlNVc2VyQWN0aXZlID0gdGhpcy5vblZpZGVvSlNVc2VyQWN0aXZlLmJpbmQodGhpcylcbiAgICB0aGlzLm9uVmlkZW9KU1VzZXJJbmFjdGl2ZSA9IHRoaXMub25WaWRlb0pTVXNlckluYWN0aXZlLmJpbmQodGhpcylcbiAgICB0aGlzLm9uVmlkZW9KU1ZvbHVtZUNoYW5nZSA9IHRoaXMub25WaWRlb0pTVm9sdW1lQ2hhbmdlLmJpbmQodGhpcylcbiAgICB0aGlzLm9uVmlkZW9KU0VuZGVkID0gdGhpcy5vblZpZGVvSlNFbmRlZC5iaW5kKHRoaXMpXG4gIH1cblxuICAvLyAgQXNzaWduIGFsbCB2aWRlby5qcyBsaXN0ZW5lcnMgKHRob3NlIHdoaWNoIGFyZSBsaXN0ZWQgb24gaHR0cDovL2RvY3MudmlkZW9qcy5jb20vZG9jcy9hcGkvcGxheWVyLmh0bWwjZXZlbnRzKVxuICBhZGRWaWRlb0pTRXZlbnRMaXN0ZW5lcnMgKCkge1xuICAgIGlmICh0aGlzLmhhc0Fzc2lnbmVkRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnZpZGVvanMub24oJ2Vycm9yJywgdGhpcy5vblZpZGVvSlNFcnJvcilcbiAgICB0aGlzLnZpZGVvanMub24oJ2xvYWRlZGRhdGEnLCB0aGlzLm9uVmlkZW9KU0xvYWRlZERhdGEpXG4gICAgdGhpcy52aWRlb2pzLm9uKCdsb2FkZWRtZXRhZGF0YScsIHRoaXMub25WaWRlb0pTTG9hZGVkTWV0YWRhdGEpXG4gICAgdGhpcy52aWRlb2pzLm9uKCd0aW1ldXBkYXRlJywgdGhpcy5vblZpZGVvSlNUaW1lVXBkYXRlKVxuICAgIHRoaXMudmlkZW9qcy5vbigndXNlcmFjdGl2ZScsIHRoaXMub25WaWRlb0pTVXNlckFjdGl2ZSlcbiAgICB0aGlzLnZpZGVvanMub24oJ3VzZXJpbmFjdGl2ZScsIHRoaXMub25WaWRlb0pTVXNlckluYWN0aXZlKVxuICAgIHRoaXMudmlkZW9qcy5vbigndm9sdW1lY2hhbmdlJywgdGhpcy5vblZpZGVvSlNWb2x1bWVDaGFuZ2UpXG4gICAgdGhpcy52aWRlb2pzLm9uKCdlbmRlZCcsIHRoaXMub25WaWRlb0pTRW5kZWQpXG4gICAgdGhpcy5oYXNBc3NpZ25lZEV2ZW50TGlzdGVuZXJzID0gdHJ1ZVxuICB9XG5cbiAgLy8gIFJlbW92ZSBhbGwgdmlkZW8uanMgbGlzdGVuZXJzICh0aG9zZSB3aGljaCBhcmUgbGlzdGVkIG9uIGh0dHA6Ly9kb2NzLnZpZGVvanMuY29tL2RvY3MvYXBpL3BsYXllci5odG1sI2V2ZW50cylcbiAgcmVtb3ZlVmlkZW9KU0V2ZW50TGlzdGVuZXJzICgpIHtcbiAgICBpZiAoIXRoaXMuaGFzQXNzaWduZWRFdmVudExpc3RlbmVycykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMudmlkZW9qcy5vZmYoJ2Vycm9yJywgdGhpcy5vblZpZGVvSlNFcnJvcilcbiAgICB0aGlzLnZpZGVvanMub2ZmKCdsb2FkZWRkYXRhJywgdGhpcy5vblZpZGVvSlNMb2FkZWREYXRhKVxuICAgIHRoaXMudmlkZW9qcy5vZmYoJ2xvYWRlZG1ldGFkYXRhJywgdGhpcy5vblZpZGVvSlNMb2FkZWRNZXRhZGF0YSlcbiAgICB0aGlzLnZpZGVvanMub2ZmKCd0aW1ldXBkYXRlJywgdGhpcy5vblZpZGVvSlNUaW1lVXBkYXRlKVxuICAgIHRoaXMudmlkZW9qcy5vZmYoJ3VzZXJhY3RpdmUnLCB0aGlzLm9uVmlkZW9KU1VzZXJBY3RpdmUpXG4gICAgdGhpcy52aWRlb2pzLm9mZigndXNlcmluYWN0aXZlJywgdGhpcy5vblZpZGVvSlNVc2VySW5hY3RpdmUpXG4gICAgdGhpcy52aWRlb2pzLm9mZigndm9sdW1lY2hhbmdlJywgdGhpcy5vblZpZGVvSlNWb2x1bWVDaGFuZ2UpXG4gICAgdGhpcy52aWRlb2pzLm9mZignZW5kZWQnLCB0aGlzLm9uVmlkZW9KU0VuZGVkKVxuICAgIHRoaXMuaGFzQXNzaWduZWRFdmVudExpc3RlbmVycyA9IGZhbHNlXG4gIH1cblxuICAvLyAgQ2xlYW51cCBvdXIgPHNvdXJjZT4gaWYgaXQgZXhpc3RzXG4gIGNsZWFudXAgKCkge1xuICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UucmVtb3ZlKClcbiAgICB9XG4gICAgdGhpcy5zb3VyY2UgPSBudWxsXG4gIH1cblxuICAvLyAgQ2xlYW51cCBvdXIgdmlkZW8uanMgaW1wbGVtZW50YXRpb25cbiAgY2xlYW51cFZpZGVvSlMgKCkge1xuICAgIGlmICh0aGlzLnZpZGVvanMpIHtcbiAgICAgIHRoaXMudmlkZW8ucmVtb3ZlKClcbiAgICAgIHRoaXMucmVtb3ZlVmlkZW9KU0V2ZW50TGlzdGVuZXJzKClcbiAgICAgIHRoaXMudmlkZW9qcy5kaXNwb3NlKClcbiAgICAgIC8vICBUaGlzIHJlY3JlYXRlcyBvdXIgb3JpZ2luYWwgPHZpZGVvPiBlbGVtZW50IGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBvcmlnaW5hbCBjb250YWluaW5nIGVsZW1lbnRcbiAgICAgIHRoaXMudmlkZW8gPSB0aGlzLmNsb25lLmNsb25lTm9kZSh0cnVlKVxuICAgICAgdGhpcy5ob2xkZXIuYXBwZW5kQ2hpbGQodGhpcy52aWRlbylcbiAgICB9XG4gICAgdGhpcy52aWRlb2pzID0gbnVsbFxuICB9XG5cbiAgLy8gIEFkZCBhIG5ldyA8c291cmNlPiBmb3Igb3VyIDx2aWRlbz4gYW5kIHN0YXJ0dXAgdmlkZW8uanNcbiAgYWRkU291cmNlIChzcmMsIHR5cGUgPSBtaW1lVHlwZSwgdmlkZW9JbXBsID0gdmlkZW9qcywgc3dmVVJMID0gbnVsbCkge1xuICAgIGxldCBzZWxmID0gdGhpc1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlU291cmNlIChfc3JjLCBfdHlwZSkge1xuICAgICAgbGV0IHNvdXJjZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJylcbiAgICAgIHNvdXJjZUVsLnNyYyA9IF9zcmNcbiAgICAgIHNvdXJjZUVsLnR5cGUgPSBfdHlwZVxuICAgICAgcmV0dXJuIHNvdXJjZUVsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0U291cmNlSW50byAoX3NyYywgX3R5cGUsIF9wYXJlbnQpIHtcbiAgICAgIGxldCBzb3VyY2VFbCA9IGNyZWF0ZVNvdXJjZShfc3JjLCBfdHlwZSlcbiAgICAgIGlmIChfcGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgX3BhcmVudC5pbnNlcnRCZWZvcmUoc291cmNlRWwsIF9wYXJlbnQuZmlyc3RDaGlsZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9wYXJlbnQuYXBwZW5kQ2hpbGQoc291cmNlRWwpXG4gICAgICB9XG4gICAgICByZXR1cm4gc291cmNlRWxcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gIElmIHdlIGhhdmUgYSBjdXJyZW50IDxzb3VyY2U+IGVsZW1lbnQsIHJlbW92ZSBpdFxuICAgICAgICBzZWxmLmNsZWFudXAoKVxuICAgICAgICAvLyAgSWYgdmlkZW8uanMgaGFzIGFscmVhZHkgYmVlbiBpbnN0YW50aWF0ZWQsIGRpc3Bvc2Ugb2YgaXRcbiAgICAgICAgc2VsZi5jbGVhbnVwVmlkZW9KUygpXG5cbiAgICAgICAgLy8gIENyZWF0ZSB0aGUgbmV3IDxzb3VyY2U+IGVsZW1lbnRcbiAgICAgICAgY29uc3Qgc3JjVVJMID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyBzcmMgOiBvcHRpb25zVG9VUkwoc3JjKVxuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gdHlwZSA6ICgoc3JjLm1pbWVUeXBlKSA/IHNyYy5taW1lVHlwZSA6IHR5cGUpXG4gICAgICAgIGRlYnVnKE5BTUUsIGBcIiR7c2VsZi5wbGF5ZXJUeXBlfVwiIGxvYWRpbmcgJHtzcmNVUkx9YClcbiAgICAgICAgc2VsZi5zb3VyY2UgPSBpbnNlcnRTb3VyY2VJbnRvKHNyY1VSTCwgbWltZVR5cGUsIHNlbGYudmlkZW8pXG5cbiAgICAgICAgLy8gIEluc3RhbnRpYXRlIHZpZGVvLmpzXG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgdGVjaE9yZGVyOiBbJ2h0bWw1JywgJ2ZsYXNoJ11cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3dmVVJMKSB7XG4gICAgICAgICAgZGVlcERlZmluZSh2aWRlb0ltcGwsIFsnb3B0aW9ucycsICdmbGFzaCcsICdzd2YnXSwgc3dmVVJMKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9yaWVudGF0aW9uID0gMFxuICAgICAgICBzZWxmLnZpZGVvanMgPSB2aWRlb0ltcGwoc2VsZi52aWRlbywgb3B0cywgKCkgPT4ge1xuICAgICAgICAgIGRlYnVnKE5BTUUsICd2aWRlb0pTIGVtYmVkIGNvbXBsZXRlLicpXG4gICAgICAgICAgbGV0IHBsYXllciA9IHNlbGYuZ2V0UGxheWVyKClcbiAgICAgICAgICBpZiAocGxheWVyKSB7XG4gICAgICAgICAgICBicm93c2VyLm9uT3JpZW50YXRpb25NZXRhZGF0YShwbGF5ZXIsIChtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBkZWJ1ZyhOQU1FLCAnTWV0YWRhdGEgcmVjZWl2ZWQ6ICcgKyBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSwgbnVsbCwgMikpXG4gICAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiAhPT0gbWV0YWRhdGEub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICBicm93c2VyLmFwcGx5T3JpZW50YXRpb24oc2VsZi52aWRlbywgbWV0YWRhdGEub3JpZW50YXRpb24pXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX01FVEFEQVRBLCBtZXRhZGF0YSkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3JpZW50YXRpb24gPSBtZXRhZGF0YS5vcmllbnRhdGlvblxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShzZWxmKVxuICAgICAgICB9KVxuICAgICAgICBzZWxmLmFkZFZpZGVvSlNFdmVudExpc3RlbmVycygpXG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcihOQU1FLCBgQ291bGQgbm90IGluc3RhbnRpYXRlIG5ldyBWaWRlb0pTLWJhc2VkIFwiJHtzZWxmLnBsYXllclR5cGV9XCIgUGxheWVyLlxcblJlYXNvbjogJHtlLm1lc3NhZ2V9YClcbiAgICAgICAgcmVqZWN0KGBDb3VsZCBub3QgaW5zdGFudGlhdGUgbmV3IFZpZGVvSlMtYmFzZWQgXCIke3NlbGYucGxheWVyVHlwZX1cIiBQbGF5ZXIuXFxuUmVhc29uOiAke2UubWVzc2FnZX1gKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBvblZpZGVvSlNFcnJvciAoZSkge1xuICAgIGVycm9yKE5BTUUsICdvblZpZGVvSlNFcnJvcjogJyArIEpTT04uc3RyaW5naWZ5KGUsIG51bGwsIDIpKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9GQUlMLCBudWxsLCBlKSlcbiAgfVxuXG4gIG9uVmlkZW9KU0xvYWRlZERhdGEgKCkge1xuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9TVEFSVCkpXG4gIH1cblxuICBvblZpZGVvSlNFbmRlZCAoKSB7XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX1NUT1ApKVxuICB9XG5cbiAgb25WaWRlb0pTTG9hZGVkTWV0YWRhdGEgKCkge31cblxuICBvblZpZGVvSlNUaW1lVXBkYXRlICgpIHt9XG5cbiAgb25WaWRlb0pTVXNlckFjdGl2ZSAoKSB7fVxuXG4gIG9uVmlkZW9KU1VzZXJJbmFjdGl2ZSAoKSB7fVxuXG4gIG9uVmlkZW9KU1ZvbHVtZUNoYW5nZSAoKSB7fVxuXG4gIGFkZFNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgLy8gdW5zdXBwb3J0ZWQgYXQgdGhlIG1vbWVudC5cbiAgfVxuXG4gIHJlbW92ZVNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgLy8gdW5zdXBwb3J0ZWQgYXQgdGhlIG1vbWVudC5cbiAgfVxuXG4gIHNlbmRUb1NoYXJlZE9iamVjdCAobmFtZSwgY2FsbE5hbWUsIG1lc3NhZ2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIC8vIHVuc3VwcG9ydGVkIGF0IHRoZSBtb21lbnQuXG4gIH1cblxuICBzZW5kUHJvcGVydHlUb1NoYXJlZE9iamVjdCAobmFtZSwga2V5LCB2YWx1ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgLy8gdW5zdXBwb3J0ZWQgYXQgdGhlIG1vbWVudC5cbiAgfVxuXG4gIGdldFJlbW90ZVNoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgLy8gdW5zdXBwb3J0ZWQgYXQgdGhlIG1vbWVudC5cbiAgfVxuXG4gIGNvbm5lY3RUb1NoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgLy8gdW5zdXBwb3J0ZWQgYXQgdGhlIG1vbWVudC5cbiAgfVxuXG4gIGRpc2Nvbm5lY3RGcm9tU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAvLyB1bnN1cHBvcnRlZCBhdCB0aGUgbW9tZW50LlxuICB9XG5cbiAgZ2V0UGxheWVyICgpIHtcbiAgICByZXR1cm4gdGhpcy52aWRlb2pzXG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJUeXBlXG4gIH1cblxuICBkaXNjb25uZWN0ICgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy52aWRlby5wYXVzZSgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gbmFkYS5cbiAgICB9XG4gICAgdGhpcy5jbGVhbnVwKClcbiAgICB0aGlzLmNsZWFudXBWaWRlb0pTKClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlSGFuZGxlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvc3Vic2NyaWJlci92aWRlb2pzLXNvdXJjZS1oYW5kbGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kaWZpZXMgdGFyZ2V0IGBvYmplY3RgIGluIHBsYWNlIHdpdGggYSBuYW1lc3BhY2VkIHZhbHVlLlxuICovXG5leHBvcnQgY29uc3QgZGVlcERlZmluZSA9IChvYmplY3QsIHBhdGhzLCB2YWx1ZSkgPT4ge1xuICBsZXQgaSA9IDBcbiAgbGV0IHRhaWwgPSBvYmplY3RcbiAgY29uc3QgcHJvcCA9IHBhdGhzLnBvcCgpXG4gIGNvbnN0IGxlbmd0aCA9IHBhdGhzLmxlbmd0aFxuICBmb3IgKGk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGxldCBwYXRoID0gcGF0aHNbaV1cbiAgICB0YWlsW3BhdGhdID0gdGFpbFtwYXRoXSB8fCB7fVxuICAgIHRhaWwgPSB0YWlsW3BhdGhdXG4gIH1cbiAgdGFpbFtwcm9wXSA9IHZhbHVlXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy91dGlsL29iamVjdC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCBWaWRlb0pTU3Vic2NyaWJlciBmcm9tICcuL3JlZDVwcm8tcnRtcC12aWRlb2pzJ1xuaW1wb3J0IFI1TGl2ZVN1YnNjcmliZXIgZnJvbSAnLi9yZWQ1cHJvLXJ0bXAtbGl2ZSdcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvUlRNUFN1YnNjcmliZXJQcm94eSdcblxuY2xhc3MgUlRNUFN1YnNjcmliZXJQcm94eSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fYm91bmRCdWJibGVTdWJJbXBsRXZlbnQgPSB0aGlzLmJ1YmJsZVN1YnNjcmliZXJFdmVudC5iaW5kKHRoaXMpXG4gIH1cblxuICBpbml0IChvcHRpb25zKSB7XG4gICAgbGV0IGltcGxcbiAgICBkZWJ1ZyhOQU1FLCBgT3B0aW9ucyBwcm9wZXJ0eSBmb3IgdXNlVmlkZW9KUzogJHtvcHRpb25zLnVzZVZpZGVvSlN9LmApXG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3VzZVZpZGVvSlMnKSAmJiB0eXBlb2Ygb3B0aW9ucy51c2VWaWRlb0pTID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy51c2VWaWRlb0pTKSB7XG4gICAgICBkZWJ1ZyhOQU1FLCAnRGVmYXVsdCB0byBSVE1QU3Vic2NyaWJlciB1c2luZyB2aWRlb2pzIHN1cHBvcnQuJylcbiAgICAgIGltcGwgPSBuZXcgVmlkZW9KU1N1YnNjcmliZXIoKVxuICAgICAgaW1wbC5vbignKicsIHRoaXMuX2JvdW5kQnViYmxlU3ViSW1wbEV2ZW50KVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGRlYnVnKE5BTUUsICdEZWZhdWx0aW5nIHRvIFJUTVBTdWJzY3JpYmVyIHVzaW5nIGN1c3RvbSBsaXZlIFNXRi4nKVxuICAgICAgaW1wbCA9IG5ldyBSNUxpdmVTdWJzY3JpYmVyKClcbiAgICAgIGltcGwub24oJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVN1YkltcGxFdmVudClcbiAgICB9XG4gICAgaWYgKHRoaXMuX3ZpZXcpIHtcbiAgICAgIGltcGwuc2V0Vmlldyh0aGlzLl92aWV3KVxuICAgICAgdGhpcy5fdmlldyA9IHVuZGVmaW5lZFxuICAgIH1cbiAgICByZXR1cm4gaW1wbC5pbml0KG9wdGlvbnMpXG4gIH1cblxuICBzZXRWaWV3ICh2aWV3KSB7XG4gICAgdGhpcy5fdmlldyA9IHZpZXdcbiAgfVxuXG4gIGJ1YmJsZVN1YnNjcmliZXJFdmVudCAoc3Vic2NyaWJlckV2ZW50KSB7XG4gICAgdGhpcy50cmlnZ2VyLmNhbGwodGhpcywgc3Vic2NyaWJlckV2ZW50KVxuICB9XG5cbiAgZ2V0T3B0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnNcbiAgfVxuXG4gIGdldFR5cGUgKCkge1xuICAgIHJldHVybiAnUlRNUFN1YnNjcmliZXJQcm94eSdcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJUTVBTdWJzY3JpYmVyUHJveHlcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3N1YnNjcmliZXIvcmVkNXByby1ydG1wLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IFZpZGVvSlNIYW5kbGVyIGZyb20gJy4vdmlkZW9qcy1zb3VyY2UtaGFuZGxlcidcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvUlRNUFN1YnNjcmliZXInXG5jb25zdCB2aWRlb2pzID0gZW52aXJvbm1lbnQuZ2V0VmlkZW9KcygpXG5jb25zdCBkZWZhdWx0TWltZVR5cGUgPSAncnRtcC9mbHYnXG5jb25zdCBkZWZhdWx0Rmxhc2hWZXJzaW9uID0gJzEwLjAuMCdcbmNvbnN0IGRlZmF1bHRTV0YgPSAnbGliL3JlZDVwcm8vcmVkNXByby12aWRlby1qcy5zd2YnXG5jb25zdCBvcHRpb25zVG9SdG1wVVJMID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcHJvdG9jb2wgPSBvcHRpb25zLnJ0bXBwcm90b2NvbCA/IG9wdGlvbnMucnRtcHByb3RvY29sIDogb3B0aW9ucy5wcm90b2NvbFxuICBjb25zdCBwb3J0ID0gb3B0aW9ucy5ydG1wcG9ydCA/IG9wdGlvbnMucnRtcHBvcnQgOiBvcHRpb25zLnBvcnRcbiAgY29uc3QgYXBwRW5kcG9pbnQgPSBvcHRpb25zLmNvbnRleHQgPyBbb3B0aW9ucy5hcHAsIG9wdGlvbnMuY29udGV4dF0uam9pbignLycpIDogb3B0aW9ucy5hcHBcbiAgcmV0dXJuIGAke3Byb3RvY29sfTovLyR7b3B0aW9ucy5ob3N0fToke3BvcnR9LyR7YXBwRW5kcG9pbnR9LyR7b3B0aW9ucy5zdHJlYW1OYW1lfWBcbn1cblxuY2xhc3MgVmlkZW9KU1N1YnNjcmliZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fb3B0aW9ucyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3ZpZXcgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWRlb2pzSGFuZGxlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50cyA9IHRoaXMuYnViYmxlU3Vic2NyaWJlckV2ZW50cy5iaW5kKHRoaXMpXG4gIH1cblxuICBidWJibGVTdWJzY3JpYmVyRXZlbnRzIChldmVudCkge1xuICAgIHRoaXMudHJpZ2dlci5jYWxsKHRoaXMsIGV2ZW50KVxuICB9XG5cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgaWYgKCFlbnZpcm9ubWVudC5zdXBwb3J0c0ZsYXNoVmVyc2lvbihkZWZhdWx0Rmxhc2hWZXJzaW9uKSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KGBDb3VsZCBub3QgcmVzb2x2ZSBSVE1QU3Vic2NyaWJlciBpbnN0YW5jZS4gUmVxdWlyZXMgbWluaW11bSBGbGFzaCBQbGF5ZXIgaW5zdGFsbCBvZiAke2RlZmF1bHRGbGFzaFZlcnNpb259LmApXG4gICAgfSBlbHNlIGlmICghZW52aXJvbm1lbnQuZ2V0VmlkZW9KcygpKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoJ0NvdWxkIG5vdCByZXNvbHZlIFJUTVBTdWJzY3JpYmVyIGluc3RhbmNlLiBSZXF1aXJlcyB2aWRlb2pzIGxpYnJhcnkuJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnNcbiAgICAgIGRlZmVycmVkLnJlc29sdmUodGhpcylcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIHNldFZpZXcgKHZpZXcpIHtcbiAgICB0aGlzLl92aWV3ID0gdmlld1xuICAgIGlmICh0aGlzLl92aWRlb2pzSGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl92aWRlb2pzSGFuZGxlci5vZmYoJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudHMpXG4gICAgICB0aGlzLl92aWRlb2pzSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIGlmICh2aWV3KSB7XG4gICAgICB0aGlzLl92aWRlb2pzSGFuZGxlciA9IG5ldyBWaWRlb0pTSGFuZGxlcih0aGlzLl92aWV3LnZpZXcsIHRoaXMuZ2V0VHlwZSgpKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcGxheSAoc3RyZWFtTmFtZSA9IG51bGwsIHByb21pc2UgPSBudWxsKSB7XG4gICAgY29uc3QgcCA9IHByb21pc2UgfHwgbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lID0gc3RyZWFtTmFtZSB8fCB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWVcbiAgICBsZXQgdXJsID0gb3B0aW9uc1RvUnRtcFVSTCh0aGlzLl9vcHRpb25zKVxuICAgIGxldCB0eXBlID0gZGVmYXVsdE1pbWVUeXBlXG4gICAgbGV0IHN3ZlVSTCA9IGRlZmF1bHRTV0ZcbiAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICB0eXBlID0gdGhpcy5fb3B0aW9ucy5ydG1wTWltZVR5cGUgfHwgdGhpcy5fb3B0aW9ucy5taW1lVHlwZSB8fCB0eXBlXG4gICAgICBzd2ZVUkwgPSB0aGlzLl9vcHRpb25zLnN3ZiB8fCBzd2ZVUkxcbiAgICB9XG4gICAgZGVidWcoTkFNRSwgYFtwbGF5XTogVVJMKCR7dXJsfSkuYClcbiAgICB0aGlzLl92aWRlb2pzSGFuZGxlci5vbignKicsIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50cylcbiAgICB0aGlzLl92aWRlb2pzSGFuZGxlci5hZGRTb3VyY2UodXJsLCB0eXBlLCB2aWRlb2pzLCBzd2ZVUkwpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHAucmVzb2x2ZSh0aGlzKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChwLnJlamVjdClcbiAgICByZXR1cm4gcC5oYXNPd25Qcm9wZXJ0eSgncHJvbWlzZScpID8gcC5wcm9taXNlIDogcFxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzdG9wXScpXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0cnkge1xuICAgICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIub2ZmKCcqJywgdGhpcy5fYm91bmRCdWJibGVTdWJzY3JpYmVyRXZlbnRzKVxuICAgICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIuZGlzY29ubmVjdCgpXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoZS5tZXNzYWdlKVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgZ2V0Q29ubmVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZGVvanNIYW5kbGVyXG4gIH1cblxuICBnZXRPcHRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9uc1xuICB9XG5cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuICdSVE1QIC0gVmlkZW9KUydcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFZpZGVvSlNTdWJzY3JpYmVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRtcC12aWRlb2pzLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IHsgU3Vic2NyaWJlckV2ZW50IH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgTGl2ZVNvdXJjZUhhbmRsZXIgZnJvbSAnLi9saXZlLXNvdXJjZS1oYW5kbGVyJ1xuaW1wb3J0IHsgU3Vic2NyaWJlckV2ZW50VHlwZXMsIFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IHsgZGVidWcsIGVycm9yIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvTGl2ZVJUTVBTdWJjcmliZXInXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgcHJvdG9jb2w6ICdydG1wJyxcbiAgcG9ydDogMTkzNSxcbiAgd2lkdGg6IDMyMCwgLy8gdmlkZW8gcGxheWJhY2tcbiAgaGVpZ2h0OiAyNDAsIC8vIHZpZGVvIHBsYXliYWNrXG4gIGVtYmVkV2lkdGg6ICcxMDAlJywgLy8gRE9NIGRpc3BsYXkgc3R5bGVcbiAgZW1iZWRIZWlnaHQ6ICcxMDAlJywgLy8gRE9NIGRpc3BsYXkgc3R5bGVcbiAgbWluRmxhc2hWZXJzaW9uOiAnMTAuMC4wJyxcbiAgc3dmOiAnbGliL3JlZDVwcm8vcmVkNXByby1zdWJzY3JpYmVyLnN3ZicsXG4gIHN3Zm9iamVjdFVSTDogJ2xpYi9yZWQ1cHJvL3JlZDVwcm8tc3Vic2NyaWJlci5zd2YnLFxuICBwcm9kdWN0SW5zdGFsbFVybDogJ2xpYi9zd2ZvYmplY3QvcGxheWVyUHJvZHVjdEluc3RhbGwuc3dmJ1xufVxuXG5jbGFzcyBSNUxpdmVTdWJzY3JpYmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc291cmNlSGFuZGxlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2VsZW1lbnRJZCA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3BsYXliYWNrUHJvbWlzZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCB2ZXJzaW9uID0gb3B0aW9ucy5taW5GbGFzaFZlcnNpb24gfHwgZGVmYXVsdE9wdGlvbnMubWluRmxhc2hWZXJzaW9uXG4gICAgaWYgKCFlbnZpcm9ubWVudC5zdXBwb3J0c0ZsYXNoVmVyc2lvbih2ZXJzaW9uKSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KGBDb3VsZCBub3QgcmVzb2x2ZSBMaXZlUlRNUFN1YnNjcmliZXIgaW5zdGFuY2UuIFJlcXVpcmVzIG1pbmltdW0gRmxhc2ggUGxheWVyIGluc3RhbGwgb2YgJHt2ZXJzaW9ufS5gKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpXG4gICAgICB0cnkge1xuICAgICAgICBlbnZpcm9ubWVudC5pbmplY3RTY3JpcHQodGhpcy5fb3B0aW9ucy5zd2ZvYmplY3RVUkwpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoTkFNRSwgJ1NXRk9iamVjdCBlbWJlZGRlZC4nKVxuICAgICAgICAgICAgaWYgKHNlbGYuX3NvdXJjZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3NvdXJjZUhhbmRsZXIuYWRkU291cmNlKHNlbGYuX2VsZW1lbnRJZCwgc2VsZi5fb3B0aW9ucylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHNlbGYpXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVE1QU3Vic2NyaWJlckV2ZW50VHlwZXMuRU1CRURfU1VDQ0VTUywgc2VsZikpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGVycm9yKE5BTUUsIGBDb3VsZCBub3QgZW1iZWQgRmxhc2gtYmFzZWQgUlRNUCBQbGF5ZXIuIFJlYXNvbjogJHtlcnJ9YClcbiAgICAgICAgICAgIGlmIChzZWxmLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIHNlbGYuX3NvdXJjZUhhbmRsZXIuZGlzY29ubmVjdCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVE1QU3Vic2NyaWJlckV2ZW50VHlwZXMuRU1CRURfRkFJTFVSRSwgc2VsZikpXG4gICAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGBDb3VsZCBub3QgaW5qZWN0IEZsYXNoLWJhc2VkIFBsYXllciBpbnRvIHRoZSBwYWdlLiBSZWFzb246ICR7ZS5tZXNzYWdlfWApXG4gICAgICAgIHNlbGYudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcy5FTUJFRF9GQUlMVVJFLCBzZWxmKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIHNldFZpZXcgKHZpZXcsIGVsZW1lbnRJZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgdGhpcy5fdmlldyA9IHZpZXdcbiAgICB0aGlzLl9lbGVtZW50SWQgPSBlbGVtZW50SWRcbiAgICBpZiAodGhpcy5fc291cmNlSGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmRpc2Nvbm5lY3QoKVxuICAgICAgdGhpcy5fc291cmNlSGFuZGxlciA9IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmICh2aWV3KSB7XG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyID0gbmV3IExpdmVTb3VyY2VIYW5kbGVyKHRoaXMuX3ZpZXcudmlldywgdGhpcy5nZXRUeXBlKCkpXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmFkZFNvdXJjZSh0aGlzLl9lbGVtZW50SWQsIHRoaXMuX29wdGlvbnMpXG4gICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcy5FTUJFRF9GQUlMVVJFLCBzZWxmKSlcblxuICAgICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBfZXN0YWJsaXNoRXh0SW50SGFuZGxlcnMgKCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgY29uc3QgaW52b2tlRm4gPSAobGFiZWwpID0+IHtcbiAgICAgIHJldHVybiBbJ3N1YnNjcmliZXInLCBsYWJlbCwgaWRdLmpvaW4oJ18nKVxuICAgIH1cbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvQ29ubmVjdFN1Y2Nlc3MnKV0gPSAoKSA9PiB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUX1NVQ0NFU1MsIHRoaXMpKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9Db25uZWN0RmFpbHVyZScpXSA9ICgpID0+IHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSwgdGhpcykpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZVN0b3AnKV0gPSAoKSA9PiB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU1RPUCwgdGhpcykpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZUludmFsaWROYW1lJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX0lOVkFMSURfTkFNRSwgdGhpcykpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZU1ldGFkYXRhJyldID0gKG1ldGFkYXRhKSA9PiB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfTUVUQURBVEEsIHRoaXMsIG1ldGFkYXRhKSlcbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlU3RhcnQnKV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9wbGF5YmFja1Byb21pc2UucmVzb2x2ZSh0aGlzKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX1NUQVJULCB0aGlzKSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZUZhaWwnKV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9wbGF5YmFja1Byb21pc2UucmVqZWN0KFwiRmFpbGVkIHRvIHN0YXJ0IHBsYXliYWNrIHN0cmVhbS5cIilcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9GQUlMLCB0aGlzKSlcbiAgICB9XG5cbiAgfVxuXG4gIHBsYXkgKHN0cmVhbU5hbWUgPSBudWxsLCBwcm9taXNlID0gbnVsbCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdGhpcy5fcGxheWJhY2tQcm9taXNlID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5fZXN0YWJsaXNoRXh0SW50SGFuZGxlcnMoKVxuICAgIHJldHVybiB0aGlzLl9wbGF5YmFja1Byb21pc2UucHJvbWlzZVxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgY29uc3QgY2IgPSAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmRpc2Nvbm5lY3QoKVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUubWVzc2FnZSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcGxheWJhY2tQcm9taXNlID0gdW5kZWZpbmVkXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGNiKVxuICB9XG5cbiAgZ2V0Q29ubmVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZUhhbmRsZXJcbiAgfVxuXG4gIGdldE9wdGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zXG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gJ1JUTVAnXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSNUxpdmVTdWJzY3JpYmVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRtcC1saXZlLmpzXG4gKiovIiwiJ3VzZSBzY3JpcHQnXG5cbmltcG9ydCAqIGFzIGVtYmVkIGZyb20gJy4uL2Vudi9lbWJlZCdcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nJ1xuaW1wb3J0IFJUTVBTaGFyZWRPYmplY3RIYW5kbGVyIGZyb20gJy4uL2hlbHBlci9zaGFyZWRvYmplY3QtaGVscGVyLXJ0bXAnXG5cbmNvbnN0IE5BTUUgPSAnUlRNUExpdmVTb3VyY2VIYW5kbGVyJ1xuY29uc3QgdG9JbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUucGFyc2VJbnQoMTApXG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpXG4gIH1cbn1cblxuY2xhc3MgTGl2ZVNvdXJjZUhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yICh2aWRlbywgdHlwZSwgc29SZXNwb25kZXIgPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnZpZGVvID0gdmlkZW9cbiAgICB0aGlzLmNsb25lID0gdGhpcy52aWRlby5jbG9uZU5vZGUodHJ1ZSlcbiAgICB0aGlzLmhvbGRlciA9IHRoaXMudmlkZW8ucGFyZW50Tm9kZVxuICAgIHRoaXMucGxheWVyVHlwZSA9IHR5cGVcbiAgICB0aGlzLl9zd2ZJZCA9IG51bGxcbiAgICB0aGlzLl9zb1Jlc3BvbmRlciA9IHNvUmVzcG9uZGVyIHx8IG5ldyBSVE1QU2hhcmVkT2JqZWN0SGFuZGxlcigpXG4gIH1cblxuICBjbGVhblVwICgpIHtcbiAgICAvLyBSZXR1cm4gdG8gcHJpb3IgRE9NIG1hbmlwdWxhdGlvbi5cbiAgICB0aGlzLnZpZGVvLnJlbW92ZSgpXG4gICAgdGhpcy52aWRlbyA9IHRoaXMuY2xvbmUuY2xvbmVOb2RlKHRydWUpXG4gICAgdGhpcy5ob2xkZXIuYXBwZW5kQ2hpbGQodGhpcy52aWRlbylcbiAgfVxuXG4gIF9zZXRVcEluaXRDYWxsYmFjayAocHJvbWlzZSkge1xuICAgIHdpbmRvdy5zZXRTdWJzY3JpYmVySWQgPSAoc3VjY2Vzc0lkKSA9PiB7XG4gICAgICAvLyBzdWNjZXNzSWQgPT09IF9vcHRpb25zLnN0cmVhbU5hbWVcbiAgICAgIGRlYnVnKE5BTUUsIGBFbWJlZCBhbmQgaW5pdCgpIGNvbXBsZXRlIGZvciBzdWJzY3JpYmVyIHN3Zi4gc3VjY2Vzc0lkKCR7c3VjY2Vzc0lkfSkuYClcbiAgICAgIHByb21pc2UucmVzb2x2ZShzdWNjZXNzSWQpXG4gICAgICB0aGlzLl90ZWFyRG93bkluaXRDYWxsYmFjaygpXG4gICAgfVxuICAgIC8vIFRPRE86IFNldHVwIHRpbWVvdXQgdG8gcmVqZWN0P1xuICB9XG5cbiAgX3RlYXJEb3duSW5pdENhbGxiYWNrICgpIHtcbiAgICB3aW5kb3cuc2V0QWN0aXZlSWQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGFkZFNvdXJjZSAoc3dmSWQsIG9wdGlvbnMsIHN3ZlVybCA9IG51bGwsIG1pbkZsYXNoVmVyc2lvbiA9IG51bGwpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2FkZHNvdXJjZV0nKVxuICAgIHRoaXMuX3N3ZklkID0gc3dmSWQ7XG4gICAgY29uc3Qgc29SZXNwb25kZXIgPSB0aGlzLl9zb1Jlc3BvbmRlclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgb3B0aW9ucy5zd2YgPSBzd2ZVcmwgfHwgb3B0aW9ucy5zd2ZcbiAgICBvcHRpb25zLm1pbkZsYXNoVmVyc2lvbiA9IG1pbkZsYXNoVmVyc2lvbiB8fCBvcHRpb25zLm1pbkZsYXNoVmVyc2lvblxuICAgIHRoaXMuX3NldFVwSW5pdENhbGxiYWNrKGRlZmVycmVkKVxuICAgIGVtYmVkLmRlZmluZUVtYmVkRWxlbWVudCh0aGlzLnZpZGVvLCB0aGlzLmhvbGRlcilcbiAgICAgIC50aGVuKGVsZW1lbnRJZCA9PiB7XG4gICAgICAgIGxldCBmbGFzaHZhcnMgPSB7XG4gICAgICAgICAgc3RyZWFtOiBvcHRpb25zLnN0cmVhbU5hbWUsXG4gICAgICAgICAgYXBwOiBvcHRpb25zLmNvbnRleHQgPyBgJHtvcHRpb25zLmFwcH0vJHtvcHRpb25zLmNvbnRleHR9YCA6IG9wdGlvbnMuYXBwLFxuICAgICAgICAgIGhvc3Q6IG9wdGlvbnMuaG9zdFxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmJ1ZmZlciAmJiAhaXNOYU4oTnVtYmVyKG9wdGlvbnMuYnVmZmVyKSkpIHtcbiAgICAgICAgICBmbGFzaHZhcnMuYnVmZmVyID0gb3B0aW9ucy5idWZmZXJcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAmJiAhaXNOYU4ob3B0aW9ucy53aWR0aCkpIHtcbiAgICAgICAgICBmbGFzaHZhcnMud2lkdGggPSB0b0ludChvcHRpb25zLndpZHRoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmhlaWdodCAmJiAhaXNOYU4ob3B0aW9ucy5oZWlnaHQpKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLmhlaWdodCA9IHRvSW50KG9wdGlvbnMuaGVpZ2h0KVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVtYmVkV2lkdGggPT09ICcxMDAlJyB8fCBvcHRpb25zLmVtYmVkSGVpZ2h0ID09PSAnMTAwJScpIHtcbiAgICAgICAgICBmbGFzaHZhcnMuYXV0b3NpemUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbm5lY3Rpb25QYXJhbXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLmNvbm5lY3Rpb25QYXJhbXMgPSBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5jb25uZWN0aW9uUGFyYW1zKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1iZWQuZW1iZWRTd2ZPYmplY3Qoc3dmSWQsIG9wdGlvbnMsIGZsYXNodmFycywgZW52aXJvbm1lbnQuZ2V0U3dmT2JqZWN0KCksIGVsZW1lbnRJZClcbiAgICAgIH0pXG4gICAgICAudGhlbiggKCkgPT4ge1xuICAgICAgICBzb1Jlc3BvbmRlci5jb25uZWN0KHN3ZklkKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlID0+IGRlZmVycmVkLnJlamVjdChlKSlcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgY29ubmVjdCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjb25uZWN0XScpXG4gICAgdHJ5IHtcbiAgICAgIGVudmlyb25tZW50LmdldEVtYmVkT2JqZWN0KHRoaXMuX3N3ZklkKS5jb25uZWN0KClcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5hZGEuXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tkaXNjb25uZWN0XScpXG4gICAgdHJ5IHtcbiAgICAgIGVudmlyb25tZW50LmdldEVtYmVkT2JqZWN0KCkuZGlzY29ubmVjdCgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gbmFkYS5cbiAgICB9XG4gICAgdGhpcy5jbGVhblVwKClcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5kaXNjb25uZWN0KClcbiAgfVxuXG4gIGFkZFNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmFkZFJlc3BvbnNlSGFuZGxlcihoYW5kbGVyKVxuICB9XG5cbiAgcmVtb3ZlU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyIChoYW5kbGVyKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIucmVtb3ZlUmVzcG9uc2VIYW5kbGVyKGhhbmRsZXIpXG4gIH1cblxuICBzZW5kVG9TaGFyZWRPYmplY3QgKG5hbWUsIGNhbGxOYW1lLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuc2VuZFRvU2hhcmVkT2JqZWN0KG5hbWUsIGNhbGxOYW1lLCBtZXNzYWdlKVxuICB9XG5cbiAgc2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QgKG5hbWUsIGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5zZW5kUHJvcGVydHlUb1NoYXJlZE9iamVjdChuYW1lLCBrZXksIHZhbHVlKVxuICB9XG5cbiAgZ2V0UmVtb3RlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuZ2V0UmVtb3RlU2hhcmVkT2JqZWN0KHNoYXJlZE9iamVjdE5hbWUpXG4gIH1cblxuICBjb25uZWN0VG9TaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5jb25uZWN0VG9TaGFyZWRPYmplY3Qoc2hhcmVkT2JqZWN0TmFtZSlcbiAgfVxuXG4gIGNsb3NlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuY2xvc2VTaGFyZWRPYmplY3Qoc2hhcmVkT2JqZWN0TmFtZSlcbiAgfVxuXG4gIGdldFR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXllclR5cGVcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IExpdmVTb3VyY2VIYW5kbGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9zdWJzY3JpYmVyL2xpdmUtc291cmNlLWhhbmRsZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuXG5leHBvcnQgY29uc3QgZGVmaW5lRW1iZWRFbGVtZW50ID0gKHRhcmdldEVsZW1lbnQsIHRhcmdldFBhcmVudCkgPT4ge1xuICBsZXQgZGZkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gIGNvbnN0IGVsZW1lbnRJZCA9IHRhcmdldEVsZW1lbnQuaWRcbiAgaWYgKHRhcmdldEVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvJykge1xuICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIGRpdi5pZCA9IGVsZW1lbnRJZCArICdfcnRtcCdcbiAgICB0YXJnZXRQYXJlbnQuYXBwZW5kQ2hpbGQoZGl2KVxuICAgIHRhcmdldEVsZW1lbnQucmVtb3ZlKClcbiAgICBkZmQucmVzb2x2ZShkaXYuaWQpXG4gIH0gZWxzZSB7XG4gICAgZGZkLnJlc29sdmUoZWxlbWVudElkKVxuICB9XG4gIHJldHVybiBkZmQucHJvbWlzZVxufVxuXG5leHBvcnQgY29uc3QgZW1iZWRTd2ZPYmplY3QgPSAoaWROYW1lLCBvcHRpb25zLCBmbGFzaHZhcnMsIHN3Zm9iamVjdCwgZWxlbWVudElkKSA9PiB7XG4gIGxldCBkZmQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgbGV0IHBhcmFtcyA9IHtcbiAgICBxdWFsaXR5OiAnaGlnaCcsXG4gICAgYmdjb2xvcjogJyMwMDAnLFxuICAgIGFsbG93c2NyaXB0YWNjZXNzOiAnYWx3YXlzJyxcbiAgICBhbGxvd2Z1bGxzY3JlZW46ICd0cnVlJ1xuICB9XG4gIGxldCBhdHRyaWJ1dGVzID0ge1xuICAgIGlkOiBpZE5hbWUsXG4gICAgbmFtZTogaWROYW1lLFxuICAgIGFsaWduOiAnbWlkZGxlJ1xuICB9XG4gIGlmIChzd2ZvYmplY3QuaGFzRmxhc2hQbGF5ZXJWZXJzaW9uKG9wdGlvbnMubWluRmxhc2hWZXJzaW9uKSkge1xuICAgIHN3Zm9iamVjdC5lbWJlZFNXRihcbiAgICAgIG9wdGlvbnMuc3dmLFxuICAgICAgZWxlbWVudElkLFxuICAgICAgb3B0aW9ucy5lbWJlZFdpZHRoIHx8IG9wdGlvbnMud2lkdGgsXG4gICAgICBvcHRpb25zLmVtYmVkSGVpZ2h0IHx8IG9wdGlvbnMuaGVpZ2h0LFxuICAgICAgb3B0aW9ucy5taW5GbGFzaFZlcnNpb24sXG4gICAgICBvcHRpb25zLnByb2R1Y3RJbnN0YWxsVVJMLFxuICAgICAgZmxhc2h2YXJzLFxuICAgICAgcGFyYW1zLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIGRmZC5yZXNvbHZlKVxuICB9IGVsc2Uge1xuICAgIGRmZC5yZWplY3QoJ0ZsYXNoIFBsYXllciBWZXJzaW9uIGlzIG5vdCBzdXBwb3J0ZWQuJylcbiAgfVxuICByZXR1cm4gZGZkLnByb21pc2Vcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2Vudi9lbWJlZC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBkZWJ1Zywgd2FybiB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1JUTVBTaGFyZWRPYmplY3RIYW5kbGVyJ1xuXG5jbGFzcyBSVE1QU2hhcmVkT2JqZWN0SGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzID0gW11cbiAgfVxuXG4gIGFkZFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMucHVzaChoYW5kbGVyKVxuICB9XG5cbiAgcmVtb3ZlUmVzcG9uc2VIYW5kbGVyIChoYW5kbGVyKSB7XG4gICAgbGV0IGkgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmxlbmd0aFxuICAgIGxldCBySGFuZGxlclxuICAgIHdoaWxlKC0taSA+IC0xKSB7XG4gICAgICBySGFuZGxlciA9IHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnNbaV1cbiAgICAgIGlmIChySGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLnNwbGljZShpLCAxKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVTaGFyZWRPYmplY3RFdmVudCAoZXZlbnQpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3NoYXJlZG9iamVjdDpldmVudF0nKVxuICAgIGxldCBpXG4gICAgbGV0IGxlbmd0aCA9IHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMubGVuZ3RoXG4gICAgbGV0IGhhbmRsZXJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhbmRsZXIgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzW2ldXG4gICAgICBpZiAoaGFuZGxlci5yZXNwb25kKEpTT04ucGFyc2UoZXZlbnQpKSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzc2lnblNoYXJlZE9iamVjdFJlc3BvbmRlciAobmFtZSwgZWwpIHtcbiAgICBjb25zdCBfaGFuZGxlU2hhcmVkT2JqZWN0RXZlbnQgPSB0aGlzLmhhbmRsZVNoYXJlZE9iamVjdEV2ZW50LmJpbmQodGhpcylcbiAgICBjb25zdCBlbElkID0gZWwuaWQuc3BsaXQoJy0nKS5qb2luKCdfJylcbiAgICBjb25zdCBoYW5kbGVyTmFtZSA9IFsnaGFuZGxlU2hhcmVkT2JqZWN0RXZlbnQnLCBlbElkXS5qb2luKCdfJylcbiAgICBkZWJ1ZyhOQU1FLCBgW2Fzc2lnbjpzaGFyZWRvYmplY3Q6cmVzcG9uZGVyXSA6OiAke2VsSWR9YClcbiAgICBkZWJ1ZyhOQU1FLCBgW3NoYXJlZG9qZWN0OnJlc3BvbmRlcl0gOjogJHtoYW5kbGVyTmFtZX1gKVxuICAgIGVsLnNldFNoYXJlZE9iamVjdFJlc3BvbmRlcihuYW1lLCBoYW5kbGVyTmFtZSlcbiAgICBlbnZpcm9ubWVudC5zZXRHbG9iYWwoaGFuZGxlck5hbWUsIF9oYW5kbGVTaGFyZWRPYmplY3RFdmVudClcbiAgfVxuXG4gIGNvbm5lY3QgKHN3ZklkKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVudmlyb25tZW50LmdldEVtYmVkT2JqZWN0KHN3ZklkKVxuICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xuICAgICAgd2FybihgQ291bGQgbm90IGxvY2F0ZSBlbWJlZGRlZCBGbGFzaCBvYmplY3QgZm9yIGlkOiAke3N3ZklkfWApXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdCAoKSB7XG4gICAgd2hpbGUgKHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5zaGlmdCgpXG4gICAgfVxuICB9XG5cbiAgc2VuZFRvU2hhcmVkT2JqZWN0IChuYW1lLCBjYWxsTmFtZSwgbWVzc2FnZSkge1xuICAgIGRlYnVnKE5BTUUsICdbc2VuZFRvU2hhcmVkT2JqZWN0XScpXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2hhcmVkT2JqZWN0U2VuZChuYW1lLCBjYWxsTmFtZSwgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gbWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgd2FybignQ291bGQgbm90IHNlbmQgdG8gc2hhcmVkIG9iamVjdCAoJyArIG5hbWUgKyAnKS4gRXJyb3I6ICcgKyBlLm1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgc2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QgKG5hbWUsIGtleSwgdmFsdWUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3NlbmRQcm9wZXJ0eVRvU2hhcmVkT2JqZWN0XScpXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2hhcmVkT2JqZWN0U2VuZFByb3BlcnR5KG5hbWUsIGtleSwgdmFsdWUpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB3YXJuKCdDb3VsZCBub3Qgc2VuZCB0byBzaGFyZWQgb2JqZWN0ICgnICsgbmFtZSArICcpLiBFcnJvcjogJyArIGUubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICBnZXRSZW1vdGVTaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2dldFJlbW90ZVNoYXJlZE9iamVjdF0nKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmFzc2lnblNoYXJlZE9iamVjdFJlc3BvbmRlcihzaGFyZWRPYmplY3ROYW1lLCB0aGlzLl9lbGVtZW50KVxuICAgICAgdGhpcy5fZWxlbWVudC5nZXRSZW1vdGVTaGFyZWRPYmplY3Qoc2hhcmVkT2JqZWN0TmFtZSlcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oJ0NvdWxkIG5vdCBnZXQgcmVtb3RlIHNoYXJlZCBvYmplY3QgKCcgKyBuYW1lICsgJykuIEVycm9yOiAnICsgZS5tZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RUb1NoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkge1xuICAgIGRlYnVnKE5BTUUsICdbY29ubmVjdFRvU2hhcmVkT2JqZWN0XScpXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY29ubmVjdFRvU2hhcmVkT2JqZWN0KHNoYXJlZE9iamVjdE5hbWUpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB3YXJuKCdDb3VsZCBub3QgY29ubmVjdCB0byBzaGFyZWQgb2JqZWN0ICgnICsgbmFtZSArICcpLiBFcnJvcjogJyArIGUubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICBjbG9zZVNoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkge1xuICAgIGRlYnVnKE5BTUUsICdbZGlzY29ubmVjdFRvU2hhcmVkT2JqZWN0XScpXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuZGlzY29ubmVjdEZyb21TaGFyZWRPYmplY3Qoc2hhcmVkT2JqZWN0TmFtZSlcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oJ0NvdWxkIG5vdCBkaXNjb25uZWN0IHRvIHNoYXJlZCBvYmplY3QgKCcgKyBuYW1lICsgJykuIEVycm9yOiAnICsgZS5tZXNzYWdlKVxuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJUTVBTaGFyZWRPYmplY3RIYW5kbGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9oZWxwZXIvc2hhcmVkb2JqZWN0LWhlbHBlci1ydG1wLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4vcHJvbWlzZSdcblxuY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKVxuXG5jb25zdCBwdnQgPSAoY3R4KSA9PiB7XG4gIGlmICghbWFwLmhhcyhjdHgpKSB7XG4gICAgbWFwLnNldChjdHgsIHt9KVxuICB9XG5cbiAgcmV0dXJuIG1hcC5nZXQoY3R4KVxufVxuXG5leHBvcnQgY2xhc3MgSW1wbEZhY3RvcnlPcmRlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubGlzdG9yZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAqIGxpc3RvcmRlciAobGlzdCkge1xuICAgICAgICB3aGlsZSAobGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgeWllbGQgbGlzdC5zaGlmdCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KCkpXG5cbiAgICBwdnQodGhpcykuZmluZCA9IChpdGVyYXRvciwgbWFwLCBvcHRpb25zLCBwcm9taXNlLCBpbml0Rm4gPSBudWxsKSA9PiB7XG4gICAgICBjb25zdCBbdHlwZSwgSW1wbF0gPSBwdnQodGhpcykubmV4dChpdGVyYXRvciwgbWFwKVxuICAgICAgaWYgKCFJbXBsKSB7XG4gICAgICAgIHByb21pc2UucmVqZWN0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwXG4gICAgICAgIGxldCBzcmMgPSBvcHRpb25zW3R5cGVdXG4gICAgICAgIHNyYyA9IHNyYyB8fCBvcHRpb25zXG4gICAgICAgIGlmIChpbml0Rm4pIHtcbiAgICAgICAgICBwID0gbmV3IEltcGwoKVtpbml0Rm5dKHNyYylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwID0gbmV3IEltcGwoc3JjKVxuICAgICAgICB9XG4gICAgICAgIHAudGhlbigoY29uY3JldGUpID0+IHtcbiAgICAgICAgICBwcm9taXNlLnJlc29sdmUoY29uY3JldGUpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICBwdnQodGhpcykuZmluZChpdGVyYXRvciwgbWFwLCBvcHRpb25zLCBwcm9taXNlLCBpbml0Rm4pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcHZ0KHRoaXMpLm5leHQgPSAob3JkZXIsIG1hcCkgPT4ge1xuICAgICAgbGV0IEltcGxcbiAgICAgIGxldCBrZXlcbiAgICAgIGNvbnN0IG5leHQgPSBvcmRlci5uZXh0KClcbiAgICAgIGlmICghbmV4dC5kb25lKSB7XG4gICAgICAgIGtleSA9IG5leHQudmFsdWVcbiAgICAgICAgSW1wbCA9IG1hcC5nZXQoa2V5KVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtrZXksIEltcGxdXG4gICAgfVxuICB9XG5cbiAgY3JlYXRlIChvcmRlciwgbWFwLCBvcHRpb25zLCBpbml0Rm4gPSBudWxsKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHB2dCh0aGlzKS5maW5kKHRoaXMubGlzdG9yZGVyKG9yZGVyLnNsaWNlKCkpLCBtYXAsIG9wdGlvbnMsIHByb21pc2UsIGluaXRGbilcbiAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBJbXBsRmFjdG9yeU9yZGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy91dGlsL2ltcGwtZmFjdG9yeS1vcmRlci5qc1xuICoqLyIsIi8qKlxuICogTWFpbiBlbnRyeSBmb3IgZmFpbG92ZXIgc3VwcG9ydCBvZiBhbGwgcHVibGlzaGVyIGltcGxlbWVudGF0aW9ucy5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBJbXBsRmFjdG9yeU9yZGVyIGZyb20gJy4uL3V0aWwvaW1wbC1mYWN0b3J5LW9yZGVyJ1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgUlRNUFB1Ymxpc2hlciBmcm9tICcuL3JlZDVwcm8tcnRtcCdcbmltcG9ydCBSVENQdWJsaXNoZXIgZnJvbSAnLi9yZWQ1cHJvLXJ0YydcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IFB1Ymxpc2hUeXBlcyB9IGZyb20gJy4uL2VudW0vcHVibGlzaCdcbmltcG9ydCB7IGRlYnVnLCB3YXJuIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvUHVibGlzaGVyJ1xuY29uc3QgcHVibGlzaEZhY3RvcnkgPSBuZXcgSW1wbEZhY3RvcnlPcmRlcigpXG5jb25zdCBwdWJsaXNoZXJJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgbGV0IG1hcCA9IG5ldyBNYXAoKVxuICBtYXAuc2V0KFB1Ymxpc2hUeXBlcy5SVE1QLCBSVE1QUHVibGlzaGVyKVxuICBtYXAuc2V0KFB1Ymxpc2hUeXBlcy5SVEMsIFJUQ1B1Ymxpc2hlcilcbiAgcmV0dXJuIG1hcFxufSgpKVxuXG5jbGFzcyBSZWQ1UHJvUHVibGlzaGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fY3VycmVudFB1Ymxpc2hlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2JvdW5kQnViYmxlUHVibGlzaGVyRXZlbnQgPSB0aGlzLmJ1YmJsZVB1Ymxpc2hlckV2ZW50LmJpbmQodGhpcylcbiAgICB0aGlzLl9vcmRlciA9IFtcbiAgICAgIFB1Ymxpc2hUeXBlcy5SVE1QLFxuICAgICAgUHVibGlzaFR5cGVzLlJUQ1xuICAgIF1cbiAgfVxuXG4gIGdldFB1Ymxpc2hPcmRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yZGVyXG4gIH1cblxuICBzZXRQdWJsaXNoT3JkZXIgKG9yZGVyKSB7XG4gICAgLy8gQWxsb3cgZm9yIHN0cmluZyB2YWx1ZSB0byBkZWZpbmUgc2luZ2xlIGl0ZW0gaW4gb3JkZXIuXG4gICAgb3JkZXIgPSB0eXBlb2Ygb3JkZXIgPT09ICdzdHJpbmcnID8gW29yZGVyXSA6IG9yZGVyXG5cbiAgICAvLyBGaWx0ZXIgb3V0IHZhbHVlcyBub3QgYXZhaWxhYmxlIGluIGVudW1lcmF0aW9uIG9mIHBsYXliYWNrIHR5cGVzLlxuICAgIGNvbnN0IHQgPSBvcmRlci5maWx0ZXIoZW50cnkgPT4ge1xuICAgICAgbGV0IGtleVxuICAgICAgZm9yIChrZXkgaW4gUHVibGlzaFR5cGVzKSB7XG4gICAgICAgIGlmIChQdWJsaXNoVHlwZXNba2V5XS50b0xvd2VyQ2FzZSgpID09PSBlbnRyeS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSkubWFwKGVudHJ5ID0+IGVudHJ5LnRvTG93ZXJDYXNlKCkpXG5cbiAgICAvLyBEZWZpbmUgbmV3IG9yZGVyLlxuICAgIHRoaXMuX29yZGVyID0gWy4uLm5ldyBTZXQodCldXG4gICAgZGVidWcoTkFNRSwgYFtvcmRlcnVwZGF0ZV06ICR7dGhpcy5fb3JkZXJ9YClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc2V0VmlldyAocHVibGlzaFZpZXcpIHtcbiAgICB0aGlzLl92aWV3ID0gcHVibGlzaFZpZXdcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0UHVibGlzaGVyRnJvbU9yZGVyIChvcmRlciwgb3B0aW9ucykge1xuICAgIHJldHVybiBwdWJsaXNoRmFjdG9yeS5jcmVhdGUob3JkZXIsIHB1Ymxpc2hlckltcGwsIG9wdGlvbnMsICdpbml0JylcbiAgfVxuXG4gIGluaXQgKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGRlYnVnKE5BTUUsICdbcHVibGlzaF0nKVxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgdGhpcy5nZXRQdWJsaXNoZXJGcm9tT3JkZXIodGhpcy5fb3JkZXIsIHRoaXMuX29wdGlvbnMpXG4gICAgICAudGhlbihwdWJsaXNoZXIgPT4ge1xuICAgICAgICB0aGlzLl9jdXJyZW50UHVibGlzaGVyID0gcHVibGlzaGVyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIuc2V0Vmlldyh0aGlzLl92aWV3KVxuICAgICAgICB0aGlzLl9jdXJyZW50UHVibGlzaGVyLm9uKCcqJywgdGhpcy5fYm91bmRCdWJibGVQdWJsaXNoZXJFdmVudClcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0aGlzLl9jdXJyZW50UHVibGlzaGVyKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICB3YXJuKE5BTUUsIGBbcHVibGlzaGVycm9yXTogQ291bGQgbm90IGltcGxlbWVudCBhIHB1Ymxpc2hlcjogJHtlcnJ9YClcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycilcbiAgICAgIH0pXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIHN0b3AgKCkge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgaWYgKCF0aGlzLl9jdXJyZW50UHVibGlzaGVyKSB7XG4gICAgICB3YXJuKE5BTUUsICdbc3RvcF06IENvdWxkIG5vdCBpbnZva2Ugc3RvcCgpIG9uIHVuZGVmaW5lZCBwdWJsaXNoZXIuJylcbiAgICAgIGRlZmVycmVkLnJlamVjdCgnQSBjdXJyZW50IHB1Ymxpc2hlciBpcyBub3QgYXZhaWxhYmxlIHRvIGlzc3VlIGEgOnN0b3AoKSBjb21tYW5kIHRvLicpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKE5BTUUsICdbc3RvcF06IEludm9raW5nIHN0b3Agb24gaGVsZCBwdWJsaXNoZXInKVxuICAgICAgdGhpcy5fY3VycmVudFB1Ymxpc2hlci51bnB1Ymxpc2goKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgZGVidWcoTkFNRSwgJ1tzdG9wc3VjY2Vzc10nKVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIub2ZmKCcqJywgdGhpcy5fYm91bmRCdWJibGVQdWJsaXNoZXJFdmVudClcbiAgICAgICAgICB0aGlzLl9jdXJyZW50UHVibGlzaGVyID0gdW5kZWZpbmVkXG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGRlYnVnKE5BTUUsIGBbc3RvcGVycm9yXTogJHtlcnJ9YClcbiAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFB1Ymxpc2hlcikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFB1Ymxpc2hlci5vZmYoJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVB1Ymxpc2hlckV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jdXJyZW50UHVibGlzaGVyID0gdW5kZWZpbmVkXG4gICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycilcbiAgICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGJ1YmJsZVB1Ymxpc2hlckV2ZW50IChwdWJsaXNoZXJFdmVudCkge1xuICAgIHRoaXMudHJpZ2dlci5jYWxsKHRoaXMsIHB1Ymxpc2hlckV2ZW50KVxuICB9XG5cbiAgZ2V0IHB1Ymxpc2hUeXBlcyAoKSB7XG4gICAgcmV0dXJuIFB1Ymxpc2hUeXBlc1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRQdWJsaXNoZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50UHVibGlzaGVyXG4gIH1cblxufVxuXG5leHBvcnQgeyBSZWQ1UHJvUHVibGlzaGVyLCBSVE1QUHVibGlzaGVyLCBSVENQdWJsaXNoZXIgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvcHVibGlzaGVyL2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IHsgUHVibGlzaGVyRXZlbnQgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IFB1Ymxpc2hUeXBlcyB9IGZyb20gJy4uL2VudW0vcHVibGlzaCdcbmltcG9ydCBQdWJsaXNoZXJTb3VyY2VIYW5kbGVyIGZyb20gJy4vcHViLXNvdXJjZS1oYW5kbGVyJ1xuaW1wb3J0IHsgUHVibGlzaGVyRXZlbnRUeXBlcywgUlRNUFB1Ymxpc2hlckV2ZW50VHlwZXMgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IGRlYnVnLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1JUTVBQdWJsaXNoZXInXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgcHJvdG9jb2w6ICdydG1wJyxcbiAgcG9ydDogMTkzNSxcbiAgc3RyZWFtTW9kZTogJ2xpdmUnLFxuICB3aWR0aDogMzIwLCAvLyBjYW1lcmEvdmlkZW9cbiAgaGVpZ2h0OiAyNDAsIC8vIGNhbWVyYS92aWRlb1xuICBlbWJlZFdpZHRoOiAnMTAwJScsIC8vIERPTSBkaXNwbGF5IHN0eWxlXG4gIGVtYmVkSGVpZ2h0OiAnMTAwJScsIC8vIERPTSBkaXNwbGF5IHN0eWxlXG4gIG1pbkZsYXNoVmVyc2lvbjogJzEwLjAuMCcsXG4gIHN3ZjogJ2xpYi9yZWQ1cHJvL3JlZDVwcm8tcHVibGlzaGVyLnN3ZicsXG4gIHN3Zm9iamVjdFVSTDogJ2xpYi9zd2ZvYmplY3Qvc3dmb2JqZWN0LmpzJyxcbiAgcHJvZHVjdEluc3RhbGxVUkw6ICdsaWIvc3dmb2JqZWN0L3BsYXllclByb2R1Y3RJbnN0YWxsLnN3Zidcbn1cblxuY2xhc3MgUlRNUFB1Ymxpc2hlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9vcHRpb25zID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdmlldyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9lbGVtZW50SWQgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9jb25uZWN0RnV0dXJlID0gdW5kZWZpbmVkXG4gIH1cblxuICBpbml0IChvcHRpb25zKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGNvbnN0IHZlcnNpb24gPSBvcHRpb25zLm1pbkZsYXNoVmVyc2lvbiB8fCBkZWZhdWx0T3B0aW9ucy5taW5GbGFzaFZlcnNpb25cbiAgICBpZiAoIWVudmlyb25tZW50LnN1cHBvcnRzRmxhc2hWZXJzaW9uKHZlcnNpb24pKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoYENvdWxkIG5vdCByZXNvbHZlIFJUTVBQdWJsaXNoZXIgaW5zdGFuY2UuIFJlcXVpcmVzIG1pbmltdW0gRmxhc2ggUGxheWVyIGluc3RhbGwgb2YgJHt2ZXJzaW9ufWApXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuICAgICAgdHJ5IHtcbiAgICAgICAgZW52aXJvbm1lbnQuaW5qZWN0U2NyaXB0KHRoaXMuX29wdGlvbnMuc3dmb2JqZWN0VVJMKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKE5BTUUsICdTV0ZPYmplY3QgZW1iZWRkZWQuJylcbiAgICAgICAgICAgIGlmIChzZWxmLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIGRlYnVnKE5BTUUsICdQdWJsaXNoIGhhbmRsZXIgZXN0YWJsaXNoZWQuJylcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3NvdXJjZUhhbmRsZXIuYWRkU291cmNlKHNlbGYuX2VsZW1lbnRJZCwgc2VsZi5fb3B0aW9ucylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlYnVnKE5BTUUsICdQdWJsaXNoIGhhbmRsZXIgbm90IGVzdGFibGlzaGVkLicpXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbigoKSA9PiBkZWZlcnJlZC5yZXNvbHZlKHNlbGYpKVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgZXJyb3IoTkFNRSwgYENvdWxkIG5vdCBlbWJlZCBGbGFzaC1iYXNlZCBSVE1QIFB1Ymxpc2hlci4gUmVhc29uOiAke2Vycn1gKVxuICAgICAgICAgICAgaWYgKHNlbGYuX3NvdXJjZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgc2VsZi5fc291cmNlSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUTVBQdWJsaXNoZXJFdmVudFR5cGVzLkVNQkVEX0ZBSUxVUkUsIHNlbGYpKVxuICAgICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChgQ291bGQgbm90IGluamVjdCBGbGFzaC1iYXNlZCBQdWJsaXNoZXIgaW50byB0aGUgcGFnZS4gUmVhc29uOiAke2UubWVzc2FnZX1gKVxuICAgICAgICBzZWxmLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUTVBQdWJsaXNoZXJFdmVudFR5cGVzLkVNQkVEX0ZBSUxVUkUsIHNlbGYpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgX3NldFVwQ29ubmVjdENhbGxiYWNrIChwcm9taXNlKSB7XG4gICAgd2luZG93LnNldEFjdGl2ZUlkID0gKHN1Y2Nlc3NJZCkgPT4ge1xuICAgICAgLy8gc3VjY2Vzc0lkID09PSBfb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgICBkZWJ1ZyhOQU1FLCBgRW1iZWQgYW5kIGNvbm5lY3QoKSBjb21wbGV0ZSBmb3IgcHVibGlzaGVyIHN3Zi4gc3VjY2Vzc0lkKCR7c3VjY2Vzc0lkfSkuYClcbiAgICAgIHByb21pc2UucmVzb2x2ZShzdWNjZXNzSWQpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUTVBQdWJsaXNoZXJFdmVudFR5cGVzLkVNQkVEX1NVQ0NFU1MsIHRoaXMpKVxuICAgICAgdGhpcy5fdGVhckRvd25Db25uZWN0Q2FsbGJhY2soKVxuICAgIH1cbiAgICAvLyBUT0RPOiBTZXR1cCB0aW1lb3V0IHRvIHJlamVjdD9cbiAgfVxuXG4gIF90ZWFyRG93bkNvbm5lY3RDYWxsYmFjayAoKSB7XG4gICAgd2luZG93LnNldEFjdGl2ZUlkID0gdW5kZWZpbmVkXG4gIH1cblxuICBfZXN0YWJsaXNoRXh0SW50SGFuZGxlcnMgKCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgY29uc3QgaW52b2tlRm4gPSAobGFiZWwpID0+IHtcbiAgICAgIHJldHVybiBbJ3B1Ymxpc2hlcicsIGxhYmVsLCBpZF0uam9pbignXycpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9Db25uZWN0U3VjY2VzcycpXSA9ICgpID0+IHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX1NVQ0NFU1MsIHRoaXMpKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9VbnB1Ymxpc2hTdWNjZXNzJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlVOUFVCTElTSF9TVUNDRVNTLCB0aGlzKSlcbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvUHVibGlzaFN0YXJ0JyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfU1RBUlQsIHRoaXMpKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9QdWJsaXNoTWV0YWRhdGEnKV0gPSAobWV0YWRhdGEpID0+IHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX01FVEFEQVRBLCB0aGlzLCBtZXRhZGF0YSkpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb0Nvbm5lY3RGYWlsdXJlJyldID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdEZ1dHVyZS5yZWplY3QoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzKSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1B1Ymxpc2hGYWlsJyldID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdEZ1dHVyZS5yZWplY3QoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX0ZBSUwpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9GQUlMLCB0aGlzKSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1B1Ymxpc2hJbnZhbGlkTmFtZScpXSA9KCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdEZ1dHVyZS5yZWplY3QoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX0lOVkFMSURfTkFNRSlcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX0lOVkFMSURfTkFNRSwgdGhpcykpXG4gICAgfVxuICB9XG5cbiAgcHVibGlzaCAoc3RyZWFtTmFtZSA9IHVuZGVmaW5lZCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgY29uc3QgZGZkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5fc2V0VXBDb25uZWN0Q2FsbGJhY2soZGZkKVxuICAgIHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSA9IHN0cmVhbU5hbWUgfHwgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgY29uc3QgcHVibGlzaE9wdGlvbnMgPSB0aGlzLl9vcHRpb25zXG4gICAgdHJ5IHtcbiAgICAgIGxldCBzcmNIYW5kbGVyID0gdGhpcy5fc291cmNlSGFuZGxlclxuICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5nZXRFbWJlZE9wZXJhdGlvbigpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBkZWJ1ZyhOQU1FLCAnW2hhbmRsZXI6ZW1iZWQ6Y29tcGxldGVdJylcbiAgICAgICAgICBjb25zdCBlbCA9IGVudmlyb25tZW50LmdldEVtYmVkT2JqZWN0KHRoaXMuX2VsZW1lbnRJZClcbiAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2VzdGFibGlzaEV4dEludEhhbmRsZXJzKClcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGNvdW50ID0gMFxuICAgICAgICAgIGNvbnN0IGxpbWl0ID0gMTAwMFxuICAgICAgICAgIGxldCB0cnlDb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGV0IHRpbWVvdXRcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgICAgICAgICAgICBzcmNIYW5kbGVyLmNvbm5lY3QoSlNPTi5zdHJpbmdpZnkocHVibGlzaE9wdGlvbnMpKVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50KysgPiBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnlDb25uZWN0KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDMwMClcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5Q29ubmVjdCgpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGRmZC5yZWplY3QoZXJyKVxuICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMpKVxuICAgICAgICB9KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yKE5BTUUsICdbaGFuZGxlcjplbWJlZDplcnJvcl0nKVxuICAgICAgZGZkLnJlamVjdChgQ291bGQgbm90IGluaXRpYXRlIGNvbm5lY3Rpb24gc2VxdWVuY2UuIFJlYXNvbjogJHtlLm1lc3NhZ2V9YClcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMpKVxuICAgICAgdGhpcy5fdGVhckRvd25Db25uZWN0Q2FsbGJhY2soKVxuICAgIH1cbiAgICB0aGlzLl9jb25uZWN0RnV0dXJlID0gZGZkXG4gICAgcmV0dXJuIGRmZC5wcm9taXNlXG4gIH1cblxuICB1bnB1Ymxpc2ggKCkge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdHJ5IHtcbiAgICAgIGVudmlyb25tZW50LmdldEVtYmVkT2JqZWN0KHRoaXMuX2VsZW1lbnRJZCkuZGlzY29ubmVjdCgpXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihOQU1FLCBgQ291bGQgbm90IGluaXRpYXRlIGRpc2Nvbm5lY3Rpb24gc2VxdWVuY2UuIFJlYXNvbjogJHtlLm1lc3NhZ2V9YClcbiAgICAgIGRlZmVycmVkLnJlamVjdChlLm1lc3NhZ2UpXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBzZW5kIChtZXRob2ROYW1lLCBkYXRhKSB7XG4gICAgdGhpcy5fc291cmNlSGFuZGxlci5zZW5kKG1ldGhvZE5hbWUsIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBKU09OLnN0cmluZ2lmeShkYXRhKSlcbiAgfVxuXG4gIHNldFZpZXcgKHZpZXcsIGVsZW1lbnRJZCkge1xuICAgIHRoaXMuX3ZpZXcgPSB2aWV3XG4gICAgdGhpcy5fZWxlbWVudElkID0gZWxlbWVudElkXG4gICAgaWYgKHRoaXMuX3NvdXJjZUhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSB1bmRlZmluZWRcbiAgICB9XG4gICAgaWYgKHRoaXMuX3ZpZXcpIHtcbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSBuZXcgUHVibGlzaGVyU291cmNlSGFuZGxlcih0aGlzLl92aWV3LnZpZXcsIHRoaXMuZ2V0VHlwZSgpKVxuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmFkZFNvdXJjZSh0aGlzLl9lbGVtZW50SWQsIHRoaXMuX29wdGlvbnMpXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGVycm9yKE5BTUUsIGBDb3VsZCBub3QgZXN0YWJsaXNoIHByb3BlciBSVE1QIHB1Ymxpc2hlcjogJHtlcnJ9YClcbiAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUTVBQdWJsaXNoZXJFdmVudFR5cGVzLkVNQkVEX0ZBSUxVUkUsIHRoaXMpKVxuICAgICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc2V0TWVkaWFRdWFsaXR5IChxdWFsaXR5KSB7XG4gICAgaWYgKHRoaXMuX3NvdXJjZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuc2V0TWVkaWFRdWFsaXR5KHF1YWxpdHkpXG4gICAgfVxuICB9XG5cbiAgb3ZlcmxheU9wdGlvbnMgKG5ld09wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih0aGlzLl9vcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgfVxuXG4gIGdldENvbm5lY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VIYW5kbGVyXG4gIH1cblxuICBnZXRPcHRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9uc1xuICB9XG5cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIFB1Ymxpc2hUeXBlcy5SVE1QLnRvVXBwZXJDYXNlKClcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJUTVBQdWJsaXNoZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3B1Ymxpc2hlci9yZWQ1cHJvLXJ0bXAuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0IGNvbnN0IFB1Ymxpc2hUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBSVE1QOiAncnRtcCcsXG4gIFJUQzogJ3J0Yydcbn0pXG5cbmV4cG9ydCBjb25zdCBQdWJsaXNoTW9kZVR5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIExJVkU6ICdsaXZlJyxcbiAgUkVDT1JEOiAncmVjb3JkJyxcbiAgQVBQRU5EOiAnYXBwZW5kJ1xufSlcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvZW51bS9wdWJsaXNoLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCAqIGFzIGVtYmVkIGZyb20gJy4uL2Vudi9lbWJlZCdcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IEZ1dHVyZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nJ1xuaW1wb3J0IFJUTVBTaGFyZWRPYmplY3RIYW5kbGVyIGZyb20gJy4uL2hlbHBlci9zaGFyZWRvYmplY3QtaGVscGVyLXJ0bXAnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9QdWJsaXNoZXJTb3VyY2VIYW5kbGVyJ1xuY29uc3QgdG9JbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUucGFyc2VJbnQoMTApXG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpXG4gIH1cbn1cblxuY2xhc3MgUHVibGlzaGVyU291cmNlSGFuZGxlciB7XG5cbiAgY29uc3RydWN0b3IgKHZpZGVvLCB0eXBlLCBzb1Jlc3BvbmRlciA9IHVuZGVmaW5lZCkge1xuICAgIHRoaXMudmlkZW8gPSB2aWRlb1xuICAgIHRoaXMuY2xvbmUgPSB0aGlzLnZpZGVvLmNsb25lTm9kZSh0cnVlKVxuICAgIHRoaXMuaG9sZGVyID0gdGhpcy52aWRlby5wYXJlbnROb2RlXG4gICAgdGhpcy5wdWJsaXNoZXJUeXBlID0gdHlwZVxuICAgIHRoaXMuX3N3ZklkID0gbnVsbFxuICAgIHRoaXMuX2VtYmVkRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc29SZXNwb25kZXIgPSBzb1Jlc3BvbmRlciB8fCBuZXcgUlRNUFNoYXJlZE9iamVjdEhhbmRsZXIoKVxuICB9XG5cbiAgZ2V0RW1iZWRPcGVyYXRpb24gKCkge1xuICAgIHRoaXMuX2VtYmVkRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fZW1iZWRGdXR1cmUpXG4gICAgcmV0dXJuIHRoaXMuX2VtYmVkRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIGNsZWFuVXAgKCkge1xuICAgIC8vIFJldHVybiB0byBwcmlvciBET00gbWFuaXB1bGF0aW9uLlxuICAgIHRoaXMudmlkZW8ucmVtb3ZlKClcbiAgICB0aGlzLnZpZGVvID0gdGhpcy5jbG9uZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICB0aGlzLmhvbGRlci5hcHBlbmRDaGlsZCh0aGlzLnZpZGVvKVxuICAgIHRoaXMuX2VtYmVkRnV0dXJlID0gdW5kZWZpbmVkXG4gIH1cblxuICBhZGRTb3VyY2UgKHN3ZklkLCBvcHRpb25zLCBzd2ZVcmwgPSBudWxsLCBtaW5GbGFzaFZlcnNpb24gPSBudWxsKSB7XG4gICAgZGVidWcoTkFNRSwgJ1thZGRzb3VyY2VdJylcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIHRoaXMuX3N3ZklkID0gc3dmSWQ7XG4gICAgdGhpcy5fZW1iZWRGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9lbWJlZEZ1dHVyZSlcbiAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMuX2VtYmVkRnV0dXJlXG4gICAgb3B0aW9ucy5zd2YgPSBzd2ZVcmwgfHwgb3B0aW9ucy5zd2ZcbiAgICBvcHRpb25zLm1pbkZsYXNoVmVyc2lvbiA9IG1pbkZsYXNoVmVyc2lvbiB8fCBvcHRpb25zLm1pbkZsYXNoVmVyc2lvblxuICAgIGVtYmVkLmRlZmluZUVtYmVkRWxlbWVudCh0aGlzLnZpZGVvLCB0aGlzLmhvbGRlcilcbiAgICAgIC50aGVuKGVsZW1lbnRJZCA9PiB7XG4gICAgICAgIGRlYnVnKE5BTUUsICdbZWxlbWVudDpjb21wbGV0ZV0nKVxuICAgICAgICBsZXQgZmxhc2h2YXJzID0ge1xuICAgICAgICAgIGJ1ZmZlcjogb3B0aW9ucy5idWZmZXIgIT0gbnVsbCA/IG9wdGlvbnMuYnVmZmVyIDogMixcbiAgICAgICAgICBzdHJlYW1Nb2RlOiBvcHRpb25zLnN0cmVhbU1vZGUsXG4gICAgICAgICAgc3RyZWFtTmFtZTogb3B0aW9ucy5zdHJlYW1OYW1lLFxuICAgICAgICAgIGFwcE5hbWU6IG9wdGlvbnMuYXBwLFxuICAgICAgICAgIGhvc3Q6IG9wdGlvbnMuaG9zdFxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICBmbGFzaHZhcnMucm9vbU5hbWUgPSBvcHRpb25zLmNvbnRleHRcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAmJiAhaXNOYU4ob3B0aW9ucy53aWR0aCkpIHtcbiAgICAgICAgICBmbGFzaHZhcnMud2lkdGggPSB0b0ludChvcHRpb25zLndpZHRoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmhlaWdodCAmJiAhaXNOYU4ob3B0aW9ucy5oZWlnaHQpKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLmhlaWdodCA9IHRvSW50KG9wdGlvbnMuaGVpZ2h0KVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVtYmVkV2lkdGggPT09ICcxMDAlJyB8fCBvcHRpb25zLmVtYmVkSGVpZ2h0ID09PSAnMTAwJScpIHtcbiAgICAgICAgICBmbGFzaHZhcnMuYXV0b3NpemUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbm5lY3Rpb25QYXJhbXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLmNvbm5lY3Rpb25QYXJhbXMgPSBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5jb25uZWN0aW9uUGFyYW1zKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1iZWQuZW1iZWRTd2ZPYmplY3Qoc3dmSWQsIG9wdGlvbnMsIGZsYXNodmFycywgZW52aXJvbm1lbnQuZ2V0U3dmT2JqZWN0KCksIGVsZW1lbnRJZClcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGRlYnVnKE5BTUUsICdbZW1iZWQ6Y29tcGxldGVdJylcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShzZWxmKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4gZGVmZXJyZWQucmVqZWN0KGVycikpXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGNvbm5lY3QgKHB1Ymxpc2hPcHRpb25zKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjb25uZWN0XScpXG4gICAgY29uc3QgZWwgPSBlbnZpcm9ubWVudC5nZXRFbWJlZE9iamVjdCh0aGlzLl9zd2ZJZClcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLmNvbm5lY3QocHVibGlzaE9wdGlvbnMpXG4gICAgICB0aGlzLl9zb1Jlc3BvbmRlci5jb25uZWN0KHRoaXMuX3N3ZklkKVxuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbZGlzY29ubmVjdF0nKVxuICAgIHRyeSB7XG4gICAgICAvLyBObyBpbnZvY2FibGUgQVBJIGZvciBjdXN0b20gbGl2ZSBmbGFzaCBwdWJsaXNoZXIgZnJvbSBSZWQ1IFBybyBhdCB0aGUgdGltZS5cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBuYWRhLlxuICAgIH1cbiAgICB0aGlzLmNsZWFuVXAoKVxuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmRpc2Nvbm5lY3QoKVxuICB9XG5cbiAgc2VuZCAobWV0aG9kTmFtZSwgZGF0YSkge1xuICAgIGNvbnN0IGVsID0gZW52aXJvbm1lbnQuZ2V0RW1iZWRPYmplY3QodGhpcy5fc3dmSWQpXG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5zZW5kKG1ldGhvZE5hbWUsIGRhdGEpXG4gICAgfVxuICB9XG5cbiAgYWRkU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyIChoYW5kbGVyKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuYWRkUmVzcG9uc2VIYW5kbGVyKGhhbmRsZXIpXG4gIH1cblxuICByZW1vdmVTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5yZW1vdmVSZXNwb25zZUhhbmRsZXIoaGFuZGxlcilcbiAgfVxuXG4gIHNlbmRUb1NoYXJlZE9iamVjdCAobmFtZSwgY2FsbE5hbWUsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5zZW5kVG9TaGFyZWRPYmplY3QobmFtZSwgY2FsbE5hbWUsIG1lc3NhZ2UpXG4gIH1cblxuICBzZW5kUHJvcGVydHlUb1NoYXJlZE9iamVjdCAobmFtZSwga2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLnNlbmRQcm9wZXJ0eVRvU2hhcmVkT2JqZWN0KG5hbWUsIGtleSwgdmFsdWUpXG4gIH1cblxuICBnZXRSZW1vdGVTaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5nZXRSZW1vdGVTaGFyZWRPYmplY3Qoc2hhcmVkT2JqZWN0TmFtZSlcbiAgfVxuXG4gIGNvbm5lY3RUb1NoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmNvbm5lY3RUb1NoYXJlZE9iamVjdChzaGFyZWRPYmplY3ROYW1lKVxuICB9XG5cbiAgY2xvc2VTaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5jbG9zZVNoYXJlZE9iamVjdChzaGFyZWRPYmplY3ROYW1lKVxuICB9XG5cbiAgc2V0TWVkaWFRdWFsaXR5IChxdWFsaXR5KSB7XG4gICAgY29uc3QgZWwgPSBlbnZpcm9ubWVudC5nZXRFbWJlZE9iamVjdCh0aGlzLl9zd2ZJZClcbiAgICBpZiAoZWwpIHtcbiAgICAgIGlmIChxdWFsaXR5LnZpZGVvICYmIHR5cGVvZiBxdWFsaXR5LnZpZGVvICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgY29uc3QgdyA9ICFpc05hTihxdWFsaXR5LnZpZGVvLndpZHRoKSA/IHRvSW50KHF1YWxpdHkudmlkZW8ud2lkdGgpIDogTnVtYmVyLmlzTmFOO1xuICAgICAgICBjb25zdCBoID0gIWlzTmFOKHF1YWxpdHkudmlkZW8uaGVpZ2h0KSA/IHRvSW50KHF1YWxpdHkudmlkZW8uaGVpZ2h0KSA6IE51bWJlci5pc05hTjtcbiAgICAgICAgZWwudXBkYXRlUmVzb2x1dGlvbih3LCBoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldFR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlclR5cGVcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFB1Ymxpc2hlclNvdXJjZUhhbmRsZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3B1Ymxpc2hlci9wdWItc291cmNlLWhhbmRsZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgeyBQdWJsaXNoZXJFdmVudCB9IGZyb20gJy4uL2V2ZW50J1xuaW1wb3J0IFB1Ymxpc2hlclNvY2tldEhlbHBlciBmcm9tICcuLi9oZWxwZXIvc29ja2V0LWhlbHBlci1wdWInXG5pbXBvcnQgUHVibGlzaGVyUGVlckhlbHBlciBmcm9tICcuLi9oZWxwZXIvd2VicnRjLWhlbHBlci1wdWInXG5pbXBvcnQgeyBQdWJsaXNoTW9kZVR5cGVzIH0gZnJvbSAnLi4vZW51bS9wdWJsaXNoJ1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlLCBGdXR1cmUgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgKiBhcyB3ZWJydGMgZnJvbSAnLi4vYWRhcHRlci93ZWJydGMnXG5pbXBvcnQgKiBhcyB3ZWJzb2NrZXQgZnJvbSAnLi4vYWRhcHRlci93ZWJzb2NrZXQnXG5pbXBvcnQgeyBQdWJsaXNoVHlwZXMgfSBmcm9tICcuLi9lbnVtL3B1Ymxpc2gnXG5pbXBvcnQgeyBQdWJsaXNoZXJFdmVudFR5cGVzLCBSVENQdWJsaXNoZXJFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQnXG5cbmltcG9ydCB7IGRlYnVnIGFzIGRlYnVnTG9nIH0gZnJvbSAnLi4vbG9nJ1xuaW1wb3J0IHsgZXJyb3IgYXMgZXJyb3JMb2cgfSBmcm9tICcuLi9sb2cnXG5pbXBvcnQgeyB3YXJuIGFzIHdhcm5Mb2cgfSBmcm9tICcuLi9sb2cnXG5cbi8vIERlZmF1bHQgdG8gc2VjdXJlIHNldHRpbmdzLlxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHByb3RvY29sOiAnd3NzJyxcbiAgcG9ydDogODA4MyxcbiAgc3RyZWFtVHlwZTogJ3dlYnJ0YycsXG4gIHN0cmVhbU1vZGU6IFB1Ymxpc2hNb2RlVHlwZXMuTElWRSxcbiAgYmFuZHdpZHRoOiB7XG4gICAgYXVkaW86IDU2LFxuICAgIHZpZGVvOiA1MTJcbiAgfVxufVxuY29uc3QgZW5kcG9pbnRGcm9tT3B0aW9ucyA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHByb3RvY29sID0gb3B0aW9ucy53c3Byb3RvY29sIHx8IG9wdGlvbnMucHJvdG9jb2xcbiAgY29uc3QgcG9ydCA9IG9wdGlvbnMud3Nwb3J0IHx8IG9wdGlvbnMucG9ydFxuICBjb25zdCBhcHBFbmRwb2ludCA9IG9wdGlvbnMuY29udGV4dCA/IFtvcHRpb25zLmFwcCwgb3B0aW9ucy5jb250ZXh0XS5qb2luKCcvJykgOiBvcHRpb25zLmFwcFxuICBsZXQgZW5kcG9pbnQgPSBgJHtwcm90b2NvbH06Ly8ke29wdGlvbnMuaG9zdH06JHtwb3J0fS8ke2FwcEVuZHBvaW50fT9pZD0ke29wdGlvbnMuc3RyZWFtTmFtZX1gXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5jb25uZWN0aW9uUGFyYW1zICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxldCBwYXJhbXMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zLmNvbm5lY3Rpb25QYXJhbXMpLmZvckVhY2goIChrZXksIGluZGV4KSA9PiB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHBhcmFtcy5wdXNoKFtrZXksIG9wdGlvbnMuY29ubmVjdGlvblBhcmFtc1trZXldXS5qb2luKCc9JykpXG4gICAgfSlcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGVuZHBvaW50ICs9ICcmJyArIChwYXJhbXMuam9pbignJicpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kcG9pbnRcbn1cblxuY29uc3QgcHViU3RhcnRSZWdleCA9IC8oLiopIHN0YXJ0aW5nL2dpXG5jb25zdCBwdWJTdG9wUmVnZXggPSAvKC4qKSBzdG9wcGluZy9naVxuY29uc3QgTkFNRSA9ICdSVENQdWJsaXNoZXInXG5jb25zdCBkZWJ1ZyA9IChtZXNzYWdlKSA9PiB7XG4gIGRlYnVnTG9nKE5BTUUsIG1lc3NhZ2UpXG59XG5jb25zdCB3YXJuID0gKG1lc3NhZ2UpID0+IHtcbiAgd2FybkxvZyhOQU1FLCBtZXNzYWdlKVxufVxuY29uc3QgZXJyb3IgPSAobWVzc2FnZSkgPT4ge1xuICBlcnJvckxvZyhOQU1FLCBtZXNzYWdlKVxufVxuXG5jbGFzcyBSVENQdWJsaXNoZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fb3B0aW9ucyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3ZpZXcgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZWVySGVscGVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc29ja2V0SGVscGVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fbWVkaWFTdHJlYW0gPSB1bmRlZmluZWRcblxuICAgIHRoaXMuX3N0cmVhbUZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2F2YWlsYWJsZUZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3BlZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9vZmZlckZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NlbmRPZmZlckZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3RyaWNrbGVFbmRGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wdWJsaXNoRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdW5wdWJsaXNoRnV0dXJlID0gdW5kZWZpbmVkXG4gIH1cblxuICBfZ2V0TWVkaWFTdHJlYW0gKCkge1xuICAgIHRoaXMuX3N0cmVhbUZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3N0cmVhbUZ1dHVyZSlcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIF9nZXRUcmlja2xlRW5kICgpIHtcbiAgICByZXR1cm4gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fdHJpY2tsZUVuZEZ1dHVyZSlcbiAgfVxuXG4gIGluaXQgKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGlmICghd2VicnRjLmlzU3VwcG9ydGVkKCkgfHwgIXdlYnNvY2tldC5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoJ0Nhbm5vdCBjcmVhdGUgV2ViUlRDIHBsYXliYWNrIGluc3RhbmNlLiBZb3VyIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgV2ViUlRDIGFuZC9vciBXZWJTb2NrZXRzLicpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuICAgICAgdGhpcy5fcGVlckhlbHBlciA9IG5ldyBQdWJsaXNoZXJQZWVySGVscGVyKHRoaXMpXG4gICAgICB0aGlzLl9zb2NrZXRIZWxwZXIgPSBuZXcgUHVibGlzaGVyU29ja2V0SGVscGVyKHRoaXMpXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMpXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBzZXRWaWV3ICh2aWV3KSB7XG4gICAgdGhpcy5fdmlldyA9IHZpZXdcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYXR0YWNoU3RyZWFtIChtZWRpYSkge1xuICAgIHRoaXMuX3N0cmVhbUZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3N0cmVhbUZ1dHVyZSlcbiAgICB0aGlzLl9zdHJlYW1GdXR1cmUucmVzb2x2ZShtZWRpYSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZGV0YWNoU3RyZWFtICgpIHtcbiAgICBpZiAodGhpcy5fbWVkaWFTdHJlYW0gJiYgdGhpcy5fbWVkaWFTdHJlYW0uc3RvcCkge1xuICAgICAgdGhpcy5fbWVkaWFTdHJlYW0uc3RvcCgpXG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX21lZGlhU3RyZWFtICYmIHRoaXMuX21lZGlhU3RyZWFtLmdldFRyYWNrcykge1xuICAgICAgY29uc3QgdHJhY2tzID0gdGhpcy5fbWVkaWFTdHJlYW0uZ2V0VHJhY2tzKClcbiAgICAgIGxldCB0cmFja0xlbmd0aCA9IHRyYWNrcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoLS10cmFja0xlbmd0aCA+IC0xKSB7XG4gICAgICAgIGlmICh0cmFja3NbdHJhY2tMZW5ndGhdLnN0b3ApIHtcbiAgICAgICAgICB0cmFja3NbdHJhY2tMZW5ndGhdLnN0b3AoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3N0cmVhbUZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX21lZGlhU3RyZWFtID0gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJlcXVlc3RBdmFpbGFiaWxpdHkgKHN0cmVhbU5hbWUsIHR5cGUpIHtcbiAgICBkZWJ1ZygnW3JlcXVlc3RhdmFpbGFiaWxpdHldJylcbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9hdmFpbGFibGVGdXR1cmUpXG4gICAgLy8gbWVzc2FnZSBvbiBzb2NrZXQgcmV0dXJucyAtPiBvblN0cmVhbShVbilBdmFpbGFibGVcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBpc0F2YWlsYWJsZTogc3RyZWFtTmFtZSxcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBidW5kbGU6IGZhbHNlXG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy5fYXZhaWxhYmxlRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIGNyZWF0ZVBlZXJDb25uZWN0aW9uIChpY2VTZXJ2ZXJzKSB7XG4gICAgZGVidWcoJ1tjcmVhdGVwZWVlcl0nKVxuICAgIHRoaXMuX3BlZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZWVyRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fcGVlckZ1dHVyZSlcbiAgICB0aGlzLl9wZWVySGVscGVyLnNldFVwKGljZVNlcnZlcnMsIHRoaXMuX3BlZXJGdXR1cmUpXG4gICAgcmV0dXJuIHRoaXMuX3BlZXJGdXR1cmUucHJvbWlzZVxuICB9XG5cbiAgY3JlYXRlT2ZmZXIgKGJhbmR3aWR0aCA9IG51bGwpIHtcbiAgICBkZWJ1ZygnW2NyZWF0ZW9mZmVyXScpXG4gICAgdGhpcy5fb2ZmZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9vZmZlckZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX29mZmVyRnV0dXJlKVxuICAgIHRoaXMuX3BlZXJIZWxwZXIuY3JlYXRlT2ZmZXIoYmFuZHdpZHRoLCB0aGlzLl9vZmZlckZ1dHVyZSlcbiAgICByZXR1cm4gdGhpcy5fb2ZmZXJGdXR1cmUucHJvbWlzZVxuICB9XG5cbiAgc2V0UmVtb3RlRGVzY3JpcHRpb24gKHNkcCkge1xuICAgIGRlYnVnKCdbc2V0cmVtb3RlZGVzY3JpcHRpb25dJylcbiAgICByZXR1cm4gdGhpcy5fcGVlckhlbHBlci5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZHApXG4gIH1cblxuICBzZW5kT2ZmZXIgKHNkcCwgc3RyZWFtTmFtZSkge1xuICAgIGRlYnVnKCdbc2VuZG9mZmVyXScpXG4gICAgdGhpcy5fc2VuZE9mZmVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fc2VuZE9mZmVyRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fc2VuZE9mZkZ1dHVyZSlcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBoYW5kbGVPZmZlcjogc3RyZWFtTmFtZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc2RwOiBzZHBcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0aGlzLl9zZW5kT2ZmZXJGdXR1cmUucHJvbWlzZVxuICB9XG5cbiAgc2VuZENhbmRpZGF0ZSAoY2FuZGlkYXRlLCBzdHJlYW1OYW1lKSB7XG4gICAgZGVidWcoJ1tzZW5kY2FuZGlkYXRlXScpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgaGFuZGxlQ2FuZGlkYXRlOiBzdHJlYW1OYW1lLFxuICAgICAgZGF0YToge1xuICAgICAgICBjYW5kaWRhdGU6IGNhbmRpZGF0ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXF1ZXN0UHVibGlzaCAoc3RyZWFtTmFtZSwgc3RyZWFtTW9kZSkge1xuICAgIGRlYnVnKCdbcmVxdWVzdHB1Ymxpc2hdJylcbiAgICB0aGlzLl9wdWJsaXNoRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcHVibGlzaEZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3B1Ymxpc2hGdXR1cmUpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgcHVibGlzaDogc3RyZWFtTmFtZSxcbiAgICAgIG1vZGU6IHN0cmVhbU1vZGVcbiAgICB9KVxuICAgIHJldHVybiB0aGlzLl9wdWJsaXNoRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIHJlcXVlc3RVbnB1Ymxpc2ggKHN0cmVhbU5hbWUpIHtcbiAgICB0aGlzLl91bnB1Ymxpc2hGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl91bnB1Ymxpc2hGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl91bnB1Ymxpc2hGdXR1cmUpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgdW5wdWJsaXNoOiBzdHJlYW1OYW1lXG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy5fdW5wdWJsaXNoRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIHB1Ymxpc2ggKHN0cmVhbU5hbWUgPSBudWxsLCBwcm9taXNlID0gbnVsbCkge1xuICAgIGRlYnVnKCdbcHVibGlzaF0nKVxuICAgIHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSA9IHN0cmVhbU5hbWUgfHwgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgY29uc3QgcCA9IHByb21pc2UgfHwgbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgY29uc3Qgc29ja2V0UHJvbWlzZSA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGNvbnN0IHNvY2tldHVybCA9IGVuZHBvaW50RnJvbU9wdGlvbnModGhpcy5fb3B0aW9ucylcbiAgICB0aGlzLl90cmlja2xlRW5kRnV0dXJlID0gdGhpcy5fZ2V0VHJpY2tsZUVuZCgpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnNldFVwKHNvY2tldHVybCwgc29ja2V0UHJvbWlzZSlcbi8vIDAuIEVzdGFibGlzaCBzb2NrZXQgY29ubmVjdGlvbi5cbiAgICBzb2NrZXRQcm9taXNlLnByb21pc2Vcbi8vIDEuIFdhaXQgZm9yIHN0cmVhbSBhdHRhY2hcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX1NVQ0NFU1MsIHRoaXMpKVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TWVkaWFTdHJlYW0oKVxuICAgICAgfSlcbi8vIDIuIFJlcXVlc3QgYXZhaWxhYmxlIHN0cmVhbSB0byBwdWJsaXNoIG9uXG4gICAgICAudGhlbihtZWRpYVN0cmVhbSA9PiB7XG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtID0gbWVkaWFTdHJlYW1cbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChSVENQdWJsaXNoZXJFdmVudFR5cGVzLk1FRElBX1NUUkVBTV9BVkFJTEFCTEUsIHRoaXMsIG1lZGlhU3RyZWFtKSlcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEF2YWlsYWJpbGl0eSh0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsIHRoaXMuX29wdGlvbnMuc3RyZWFtVHlwZSlcbiAgICAgIH0pXG4vLyAzLiBDcmVhdGUgUGVlciBDb25uZWN0aW9uXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVBlZXJDb25uZWN0aW9uKHRoaXMuX29wdGlvbnMuaWNlU2VydmVycylcbiAgICAgIH0pXG4vLyA0LiBNYWtlIE9mZmVyIG9uIFBlZXIgQ29ubmVjdGlvblxuICAgICAgLnRoZW4oY29ubmVjdGlvbiA9PiB7XG4gICAgICAgIGNvbm5lY3Rpb24uYWRkU3RyZWFtKHRoaXMuX21lZGlhU3RyZWFtKVxuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuUEVFUl9DT05ORUNUSU9OX0FWQUlMQUJMRSwgdGhpcywgY29ubmVjdGlvbikpXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU9mZmVyKHRoaXMuX29wdGlvbnMuYmFuZHdpZHRoKVxuICAgICAgfSlcbi8vIDUuIFNlbmQgT2ZmZXJcbiAgICAgIC50aGVuKHNlc3Npb25EZXNjcmlwdGlvbiA9PiB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRDUHVibGlzaGVyRXZlbnRUeXBlcy5PRkZFUl9TVEFSVCwgdGhpcywgc2Vzc2lvbkRlc2NyaXB0aW9uKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZE9mZmVyKHNlc3Npb25EZXNjcmlwdGlvbiwgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lKVxuICAgICAgfSlcbi8vIDYuIFNldCB0aGUgc2Vzc2lvbiBkZXNjcmlwdGlvbiByZW1vdGVseVxuICAgICAgLnRoZW4oc2RwID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2RwLnNkcClcbiAgICAgIH0pXG4vLyA3LiBXYWl0IHVudGlsIGljZSB0cmlja2xlIGVuZFxuICAgICAgLnRoZW4oc2RwID0+IHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChSVENQdWJsaXNoZXJFdmVudFR5cGVzLk9GRkVSX0VORCwgdGhpcywgc2RwKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRyaWNrbGVFbmQoKS5wcm9taXNlXG4gICAgICB9KVxuLy8gOC4gUmVxdWVzdCB0byBwdWJsaXNoIHN0cmVhbVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuSUNFX1RSSUNLTEVfQ09NUExFVEUsIHRoaXMpKVxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0UHVibGlzaCh0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsIHRoaXMuX29wdGlvbnMuc3RyZWFtTW9kZSlcbiAgICAgIH0pXG4vLyA5LiBSZXN1bHRzIGluIHNvY2tldCBtZXNzYWdlIG9mIHB1Ymxpc2ggKHNlZSA6b25QdWJsaXNoU3RhdHVzKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBwLnJlc29sdmUodGhpcylcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfU1RBUlQsIHRoaXMpKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgcC5yZWplY3QoZXJyb3IpXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMsIGVycm9yKSlcbiAgICAgIH0pXG4gICAgcmV0dXJuIHAuaGFzT3duUHJvcGVydHkoJ3Byb21pc2UnKSA/IHAucHJvbWlzZSA6IHBcbiAgfVxuXG4gIHVucHVibGlzaCAoKSB7XG4gICAgZGVidWcoJ1t1bnB1Ymxpc2hdJylcbiAgICBjb25zdCBjbGVhckhlbHBlcnMgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX3NvY2tldEhlbHBlcikge1xuICAgICAgICB0aGlzLl9zb2NrZXRIZWxwZXIudGVhckRvd24oKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3BlZXJIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5fcGVlckhlbHBlci50ZWFyRG93bigpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2F2YWlsYWJsZUZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3BlZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9vZmZlckZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NlbmRPZmZlckZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3RyaWNrbGVFbmRGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wdWJsaXNoRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgY29uc3QgZiA9IHRoaXMucmVxdWVzdFVucHVibGlzaCh0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUpXG4gICAgZi50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuX3VucHVibGlzaEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgICAgY2xlYXJIZWxwZXJzKClcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5VTlBVQkxJU0hfU1VDQ0VTUywgdGhpcykpXG4gICAgfSlcbiAgICByZXR1cm4gZlxuICB9XG5cbiAgbXV0ZSAoKSB7XG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgbXV0ZTogdHJ1ZVxuICAgIH0pXG4gIH1cblxuICB1bm11dGUgKCkge1xuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIG11dGU6IGZhbHNlXG4gICAgfSlcbiAgfVxuXG4gIHNlbmQgKG1ldGhvZE5hbWUsIGRhdGEpIHtcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBzZW5kOiB7XG4gICAgICAgIG1ldGhvZDogbWV0aG9kTmFtZSxcbiAgICAgICAgZGF0YTogKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgPyBKU09OLnBhcnNlKGRhdGEpIDogZGF0YVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBvblN0cmVhbUF2YWlsYWJsZSAocmVjZWlwdCkge1xuICAgIGRlYnVnKCdbb25zdHJlYW1hdmFpbGFibGVdOiAnICsgSlNPTi5zdHJpbmdpZnkocmVjZWlwdCwgbnVsbCwgMikpXG4gICAgdGhpcy5fYXZhaWxhYmxlRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fYXZhaWxhYmxlRnV0dXJlKVxuICAgIHRoaXMuX2F2YWlsYWJsZUZ1dHVyZS5yZWplY3QoYFN0cmVhbSB3aXRoIG5hbWUgJHt0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWV9IGFscmVhZHkgaGFzIGEgYnJvYWRjYXN0IHNlc3Npb24uYClcbiAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9JTlZBTElEX05BTUUsIHRoaXMpKVxuICB9XG5cbiAgb25TdHJlYW1VbmF2YWlsYWJsZSAocmVjZWlwdCkge1xuICAgIC8vIEJlaW5nIHVuYXZhaWxhYmxlLCBpcyBhIGdvb2QgdGhpbmcgZm9yIGFsbG93aW5nIHRvIHB1Ymxpc2ggdXNpbmcgYG9wdGlvbnMuc3RyZWFtTmFtZWBcbiAgICBkZWJ1ZyhgU3RyZWFtICR7dGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lfSBkb2VzIG5vdCBleGlzdC5gKVxuICAgIGRlYnVnKCdbb25zdHJlYW11bmF2YWlsYWJsZV06ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSlcbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9hdmFpbGFibGVGdXR1cmUpXG4gICAgdGhpcy5fYXZhaWxhYmxlRnV0dXJlLnJlc29sdmUodHJ1ZSlcbiAgfVxuXG4gIG9uU29ja2V0TWVzc2FnZUVycm9yIChtZXNzYWdlLCBkZXRhaWwgPSBudWxsKSB7XG4gICAgZXJyb3IoYEVycm9yIGluIHN0cmVhbSBwbGF5YmFjazogJHttZXNzYWdlfS5cXG5bT3B0aW9uYWwgZGV0YWlsXTogJHtkZXRhaWx9YClcbiAgICBpZiAodGhpcy5fcHVibGlzaEZ1dHVyZSkge1xuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfRkFJTCwgdGhpcykpXG4gICAgICB0aGlzLl9wdWJsaXNoRnV0dXJlLnJlamVjdChtZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIG9uU0RQU3VjY2VzcyAocmVjZWlwdCkge1xuICAgIGxldCBpbmZvID0gcmVjZWlwdCA/ICc6ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSA6ICcnXG4gICAgZGVidWcoYFtvbnNkcHN1Y2Nlc3NdJHtpbmZvfWApXG4gIH1cblxuICBvblNEUEVycm9yIChyZWNlaXB0KSB7XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfRkFJTCwgdGhpcykpXG4gICAgbGV0IGVycm9yID0gcmVjZWlwdCA/ICc6ICcgKyBKU09OLnN0cmluZ2lmeShyZWNlaXB0LCBudWxsLCAyKSA6ICcnXG4gICAgZXJyb3IoYFtvbnNkcGVycm9yXSR7ZXJyb3J9YClcbiAgfVxuXG4gIG9uU0RQQW5zd2VyIChzZHApIHtcbiAgICBkZWJ1ZygnW3NkcGFuc3dlcl06OiAnICsgSlNPTi5zdHJpbmdpZnkoc2RwLCBudWxsLCAyKSlcbiAgICB0aGlzLl9zZW5kT2ZmZXJGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9zZW5kT2ZmZXJGdXR1cmUpXG4gICAgdGhpcy5fc2VuZE9mZmVyRnV0dXJlLnJlc29sdmUoc2RwKVxuICB9XG5cbiAgb25BZGRJY2VDYW5kaWRhdGUgKGNhbmRpZGF0ZSkge1xuICAgIGRlYnVnKCdbYWRkaWNlY2FuZGlkYXRlXScpXG4gICAgdGhpcy5fcGVlckhlbHBlci5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBkZWJ1ZygnW2FkZGljZWNhbmRpZGF0ZTpzdWNjZXNzXScpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIHdhcm4oYFthZGRpY2VjYW5kaWRhdGU6ZXJyb3JdIC0gJHtlcnJ9YClcbiAgICAgIH0pXG4gIH1cblxuICBvbkljZUNhbmRpZGF0ZSAoY2FuZGlkYXRlKSB7XG4gICAgZGVidWcoJ1tpY2VjYW5kaWRhdGV0cmlja2xlXScpXG4gICAgdGhpcy5zZW5kQ2FuZGlkYXRlKGNhbmRpZGF0ZSwgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lKVxuICB9XG5cbiAgb25JY2VDYW5kaWRhdGVUcmlja2xlRW5kICgpIHtcbiAgICBkZWJ1ZygnW2ljZWNhbmRpZGF0ZXRyaWNrbGU6ZW5kXScpXG4gIH1cblxuICBvblNvY2tldEljZUNhbmRpZGF0ZUVuZCAoKSB7XG4gICAgZGVidWcoJ1tzb2NrZXRpY2VjYW5kaWRhdGU6ZW5kXScpXG4gICAgdGhpcy5fZ2V0VHJpY2tsZUVuZCgpLnJlc29sdmUoKVxuICAgIC8vIHRoaXMuX3RyaWNrbGVFbmRGdXR1cmUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIG9uUHVibGlzaGVyU3RhdHVzIChzdGF0dXMpIHtcbiAgICBkZWJ1ZygnW3B1Ymxpc2hlcnN0YXR1c10gLSAnICsgSlNPTi5zdHJpbmdpZnkoc3RhdHVzLCBudWxsLCAyKSlcbiAgICBjb25zdCBzdG9wUmVzdWx0ID0gcHViU3RvcFJlZ2V4LmV4ZWMoc3RhdHVzLm1lc3NhZ2UpXG4gICAgY29uc3Qgc3RhcnRSZXN1bHQgPSBwdWJTdGFydFJlZ2V4LmV4ZWMoc3RhdHVzLm1lc3NhZ2UpXG4gICAgaWYgKHN0b3BSZXN1bHQgJiYgc3RvcFJlc3VsdFsxXSA9PT0gdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lKSB7XG4gICAgICB0aGlzLl91bnB1Ymxpc2hGdXR1cmUucmVzb2x2ZSgpXG4gICAgfSBlbHNlIGlmIChzdGFydFJlc3VsdCAmJiBzdGFydFJlc3VsdFsxXSA9PT0gdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lKSB7XG4gICAgICB0aGlzLl9wdWJsaXNoRnV0dXJlLnJlc29sdmUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKCdQdWJsaXNoZXIgc3RhdHVzIHJlY2VpdmVkLCBidXQgY291bGQgbm90IGhhbmRsZS4nKVxuICAgIH1cbiAgfVxuXG4gIG92ZXJsYXlPcHRpb25zIChuZXdPcHRpb25zKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24odGhpcy5fb3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gIH1cblxuICBnZXRDb25uZWN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ja2V0SGVscGVyXG4gIH1cblxuICBnZXRQZWVyQ29ubmVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJIZWxwZXIgPyB0aGlzLl9wZWVySGVscGVyLmNvbm5lY3Rpb24gOiB1bmRlZmluZWRcbiAgfVxuXG4gIGdldE1lZGlhU3RyZWFtICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1cbiAgfVxuXG4gIGdldE9wdGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zXG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gUHVibGlzaFR5cGVzLlJUQy50b1VwcGVyQ2FzZSgpXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSVENQdWJsaXNoZXJcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvcHVibGlzaGVyL3JlZDVwcm8tcnRjLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBTb2NrZXRIZWxwZXIgZnJvbSAnLi9zb2NrZXQtaGVscGVyJ1xuaW1wb3J0IHsgd2FybiwgZXJyb3IgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9QdWJsaXNoZXJTb2NrZXQnXG5cbmNsYXNzIFB1Ymxpc2hlclNvY2tldEhlbHBlciBleHRlbmRzIFNvY2tldEhlbHBlciB7XG5cbiAgY29uc3RydWN0b3IgKHJlc3BvbmRlcikge1xuICAgIHN1cGVyKHJlc3BvbmRlciwgTkFNRSlcbiAgfVxuXG4gIHJlc3BvbmQgKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS5kYXRhKSB7XG4gICAgICBsZXQganNvbiA9IHRoaXMuZ2V0SnNvbkZyb21Tb2NrZXRNZXNzYWdlKG1lc3NhZ2UpXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXN1cGVyLnJlc3BvbmQobWVzc2FnZSkpIHtcbiAgICAgICAgICBpZiAoanNvbi5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChqc29uLmRhdGEuc2RwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5zZHAudHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TRFBBbnN3ZXIoanNvbi5kYXRhKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNvbi5kYXRhLmNhbmRpZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkFkZEljZUNhbmRpZGF0ZShqc29uLmRhdGEuY2FuZGlkYXRlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24uZGF0YS50eXBlID09PSAnc3RhdHVzJykge1xuICAgICAgICAgICAgICBpZiAoanNvbi5kYXRhLmNvZGUgPT09ICdOZXRDb25uZWN0aW9uLklDRS5UcmljbGVDb21wbGV0ZWQnIHx8XG4gICAgICAgICAgICAgICAgIGpzb24uZGF0YS5jb2RlID09PSAnTmV0Q29ubmVjdGlvbi5JQ0UuVHJpY2tsZUNvbXBsZXRlZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25Tb2NrZXRJY2VDYW5kaWRhdGVFbmQoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblB1Ymxpc2hlclN0YXR1cyhqc29uLmRhdGEpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoTkFNRSwgYFt3cy5vbm1lc3NhZ2VdIC0gRXJyb3IgaW4gYWNjZXNzaW5nIG1lc3NhZ2UgZGF0YSBhcyBKU09OLiAke2UubWVzc2FnZX1gKVxuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25Tb2NrZXRNZXNzYWdlRXJyb3IoYFt3cy5vbm1lc3NhZ2VdIC0gRXJyb3IgaW4gYWNjZXNzaW5nIG1lc3NhZ2UgZGF0YSBhcyBKU09OLiAke2UubWVzc2FnZX1gKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKE5BTUUsICdbd3Mub25tZXNzYWdlXSAtIE5vIE1lc3NhZ2UgRGF0YS4nKVxuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFB1Ymxpc2hlclNvY2tldEhlbHBlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvaGVscGVyL3NvY2tldC1oZWxwZXItcHViLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5pbXBvcnQgKiBhcyB3ZWJydGMgZnJvbSAnLi4vYWRhcHRlci93ZWJydGMnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBkZWJ1Zywgd2FybiB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1B1Ymxpc2hQZWVyJ1xuXG5jbGFzcyBQdWJsaXNoZXJQZWVySGVscGVyIHtcblxuICBjb25zdHJ1Y3RvciAocmVzcG9uZGVyKSB7XG4gICAgdGhpcy5fcmVzcG9uZGVyID0gcmVzcG9uZGVyXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24gPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9yZW1vdmVDb25uZWN0aW9uSGFuZGxlcnMgKGNvbm5lY3Rpb24pIHtcbiAgICBjb25uZWN0aW9uLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gdW5kZWZpbmVkXG4gICAgY29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgX2FkZENvbm5lY3Rpb25IYW5kbGVycyAoY29ubmVjdGlvbiwgcHJvbWlzZSkge1xuICAgIGNvbm5lY3Rpb24ub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAoY29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgIGRlYnVnKE5BTUUsICdbcGVlcmNvbm5lY3Rpb246b3Blbl0nKVxuICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgIHByb21pc2UucmVzb2x2ZSh0aGlzKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJyB8fFxuICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgd2FybihOQU1FLCAnW3BlZXJjb25uZWN0aW9uOmVycm9yXScpXG4gICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZWplY3QoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgZGVidWcoTkFNRSwgYFtwZWVyLm9uaWNlY2FuZGlkYXRlXSAtIFBlZXIgQ2FuZGlkYXRlOiAke2V2ZW50LmNhbmRpZGF0ZX1gKVxuICAgICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSkge1xuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25JY2VDYW5kaWRhdGUoZXZlbnQuY2FuZGlkYXRlKVxuICAgICAgfSBlbHNlIGlmIChldmVudC5jYW5kaWRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gbnVsbCBtZWFucyB0aGV5IGhhdmUgZmluaXNoZWQgc2VuZGluZyBjYW5kaWRhdGVzIGJhY2sgYW5kIGZvcnRoP1xuICAgICAgICAvLyBNb3ZlZCB0byBub3RpZmljYXRpb24gZnJvbSBzZXJ2ZXIgb24gdHJpY2tsZSBlbmQgZXZlbnQuXG4gICAgICAgIC8vIHRoaXMuX3Jlc3BvbmRlci5vbkljZUNhbmRpZGF0ZVRyaWNrbGVFbmQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZU9mZmVyIChiYW5kd2lkdGggPSBudWxsLCBvZmZlclByb21pc2UgPSBudWxsKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjcmVhdGVvZmZlcl0nKVxuICAgIGNvbnN0IHAgPSBvZmZlclByb21pc2UgfHwgbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uY3JlYXRlT2ZmZXIoKVxuICAgICAgLnRoZW4oKHNlc3Npb25EZXNjcmlwdGlvbikgPT4ge1xuICAgICAgICB0aGlzLnNldExvY2FsRGVzY3JpcHRpb24oc2Vzc2lvbkRlc2NyaXB0aW9uLCBiYW5kd2lkdGgpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGJhbmR3aWR0aCkge1xuICAgICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb24uc2RwID0gd2VicnRjLnVwZGF0ZUJhbmR3aWR0aChiYW5kd2lkdGgsIHNlc3Npb25EZXNjcmlwdGlvbi5zZHApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TRFBTdWNjZXNzKClcbiAgICAgICAgICAgIHAucmVzb2x2ZShzZXNzaW9uRGVzY3JpcHRpb24pXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU0RQRXJyb3IoZXJyKVxuICAgICAgICAgICAgcC5yZWplY3QoZXJyKVxuICAgICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGRlYnVnKE5BTUUsICdbY3JlYXRlb2ZmZXI6ZXJyb3JdJylcbiAgICAgICAgcC5yZWplY3QoZXJyKVxuICAgICAgfSlcbiAgICByZXR1cm4gcC5oYXNPd25Qcm9wZXJ0eSgncHJvbWlzZScpID8gcC5wcm9taXNlIDogcFxuICB9XG5cbiAgc2V0TG9jYWxEZXNjcmlwdGlvbiAoc2Vzc2lvbkRlc2NyaXB0aW9uLCBiYW5kd2lkdGggPSBudWxsKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBkZWJ1ZyhOQU1FLCAnW3NldGxvY2FsZGVzY3JpcHRpb25dJylcbiAgICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihzZXNzaW9uRGVzY3JpcHRpb24pXG4gIH1cblxuICBzZXRSZW1vdGVEZXNjcmlwdGlvbiAoc2RwKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzZXRyZW1vdGVkZXNjcmlwdGlvbl0nKVxuICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgd2VicnRjLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbihzZHApKVxuICB9XG5cbiAgYWRkSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2FkZGNhbmRpZGF0ZV0nKVxuICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvbi5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICB9XG5cbiAgc2V0VXAgKGljZVNlcnZlcnMsIHNldFVwUHJvbWlzZSA9IG51bGwpIHtcbiAgICB0aGlzLnRlYXJEb3duKClcbiAgICBkZWJ1ZyhOQU1FLCAnW3NldHVwXScpXG4gICAgY29uc3QgcCA9IHNldFVwUHJvbWlzZSB8fCBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0cnkge1xuICAgICAgbGV0IHBlZXIgPSBuZXcgd2VicnRjLlJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyxcbiAgICAgICAgcnRjcE11eFBvbGljeTogJ25lZ290aWF0ZSdcbiAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBvcHRpb25hbDogW1xuICAgICAgICAgICAge0R0bHNTcnRwS2V5QWdyZWVtZW50OiB0cnVlfSxcbiAgICAgICAgICAgIHtSdHBEYXRhQ2hhbm5lbHM6IGZhbHNlfSxcbiAgICAgICAgICAgIHtnb29nQ3B1T3ZlcnVzZURldGVjdGlvbjogdHJ1ZX1cbiAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICB0aGlzLl9hZGRDb25uZWN0aW9uSGFuZGxlcnMocGVlcilcbiAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uID0gcGVlclxuICAgICAgcC5yZXNvbHZlKHBlZXIpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybihOQU1FLCBgQ291bGQgbm90IGVzdGFibGlzaCBhIFBlZXJDb25uZWN0aW9uLiAke2UubWVzc2FnZX1gKVxuICAgICAgcC5yZWplY3QoZS5tZXNzYWdlKVxuICAgIH1cbiAgICByZXR1cm4gcC5oYXNPd25Qcm9wZXJ0eSgncHJvbWlzZScpID8gcC5wcm9taXNlIDogcFxuICB9XG5cbiAgdGVhckRvd24gKCkge1xuICAgIGRlYnVnKE5BTUUsICdbdGVhcmRvd25dJylcbiAgICBpZiAodGhpcy5fcGVlckNvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMuX3JlbW92ZUNvbm5lY3Rpb25IYW5kbGVycyh0aGlzLl9wZWVyQ29ubmVjdGlvbilcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLmNsb3NlKClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd2FybihOQU1FLCBgW3BlZXJjb25uZWN0aW9uLmNsb3NlXSBlcnJvcjogJHtlLm1lc3NhZ2V9YClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgY29ubmVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJDb25uZWN0aW9uXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQdWJsaXNoZXJQZWVySGVscGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9oZWxwZXIvd2VicnRjLWhlbHBlci1wdWIuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBTaGFyZWRPYmplY3RFdmVudCB9IGZyb20gJy4uL2V2ZW50L2luZGV4J1xuaW1wb3J0IHsgY29tbW9uIGFzIFNoYXJlZE9iamVjdEV2ZW50VHlwZXMgfSBmcm9tICcuLi9ldmVudC9zaGFyZWRvYmplY3QtZXZlbnQnXG5cbmltcG9ydCB7IGRlYnVnIGFzIGRlYnVnTG9nIH0gZnJvbSAnLi4vbG9nJ1xuaW1wb3J0IHsgd2FybiBhcyB3YXJuTG9nIH0gZnJvbSAnLi4vbG9nJ1xuaW1wb3J0IHsgZXJyb3IgYXMgZXJyb3JMb2cgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUmVkNVByb1NoYXJlZE9iamVjdCdcbmNvbnN0IGRlYnVnID0gKHNvTmFtZSwgbWVzc2FnZSkgPT4ge1xuICBkZWJ1Z0xvZyhbTkFNRSwgc29OYW1lXS5qb2luKCc6JyksIG1lc3NhZ2UpXG59XG5jb25zdCB3YXJuID0gKHNvTmFtZSwgbWVzc2FnZSkgPT4ge1xuICB3YXJuTG9nKFtOQU1FLCBzb05hbWVdLmpvaW4oJzonKSwgbWVzc2FnZSlcbn1cbmNvbnN0IGVycm9yID0gKHNvTmFtZSwgbWVzc2FnZSkgPT4ge1xuICBlcnJvckxvZyhbTkFNRSwgc29OYW1lXS5qb2luKCc6JyksIG1lc3NhZ2UpXG59XG5cbmNvbnN0IFNPX1NVQlRZUEVfUFJPUEVSVFkgPSA0XG5jb25zdCBTT19TVUJUWVBFX01FVEhPRCA9IDZcblxuY29uc3QgZGVjb2RlTWVzc2FnZUlmSlNPTlN0cmluZyA9IChtZXNzYWdlKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKG1lc3NhZ2UpIDogbWVzc2FnZVxufVxuXG5jbGFzcyBQcm9wZXJ0eURhdGEge1xuXG4gIGNvbnN0cnVjdG9yIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5rZXkgPSBrZXlcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgfVxuXG4gIHRvT2JqZWN0ICgpIHtcbiAgICBsZXQgb2JqID0gIHt9XG4gICAgb2JqW3RoaXMua2V5XSA9IHRoaXMudmFsdWVcbiAgICByZXR1cm4gb2JqXG4gIH1cblxufVxuXG5jbGFzcyBNZXRob2REYXRhIHtcblxuICBjb25zdHJ1Y3RvciAobWV0aG9kTmFtZSwgbWVzc2FnZSkge1xuICAgIHRoaXMubWV0aG9kTmFtZSA9IG1ldGhvZE5hbWVcbiAgICBsZXQgbWVzc2FnZUxpc3RcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICBsZXQgaVxuICAgICAgbGV0IG1zZ1xuICAgICAgbGV0IGxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoXG4gICAgICBtZXNzYWdlTGlzdCA9IFtdXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbXNnID0gZGVjb2RlTWVzc2FnZUlmSlNPTlN0cmluZyhtZXNzYWdlW2ldKVxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgbWVzc2FnZUxpc3QgPSBtZXNzYWdlTGlzdC5jb25jYXQobXNnKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2VMaXN0LnB1c2gobXNnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbWVzc2FnZUxpc3QgPSBbZGVjb2RlTWVzc2FnZUlmSlNPTlN0cmluZyhtZXNzYWdlKV1cbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZUxpc3QubGVuZ3RoID09PSAxID8gbWVzc2FnZUxpc3RbMF0gOiBtZXNzYWdlTGlzdFxuICB9XG5cbiAgdG9PYmplY3QgKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtZXRob2ROYW1lOiB0aGlzLm1ldGhvZE5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBSZWQ1UHJvU2hhcmVkT2JqZWN0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAobmFtZSwgY29ubmVjdGlvbikge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9uYW1lID0gbmFtZVxuICAgIHRoaXMuX3NvY2tldCA9IGNvbm5lY3Rpb24uZ2V0Q29ubmVjdGlvbigpXG4gICAgdGhpcy5fc29ja2V0LmFkZFNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlcih0aGlzKVxuICAgIHRoaXMuX29uY2xvc2UgPSB0aGlzLmNsb3NlLmJpbmQodGhpcylcbiAgICB0cnkge1xuICAgICAgZGVidWcodGhpcy5fbmFtZSwgJ1tzaGFyZWRvYmplY3Q6Y29ubmVjdDphdHRlbXB0XScpXG4gICAgICB0aGlzLl9zb2NrZXQuZ2V0UmVtb3RlU2hhcmVkT2JqZWN0KHRoaXMuX25hbWUpXG4gICAgICBlbnZpcm9ubWVudC5hZGRDbG9zZUhhbmRsZXIodGhpcy5fb25jbG9zZSwgMClcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yKHRoaXMuX25hbWUsICdbc2hhcmVkb2JqZWN0OmNvbm5lY3Q6ZXJyb3JdOiAnICsgZS5tZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIGdldEpzb25Gcm9tU29ja2V0TWVzc2FnZSAobWVzc2FnZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2UuZGF0YSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKG1lc3NhZ2UuZGF0YSkgOiBtZXNzYWdlLmRhdGFcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4odGhpcy5fbmFtZSwgJ0NvdWxkIG5vdCBwYXJzZSBtZXNzYWdlIGFzIEpTT04uIE1lc3NhZ2U9ICcgKyBtZXNzYWdlLmRhdGEgKyAnLiBFcnJvcj0gJyArIGUubWVzc2FnZSlcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIG5vdGlmeU9mUHJvcGVydHlWYWx1ZXMgKHZhbHVlT2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlT2JqZWN0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTaGFyZWRPYmplY3RFdmVudChTaGFyZWRPYmplY3RFdmVudFR5cGVzLlBST1BFUlRZX1VQREFURSwgdGhpcy5fbmFtZSwge30pKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxldCBrZXlcbiAgICAgIGZvciAoa2V5IGluIHZhbHVlT2JqZWN0KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU2hhcmVkT2JqZWN0RXZlbnQoU2hhcmVkT2JqZWN0RXZlbnRUeXBlcy5QUk9QRVJUWV9VUERBVEUsIHRoaXMuX25hbWUsIG5ldyBQcm9wZXJ0eURhdGEoa2V5LCB2YWx1ZU9iamVjdFtrZXldKS50b09iamVjdCgpKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBub3RpZnlPZkV2ZW50cyAoZXZlbnRzKSB7XG4gICAgbGV0IGksIGV2ZW50XG4gICAgY29uc3QgbGVuZ3RoID0gZXZlbnRzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgZXZlbnQgPSBldmVudHNbaV1cbiAgICAgIHN3aXRjaCAoZXZlbnQuc3VidHlwZSkge1xuICAgICAgICBjYXNlIFNPX1NVQlRZUEVfUFJPUEVSVFk6XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTaGFyZWRPYmplY3RFdmVudChTaGFyZWRPYmplY3RFdmVudFR5cGVzLlBST1BFUlRZX1VQREFURSwgdGhpcy5fbmFtZSwgbmV3IFByb3BlcnR5RGF0YShldmVudC5hdHRyaWJ1dGUsIGV2ZW50LnZhbHVlKS50b09iamVjdCgpKSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBjYXNlIFNPX1NVQlRZUEVfTUVUSE9EOlxuICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU2hhcmVkT2JqZWN0RXZlbnQoU2hhcmVkT2JqZWN0RXZlbnRUeXBlcy5NRVRIT0RfVVBEQVRFLCB0aGlzLl9uYW1lLCBuZXcgTWV0aG9kRGF0YShldmVudC5tZXRob2QsIGV2ZW50LnZhbHVlKS50b09iamVjdCgpKSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJlc3BvbmQgKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS5kYXRhKSB7XG4gICAgICBsZXQganNvbiA9IHRoaXMuZ2V0SnNvbkZyb21Tb2NrZXRNZXNzYWdlKG1lc3NhZ2UpXG4gICAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgICAgICB3YXJuKHRoaXMuX25hbWUsICdEZXRlcm1pbmVkIHdlYnNvY2tldCByZXNwb25zZSBub3QgaW4gY29ycmVjdCBmb3JtYXQuIEFib3J0aW5nIG1lc3NhZ2UgaGFuZGxlLicpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGpzb24uZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChqc29uLmRhdGEubmFtZSA9PT0gdGhpcy5fbmFtZSkge1xuICAgICAgICAgIGRlYnVnKHRoaXMuX25hbWUsICdbc2hhcmVkb2JqZWN0LXJlc3BvbnNlXTogJyArIEpTT04uc3RyaW5naWZ5KGpzb24sIG51bGwsIDIpKVxuICAgICAgICAgIGlmIChqc29uLmRhdGEuc3RhdHVzID09PSAnU2hhcmVkT2JqZWN0LlN0YXR1cy5HZXRSZW1vdGUnICYmXG4gICAgICAgICAgICAgIGpzb24uZGF0YS5tZXNzYWdlID09PSAnU3VjY2VzcycpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvY2tldC5jb25uZWN0VG9TaGFyZWRPYmplY3QodGhpcy5fbmFtZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGpzb24uZGF0YS5zdGF0dXMgPT09ICdTaGFyZWRPYmplY3QuU3RhdHVzLkdldFJlbW90ZScgJiZcbiAgICAgICAgICAgICAganNvbi5kYXRhLm1lc3NhZ2UgPT09ICdGYWlsJykge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTaGFyZWRPYmplY3RFdmVudChTaGFyZWRPYmplY3RFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSwgdGhpcy5fbmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChqc29uLmRhdGEuc3RhdHVzID09PSAnU2hhcmVkT2JqZWN0LlN0YXR1cy5Db25uZWN0JyAmJlxuICAgICAgICAgICAgICBqc29uLmRhdGEubWVzc2FnZSA9PT0gJ1N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFNoYXJlZE9iamVjdEV2ZW50KFNoYXJlZE9iamVjdEV2ZW50VHlwZXMuQ09OTkVDVF9TVUNDRVNTLCB0aGlzLl9uYW1lKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGpzb24uZGF0YS5zdGF0dXMgPT09ICdTaGFyZWRPYmplY3QuU3RhdHVzLkNvbm5lY3QnICYmXG4gICAgICAgICAgICAgIGpzb24uZGF0YS5tZXNzYWdlID09PSAnRmFpbCcpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU2hhcmVkT2JqZWN0RXZlbnQoU2hhcmVkT2JqZWN0RXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMuX25hbWUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoanNvbi5kYXRhLnR5cGUgPT09ICdzaGFyZWRvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoanNvbi5kYXRhLmhhc093blByb3BlcnR5KCdldmVudHMnKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub3RpZnlPZkV2ZW50cyhqc29uLmRhdGEuZXZlbnRzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoanNvbi5kYXRhLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vdGlmeU9mUHJvcGVydHlWYWx1ZXMoanNvbi5kYXRhLnZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnVW5oYW5kbGVkIFNvY2tldCBleGNoYW5nZTogJyArIEpTT04uc3RyaW5naWZ5KGpzb24sIG51bGwsIDIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHNlbmQgKG1lc3NhZ2VOYW1lLCBkYXRhKSB7XG4gICAgdGhpcy5fc29ja2V0LnNlbmRUb1NoYXJlZE9iamVjdCh0aGlzLl9uYW1lLCBtZXNzYWdlTmFtZSwgZGF0YSlcbiAgfVxuXG4gIHNlbmRQcm9wZXJ0eSAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3NvY2tldC5zZW5kUHJvcGVydHlUb1NoYXJlZE9iamVjdCh0aGlzLl9uYW1lLCBrZXksIHZhbHVlKVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIGlmICh0aGlzLl9zb2NrZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgd2FybignU29ja2V0IG5vIGxvbmdlciBleGlzdCB0byBjbG9zZSBzaGFyZWQgb2JqZWN0IHByb3Blcmx5LicpXG4gICAgfVxuICAgIHRoaXMuX3NvY2tldC5jbG9zZVNoYXJlZE9iamVjdCh0aGlzLl9uYW1lKVxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3NvY2tldC5yZW1vdmVTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIodGhpcylcbiAgICB9XG4gICAgdGhpcy5fc29ja2V0ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fbmFtZSA9IHVuZGVmaW5lZFxuICAgIGVudmlyb25tZW50LnJlbW92ZUNsb3NlSGFuZGxlcih0aGlzLl9vbmNsb3NlKVxuICB9XG5cbiAgZ2V0TmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVcbiAgfVxuXG59XG5cbmV4cG9ydCB7IFJlZDVQcm9TaGFyZWRPYmplY3QgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvc2hhcmVkb2JqZWN0L2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzY3JpcHQnXG5cbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IGRlYnVnLCB3YXJuLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1BsYXliYWNrVmlldydcbmNvbnN0IHBsYXliYWNrSWQgPSAncmVkNXByby1zdWJzY3JpYmVyJ1xuXG5leHBvcnQgY2xhc3MgUGxheWJhY2tWaWV3IHtcblxuICBjb25zdHJ1Y3RvciAoZWxlbWVudElkID0gcGxheWJhY2tJZCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBUYXJnZXQgdmlkZW8gZWxlbWVudC5cbiAgICAgIHRoaXMuX3RhcmdldEVsZW1lbnQgPSBlbnZpcm9ubWVudC5yZXNvbHZlRWxlbWVudChlbGVtZW50SWQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoTkFNRSwgYENvdWxkIG5vdCBpbnN0YW50aWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBSZWQ1UHJvU3Vic2NyaWJlci4gUmVhc29uOiAke2UubWVzc2FnZX1gKVxuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIGF0dGFjaFN1YnNjcmliZXIgKHN1YnNjcmliZXIpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2F0dGFjaHN1YnNjcmliZXJdJylcbiAgICBzdWJzY3JpYmVyLnNldFZpZXcodGhpcywgZW52aXJvbm1lbnQuZ2V0RWxlbWVudElkKHRoaXMuX3RhcmdldEVsZW1lbnQpKVxuICB9XG5cbiAgYXR0YWNoU3RyZWFtIChtZWRpYVN0cmVhbSwgYXV0b3BsYXkgPSBmYWxzZSkge1xuICAgIGRlYnVnKE5BTUUsIGBbYXR0YWNoc3RyZWFtXTogYXV0b3BsYXkoJHthdXRvcGxheX0pYClcbiAgICBlbnZpcm9ubWVudC5zZXRWaWRlb1NvdXJjZSh0aGlzLl90YXJnZXRFbGVtZW50LCBtZWRpYVN0cmVhbSwgYXV0b3BsYXkpXG4gIH1cblxuICBzdG9wICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3N0b3BdJylcbiAgICB0cnkge1xuICAgICAgdGhpcy5fdGFyZ2V0RWxlbWVudC5wYXVzZSgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybihOQU1FLCBgQ291bGQgbm90IHN0b3AgdmlkZW8gZWxlbWVudDogJHtlLm1lc3NhZ2V9YClcbiAgICB9XG4gIH1cblxuICBnZXQgdmlldyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldEVsZW1lbnRcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBsYXliYWNrVmlld1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvdmlldy9wbGF5YmFjay5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5cbmltcG9ydCB7IGRlYnVnLCBlcnJvciB9IGZyb20gJy4uL2xvZydcbmNvbnN0IE5BTUUgPSAnUjVQcm9QdWJsaXNoVmlldydcblxuY29uc3QgcHVibGlzaGVySWQgPSAncmVkNXByby1wdWJsaXNoZXInXG5cbmNsYXNzIFB1Ymxpc2hWaWV3IHtcblxuICBjb25zdHJ1Y3RvciAoZWxlbWVudElkID0gcHVibGlzaGVySWQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fdGFyZ2V0RWxlbWVudCA9IGVudmlyb25tZW50LnJlc29sdmVFbGVtZW50KGVsZW1lbnRJZClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihOQU1FLCBgQ291bGQgbm90IGluc3RhbnRpYXRlIGEgbmV3IGluc3RhbmNlIG9mIFJlZDVQcm9QdWJsaXNoZXIuIFJlYXNvbjogJHtlLm1lc3NhZ2V9YClcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICBhdHRhY2hQdWJsaXNoZXIgKHB1Ymxpc2hlcikge1xuICAgIGRlYnVnKE5BTUUsICdbYXR0YWNocHVibGlzaGVyXScpXG4gICAgcHVibGlzaGVyLnNldFZpZXcodGhpcywgZW52aXJvbm1lbnQuZ2V0RWxlbWVudElkKHRoaXMuX3RhcmdldEVsZW1lbnQpKVxuICB9XG5cbiAgcHJldmlldyAobWVkaWFTdHJlYW0sIGF1dG9wbGF5ID0gZmFsc2UpIHtcbiAgICBkZWJ1ZyhOQU1FLCBgW3ByZXZpZXddOiBhdXRvcGxheSgke2F1dG9wbGF5fSlgKVxuICAgIGVudmlyb25tZW50LnNldFZpZGVvU291cmNlKHRoaXMuX3RhcmdldEVsZW1lbnQsIG1lZGlhU3RyZWFtLCBhdXRvcGxheSlcbiAgfVxuXG4gIGdldCB2aWV3ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0RWxlbWVudFxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHVibGlzaFZpZXdcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3ZpZXcvcHVibGlzaC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=