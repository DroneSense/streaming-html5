/*!
 * 
 *   red5pro-sdk - Red5 Pro HTML Publisher and Subscriber SDK.
 *   Author: Infrared5 Inc.
 *   Version: 3.2.0
 *   Url: https://github.com/red5pro/red5pro-html-sdk#readme
 *   License(s): MIT
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["red5prosdk"] = factory();
	else
		root["red5prosdk"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(298);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	__webpack_require__(2);
	
	__webpack_require__(293);
	
	__webpack_require__(295);
	
	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	global._babelPolyfill = true;
	
	var DEFINE_PROPERTY = "defineProperty";
	function define(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}
	
	define(String.prototype, "padLeft", "".padStart);
	define(String.prototype, "padRight", "".padEnd);
	
	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define(Array, key, Function.call.bind([][key]));
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(3);
	__webpack_require__(52);
	__webpack_require__(53);
	__webpack_require__(54);
	__webpack_require__(55);
	__webpack_require__(57);
	__webpack_require__(60);
	__webpack_require__(61);
	__webpack_require__(62);
	__webpack_require__(63);
	__webpack_require__(64);
	__webpack_require__(65);
	__webpack_require__(66);
	__webpack_require__(67);
	__webpack_require__(68);
	__webpack_require__(70);
	__webpack_require__(72);
	__webpack_require__(74);
	__webpack_require__(76);
	__webpack_require__(79);
	__webpack_require__(80);
	__webpack_require__(81);
	__webpack_require__(85);
	__webpack_require__(87);
	__webpack_require__(89);
	__webpack_require__(92);
	__webpack_require__(93);
	__webpack_require__(94);
	__webpack_require__(95);
	__webpack_require__(97);
	__webpack_require__(98);
	__webpack_require__(99);
	__webpack_require__(100);
	__webpack_require__(101);
	__webpack_require__(102);
	__webpack_require__(103);
	__webpack_require__(105);
	__webpack_require__(106);
	__webpack_require__(107);
	__webpack_require__(109);
	__webpack_require__(110);
	__webpack_require__(111);
	__webpack_require__(113);
	__webpack_require__(114);
	__webpack_require__(115);
	__webpack_require__(116);
	__webpack_require__(117);
	__webpack_require__(118);
	__webpack_require__(119);
	__webpack_require__(120);
	__webpack_require__(121);
	__webpack_require__(122);
	__webpack_require__(123);
	__webpack_require__(124);
	__webpack_require__(125);
	__webpack_require__(126);
	__webpack_require__(131);
	__webpack_require__(132);
	__webpack_require__(136);
	__webpack_require__(137);
	__webpack_require__(138);
	__webpack_require__(139);
	__webpack_require__(141);
	__webpack_require__(142);
	__webpack_require__(143);
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(146);
	__webpack_require__(147);
	__webpack_require__(148);
	__webpack_require__(149);
	__webpack_require__(150);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(153);
	__webpack_require__(154);
	__webpack_require__(155);
	__webpack_require__(156);
	__webpack_require__(157);
	__webpack_require__(159);
	__webpack_require__(160);
	__webpack_require__(166);
	__webpack_require__(167);
	__webpack_require__(169);
	__webpack_require__(170);
	__webpack_require__(171);
	__webpack_require__(175);
	__webpack_require__(176);
	__webpack_require__(177);
	__webpack_require__(178);
	__webpack_require__(179);
	__webpack_require__(181);
	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(184);
	__webpack_require__(187);
	__webpack_require__(189);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(193);
	__webpack_require__(195);
	__webpack_require__(197);
	__webpack_require__(198);
	__webpack_require__(199);
	__webpack_require__(201);
	__webpack_require__(202);
	__webpack_require__(203);
	__webpack_require__(204);
	__webpack_require__(211);
	__webpack_require__(214);
	__webpack_require__(215);
	__webpack_require__(217);
	__webpack_require__(218);
	__webpack_require__(221);
	__webpack_require__(222);
	__webpack_require__(224);
	__webpack_require__(225);
	__webpack_require__(226);
	__webpack_require__(227);
	__webpack_require__(228);
	__webpack_require__(229);
	__webpack_require__(230);
	__webpack_require__(231);
	__webpack_require__(232);
	__webpack_require__(233);
	__webpack_require__(234);
	__webpack_require__(235);
	__webpack_require__(236);
	__webpack_require__(237);
	__webpack_require__(238);
	__webpack_require__(239);
	__webpack_require__(240);
	__webpack_require__(241);
	__webpack_require__(242);
	__webpack_require__(244);
	__webpack_require__(245);
	__webpack_require__(246);
	__webpack_require__(247);
	__webpack_require__(248);
	__webpack_require__(249);
	__webpack_require__(251);
	__webpack_require__(252);
	__webpack_require__(253);
	__webpack_require__(254);
	__webpack_require__(255);
	__webpack_require__(256);
	__webpack_require__(257);
	__webpack_require__(258);
	__webpack_require__(260);
	__webpack_require__(261);
	__webpack_require__(263);
	__webpack_require__(264);
	__webpack_require__(265);
	__webpack_require__(266);
	__webpack_require__(269);
	__webpack_require__(270);
	__webpack_require__(271);
	__webpack_require__(272);
	__webpack_require__(273);
	__webpack_require__(274);
	__webpack_require__(275);
	__webpack_require__(276);
	__webpack_require__(278);
	__webpack_require__(279);
	__webpack_require__(280);
	__webpack_require__(281);
	__webpack_require__(282);
	__webpack_require__(283);
	__webpack_require__(284);
	__webpack_require__(285);
	__webpack_require__(286);
	__webpack_require__(287);
	__webpack_require__(288);
	__webpack_require__(291);
	__webpack_require__(292);
	module.exports = __webpack_require__(9);

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(4)
	  , has            = __webpack_require__(5)
	  , DESCRIPTORS    = __webpack_require__(6)
	  , $export        = __webpack_require__(8)
	  , redefine       = __webpack_require__(18)
	  , META           = __webpack_require__(22).KEY
	  , $fails         = __webpack_require__(7)
	  , shared         = __webpack_require__(23)
	  , setToStringTag = __webpack_require__(24)
	  , uid            = __webpack_require__(19)
	  , wks            = __webpack_require__(25)
	  , wksExt         = __webpack_require__(26)
	  , wksDefine      = __webpack_require__(27)
	  , keyOf          = __webpack_require__(29)
	  , enumKeys       = __webpack_require__(42)
	  , isArray        = __webpack_require__(45)
	  , anObject       = __webpack_require__(12)
	  , toIObject      = __webpack_require__(32)
	  , toPrimitive    = __webpack_require__(16)
	  , createDesc     = __webpack_require__(17)
	  , _create        = __webpack_require__(46)
	  , gOPNExt        = __webpack_require__(49)
	  , $GOPD          = __webpack_require__(51)
	  , $DP            = __webpack_require__(11)
	  , $keys          = __webpack_require__(30)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(50).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(44).f  = $propertyIsEnumerable;
	  __webpack_require__(43).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(28)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(10)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 4 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 5 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(7)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , core      = __webpack_require__(9)
	  , hide      = __webpack_require__(10)
	  , redefine  = __webpack_require__(18)
	  , ctx       = __webpack_require__(20)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target)redefine(target, key, out, type & $export.U);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 9 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(11)
	  , createDesc = __webpack_require__(17);
	module.exports = __webpack_require__(6) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(12)
	  , IE8_DOM_DEFINE = __webpack_require__(14)
	  , toPrimitive    = __webpack_require__(16)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(6) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(6) && !__webpack_require__(7)(function(){
	  return Object.defineProperty(__webpack_require__(15)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13)
	  , document = __webpack_require__(4).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(13);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , hide      = __webpack_require__(10)
	  , has       = __webpack_require__(5)
	  , SRC       = __webpack_require__(19)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);
	
	__webpack_require__(9).inspectSource = function(it){
	  return $toString.call(it);
	};
	
	(module.exports = function(O, key, val, safe){
	  var isFunction = typeof val == 'function';
	  if(isFunction)has(val, 'name') || hide(val, 'name', key);
	  if(O[key] === val)return;
	  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe){
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if(O[key])O[key] = val;
	      else hide(O, key, val);
	    }
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 19 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(21);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(19)('meta')
	  , isObject = __webpack_require__(13)
	  , has      = __webpack_require__(5)
	  , setDesc  = __webpack_require__(11).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(7)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(11).f
	  , has = __webpack_require__(5)
	  , TAG = __webpack_require__(25)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(23)('wks')
	  , uid        = __webpack_require__(19)
	  , Symbol     = __webpack_require__(4).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(25);

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(4)
	  , core           = __webpack_require__(9)
	  , LIBRARY        = __webpack_require__(28)
	  , wksExt         = __webpack_require__(26)
	  , defineProperty = __webpack_require__(11).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(30)
	  , toIObject = __webpack_require__(32);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(31)
	  , enumBugKeys = __webpack_require__(41);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(5)
	  , toIObject    = __webpack_require__(32)
	  , arrayIndexOf = __webpack_require__(36)(false)
	  , IE_PROTO     = __webpack_require__(40)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(33)
	  , defined = __webpack_require__(35);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(34);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 34 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(32)
	  , toLength  = __webpack_require__(37)
	  , toIndex   = __webpack_require__(39);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(38)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 38 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(38)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(23)('keys')
	  , uid    = __webpack_require__(19);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 41 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(30)
	  , gOPS    = __webpack_require__(43)
	  , pIE     = __webpack_require__(44);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 44 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(34);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(12)
	  , dPs         = __webpack_require__(47)
	  , enumBugKeys = __webpack_require__(41)
	  , IE_PROTO    = __webpack_require__(40)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(15)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(48).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(11)
	  , anObject = __webpack_require__(12)
	  , getKeys  = __webpack_require__(30);
	
	module.exports = __webpack_require__(6) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(4).document && document.documentElement;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(32)
	  , gOPN      = __webpack_require__(50).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(31)
	  , hiddenKeys = __webpack_require__(41).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(44)
	  , createDesc     = __webpack_require__(17)
	  , toIObject      = __webpack_require__(32)
	  , toPrimitive    = __webpack_require__(16)
	  , has            = __webpack_require__(5)
	  , IE8_DOM_DEFINE = __webpack_require__(14)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(6) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(46)});

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(6), 'Object', {defineProperty: __webpack_require__(11).f});

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(6), 'Object', {defineProperties: __webpack_require__(47)});

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(32)
	  , $getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	__webpack_require__(56)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(8)
	  , core    = __webpack_require__(9)
	  , fails   = __webpack_require__(7);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(58)
	  , $getPrototypeOf = __webpack_require__(59);
	
	__webpack_require__(56)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(35);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(5)
	  , toObject    = __webpack_require__(58)
	  , IE_PROTO    = __webpack_require__(40)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(58)
	  , $keys    = __webpack_require__(30);
	
	__webpack_require__(56)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(56)('getOwnPropertyNames', function(){
	  return __webpack_require__(49).f;
	});

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(13)
	  , meta     = __webpack_require__(22).onFreeze;
	
	__webpack_require__(56)('preventExtensions', function($preventExtensions){
	  return function preventExtensions(it){
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isFrozen', function($isFrozen){
	  return function isFrozen(it){
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isSealed', function($isSealed){
	  return function isSealed(it){
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(13);
	
	__webpack_require__(56)('isExtensible', function($isExtensible){
	  return function isExtensible(it){
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(8);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(69)});

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(30)
	  , gOPS     = __webpack_require__(43)
	  , pIE      = __webpack_require__(44)
	  , toObject = __webpack_require__(58)
	  , IObject  = __webpack_require__(33)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(7)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(8);
	$export($export.S, 'Object', {is: __webpack_require__(71)});

/***/ },
/* 71 */
/***/ function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(8);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(73).set});

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(13)
	  , anObject = __webpack_require__(12);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(20)(Function.call, __webpack_require__(51).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(75)
	  , test    = {};
	test[__webpack_require__(25)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(18)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(34)
	  , TAG = __webpack_require__(25)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Function', {bind: __webpack_require__(77)});

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var aFunction  = __webpack_require__(21)
	  , isObject   = __webpack_require__(13)
	  , invoke     = __webpack_require__(78)
	  , arraySlice = [].slice
	  , factories  = {};
	
	var construct = function(F, len, args){
	  if(!(len in factories)){
	    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};
	
	module.exports = Function.bind || function bind(that /*, args... */){
	  var fn       = aFunction(this)
	    , partArgs = arraySlice.call(arguments, 1);
	  var bound = function(/* args... */){
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if(isObject(fn.prototype))bound.prototype = fn.prototype;
	  return bound;
	};

/***/ },
/* 78 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(11).f
	  , createDesc = __webpack_require__(17)
	  , has        = __webpack_require__(5)
	  , FProto     = Function.prototype
	  , nameRE     = /^\s*function ([^ (]*)/
	  , NAME       = 'name';
	
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	
	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(6) && dP(FProto, NAME, {
	  configurable: true,
	  get: function(){
	    try {
	      var that = this
	        , name = ('' + that).match(nameRE)[1];
	      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
	      return name;
	    } catch(e){
	      return '';
	    }
	  }
	});

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isObject       = __webpack_require__(13)
	  , getPrototypeOf = __webpack_require__(59)
	  , HAS_INSTANCE   = __webpack_require__(25)('hasInstance')
	  , FunctionProto  = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if(!(HAS_INSTANCE in FunctionProto))__webpack_require__(11).f(FunctionProto, HAS_INSTANCE, {value: function(O){
	  if(typeof this != 'function' || !isObject(O))return false;
	  if(!isObject(this.prototype))return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
	  return false;
	}});

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , $parseInt = __webpack_require__(82);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var $parseInt = __webpack_require__(4).parseInt
	  , $trim     = __webpack_require__(83).trim
	  , ws        = __webpack_require__(84)
	  , hex       = /^[\-+]?0[xX]/;
	
	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , defined = __webpack_require__(35)
	  , fails   = __webpack_require__(7)
	  , spaces  = __webpack_require__(84)
	  , space   = '[' + spaces + ']'
	  , non     = '\u200b\u0085'
	  , ltrim   = RegExp('^' + space + space + '*')
	  , rtrim   = RegExp(space + space + '*$');
	
	var exporter = function(KEY, exec, ALIAS){
	  var exp   = {};
	  var FORCE = fails(function(){
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if(ALIAS)exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};
	
	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function(string, TYPE){
	  string = String(defined(string));
	  if(TYPE & 1)string = string.replace(ltrim, '');
	  if(TYPE & 2)string = string.replace(rtrim, '');
	  return string;
	};
	
	module.exports = exporter;

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(8)
	  , $parseFloat = __webpack_require__(86);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	var $parseFloat = __webpack_require__(4).parseFloat
	  , $trim       = __webpack_require__(83).trim;
	
	module.exports = 1 / $parseFloat(__webpack_require__(84) + '-0') !== -Infinity ? function parseFloat(str){
	  var string = $trim(String(str), 3)
	    , result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(4)
	  , has               = __webpack_require__(5)
	  , cof               = __webpack_require__(34)
	  , inheritIfRequired = __webpack_require__(88)
	  , toPrimitive       = __webpack_require__(16)
	  , fails             = __webpack_require__(7)
	  , gOPN              = __webpack_require__(50).f
	  , gOPD              = __webpack_require__(51).f
	  , dP                = __webpack_require__(11).f
	  , $trim             = __webpack_require__(83).trim
	  , NUMBER            = 'Number'
	  , $Number           = global[NUMBER]
	  , Base              = $Number
	  , proto             = $Number.prototype
	  // Opera ~12 has broken Object#toString
	  , BROKEN_COF        = cof(__webpack_require__(46)(proto)) == NUMBER
	  , TRIM              = 'trim' in String.prototype;
	
	// 7.1.3 ToNumber(argument)
	var toNumber = function(argument){
	  var it = toPrimitive(argument, false);
	  if(typeof it == 'string' && it.length > 2){
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0)
	      , third, radix, maxCode;
	    if(first === 43 || first === 45){
	      third = it.charCodeAt(2);
	      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if(first === 48){
	      switch(it.charCodeAt(1)){
	        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default : return +it;
	      }
	      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if(code < 48 || code > maxCode)return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};
	
	if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
	  $Number = function Number(value){
	    var it = arguments.length < 1 ? 0 : value
	      , that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for(var keys = __webpack_require__(6) ? gOPN(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys.length > j; j++){
	    if(has(Base, key = keys[j]) && !has($Number, key)){
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(18)(global, NUMBER, $Number);
	}

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var isObject       = __webpack_require__(13)
	  , setPrototypeOf = __webpack_require__(73).set;
	module.exports = function(that, target, C){
	  var P, S = target.constructor;
	  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
	    setPrototypeOf(that, P);
	  } return that;
	};

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , toInteger    = __webpack_require__(38)
	  , aNumberValue = __webpack_require__(90)
	  , repeat       = __webpack_require__(91)
	  , $toFixed     = 1..toFixed
	  , floor        = Math.floor
	  , data         = [0, 0, 0, 0, 0, 0]
	  , ERROR        = 'Number.toFixed: incorrect invocation!'
	  , ZERO         = '0';
	
	var multiply = function(n, c){
	  var i  = -1
	    , c2 = c;
	  while(++i < 6){
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function(n){
	  var i = 6
	    , c = 0;
	  while(--i >= 0){
	    c += data[i];
	    data[i] = floor(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function(){
	  var i = 6
	    , s = '';
	  while(--i >= 0){
	    if(s !== '' || i === 0 || data[i] !== 0){
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function(x, n, acc){
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function(x){
	  var n  = 0
	    , x2 = x;
	  while(x2 >= 4096){
	    n += 12;
	    x2 /= 4096;
	  }
	  while(x2 >= 2){
	    n  += 1;
	    x2 /= 2;
	  } return n;
	};
	
	$export($export.P + $export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128..toFixed(0) !== '1000000000000000128'
	) || !__webpack_require__(7)(function(){
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits){
	    var x = aNumberValue(this, ERROR)
	      , f = toInteger(fractionDigits)
	      , s = ''
	      , m = ZERO
	      , e, z, j, k;
	    if(f < 0 || f > 20)throw RangeError(ERROR);
	    if(x != x)return 'NaN';
	    if(x <= -1e21 || x >= 1e21)return String(x);
	    if(x < 0){
	      s = '-';
	      x = -x;
	    }
	    if(x > 1e-21){
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if(e > 0){
	        multiply(0, z);
	        j = f;
	        while(j >= 7){
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while(j >= 23){
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if(f > 0){
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var cof = __webpack_require__(34);
	module.exports = function(it, msg){
	  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
	  return +it;
	};

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(38)
	  , defined   = __webpack_require__(35);
	
	module.exports = function repeat(count){
	  var str = String(defined(this))
	    , res = ''
	    , n   = toInteger(count);
	  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
	  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
	  return res;
	};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , $fails       = __webpack_require__(7)
	  , aNumberValue = __webpack_require__(90)
	  , $toPrecision = 1..toPrecision;
	
	$export($export.P + $export.F * ($fails(function(){
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function(){
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision){
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
	  }
	});

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export   = __webpack_require__(8)
	  , _isFinite = __webpack_require__(4).isFinite;
	
	$export($export.S, 'Number', {
	  isFinite: function isFinite(it){
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {isInteger: __webpack_require__(96)});

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(13)
	  , floor    = Math.floor;
	module.exports = function isInteger(it){
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {
	  isNaN: function isNaN(number){
	    return number != number;
	  }
	});

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export   = __webpack_require__(8)
	  , isInteger = __webpack_require__(96)
	  , abs       = Math.abs;
	
	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number){
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(8)
	  , $parseFloat = __webpack_require__(86);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , $parseInt = __webpack_require__(82);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(8)
	  , log1p   = __webpack_require__(104)
	  , sqrt    = Math.sqrt
	  , $acosh  = Math.acosh;
	
	$export($export.S + $export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x){
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

/***/ },
/* 104 */
/***/ function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x){
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(8)
	  , $asinh  = Math.asinh;
	
	function asinh(x){
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}
	
	// Tor Browser bug: Math.asinh(0) -> -0 
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(8)
	  , $atanh  = Math.atanh;
	
	// Tor Browser bug: Math.atanh(-0) -> 0 
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x){
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(8)
	  , sign    = __webpack_require__(108);
	
	$export($export.S, 'Math', {
	  cbrt: function cbrt(x){
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

/***/ },
/* 108 */
/***/ function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x){
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  clz32: function clz32(x){
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(8)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  cosh: function cosh(x){
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(8)
	  , $expm1  = __webpack_require__(112);
	
	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});

/***/ },
/* 112 */
/***/ function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x){
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export   = __webpack_require__(8)
	  , sign      = __webpack_require__(108)
	  , pow       = Math.pow
	  , EPSILON   = pow(2, -52)
	  , EPSILON32 = pow(2, -23)
	  , MAX32     = pow(2, 127) * (2 - EPSILON32)
	  , MIN32     = pow(2, -126);
	
	var roundTiesToEven = function(n){
	  return n + 1 / EPSILON - 1 / EPSILON;
	};
	
	
	$export($export.S, 'Math', {
	  fround: function fround(x){
	    var $abs  = Math.abs(x)
	      , $sign = sign(x)
	      , a, result;
	    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	    a = (1 + EPSILON32 / EPSILON) * $abs;
	    result = a - (a - $abs);
	    if(result > MAX32 || result != result)return $sign * Infinity;
	    return $sign * result;
	  }
	});

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
	var $export = __webpack_require__(8)
	  , abs     = Math.abs;
	
	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
	    var sum  = 0
	      , i    = 0
	      , aLen = arguments.length
	      , larg = 0
	      , arg, div;
	    while(i < aLen){
	      arg = abs(arguments[i++]);
	      if(larg < arg){
	        div  = larg / arg;
	        sum  = sum * div * div + 1;
	        larg = arg;
	      } else if(arg > 0){
	        div  = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(8)
	  , $imul   = Math.imul;
	
	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y){
	    var UINT16 = 0xffff
	      , xn = +x
	      , yn = +y
	      , xl = UINT16 & xn
	      , yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  log10: function log10(x){
	    return Math.log(x) / Math.LN10;
	  }
	});

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {log1p: __webpack_require__(104)});

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  log2: function log2(x){
	    return Math.log(x) / Math.LN2;
	  }
	});

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {sign: __webpack_require__(108)});

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(8)
	  , expm1   = __webpack_require__(112)
	  , exp     = Math.exp;
	
	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x){
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(8)
	  , expm1   = __webpack_require__(112)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  tanh: function tanh(x){
	    var a = expm1(x = +x)
	      , b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  trunc: function trunc(it){
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var $export        = __webpack_require__(8)
	  , toIndex        = __webpack_require__(39)
	  , fromCharCode   = String.fromCharCode
	  , $fromCodePoint = String.fromCodePoint;
	
	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
	    var res  = []
	      , aLen = arguments.length
	      , i    = 0
	      , code;
	    while(aLen > i){
	      code = +arguments[i++];
	      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(8)
	  , toIObject = __webpack_require__(32)
	  , toLength  = __webpack_require__(37);
	
	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite){
	    var tpl  = toIObject(callSite.raw)
	      , len  = toLength(tpl.length)
	      , aLen = arguments.length
	      , res  = []
	      , i    = 0;
	    while(len > i){
	      res.push(String(tpl[i++]));
	      if(i < aLen)res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(83)('trim', function($trim){
	  return function trim(){
	    return $trim(this, 3);
	  };
	});

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(127)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(128)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(38)
	  , defined   = __webpack_require__(35);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(28)
	  , $export        = __webpack_require__(8)
	  , redefine       = __webpack_require__(18)
	  , hide           = __webpack_require__(10)
	  , has            = __webpack_require__(5)
	  , Iterators      = __webpack_require__(129)
	  , $iterCreate    = __webpack_require__(130)
	  , setToStringTag = __webpack_require__(24)
	  , getPrototypeOf = __webpack_require__(59)
	  , ITERATOR       = __webpack_require__(25)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 129 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(46)
	  , descriptor     = __webpack_require__(17)
	  , setToStringTag = __webpack_require__(24)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(10)(IteratorPrototype, __webpack_require__(25)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $at     = __webpack_require__(127)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $export   = __webpack_require__(8)
	  , toLength  = __webpack_require__(37)
	  , context   = __webpack_require__(133)
	  , ENDS_WITH = 'endsWith'
	  , $endsWith = ''[ENDS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(135)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /*, endPosition = @length */){
	    var that = context(this, searchString, ENDS_WITH)
	      , endPosition = arguments.length > 1 ? arguments[1] : undefined
	      , len    = toLength(that.length)
	      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
	      , search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(134)
	  , defined  = __webpack_require__(35);
	
	module.exports = function(that, searchString, NAME){
	  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(13)
	  , cof      = __webpack_require__(34)
	  , MATCH    = __webpack_require__(25)('match');
	module.exports = function(it){
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(25)('match');
	module.exports = function(KEY){
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch(e){
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch(f){ /* empty */ }
	  } return true;
	};

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $export  = __webpack_require__(8)
	  , context  = __webpack_require__(133)
	  , INCLUDES = 'includes';
	
	$export($export.P + $export.F * __webpack_require__(135)(INCLUDES), 'String', {
	  includes: function includes(searchString /*, position = 0 */){
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	
	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(91)
	});

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $export     = __webpack_require__(8)
	  , toLength    = __webpack_require__(37)
	  , context     = __webpack_require__(133)
	  , STARTS_WITH = 'startsWith'
	  , $startsWith = ''[STARTS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(135)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /*, position = 0 */){
	    var that   = context(this, searchString, STARTS_WITH)
	      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
	      , search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.2 String.prototype.anchor(name)
	__webpack_require__(140)('anchor', function(createHTML){
	  return function anchor(name){
	    return createHTML(this, 'a', 'name', name);
	  }
	});

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , fails   = __webpack_require__(7)
	  , defined = __webpack_require__(35)
	  , quot    = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function(string, tag, attribute, value) {
	  var S  = String(defined(string))
	    , p1 = '<' + tag;
	  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function(NAME, exec){
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function(){
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.3 String.prototype.big()
	__webpack_require__(140)('big', function(createHTML){
	  return function big(){
	    return createHTML(this, 'big', '', '');
	  }
	});

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.4 String.prototype.blink()
	__webpack_require__(140)('blink', function(createHTML){
	  return function blink(){
	    return createHTML(this, 'blink', '', '');
	  }
	});

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.5 String.prototype.bold()
	__webpack_require__(140)('bold', function(createHTML){
	  return function bold(){
	    return createHTML(this, 'b', '', '');
	  }
	});

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.6 String.prototype.fixed()
	__webpack_require__(140)('fixed', function(createHTML){
	  return function fixed(){
	    return createHTML(this, 'tt', '', '');
	  }
	});

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.7 String.prototype.fontcolor(color)
	__webpack_require__(140)('fontcolor', function(createHTML){
	  return function fontcolor(color){
	    return createHTML(this, 'font', 'color', color);
	  }
	});

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.8 String.prototype.fontsize(size)
	__webpack_require__(140)('fontsize', function(createHTML){
	  return function fontsize(size){
	    return createHTML(this, 'font', 'size', size);
	  }
	});

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.9 String.prototype.italics()
	__webpack_require__(140)('italics', function(createHTML){
	  return function italics(){
	    return createHTML(this, 'i', '', '');
	  }
	});

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.10 String.prototype.link(url)
	__webpack_require__(140)('link', function(createHTML){
	  return function link(url){
	    return createHTML(this, 'a', 'href', url);
	  }
	});

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.11 String.prototype.small()
	__webpack_require__(140)('small', function(createHTML){
	  return function small(){
	    return createHTML(this, 'small', '', '');
	  }
	});

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.12 String.prototype.strike()
	__webpack_require__(140)('strike', function(createHTML){
	  return function strike(){
	    return createHTML(this, 'strike', '', '');
	  }
	});

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.13 String.prototype.sub()
	__webpack_require__(140)('sub', function(createHTML){
	  return function sub(){
	    return createHTML(this, 'sub', '', '');
	  }
	});

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.14 String.prototype.sup()
	__webpack_require__(140)('sup', function(createHTML){
	  return function sup(){
	    return createHTML(this, 'sup', '', '');
	  }
	});

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export     = __webpack_require__(8)
	  , toObject    = __webpack_require__(58)
	  , toPrimitive = __webpack_require__(16);
	
	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var $export = __webpack_require__(8)
	  , fails   = __webpack_require__(7)
	  , getTime = Date.prototype.getTime;
	
	var lz = function(num){
	  return num > 9 ? num : '0' + num;
	};
	
	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (fails(function(){
	  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
	}) || !fails(function(){
	  new Date(NaN).toISOString();
	})), 'Date', {
	  toISOString: function toISOString(){
	    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
	    var d = this
	      , y = d.getUTCFullYear()
	      , m = d.getUTCMilliseconds()
	      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
	    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	  }
	});

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var DateProto    = Date.prototype
	  , INVALID_DATE = 'Invalid Date'
	  , TO_STRING    = 'toString'
	  , $toString    = DateProto[TO_STRING]
	  , getTime      = DateProto.getTime;
	if(new Date(NaN) + '' != INVALID_DATE){
	  __webpack_require__(18)(DateProto, TO_STRING, function toString(){
	    var value = getTime.call(this);
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	var TO_PRIMITIVE = __webpack_require__(25)('toPrimitive')
	  , proto        = Date.prototype;
	
	if(!(TO_PRIMITIVE in proto))__webpack_require__(10)(proto, TO_PRIMITIVE, __webpack_require__(158));

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var anObject    = __webpack_require__(12)
	  , toPrimitive = __webpack_require__(16)
	  , NUMBER      = 'number';
	
	module.exports = function(hint){
	  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Array', {isArray: __webpack_require__(45)});

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(20)
	  , $export        = __webpack_require__(8)
	  , toObject       = __webpack_require__(58)
	  , call           = __webpack_require__(161)
	  , isArrayIter    = __webpack_require__(162)
	  , toLength       = __webpack_require__(37)
	  , createProperty = __webpack_require__(163)
	  , getIterFn      = __webpack_require__(164);
	
	$export($export.S + $export.F * !__webpack_require__(165)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(12);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(129)
	  , ITERATOR   = __webpack_require__(25)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(11)
	  , createDesc      = __webpack_require__(17);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(75)
	  , ITERATOR  = __webpack_require__(25)('iterator')
	  , Iterators = __webpack_require__(129);
	module.exports = __webpack_require__(9).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(25)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export        = __webpack_require__(8)
	  , createProperty = __webpack_require__(163);
	
	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  function F(){}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */){
	    var index  = 0
	      , aLen   = arguments.length
	      , result = new (typeof this == 'function' ? this : Array)(aLen);
	    while(aLen > index)createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.13 Array.prototype.join(separator)
	var $export   = __webpack_require__(8)
	  , toIObject = __webpack_require__(32)
	  , arrayJoin = [].join;
	
	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(33) != Object || !__webpack_require__(168)(arrayJoin)), 'Array', {
	  join: function join(separator){
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	var fails = __webpack_require__(7);
	
	module.exports = function(method, arg){
	  return !!method && fails(function(){
	    arg ? method.call(null, function(){}, 1) : method.call(null);
	  });
	};

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export    = __webpack_require__(8)
	  , html       = __webpack_require__(48)
	  , cof        = __webpack_require__(34)
	  , toIndex    = __webpack_require__(39)
	  , toLength   = __webpack_require__(37)
	  , arraySlice = [].slice;
	
	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(7)(function(){
	  if(html)arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end){
	    var len   = toLength(this.length)
	      , klass = cof(this);
	    end = end === undefined ? len : end;
	    if(klass == 'Array')return arraySlice.call(this, begin, end);
	    var start  = toIndex(begin, len)
	      , upTo   = toIndex(end, len)
	      , size   = toLength(upTo - start)
	      , cloned = Array(size)
	      , i      = 0;
	    for(; i < size; i++)cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export   = __webpack_require__(8)
	  , aFunction = __webpack_require__(21)
	  , toObject  = __webpack_require__(58)
	  , fails     = __webpack_require__(7)
	  , $sort     = [].sort
	  , test      = [1, 2, 3];
	
	$export($export.P + $export.F * (fails(function(){
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function(){
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(168)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn){
	    return comparefn === undefined
	      ? $sort.call(toObject(this))
	      : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export  = __webpack_require__(8)
	  , $forEach = __webpack_require__(172)(0)
	  , STRICT   = __webpack_require__(168)([].forEach, true);
	
	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */){
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(20)
	  , IObject  = __webpack_require__(33)
	  , toObject = __webpack_require__(58)
	  , toLength = __webpack_require__(37)
	  , asc      = __webpack_require__(173);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(174);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(13)
	  , isArray  = __webpack_require__(45)
	  , SPECIES  = __webpack_require__(25)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $map    = __webpack_require__(172)(1);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */){
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $filter = __webpack_require__(172)(2);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */){
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $some   = __webpack_require__(172)(3);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */){
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $every  = __webpack_require__(172)(4);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */){
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $reduce = __webpack_require__(180);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(21)
	  , toObject  = __webpack_require__(58)
	  , IObject   = __webpack_require__(33)
	  , toLength  = __webpack_require__(37);
	
	module.exports = function(that, callbackfn, aLen, memo, isRight){
	  aFunction(callbackfn);
	  var O      = toObject(that)
	    , self   = IObject(O)
	    , length = toLength(O.length)
	    , index  = isRight ? length - 1 : 0
	    , i      = isRight ? -1 : 1;
	  if(aLen < 2)for(;;){
	    if(index in self){
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if(isRight ? index < 0 : length <= index){
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(8)
	  , $reduce = __webpack_require__(180);
	
	$export($export.P + $export.F * !__webpack_require__(168)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(8)
	  , $indexOf      = __webpack_require__(36)(false)
	  , $native       = [].indexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(168)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(8)
	  , toIObject     = __webpack_require__(32)
	  , toInteger     = __webpack_require__(38)
	  , toLength      = __webpack_require__(37)
	  , $native       = [].lastIndexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(168)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
	    // convert -0 to +0
	    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
	    var O      = toIObject(this)
	      , length = toLength(O.length)
	      , index  = length - 1;
	    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
	    if(index < 0)index = length + index;
	    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
	    return -1;
	  }
	});

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Array', {copyWithin: __webpack_require__(185)});
	
	__webpack_require__(186)('copyWithin');

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(58)
	  , toIndex  = __webpack_require__(39)
	  , toLength = __webpack_require__(37);
	
	module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
	  var O     = toObject(this)
	    , len   = toLength(O.length)
	    , to    = toIndex(target, len)
	    , from  = toIndex(start, len)
	    , end   = arguments.length > 2 ? arguments[2] : undefined
	    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
	    , inc   = 1;
	  if(from < to && to < from + count){
	    inc  = -1;
	    from += count - 1;
	    to   += count - 1;
	  }
	  while(count-- > 0){
	    if(from in O)O[to] = O[from];
	    else delete O[to];
	    to   += inc;
	    from += inc;
	  } return O;
	};

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(25)('unscopables')
	  , ArrayProto  = Array.prototype;
	if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(10)(ArrayProto, UNSCOPABLES, {});
	module.exports = function(key){
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(8);
	
	$export($export.P, 'Array', {fill: __webpack_require__(188)});
	
	__webpack_require__(186)('fill');

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(58)
	  , toIndex  = __webpack_require__(39)
	  , toLength = __webpack_require__(37);
	module.exports = function fill(value /*, start = 0, end = @length */){
	  var O      = toObject(this)
	    , length = toLength(O.length)
	    , aLen   = arguments.length
	    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
	    , end    = aLen > 2 ? arguments[2] : undefined
	    , endPos = end === undefined ? length : toIndex(end, length);
	  while(endPos > index)O[index++] = value;
	  return O;
	};

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(8)
	  , $find   = __webpack_require__(172)(5)
	  , KEY     = 'find'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(186)(KEY);

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(8)
	  , $find   = __webpack_require__(172)(6)
	  , KEY     = 'findIndex'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(186)(KEY);

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(192)('Array');

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(4)
	  , dP          = __webpack_require__(11)
	  , DESCRIPTORS = __webpack_require__(6)
	  , SPECIES     = __webpack_require__(25)('species');
	
	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(186)
	  , step             = __webpack_require__(194)
	  , Iterators        = __webpack_require__(129)
	  , toIObject        = __webpack_require__(32);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(128)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 194 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var global            = __webpack_require__(4)
	  , inheritIfRequired = __webpack_require__(88)
	  , dP                = __webpack_require__(11).f
	  , gOPN              = __webpack_require__(50).f
	  , isRegExp          = __webpack_require__(134)
	  , $flags            = __webpack_require__(196)
	  , $RegExp           = global.RegExp
	  , Base              = $RegExp
	  , proto             = $RegExp.prototype
	  , re1               = /a/g
	  , re2               = /a/g
	  // "new" creates a new object, old webkit buggy here
	  , CORRECT_NEW       = new $RegExp(re1) !== re1;
	
	if(__webpack_require__(6) && (!CORRECT_NEW || __webpack_require__(7)(function(){
	  re2[__webpack_require__(25)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))){
	  $RegExp = function RegExp(p, f){
	    var tiRE = this instanceof $RegExp
	      , piRE = isRegExp(p)
	      , fiU  = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function(key){
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function(){ return Base[key]; },
	      set: function(it){ Base[key] = it; }
	    });
	  };
	  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(18)(global, 'RegExp', $RegExp);
	}
	
	__webpack_require__(192)('RegExp');

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(12);
	module.exports = function(){
	  var that   = anObject(this)
	    , result = '';
	  if(that.global)     result += 'g';
	  if(that.ignoreCase) result += 'i';
	  if(that.multiline)  result += 'm';
	  if(that.unicode)    result += 'u';
	  if(that.sticky)     result += 'y';
	  return result;
	};

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(198);
	var anObject    = __webpack_require__(12)
	  , $flags      = __webpack_require__(196)
	  , DESCRIPTORS = __webpack_require__(6)
	  , TO_STRING   = 'toString'
	  , $toString   = /./[TO_STRING];
	
	var define = function(fn){
	  __webpack_require__(18)(RegExp.prototype, TO_STRING, fn, true);
	};
	
	// 21.2.5.14 RegExp.prototype.toString()
	if(__webpack_require__(7)(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
	  define(function toString(){
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if($toString.name != TO_STRING){
	  define(function toString(){
	    return $toString.call(this);
	  });
	}

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	if(__webpack_require__(6) && /./g.flags != 'g')__webpack_require__(11).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(196)
	});

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	// @@match logic
	__webpack_require__(200)('match', 1, function(defined, MATCH, $match){
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide     = __webpack_require__(10)
	  , redefine = __webpack_require__(18)
	  , fails    = __webpack_require__(7)
	  , defined  = __webpack_require__(35)
	  , wks      = __webpack_require__(25);
	
	module.exports = function(KEY, length, exec){
	  var SYMBOL   = wks(KEY)
	    , fns      = exec(defined, SYMBOL, ''[KEY])
	    , strfn    = fns[0]
	    , rxfn     = fns[1];
	  if(fails(function(){
	    var O = {};
	    O[SYMBOL] = function(){ return 7; };
	    return ''[KEY](O) != 7;
	  })){
	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function(string, arg){ return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function(string){ return rxfn.call(string, this); }
	    );
	  }
	};

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	// @@replace logic
	__webpack_require__(200)('replace', 2, function(defined, REPLACE, $replace){
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue){
	    'use strict';
	    var O  = defined(this)
	      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	// @@search logic
	__webpack_require__(200)('search', 1, function(defined, SEARCH, $search){
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	// @@split logic
	__webpack_require__(200)('split', 2, function(defined, SPLIT, $split){
	  'use strict';
	  var isRegExp   = __webpack_require__(134)
	    , _split     = $split
	    , $push      = [].push
	    , $SPLIT     = 'split'
	    , LENGTH     = 'length'
	    , LAST_INDEX = 'lastIndex';
	  if(
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ){
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function(separator, limit){
	      var string = String(this);
	      if(separator === undefined && limit === 0)return [];
	      // If `separator` is not a regex, use native split
	      if(!isRegExp(separator))return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while(match = separatorCopy.exec(string)){
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if(lastIndex > lastLastIndex){
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
	            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
	          });
	          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if(output[LENGTH] >= splitLimit)break;
	        }
	        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if(lastLastIndex === string[LENGTH]){
	        if(lastLength || !separatorCopy.test(''))output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
	    $split = function(separator, limit){
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit){
	    var O  = defined(this)
	      , fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(28)
	  , global             = __webpack_require__(4)
	  , ctx                = __webpack_require__(20)
	  , classof            = __webpack_require__(75)
	  , $export            = __webpack_require__(8)
	  , isObject           = __webpack_require__(13)
	  , aFunction          = __webpack_require__(21)
	  , anInstance         = __webpack_require__(205)
	  , forOf              = __webpack_require__(206)
	  , speciesConstructor = __webpack_require__(207)
	  , task               = __webpack_require__(208).set
	  , microtask          = __webpack_require__(209)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(25)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(210)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(24)($Promise, PROMISE);
	__webpack_require__(192)(PROMISE);
	Wrapper = __webpack_require__(9)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(165)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 205 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(20)
	  , call        = __webpack_require__(161)
	  , isArrayIter = __webpack_require__(162)
	  , anObject    = __webpack_require__(12)
	  , toLength    = __webpack_require__(37)
	  , getIterFn   = __webpack_require__(164)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(12)
	  , aFunction = __webpack_require__(21)
	  , SPECIES   = __webpack_require__(25)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(20)
	  , invoke             = __webpack_require__(78)
	  , html               = __webpack_require__(48)
	  , cel                = __webpack_require__(15)
	  , global             = __webpack_require__(4)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(34)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(4)
	  , macrotask = __webpack_require__(208).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(34)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(18);
	module.exports = function(target, src, safe){
	  for(var key in src)redefine(target, key, src[key], safe);
	  return target;
	};

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(212);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(213)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(11).f
	  , create      = __webpack_require__(46)
	  , redefineAll = __webpack_require__(210)
	  , ctx         = __webpack_require__(20)
	  , anInstance  = __webpack_require__(205)
	  , defined     = __webpack_require__(35)
	  , forOf       = __webpack_require__(206)
	  , $iterDefine = __webpack_require__(128)
	  , step        = __webpack_require__(194)
	  , setSpecies  = __webpack_require__(192)
	  , DESCRIPTORS = __webpack_require__(6)
	  , fastKey     = __webpack_require__(22).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(4)
	  , $export           = __webpack_require__(8)
	  , redefine          = __webpack_require__(18)
	  , redefineAll       = __webpack_require__(210)
	  , meta              = __webpack_require__(22)
	  , forOf             = __webpack_require__(206)
	  , anInstance        = __webpack_require__(205)
	  , isObject          = __webpack_require__(13)
	  , fails             = __webpack_require__(7)
	  , $iterDetect       = __webpack_require__(165)
	  , setToStringTag    = __webpack_require__(24)
	  , inheritIfRequired = __webpack_require__(88);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  var fixMethod = function(KEY){
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a){
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance             = new C
	      // early implementations not supports chaining
	      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
	      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
	      // most early implementations doesn't supports iterables, most modern - not close it correctly
	      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
	      // for early implementations -0 and +0 not the same
	      , BUGGY_ZERO = !IS_WEAK && fails(function(){
	        // V8 ~ Chromium 42- fails only with 5+ elements
	        var $instance = new C()
	          , index     = 5;
	        while(index--)$instance[ADDER](index, index);
	        return !$instance.has(-0);
	      });
	    if(!ACCEPT_ITERABLES){ 
	      C = wrapper(function(target, iterable){
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base, target, C);
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if(IS_WEAK && proto.clear)delete proto.clear;
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(212);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(213)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var each         = __webpack_require__(172)(0)
	  , redefine     = __webpack_require__(18)
	  , meta         = __webpack_require__(22)
	  , assign       = __webpack_require__(69)
	  , weak         = __webpack_require__(216)
	  , isObject     = __webpack_require__(13)
	  , getWeak      = meta.getWeak
	  , isExtensible = Object.isExtensible
	  , uncaughtFrozenStore = weak.ufstore
	  , tmp          = {}
	  , InternalMap;
	
	var wrapper = function(get){
	  return function WeakMap(){
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};
	
	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      var data = getWeak(key);
	      if(data === true)return uncaughtFrozenStore(this).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	};
	
	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(213)('WeakMap', wrapper, methods, weak, true, true);
	
	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  InternalMap = weak.getConstructor(wrapper);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    redefine(proto, key, function(a, b){
	      // store frozen objects on internal weakmap shim
	      if(isObject(a) && !isExtensible(a)){
	        if(!this._f)this._f = new InternalMap;
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var redefineAll       = __webpack_require__(210)
	  , getWeak           = __webpack_require__(22).getWeak
	  , anObject          = __webpack_require__(12)
	  , isObject          = __webpack_require__(13)
	  , anInstance        = __webpack_require__(205)
	  , forOf             = __webpack_require__(206)
	  , createArrayMethod = __webpack_require__(172)
	  , $has              = __webpack_require__(5)
	  , arrayFind         = createArrayMethod(5)
	  , arrayFindIndex    = createArrayMethod(6)
	  , id                = 0;
	
	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function(that){
	  return that._l || (that._l = new UncaughtFrozenStore);
	};
	var UncaughtFrozenStore = function(){
	  this.a = [];
	};
	var findUncaughtFrozen = function(store, key){
	  return arrayFind(store.a, function(it){
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function(key){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = arrayFindIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var data = getWeak(anObject(key), true);
	    if(data === true)uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(216);
	
	// 23.4 WeakSet Objects
	__webpack_require__(213)('WeakSet', function(get){
	  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value){
	    return weak.def(this, value, true);
	  }
	}, weak, false, true);

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(8)
	  , $typed       = __webpack_require__(219)
	  , buffer       = __webpack_require__(220)
	  , anObject     = __webpack_require__(12)
	  , toIndex      = __webpack_require__(39)
	  , toLength     = __webpack_require__(37)
	  , isObject     = __webpack_require__(13)
	  , ArrayBuffer  = __webpack_require__(4).ArrayBuffer
	  , speciesConstructor = __webpack_require__(207)
	  , $ArrayBuffer = buffer.ArrayBuffer
	  , $DataView    = buffer.DataView
	  , $isView      = $typed.ABV && ArrayBuffer.isView
	  , $slice       = $ArrayBuffer.prototype.slice
	  , VIEW         = $typed.VIEW
	  , ARRAY_BUFFER = 'ArrayBuffer';
	
	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});
	
	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it){
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});
	
	$export($export.P + $export.U + $export.F * __webpack_require__(7)(function(){
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end){
	    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
	    var len    = anObject(this).byteLength
	      , first  = toIndex(start, len)
	      , final  = toIndex(end === undefined ? len : end, len)
	      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
	      , viewS  = new $DataView(this)
	      , viewT  = new $DataView(result)
	      , index  = 0;
	    while(first < final){
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});
	
	__webpack_require__(192)(ARRAY_BUFFER);

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(4)
	  , hide   = __webpack_require__(10)
	  , uid    = __webpack_require__(19)
	  , TYPED  = uid('typed_array')
	  , VIEW   = uid('view')
	  , ABV    = !!(global.ArrayBuffer && global.DataView)
	  , CONSTR = ABV
	  , i = 0, l = 9, Typed;
	
	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');
	
	while(i < l){
	  if(Typed = global[TypedArrayConstructors[i++]]){
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}
	
	module.exports = {
	  ABV:    ABV,
	  CONSTR: CONSTR,
	  TYPED:  TYPED,
	  VIEW:   VIEW
	};

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(4)
	  , DESCRIPTORS    = __webpack_require__(6)
	  , LIBRARY        = __webpack_require__(28)
	  , $typed         = __webpack_require__(219)
	  , hide           = __webpack_require__(10)
	  , redefineAll    = __webpack_require__(210)
	  , fails          = __webpack_require__(7)
	  , anInstance     = __webpack_require__(205)
	  , toInteger      = __webpack_require__(38)
	  , toLength       = __webpack_require__(37)
	  , gOPN           = __webpack_require__(50).f
	  , dP             = __webpack_require__(11).f
	  , arrayFill      = __webpack_require__(188)
	  , setToStringTag = __webpack_require__(24)
	  , ARRAY_BUFFER   = 'ArrayBuffer'
	  , DATA_VIEW      = 'DataView'
	  , PROTOTYPE      = 'prototype'
	  , WRONG_LENGTH   = 'Wrong length!'
	  , WRONG_INDEX    = 'Wrong index!'
	  , $ArrayBuffer   = global[ARRAY_BUFFER]
	  , $DataView      = global[DATA_VIEW]
	  , Math           = global.Math
	  , RangeError     = global.RangeError
	  , Infinity       = global.Infinity
	  , BaseBuffer     = $ArrayBuffer
	  , abs            = Math.abs
	  , pow            = Math.pow
	  , floor          = Math.floor
	  , log            = Math.log
	  , LN2            = Math.LN2
	  , BUFFER         = 'buffer'
	  , BYTE_LENGTH    = 'byteLength'
	  , BYTE_OFFSET    = 'byteOffset'
	  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
	  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
	  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;
	
	// IEEE754 conversions based on https://github.com/feross/ieee754
	var packIEEE754 = function(value, mLen, nBytes){
	  var buffer = Array(nBytes)
	    , eLen   = nBytes * 8 - mLen - 1
	    , eMax   = (1 << eLen) - 1
	    , eBias  = eMax >> 1
	    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
	    , i      = 0
	    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
	    , e, m, c;
	  value = abs(value)
	  if(value != value || value === Infinity){
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if(value * (c = pow(2, -e)) < 1){
	      e--;
	      c *= 2;
	    }
	    if(e + eBias >= 1){
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if(value * c >= 2){
	      e++;
	      c /= 2;
	    }
	    if(e + eBias >= eMax){
	      m = 0;
	      e = eMax;
	    } else if(e + eBias >= 1){
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	};
	var unpackIEEE754 = function(buffer, mLen, nBytes){
	  var eLen  = nBytes * 8 - mLen - 1
	    , eMax  = (1 << eLen) - 1
	    , eBias = eMax >> 1
	    , nBits = eLen - 7
	    , i     = nBytes - 1
	    , s     = buffer[i--]
	    , e     = s & 127
	    , m;
	  s >>= 7;
	  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if(e === 0){
	    e = 1 - eBias;
	  } else if(e === eMax){
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	};
	
	var unpackI32 = function(bytes){
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	};
	var packI8 = function(it){
	  return [it & 0xff];
	};
	var packI16 = function(it){
	  return [it & 0xff, it >> 8 & 0xff];
	};
	var packI32 = function(it){
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	};
	var packF64 = function(it){
	  return packIEEE754(it, 52, 8);
	};
	var packF32 = function(it){
	  return packIEEE754(it, 23, 4);
	};
	
	var addGetter = function(C, key, internal){
	  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
	};
	
	var get = function(view, bytes, index, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	};
	var set = function(view, bytes, index, conversion, value, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = conversion(+value);
	  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	};
	
	var validateArrayBufferArguments = function(that, length){
	  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
	  var numberLength = +length
	    , byteLength   = toLength(numberLength);
	  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
	  return byteLength;
	};
	
	if(!$typed.ABV){
	  $ArrayBuffer = function ArrayBuffer(length){
	    var byteLength = validateArrayBufferArguments(this, length);
	    this._b       = arrayFill.call(Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };
	
	  $DataView = function DataView(buffer, byteOffset, byteLength){
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH]
	      , offset       = toInteger(byteOffset);
	    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };
	
	  if(DESCRIPTORS){
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }
	
	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset){
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset){
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if(!fails(function(){
	    new $ArrayBuffer;     // eslint-disable-line no-new
	  }) || !fails(function(){
	    new $ArrayBuffer(.5); // eslint-disable-line no-new
	  })){
	    $ArrayBuffer = function ArrayBuffer(length){
	      return new BaseBuffer(validateArrayBufferArguments(this, length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
	      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
	    };
	    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2))
	    , $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8);
	$export($export.G + $export.W + $export.F * !__webpack_require__(219).ABV, {
	  DataView: __webpack_require__(220).DataView
	});

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int8', 1, function(init){
	  return function Int8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	if(__webpack_require__(6)){
	  var LIBRARY             = __webpack_require__(28)
	    , global              = __webpack_require__(4)
	    , fails               = __webpack_require__(7)
	    , $export             = __webpack_require__(8)
	    , $typed              = __webpack_require__(219)
	    , $buffer             = __webpack_require__(220)
	    , ctx                 = __webpack_require__(20)
	    , anInstance          = __webpack_require__(205)
	    , propertyDesc        = __webpack_require__(17)
	    , hide                = __webpack_require__(10)
	    , redefineAll         = __webpack_require__(210)
	    , toInteger           = __webpack_require__(38)
	    , toLength            = __webpack_require__(37)
	    , toIndex             = __webpack_require__(39)
	    , toPrimitive         = __webpack_require__(16)
	    , has                 = __webpack_require__(5)
	    , same                = __webpack_require__(71)
	    , classof             = __webpack_require__(75)
	    , isObject            = __webpack_require__(13)
	    , toObject            = __webpack_require__(58)
	    , isArrayIter         = __webpack_require__(162)
	    , create              = __webpack_require__(46)
	    , getPrototypeOf      = __webpack_require__(59)
	    , gOPN                = __webpack_require__(50).f
	    , getIterFn           = __webpack_require__(164)
	    , uid                 = __webpack_require__(19)
	    , wks                 = __webpack_require__(25)
	    , createArrayMethod   = __webpack_require__(172)
	    , createArrayIncludes = __webpack_require__(36)
	    , speciesConstructor  = __webpack_require__(207)
	    , ArrayIterators      = __webpack_require__(193)
	    , Iterators           = __webpack_require__(129)
	    , $iterDetect         = __webpack_require__(165)
	    , setSpecies          = __webpack_require__(192)
	    , arrayFill           = __webpack_require__(188)
	    , arrayCopyWithin     = __webpack_require__(185)
	    , $DP                 = __webpack_require__(11)
	    , $GOPD               = __webpack_require__(51)
	    , dP                  = $DP.f
	    , gOPD                = $GOPD.f
	    , RangeError          = global.RangeError
	    , TypeError           = global.TypeError
	    , Uint8Array          = global.Uint8Array
	    , ARRAY_BUFFER        = 'ArrayBuffer'
	    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
	    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
	    , PROTOTYPE           = 'prototype'
	    , ArrayProto          = Array[PROTOTYPE]
	    , $ArrayBuffer        = $buffer.ArrayBuffer
	    , $DataView           = $buffer.DataView
	    , arrayForEach        = createArrayMethod(0)
	    , arrayFilter         = createArrayMethod(2)
	    , arraySome           = createArrayMethod(3)
	    , arrayEvery          = createArrayMethod(4)
	    , arrayFind           = createArrayMethod(5)
	    , arrayFindIndex      = createArrayMethod(6)
	    , arrayIncludes       = createArrayIncludes(true)
	    , arrayIndexOf        = createArrayIncludes(false)
	    , arrayValues         = ArrayIterators.values
	    , arrayKeys           = ArrayIterators.keys
	    , arrayEntries        = ArrayIterators.entries
	    , arrayLastIndexOf    = ArrayProto.lastIndexOf
	    , arrayReduce         = ArrayProto.reduce
	    , arrayReduceRight    = ArrayProto.reduceRight
	    , arrayJoin           = ArrayProto.join
	    , arraySort           = ArrayProto.sort
	    , arraySlice          = ArrayProto.slice
	    , arrayToString       = ArrayProto.toString
	    , arrayToLocaleString = ArrayProto.toLocaleString
	    , ITERATOR            = wks('iterator')
	    , TAG                 = wks('toStringTag')
	    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
	    , DEF_CONSTRUCTOR     = uid('def_constructor')
	    , ALL_CONSTRUCTORS    = $typed.CONSTR
	    , TYPED_ARRAY         = $typed.TYPED
	    , VIEW                = $typed.VIEW
	    , WRONG_LENGTH        = 'Wrong length!';
	
	  var $map = createArrayMethod(1, function(O, length){
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });
	
	  var LITTLE_ENDIAN = fails(function(){
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });
	
	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
	    new Uint8Array(1).set({});
	  });
	
	  var strictToLength = function(it, SAME){
	    if(it === undefined)throw TypeError(WRONG_LENGTH);
	    var number = +it
	      , length = toLength(it);
	    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
	    return length;
	  };
	
	  var toOffset = function(it, BYTES){
	    var offset = toInteger(it);
	    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
	    return offset;
	  };
	
	  var validate = function(it){
	    if(isObject(it) && TYPED_ARRAY in it)return it;
	    throw TypeError(it + ' is not a typed array!');
	  };
	
	  var allocate = function(C, length){
	    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };
	
	  var speciesFromList = function(O, list){
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };
	
	  var fromList = function(C, list){
	    var index  = 0
	      , length = list.length
	      , result = allocate(C, length);
	    while(length > index)result[index] = list[index++];
	    return result;
	  };
	
	  var addGetter = function(it, key, internal){
	    dP(it, key, {get: function(){ return this._d[internal]; }});
	  };
	
	  var $from = function from(source /*, mapfn, thisArg */){
	    var O       = toObject(source)
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , iterFn  = getIterFn(O)
	      , i, length, values, result, step, iterator;
	    if(iterFn != undefined && !isArrayIter(iterFn)){
	      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
	        values.push(step.value);
	      } O = values;
	    }
	    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
	    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };
	
	  var $of = function of(/*...items*/){
	    var index  = 0
	      , length = arguments.length
	      , result = allocate(this, length);
	    while(length > index)result[index] = arguments[index++];
	    return result;
	  };
	
	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });
	
	  var $toLocaleString = function toLocaleString(){
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };
	
	  var proto = {
	    copyWithin: function copyWithin(target, start /*, end */){
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /*, thisArg */){
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /*, thisArg */){
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /*, thisArg */){
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /*, thisArg */){
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /*, thisArg */){
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /*, fromIndex */){
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /*, fromIndex */){
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator){ // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /*, thisArg */){
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse(){
	      var that   = this
	        , length = validate(that).length
	        , middle = Math.floor(length / 2)
	        , index  = 0
	        , value;
	      while(index < middle){
	        value         = that[index];
	        that[index++] = that[--length];
	        that[length]  = value;
	      } return that;
	    },
	    some: function some(callbackfn /*, thisArg */){
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn){
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end){
	      var O      = validate(this)
	        , length = O.length
	        , $begin = toIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
	      );
	    }
	  };
	
	  var $slice = function slice(start, end){
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };
	
	  var $set = function set(arrayLike /*, offset */){
	    validate(this);
	    var offset = toOffset(arguments[1], 1)
	      , length = this.length
	      , src    = toObject(arrayLike)
	      , len    = toLength(src.length)
	      , index  = 0;
	    if(len + offset > length)throw RangeError(WRONG_LENGTH);
	    while(index < len)this[offset + index] = src[index++];
	  };
	
	  var $iterators = {
	    entries: function entries(){
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys(){
	      return arrayKeys.call(validate(this));
	    },
	    values: function values(){
	      return arrayValues.call(validate(this));
	    }
	  };
	
	  var isTAIndex = function(target, key){
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key){
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc){
	    if(isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ){
	      target[key] = desc.value;
	      return target;
	    } else return dP(target, key, desc);
	  };
	
	  if(!ALL_CONSTRUCTORS){
	    $GOPD.f = $getDesc;
	    $DP.f   = $setDesc;
	  }
	
	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty:           $setDesc
	  });
	
	  if(fails(function(){ arrayToString.call({}); })){
	    arrayToString = arrayToLocaleString = function toString(){
	      return arrayJoin.call(this);
	    }
	  }
	
	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice:          $slice,
	    set:            $set,
	    constructor:    function(){ /* noop */ },
	    toString:       arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function(){ return this[TYPED_ARRAY]; }
	  });
	
	  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
	    CLAMPED = !!CLAMPED;
	    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
	      , ISNT_UINT8 = NAME != 'Uint8Array'
	      , GETTER     = 'get' + KEY
	      , SETTER     = 'set' + KEY
	      , TypedArray = global[NAME]
	      , Base       = TypedArray || {}
	      , TAC        = TypedArray && getPrototypeOf(TypedArray)
	      , FORCED     = !TypedArray || !$typed.ABV
	      , O          = {}
	      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function(that, index){
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function(that, index, value){
	      var data = that._d;
	      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function(that, index){
	      dP(that, index, {
	        get: function(){
	          return getter(this, index);
	        },
	        set: function(value){
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if(FORCED){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME, '_d');
	        var index  = 0
	          , offset = 0
	          , buffer, byteLength, length, klass;
	        if(!isObject(data)){
	          length     = strictToLength(data, true)
	          byteLength = length * BYTES;
	          buffer     = new $ArrayBuffer(byteLength);
	        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if($length === undefined){
	            if($len % BYTES)throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if(TYPED_ARRAY in data){
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while(index < length)addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if(!$iterDetect(function(iter){
	      // V8 works with iterators, but fails in many other cases
	      // https://code.google.com/p/v8/issues/detail?id=4552
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
	        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
	        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
	      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
	      , $iterator         = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
	
	    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
	      dP(TypedArrayPrototype, TAG, {
	        get: function(){ return NAME; }
	      });
	    }
	
	    O[NAME] = TypedArray;
	
	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
	
	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES,
	      from: $from,
	      of: $of
	    });
	
	    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
	
	    $export($export.P, NAME, proto);
	
	    setSpecies(NAME);
	
	    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});
	
	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
	
	    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});
	
	    $export($export.P + $export.F * fails(function(){
	      new TypedArray(1).slice();
	    }), NAME, {slice: $slice});
	
	    $export($export.P + $export.F * (fails(function(){
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
	    }) || !fails(function(){
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, {toLocaleString: $toLocaleString});
	
	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function(){ /* empty */ };

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint8', 1, function(init){
	  return function Uint8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint8', 1, function(init){
	  return function Uint8ClampedArray(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	}, true);

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int16', 2, function(init){
	  return function Int16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint16', 2, function(init){
	  return function Uint16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Int32', 4, function(init){
	  return function Int32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Uint32', 4, function(init){
	  return function Uint32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Float32', 4, function(init){
	  return function Float32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(223)('Float64', 8, function(init){
	  return function Float64Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export   = __webpack_require__(8)
	  , aFunction = __webpack_require__(21)
	  , anObject  = __webpack_require__(12)
	  , rApply    = (__webpack_require__(4).Reflect || {}).apply
	  , fApply    = Function.apply;
	// MS Edge argumentsList argument is optional
	$export($export.S + $export.F * !__webpack_require__(7)(function(){
	  rApply(function(){});
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList){
	    var T = aFunction(target)
	      , L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export    = __webpack_require__(8)
	  , create     = __webpack_require__(46)
	  , aFunction  = __webpack_require__(21)
	  , anObject   = __webpack_require__(12)
	  , isObject   = __webpack_require__(13)
	  , fails      = __webpack_require__(7)
	  , bind       = __webpack_require__(77)
	  , rConstruct = (__webpack_require__(4).Reflect || {}).construct;
	
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function(){
	  function F(){}
	  return !(rConstruct(function(){}, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function(){
	  rConstruct(function(){});
	});
	
	$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /*, newTarget*/){
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
	    if(Target == newTarget){
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch(args.length){
	        case 0: return new Target;
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args));
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto    = newTarget.prototype
	      , instance = create(isObject(proto) ? proto : Object.prototype)
	      , result   = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP          = __webpack_require__(11)
	  , $export     = __webpack_require__(8)
	  , anObject    = __webpack_require__(12)
	  , toPrimitive = __webpack_require__(16);
	
	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(7)(function(){
	  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes){
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export  = __webpack_require__(8)
	  , gOPD     = __webpack_require__(51).f
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey){
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $export  = __webpack_require__(8)
	  , anObject = __webpack_require__(12);
	var Enumerate = function(iterated){
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = []       // keys
	    , key;
	  for(key in iterated)keys.push(key);
	};
	__webpack_require__(130)(Enumerate, 'Object', function(){
	  var that = this
	    , keys = that._k
	    , key;
	  do {
	    if(that._i >= keys.length)return {value: undefined, done: true};
	  } while(!((key = keys[that._i++]) in that._t));
	  return {value: key, done: false};
	});
	
	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target){
	    return new Enumerate(target);
	  }
	});

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD           = __webpack_require__(51)
	  , getPrototypeOf = __webpack_require__(59)
	  , has            = __webpack_require__(5)
	  , $export        = __webpack_require__(8)
	  , isObject       = __webpack_require__(13)
	  , anObject       = __webpack_require__(12);
	
	function get(target, propertyKey/*, receiver*/){
	  var receiver = arguments.length < 3 ? target : arguments[2]
	    , desc, proto;
	  if(anObject(target) === receiver)return target[propertyKey];
	  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
	}
	
	$export($export.S, 'Reflect', {get: get});

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD     = __webpack_require__(51)
	  , $export  = __webpack_require__(8)
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export  = __webpack_require__(8)
	  , getProto = __webpack_require__(59)
	  , anObject = __webpack_require__(12);
	
	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target){
	    return getProto(anObject(target));
	  }
	});

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey){
	    return propertyKey in target;
	  }
	});

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export       = __webpack_require__(8)
	  , anObject      = __webpack_require__(12)
	  , $isExtensible = Object.isExtensible;
	
	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target){
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Reflect', {ownKeys: __webpack_require__(243)});

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var gOPN     = __webpack_require__(50)
	  , gOPS     = __webpack_require__(43)
	  , anObject = __webpack_require__(12)
	  , Reflect  = __webpack_require__(4).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
	  var keys       = gOPN.f(anObject(it))
	    , getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export            = __webpack_require__(8)
	  , anObject           = __webpack_require__(12)
	  , $preventExtensions = Object.preventExtensions;
	
	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target){
	    anObject(target);
	    try {
	      if($preventExtensions)$preventExtensions(target);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP             = __webpack_require__(11)
	  , gOPD           = __webpack_require__(51)
	  , getPrototypeOf = __webpack_require__(59)
	  , has            = __webpack_require__(5)
	  , $export        = __webpack_require__(8)
	  , createDesc     = __webpack_require__(17)
	  , anObject       = __webpack_require__(12)
	  , isObject       = __webpack_require__(13);
	
	function set(target, propertyKey, V/*, receiver*/){
	  var receiver = arguments.length < 4 ? target : arguments[3]
	    , ownDesc  = gOPD.f(anObject(target), propertyKey)
	    , existingDescriptor, proto;
	  if(!ownDesc){
	    if(isObject(proto = getPrototypeOf(target))){
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if(has(ownDesc, 'value')){
	    if(ownDesc.writable === false || !isObject(receiver))return false;
	    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
	    existingDescriptor.value = V;
	    dP.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}
	
	$export($export.S, 'Reflect', {set: set});

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export  = __webpack_require__(8)
	  , setProto = __webpack_require__(73);
	
	if(setProto)$export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto){
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/Array.prototype.includes
	var $export   = __webpack_require__(8)
	  , $includes = __webpack_require__(36)(true);
	
	$export($export.P, 'Array', {
	  includes: function includes(el /*, fromIndex = 0 */){
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	
	__webpack_require__(186)('includes');

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(8)
	  , $at     = __webpack_require__(127)(true);
	
	$export($export.P, 'String', {
	  at: function at(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(8)
	  , $pad    = __webpack_require__(250);
	
	$export($export.P, 'String', {
	  padStart: function padStart(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(37)
	  , repeat   = __webpack_require__(91)
	  , defined  = __webpack_require__(35);
	
	module.exports = function(that, maxLength, fillString, left){
	  var S            = String(defined(that))
	    , stringLength = S.length
	    , fillStr      = fillString === undefined ? ' ' : String(fillString)
	    , intMaxLength = toLength(maxLength);
	  if(intMaxLength <= stringLength || fillStr == '')return S;
	  var fillLen = intMaxLength - stringLength
	    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(8)
	  , $pad    = __webpack_require__(250);
	
	$export($export.P, 'String', {
	  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(83)('trimLeft', function($trim){
	  return function trimLeft(){
	    return $trim(this, 1);
	  };
	}, 'trimStart');

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(83)('trimRight', function($trim){
	  return function trimRight(){
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/String.prototype.matchAll/
	var $export     = __webpack_require__(8)
	  , defined     = __webpack_require__(35)
	  , toLength    = __webpack_require__(37)
	  , isRegExp    = __webpack_require__(134)
	  , getFlags    = __webpack_require__(196)
	  , RegExpProto = RegExp.prototype;
	
	var $RegExpStringIterator = function(regexp, string){
	  this._r = regexp;
	  this._s = string;
	};
	
	__webpack_require__(130)($RegExpStringIterator, 'RegExp String', function next(){
	  var match = this._r.exec(this._s);
	  return {value: match, done: match === null};
	});
	
	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp){
	    defined(this);
	    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
	    var S     = String(this)
	      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
	      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(27)('asyncIterator');

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(27)('observable');

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export        = __webpack_require__(8)
	  , ownKeys        = __webpack_require__(243)
	  , toIObject      = __webpack_require__(32)
	  , gOPD           = __webpack_require__(51)
	  , createProperty = __webpack_require__(163);
	
	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
	    var O       = toIObject(object)
	      , getDesc = gOPD.f
	      , keys    = ownKeys(O)
	      , result  = {}
	      , i       = 0
	      , key;
	    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
	    return result;
	  }
	});

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(8)
	  , $values = __webpack_require__(259)(false);
	
	$export($export.S, 'Object', {
	  values: function values(it){
	    return $values(it);
	  }
	});

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(30)
	  , toIObject = __webpack_require__(32)
	  , isEnum    = __webpack_require__(44).f;
	module.exports = function(isEntries){
	  return function(it){
	    var O      = toIObject(it)
	      , keys   = getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = []
	      , key;
	    while(length > i)if(isEnum.call(O, key = keys[i++])){
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export  = __webpack_require__(8)
	  , $entries = __webpack_require__(259)(true);
	
	$export($export.S, 'Object', {
	  entries: function entries(it){
	    return $entries(it);
	  }
	});

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(8)
	  , toObject        = __webpack_require__(58)
	  , aFunction       = __webpack_require__(21)
	  , $defineProperty = __webpack_require__(11);
	
	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(6) && $export($export.P + __webpack_require__(262), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter){
	    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(28)|| !__webpack_require__(7)(function(){
	  var K = Math.random();
	  // In FF throws only define methods
	  __defineSetter__.call(null, K, function(){ /* empty */});
	  delete __webpack_require__(4)[K];
	});

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(8)
	  , toObject        = __webpack_require__(58)
	  , aFunction       = __webpack_require__(21)
	  , $defineProperty = __webpack_require__(11);
	
	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(6) && $export($export.P + __webpack_require__(262), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter){
	    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(8)
	  , toObject                 = __webpack_require__(58)
	  , toPrimitive              = __webpack_require__(16)
	  , getPrototypeOf           = __webpack_require__(59)
	  , getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(6) && $export($export.P + __webpack_require__(262), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.get;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(8)
	  , toObject                 = __webpack_require__(58)
	  , toPrimitive              = __webpack_require__(16)
	  , getPrototypeOf           = __webpack_require__(59)
	  , getOwnPropertyDescriptor = __webpack_require__(51).f;
	
	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(6) && $export($export.P + __webpack_require__(262), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.set;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(8);
	
	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(267)('Map')});

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(75)
	  , from    = __webpack_require__(268);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(206);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(8);
	
	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(267)('Set')});

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-global
	var $export = __webpack_require__(8);
	
	$export($export.S, 'System', {global: __webpack_require__(4)});

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(8)
	  , cof     = __webpack_require__(34);
	
	$export($export.S, 'Error', {
	  isError: function isError(it){
	    return cof(it) === 'Error';
	  }
	});

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  imulh: function imulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >> 16
	      , v1 = $v >> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(8);
	
	$export($export.S, 'Math', {
	  umulh: function umulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >>> 16
	      , v1 = $v >>> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(277)
	  , anObject                  = __webpack_require__(12)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	}});

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	var Map     = __webpack_require__(211)
	  , $export = __webpack_require__(8)
	  , shared  = __webpack_require__(23)('metadata')
	  , store   = shared.store || (shared.store = new (__webpack_require__(215)));
	
	var getOrCreateMetadataMap = function(target, targetKey, create){
	  var targetMetadata = store.get(target);
	  if(!targetMetadata){
	    if(!create)return undefined;
	    store.set(target, targetMetadata = new Map);
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if(!keyMetadata){
	    if(!create)return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map);
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function(target, targetKey){
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
	    , keys        = [];
	  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
	  return keys;
	};
	var toMetaKey = function(it){
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function(O){
	  $export($export.S, 'Reflect', O);
	};
	
	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , toMetaKey              = metadata.key
	  , getOrCreateMetadataMap = metadata.map
	  , store                  = metadata.store;
	
	metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
	  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
	    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
	  if(metadataMap.size)return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	}});

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , getPrototypeOf         = __webpack_require__(59)
	  , ordinaryHasOwnMetadata = metadata.has
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	var ordinaryGetMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};
	
	metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	var Set                     = __webpack_require__(214)
	  , from                    = __webpack_require__(268)
	  , metadata                = __webpack_require__(277)
	  , anObject                = __webpack_require__(12)
	  , getPrototypeOf          = __webpack_require__(59)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	var ordinaryMetadataKeys = function(O, P){
	  var oKeys  = ordinaryOwnMetadataKeys(O, P)
	    , parent = getPrototypeOf(O);
	  if(parent === null)return oKeys;
	  var pKeys  = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};
	
	metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                = __webpack_require__(277)
	  , anObject                = __webpack_require__(12)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , getPrototypeOf         = __webpack_require__(59)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	var ordinaryHasMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};
	
	metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(277)
	  , anObject               = __webpack_require__(12)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(277)
	  , anObject                  = __webpack_require__(12)
	  , aFunction                 = __webpack_require__(21)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({metadata: function metadata(metadataKey, metadataValue){
	  return function decorator(target, targetKey){
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	}});

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export   = __webpack_require__(8)
	  , microtask = __webpack_require__(209)()
	  , process   = __webpack_require__(4).process
	  , isNode    = __webpack_require__(34)(process) == 'process';
	
	$export($export.G, {
	  asap: function asap(fn){
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/zenparsing/es-observable
	var $export     = __webpack_require__(8)
	  , global      = __webpack_require__(4)
	  , core        = __webpack_require__(9)
	  , microtask   = __webpack_require__(209)()
	  , OBSERVABLE  = __webpack_require__(25)('observable')
	  , aFunction   = __webpack_require__(21)
	  , anObject    = __webpack_require__(12)
	  , anInstance  = __webpack_require__(205)
	  , redefineAll = __webpack_require__(210)
	  , hide        = __webpack_require__(10)
	  , forOf       = __webpack_require__(206)
	  , RETURN      = forOf.RETURN;
	
	var getMethod = function(fn){
	  return fn == null ? undefined : aFunction(fn);
	};
	
	var cleanupSubscription = function(subscription){
	  var cleanup = subscription._c;
	  if(cleanup){
	    subscription._c = undefined;
	    cleanup();
	  }
	};
	
	var subscriptionClosed = function(subscription){
	  return subscription._o === undefined;
	};
	
	var closeSubscription = function(subscription){
	  if(!subscriptionClosed(subscription)){
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};
	
	var Subscription = function(observer, subscriber){
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup      = subscriber(observer)
	      , subscription = cleanup;
	    if(cleanup != null){
	      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch(e){
	    observer.error(e);
	    return;
	  } if(subscriptionClosed(this))cleanupSubscription(this);
	};
	
	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe(){ closeSubscription(this); }
	});
	
	var SubscriptionObserver = function(subscription){
	  this._s = subscription;
	};
	
	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if(m)return m.call(observer, value);
	      } catch(e){
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value){
	    var subscription = this._s;
	    if(subscriptionClosed(subscription))throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if(!m)throw value;
	      value = m.call(observer, value);
	    } catch(e){
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch(e){
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});
	
	var $Observable = function Observable(subscriber){
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};
	
	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer){
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn){
	    var that = this;
	    return new (core.Promise || global.Promise)(function(resolve, reject){
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next : function(value){
	          try {
	            return fn(value);
	          } catch(e){
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});
	
	redefineAll($Observable, {
	  from: function from(x){
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if(method){
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function(observer){
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          try {
	            if(forOf(x, false, function(it){
	              observer.next(it);
	              if(done)return RETURN;
	            }) === RETURN)return;
	          } catch(e){
	            if(done)throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  },
	  of: function of(){
	    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          for(var i = 0; i < items.length; ++i){
	            observer.next(items[i]);
	            if(done)return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  }
	});
	
	hide($Observable.prototype, OBSERVABLE, function(){ return this; });
	
	$export($export.G, {Observable: $Observable});
	
	__webpack_require__(192)('Observable');

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global     = __webpack_require__(4)
	  , $export    = __webpack_require__(8)
	  , invoke     = __webpack_require__(78)
	  , partial    = __webpack_require__(289)
	  , navigator  = global.navigator
	  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
	var wrap = function(set){
	  return MSIE ? function(fn, time /*, ...args */){
	    return set(invoke(
	      partial,
	      [].slice.call(arguments, 2),
	      typeof fn == 'function' ? fn : Function(fn)
	    ), time);
	  } : set;
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout:  wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path      = __webpack_require__(290)
	  , invoke    = __webpack_require__(78)
	  , aFunction = __webpack_require__(21);
	module.exports = function(/* ...pargs */){
	  var fn     = aFunction(this)
	    , length = arguments.length
	    , pargs  = Array(length)
	    , i      = 0
	    , _      = path._
	    , holder = false;
	  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
	  return function(/* ...args */){
	    var that = this
	      , aLen = arguments.length
	      , j = 0, k = 0, args;
	    if(!holder && !aLen)return invoke(fn, pargs, that);
	    args = pargs.slice();
	    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
	    while(aLen > k)args.push(arguments[k++]);
	    return invoke(fn, args, that);
	  };
	};

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(4);

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(8)
	  , $task   = __webpack_require__(208);
	$export($export.G + $export.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	var $iterators    = __webpack_require__(193)
	  , redefine      = __webpack_require__(18)
	  , global        = __webpack_require__(4)
	  , hide          = __webpack_require__(10)
	  , Iterators     = __webpack_require__(129)
	  , wks           = __webpack_require__(25)
	  , ITERATOR      = wks('iterator')
	  , TO_STRING_TAG = wks('toStringTag')
	  , ArrayValues   = Iterators.Array;
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype
	    , key;
	  if(proto){
	    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
	    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
	  }
	}

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided, then outerFn.prototype instanceof Generator.
	    var generator = Object.create((outerFn || Generator).prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(294)))

/***/ },
/* 294 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(296);
	module.exports = __webpack_require__(9).RegExp.escape;

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(8)
	  , $re     = __webpack_require__(297)(/[\\^$*+?.()|[\]{}]/g, '\\$&');
	
	$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});


/***/ },
/* 297 */
/***/ function(module, exports) {

	module.exports = function(regExp, replace){
	  var replacer = replace === Object(replace) ? function(part){
	    return replace[part];
	  } : replace;
	  return function(it){
	    return String(it).replace(regExp, replacer);
	  };
	};

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.setLogLevel = exports.PlaybackVideoEncoder = exports.PlaybackAudioEncoder = exports.SharedObjectEventTypes = exports.FailoverSubscriberEventTypes = exports.RTCSubscriberEventTypes = exports.SubscriberEventTypes = exports.FailoverPublisherEventTypes = exports.RTCPublisherEventTypes = exports.PublisherEventTypes = exports.Red5ProSharedObject = exports.PublisherView = exports.RTCPublisher = exports.RTMPPublisher = exports.Red5ProPublisher = exports.PlaybackView = exports.RTMPSubscriber = exports.R5LiveSubscriber = exports.VideoJSSubscriber = exports.HLSSubscriber = exports.RTCSubscriber = exports.Red5ProSubscriber = exports.getLogger = exports.LogLevels = undefined;
	
	var _log = __webpack_require__(299);
	
	Object.defineProperty(exports, 'LogLevels', {
	  enumerable: true,
	  get: function get() {
	    return _log.LEVELS;
	  }
	});
	Object.defineProperty(exports, 'getLogger', {
	  enumerable: true,
	  get: function get() {
	    return _log.getLogger;
	  }
	});
	
	var _publisherEvent = __webpack_require__(302);
	
	Object.defineProperty(exports, 'PublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.common;
	  }
	});
	Object.defineProperty(exports, 'RTCPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.rtc;
	  }
	});
	Object.defineProperty(exports, 'FailoverPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.failover;
	  }
	});
	
	var _subscriberEvent = __webpack_require__(303);
	
	Object.defineProperty(exports, 'SubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.common;
	  }
	});
	Object.defineProperty(exports, 'RTCSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.rtc;
	  }
	});
	Object.defineProperty(exports, 'FailoverSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.failover;
	  }
	});
	
	var _sharedobjectEvent = __webpack_require__(304);
	
	Object.defineProperty(exports, 'SharedObjectEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _sharedobjectEvent.common;
	  }
	});
	
	var _playback = __webpack_require__(305);
	
	Object.defineProperty(exports, 'PlaybackAudioEncoder', {
	  enumerable: true,
	  get: function get() {
	    return _playback.PlaybackAudioEncoder;
	  }
	});
	Object.defineProperty(exports, 'PlaybackVideoEncoder', {
	  enumerable: true,
	  get: function get() {
	    return _playback.PlaybackVideoEncoder;
	  }
	});
	
	var _index = __webpack_require__(306);
	
	var subscriberLib = _interopRequireWildcard(_index);
	
	var _index2 = __webpack_require__(329);
	
	var publisherLib = _interopRequireWildcard(_index2);
	
	var _index3 = __webpack_require__(336);
	
	var sharedObjectLib = _interopRequireWildcard(_index3);
	
	var _playback2 = __webpack_require__(337);
	
	var _playback3 = _interopRequireDefault(_playback2);
	
	var _publish = __webpack_require__(338);
	
	var _publish2 = _interopRequireDefault(_publish);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/**
	 * Subscription related references.
	*/
	var Red5ProSubscriber = exports.Red5ProSubscriber = subscriberLib.Red5ProSubscriber;
	var RTCSubscriber = exports.RTCSubscriber = subscriberLib.RTCSubscriber;
	var HLSSubscriber = exports.HLSSubscriber = subscriberLib.HLSSubscriber;
	var VideoJSSubscriber = exports.VideoJSSubscriber = subscriberLib.VideoJSSubscriber;
	var R5LiveSubscriber = exports.R5LiveSubscriber = subscriberLib.R5LiveSubscriber;
	var RTMPSubscriber = exports.RTMPSubscriber = subscriberLib.RTMPSubscriber;
	exports.PlaybackView = _playback3.default;
	
	/**
	 * Broadcast related references.
	 */
	
	var Red5ProPublisher = exports.Red5ProPublisher = publisherLib.Red5ProPublisher;
	var RTMPPublisher = exports.RTMPPublisher = publisherLib.RTMPPublisher;
	var RTCPublisher = exports.RTCPublisher = publisherLib.RTCPublisher;
	exports.PublisherView = _publish2.default;
	
	/**
	 * Shared Object references.
	 */
	
	var Red5ProSharedObject = exports.Red5ProSharedObject = sharedObjectLib.Red5ProSharedObject;
	
	/**
	 * Events
	 */
	
	
	(0, _log.establishLogger)('' + ("debug") || _log.LEVELS.DEBUG); // eslint-disable-line no-undef
	(0, _log.getLogger)().debug('Red5 Pro SDK Version ' + ("3.2.0")); // eslint-disable-line no-undef
	
	var setLogLevel = exports.setLogLevel = function setLogLevel(level) {
	  if (_log.LEVELS.hasOwnProperty(level.toUpperCase())) {
	    (0, _log.establishLogger)(level);
	  }
	};

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.fatal = exports.error = exports.warn = exports.debug = exports.info = exports.trace = exports.getLogger = exports.establishLogger = exports.LEVELS = undefined;
	
	var _browserBunyan = __webpack_require__(300);
	
	var _bunyanWriter = __webpack_require__(301);
	
	var logger = void 0;
	var formatMessage = function formatMessage(dispatcher) {
	  return function (message) {
	    return '(' + dispatcher + ') ' + message;
	  };
	};
	var decorate = function decorate(level) {
	  return function (source, message) {
	    logger[level](formatMessage(source)(message));
	  };
	};
	var LEVELS = exports.LEVELS = {
	  TRACE: 'trace',
	  INFO: 'info',
	  DEBUG: 'debug',
	  WARN: 'warn',
	  ERROR: 'error',
	  FATAL: 'fatal'
	};
	
	var establishLogger = exports.establishLogger = function establishLogger(level) {
	  var streamList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	
	  var streams = [];
	  streams.push({
	    level: level,
	    stream: new _bunyanWriter.RawStream(),
	    type: 'raw'
	  });
	  if (streamList) {
	    var list = streamList.map(function (item) {
	      item.level = level;
	    });
	    streams = streams.concat(list);
	  }
	  logger = (0, _browserBunyan.createLogger)({
	    level: level,
	    name: 'red5pro-sdk',
	    streams: streams
	  });
	};
	
	var getLogger = exports.getLogger = function getLogger() {
	  return logger;
	};
	
	var trace = exports.trace = decorate(LEVELS.TRACE);
	var info = exports.info = decorate(LEVELS.INFO);
	var debug = exports.debug = decorate(LEVELS.DEBUG);
	var warn = exports.warn = decorate(LEVELS.WARN);
	var error = exports.error = decorate(LEVELS.ERROR);
	var fatal = exports.fatal = decorate(LEVELS.FATAL);

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * !This is a stripped down version of Bunyan targeted specifically for the browser
	 *
	 * -------------------------------------------------------------------------------
	 *
	 * Copyright (c) 2014 Trent Mick. All rights reserved.
	 * Copyright (c) 2014 Joyent Inc. All rights reserved.
	 *
	 * The bunyan logging library for node.js.
	 *
	 * -*- mode: js -*-
	 * vim: expandtab:ts=4:sw=4
	 */
	
	'use strict';
	
	var VERSION = '0.2.3';
	
	// Bunyan log format version. This becomes the 'v' field on all log records.
	// `0` is until I release a version '1.0.0' of node-bunyan. Thereafter,
	// starting with `1`, this will be incremented if there is any backward
	// incompatible change to the log record format. Details will be in
	// 'CHANGES.md' (the change log).
	var LOG_VERSION = 0;
	
	//---- Internal support stuff
	
	/**
	 * A shallow copy of an object. Bunyan logging attempts to never cause
	 * exceptions, so this function attempts to handle non-objects gracefully.
	 */
	function objCopy(obj) {
	    if (typeof obj === 'undefined' || obj === null) {  // null or undefined
	        return obj;
	    } else if (Array.isArray(obj)) {
	        return obj.slice();
	    } else if (typeof (obj) === 'object') {
	        var copy = {};
	        Object.keys(obj).forEach(function (k) {
	            copy[k] = obj[k];
	        });
	        return copy;
	    } else {
	        return obj;
	    }
	}
	
	var format = function(f) {
	
	    if(f === null) {
	        return 'null';
	    }
	
	    if(typeof f !== 'string') {
	        return f.toString();
	    }
	    var formatRegExp = /%[sdj%]/g;
	
	    var i = 1;
	    var args = arguments;
	    var len = args.length;
	    var str = String(f).replace(formatRegExp, function(x) {
	        if (x === '%%') {
	            return '%';
	        }
	        if (i >= len) {
	            return x;
	        }
	        switch (x) {
	            case '%s': return String(args[i++]);
	            case '%d': return Number(args[i++]);
	            case '%j':
	                try {
	                    return JSON.stringify(args[i++]);
	                } catch (_) {
	                    return '[Circular]';
	                }
	                break;
	            default:
	                return x;
	        }
	    });
	    for (var x = args[i]; i < len; x = args[++i]) {
	        str += ' ' + x;
	    }
	    return str;
	};
	
	/**
	 * Gather some caller info 3 stack levels up.
	 * See <http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi>.
	 */
	function getCaller3Info() {
	    var obj = {};
	    var saveLimit = Error.stackTraceLimit;
	    var savePrepare = Error.prepareStackTrace;
	    Error.stackTraceLimit = 3;
	    //Error.captureStackTrace(this, getCaller3Info);
	
	    Error.prepareStackTrace = function (_, stack) {
	        var caller = stack[2];
	        obj.file = caller.getFileName();
	        obj.line = caller.getLineNumber();
	        var func = caller.getFunctionName();
	        if (func) {
	            obj.func = func;
	        }
	    };
	    Error.stackTraceLimit = saveLimit;
	    Error.prepareStackTrace = savePrepare;
	    return obj;
	}
	
	
	function _indent(s, indent) {
	    if (!indent) {
	        indent = '    ';
	    }
	    var lines = s.split(/\r?\n/g);
	    return indent + lines.join('\n' + indent);
	}
	
	
	/**
	 * Warn about an bunyan processing error.
	 *
	 * @param msg {String} Message with which to warn.
	 * @param dedupKey {String} Optional. A short string key for this warning to
	 *      have its warning only printed once.
	 */
	function _warn(msg, dedupKey) {
	    if (dedupKey) {
	        if (_warned[dedupKey]) {
	            return;
	        }
	        _warned[dedupKey] = true;
	    }
	    console.error(msg + '\n');
	}
	function _haveWarned(dedupKey) {
	    return _warned[dedupKey];
	}
	var _warned = {};
	
	
	function ConsoleRawStream() {
	}
	ConsoleRawStream.prototype.write = function (rec) {
	    if (rec.level < INFO) {
	        console.log(rec);
	    } else if (rec.level < WARN) {
	        console.info(rec);
	    } else if (rec.level < ERROR) {
	        console.warn(rec);
	    } else {
	        console.error(rec);
	    }
	
	    if(rec.err && rec.err.stack) {
	        console.error(rec.err.stack);
	    }
	};
	
	function ConsoleFormattedStream() {}
	ConsoleFormattedStream.prototype.write = function (rec) {
	
	    var levelCss, defaultCss = 'color: DimGray', msgCss = 'color: SteelBlue';
	
	    if (rec.level < (false)) {
	        levelCss = 'color: DeepPink';
	    } else if (rec.level < INFO) {
	        levelCss = 'color: GoldenRod';
	    } else if (rec.level < WARN) {
	        levelCss = 'color: DarkTurquoise';
	    } else if (rec.level < ERROR) {
	        levelCss = 'color: Purple';
	    } else if (rec.level < FATAL) {
	        levelCss = 'color: Crimson';
	    } else {
	        levelCss = 'color: Black';
	    }
	
	    var loggerName = rec.childName ? rec.name + '/' + rec.childName : rec.name;
	
	    //get level name and pad start with spacs
	    var levelName = nameFromLevel[rec.level].toUpperCase();
	    levelName = Array(6 - levelName.length).join(' ') + levelName;
	
	    function padZeros(number, len) {
	        return Array((len + 1) - (number + '').length).join('0') + number;
	    }
	
	    console.log('[%s:%s:%s:%s] %c%s%c: %s: %c%s',
	        padZeros(rec.time.getHours(), 2), padZeros(rec.time.getMinutes(), 2),
	        padZeros(rec.time.getSeconds(), 2), padZeros(rec.time.getMilliseconds(), 4),
	        levelCss, levelName,
	        defaultCss, loggerName,
	        msgCss, rec.msg);
	    if(rec.err && rec.err.stack) {
	        console.log('%c%s,', levelCss, rec.err.stack);
	    }
	};
	
	//---- Levels
	
	var TRACE = 10;
	var DEBUG = 20;
	var INFO = 30;
	var WARN = 40;
	var ERROR = 50;
	var FATAL = 60;
	
	var levelFromName = {
	    'trace': TRACE,
	    'debug': DEBUG,
	    'info': INFO,
	    'warn': WARN,
	    'error': ERROR,
	    'fatal': FATAL
	};
	var nameFromLevel = {};
	Object.keys(levelFromName).forEach(function (name) {
	    nameFromLevel[levelFromName[name]] = name;
	});
	
	
	/**
	 * Resolve a level number, name (upper or lowercase) to a level number value.
	 *
	 * @api public
	 */
	function resolveLevel(nameOrNum) {
	    var level = (typeof (nameOrNum) === 'string' ? levelFromName[nameOrNum.toLowerCase()] : nameOrNum);
	    return level;
	}
	
	
	//---- Logger class
	
	/**
	 * Create a Logger instance.
	 *
	 * @param options {Object} See documentation for full details. At minimum
	 *    this must include a 'name' string key. Configuration keys:
	 *      - `streams`: specify the logger output streams. This is an array of
	 *        objects with these fields:
	 *          - `type`: The stream type. See README.md for full details.
	 *            Often this is implied by the other fields. Examples are
	 *            'file', 'stream' and "raw".
	 *          - `level`: Defaults to 'info'.
	 *          - `path` or `stream`: The specify the file path or writeable
	 *            stream to which log records are written. E.g.
	 *            `stream: process.stdout`.
	 *          - `closeOnExit` (boolean): Optional. Default is true for a
	 *            'file' stream when `path` is given, false otherwise.
	 *        See README.md for full details.
	 *      - `level`: set the level for a single output stream (cannot be used
	 *        with `streams`)
	 *      - `stream`: the output stream for a logger with just one, e.g.
	 *        `process.stdout` (cannot be used with `streams`)
	 *      - `serializers`: object mapping log record field names to
	 *        serializing functions. See README.md for details.
	 *      - `src`: Boolean (default false). Set true to enable 'src' automatic
	 *        field with log call source info.
	 *    All other keys are log record fields.
	 *
	 * An alternative *internal* call signature is used for creating a child:
	 *    new Logger(<parent logger>, <child options>[, <child opts are simple>]);
	 *
	 * @param _childSimple (Boolean) An assertion that the given `_childOptions`
	 *    (a) only add fields (no config) and (b) no serialization handling is
	 *    required for them. IOW, this is a fast path for frequent child
	 *    creation.
	 */
	function Logger(options, _childOptions, _childSimple) {
	    if (!(this instanceof Logger)) {
	        return new Logger(options, _childOptions);
	    }
	
	    // Input arg validation.
	    var parent;
	    if (_childOptions !== undefined) {
	        parent = options;
	        options = _childOptions;
	        if (!(parent instanceof Logger)) {
	            throw new TypeError(
	                'invalid Logger creation: do not pass a second arg');
	        }
	    }
	    if (!options) {
	        throw new TypeError('options (object) is required');
	    }
	    if (!parent) {
	        if (!options.name) {
	            throw new TypeError('options.name (string) is required');
	        }
	    } else {
	        if (options.name) {
	            throw new TypeError(
	                'invalid options.name: child cannot set logger name');
	        }
	    }
	    if (options.stream && options.streams) {
	        throw new TypeError('cannot mix "streams" and "stream" options');
	    }
	    if (options.streams && !Array.isArray(options.streams)) {
	        throw new TypeError('invalid options.streams: must be an array');
	    }
	    if (options.serializers && (typeof (options.serializers) !== 'object' || Array.isArray(options.serializers))) {
	        throw new TypeError('invalid options.serializers: must be an object');
	    }
	
	    var fields, name, i;
	
	    // Fast path for simple child creation.
	    if (parent && _childSimple) {
	        // `_isSimpleChild` is a signal to stream close handling that this child
	        // owns none of its streams.
	        this._isSimpleChild = true;
	
	        this._level = parent._level;
	        this.streams = parent.streams;
	        this.serializers = parent.serializers;
	        this.src = parent.src;
	        fields = this.fields = {};
	        var parentFieldNames = Object.keys(parent.fields);
	        for (i = 0; i < parentFieldNames.length; i++) {
	            name = parentFieldNames[i];
	            fields[name] = parent.fields[name];
	        }
	        var names = Object.keys(options);
	        for (i = 0; i < names.length; i++) {
	            name = names[i];
	            fields[name] = options[name];
	        }
	        return;
	    }
	
	    // Null values.
	    var self = this;
	    if (parent) {
	        this._level = parent._level;
	        this.streams = [];
	        for (i = 0; i < parent.streams.length; i++) {
	            var s = objCopy(parent.streams[i]);
	            s.closeOnExit = false; // Don't own parent stream.
	            this.streams.push(s);
	        }
	        this.serializers = objCopy(parent.serializers);
	        this.src = parent.src;
	        this.fields = objCopy(parent.fields);
	        if (options.level) {
	            this.level(options.level);
	        }
	    } else {
	        this._level = Number.POSITIVE_INFINITY;
	        this.streams = [];
	        this.serializers = null;
	        this.src = false;
	        this.fields = {};
	    }
	
	    // Handle *config* options (i.e. options that are not just plain data
	    // for log records).
	    if (options.stream) {
	        self.addStream({
	            type: 'stream',
	            stream: options.stream,
	            closeOnExit: false,
	            level: options.level
	        });
	    } else if (options.streams) {
	        options.streams.forEach(function (s) {
	            self.addStream(s, options.level);
	        });
	    } else if (parent && options.level) {
	        this.level(options.level);
	    } else if (!parent) {
	
	        /*
	         * In the browser we'll be emitting to console.log by default.
	         * Any console.log worth its salt these days can nicely render
	         * and introspect objects (e.g. the Firefox and Chrome console)
	         * so let's emit the raw log record. Are there browsers for which
	         * that breaks things?
	         */
	        self.addStream({
	            type: 'raw',
	            stream: new ConsoleRawStream(),
	            closeOnExit: false,
	            level: options.level
	        });
	
	    }
	    if (options.serializers) {
	        self.addSerializers(options.serializers);
	    }
	    if (options.src) {
	        this.src = true;
	    }
	
	    // Fields.
	    // These are the default fields for log records (minus the attributes
	    // removed in this constructor). To allow storing raw log records
	    // (unrendered), `this.fields` must never be mutated. Create a copy for
	    // any changes.
	    fields = objCopy(options);
	    delete fields.stream;
	    delete fields.level;
	    delete fields.streams;
	    delete fields.serializers;
	    delete fields.src;
	    if (this.serializers) {
	        this._applySerializers(fields);
	    }
	    Object.keys(fields).forEach(function (k) {
	        self.fields[k] = fields[k];
	    });
	}
	
	/**
	 * Add a stream
	 *
	 * @param stream {Object}. Object with these fields:
	 *    - `type`: The stream type. See README.md for full details.
	 *      Often this is implied by the other fields. Examples are
	 *      'file', 'stream' and "raw".
	 *    - `path` or `stream`: The specify the file path or writeable
	 *      stream to which log records are written. E.g.
	 *      `stream: process.stdout`.
	 *    - `level`: Optional. Falls back to `defaultLevel`.
	 *    - `closeOnExit` (boolean): Optional. Default is true for a
	 *      'file' stream when `path` is given, false otherwise.
	 *    See README.md for full details.
	 * @param defaultLevel {Number|String} Optional. A level to use if
	 *      `stream.level` is not set. If neither is given, this defaults to INFO.
	 */
	Logger.prototype.addStream = function addStream(s, defaultLevel) {
	    var self = this;
	    if (defaultLevel === null || defaultLevel === undefined) {
	        defaultLevel = INFO;
	    }
	
	    s = objCopy(s);
	
	    // Implicit 'type' from other args.
	    if (!s.type && s.stream) {
	        s.type = 'raw';
	    }
	    s.raw = (s.type === 'raw');  // PERF: Allow for faster check in `_emit`.
	
	    if (s.level) {
	        s.level = resolveLevel(s.level);
	    } else {
	        s.level = resolveLevel(defaultLevel);
	    }
	    if (s.level < self._level) {
	        self._level = s.level;
	    }
	
	    switch (s.type) {
	        case 'stream':
	            if (!s.closeOnExit) {
	                s.closeOnExit = false;
	            }
	            break;
	        case 'raw':
	            if (!s.closeOnExit) {
	                s.closeOnExit = false;
	            }
	            break;
	        default:
	            throw new TypeError('unknown stream type "' + s.type + '"');
	    }
	
	    self.streams.push(s);
	    delete self.haveNonRawStreams;  // reset
	};
	
	
	/**
	 * Add serializers
	 *
	 * @param serializers {Object} Optional. Object mapping log record field names
	 *    to serializing functions. See README.md for details.
	 */
	Logger.prototype.addSerializers = function addSerializers(serializers) {
	    var self = this;
	
	    if (!self.serializers) {
	        self.serializers = {};
	    }
	    Object.keys(serializers).forEach(function (field) {
	        var serializer = serializers[field];
	        if (typeof (serializer) !== 'function') {
	            throw new TypeError(format(
	                'invalid serializer for "%s" field: must be a function',
	                field));
	        } else {
	            self.serializers[field] = serializer;
	        }
	    });
	};
	
	
	/**
	 * Create a child logger, typically to add a few log record fields.
	 *
	 * This can be useful when passing a logger to a sub-component, e.g. a
	 * 'wuzzle' component of your service:
	 *
	 *    var wuzzleLog = log.child({component: 'wuzzle'})
	 *    var wuzzle = new Wuzzle({..., log: wuzzleLog})
	 *
	 * Then log records from the wuzzle code will have the same structure as
	 * the app log, *plus the component='wuzzle' field*.
	 *
	 * @param options {Object} Optional. Set of options to apply to the child.
	 *    All of the same options for a new Logger apply here. Notes:
	 *      - The parent's streams are inherited and cannot be removed in this
	 *        call. Any given `streams` are *added* to the set inherited from
	 *        the parent.
	 *      - The parent's serializers are inherited, though can effectively be
	 *        overwritten by using duplicate keys.
	 *      - Can use `level` to set the level of the streams inherited from
	 *        the parent. The level for the parent is NOT affected.
	 * @param simple {Boolean} Optional. Set to true to assert that `options`
	 *    (a) only add fields (no config) and (b) no serialization handling is
	 *    required for them. IOW, this is a fast path for frequent child
	 *    creation. See 'tools/timechild.js' for numbers.
	 */
	Logger.prototype.child = function (options, simple) {
	    return new (this.constructor)(this, options || {}, simple);
	};
	
	/**
	 * Get/set the level of all streams on this logger.
	 *
	 * Get Usage:
	 *    // Returns the current log level (lowest level of all its streams).
	 *    log.level() -> INFO
	 *
	 * Set Usage:
	 *    log.level(INFO)       // set all streams to level INFO
	 *    log.level('info')     // can use 'info' et al aliases
	 */
	Logger.prototype.level = function level(value) {
	    if (value === undefined) {
	        return this._level;
	    }
	    var newLevel = resolveLevel(value);
	    var len = this.streams.length;
	    for (var i = 0; i < len; i++) {
	        this.streams[i].level = newLevel;
	    }
	    this._level = newLevel;
	};
	
	
	/**
	 * Get/set the level of a particular stream on this logger.
	 *
	 * Get Usage:
	 *    // Returns an array of the levels of each stream.
	 *    log.levels() -> [TRACE, INFO]
	 *
	 *    // Returns a level of the identified stream.
	 *    log.levels(0) -> TRACE      // level of stream at index 0
	 *    log.levels('foo')           // level of stream with name 'foo'
	 *
	 * Set Usage:
	 *    log.levels(0, INFO)         // set level of stream 0 to INFO
	 *    log.levels(0, 'info')       // can use 'info' et al aliases
	 *    log.levels('foo', WARN)     // set stream named 'foo' to WARN
	 *
	 * Stream names: When streams are defined, they can optionally be given
	 * a name. For example,
	 *       log = new Logger({
	 *         streams: [
	 *           {
	 *             name: 'foo',
	 *             path: '/var/log/my-service/foo.log'
	 *             level: 'trace'
	 *           },
	 *         ...
	 *
	 * @param name {String|Number} The stream index or name.
	 * @param value {Number|String} The level value (INFO) or alias ('info').
	 *    If not given, this is a 'get' operation.
	 * @throws {Error} If there is no stream with the given name.
	 */
	Logger.prototype.levels = function levels(name, value) {
	    if (name === undefined) {
	        return this.streams.map(
	            function (s) {
	                return s.level;
	            });
	    }
	    var stream;
	    if (typeof (name) === 'number') {
	        stream = this.streams[name];
	        if (stream === undefined) {
	            throw new Error('invalid stream index: ' + name);
	        }
	    } else {
	        var len = this.streams.length;
	        for (var i = 0; i < len; i++) {
	            var s = this.streams[i];
	            if (s.name === name) {
	                stream = s;
	                break;
	            }
	        }
	        if (!stream) {
	            throw new Error(format('no stream with name "%s"', name));
	        }
	    }
	    if (value === undefined) {
	        return stream.level;
	    } else {
	        var newLevel = resolveLevel(value);
	        stream.level = newLevel;
	        if (newLevel < this._level) {
	            this._level = newLevel;
	        }
	    }
	};
	
	
	/**
	 * Apply registered serializers to the appropriate keys in the given fields.
	 *
	 * Pre-condition: This is only called if there is at least one serializer.
	 *
	 * @param fields (Object) The log record fields.
	 * @param excludeFields (Object) Optional mapping of keys to `true` for
	 *    keys to NOT apply a serializer.
	 */
	Logger.prototype._applySerializers = function (fields, excludeFields) {
	    var self = this;
	
	    // Check each serializer against these (presuming number of serializers
	    // is typically less than number of fields).
	    Object.keys(this.serializers).forEach(function (name) {
	        if (fields[name] === undefined ||
	            (excludeFields && excludeFields[name])) {
	            return;
	        }
	        try {
	            fields[name] = self.serializers[name](fields[name]);
	        } catch (err) {
	            _warn(format('bunyan: ERROR: Exception thrown from the "%s" ' +
	                    'Bunyan serializer. This should never happen. This is a bug' +
	                    'in that serializer function.\n%s',
	                name, err.stack || err));
	            fields[name] = format('(Error in Bunyan log "%s" serializer broke field. See stderr for details.)', name);
	        }
	    });
	};
	
	
	/**
	 * Emit a log record.
	 *
	 * @param rec {log record}
	 * @param noemit {Boolean} Optional. Set to true to skip emission
	 *      and just return the JSON string.
	 */
	Logger.prototype._emit = function (rec, noemit) {
	    var i;
	
	    // Lazily determine if this Logger has non-'raw' streams. If there are
	    // any, then we need to stringify the log record.
	    if (this.haveNonRawStreams === undefined) {
	        this.haveNonRawStreams = false;
	        for (i = 0; i < this.streams.length; i++) {
	            if (!this.streams[i].raw) {
	                this.haveNonRawStreams = true;
	                break;
	            }
	        }
	    }
	
	    // Stringify the object. Attempt to warn/recover on error.
	    var str;
	    if (noemit || this.haveNonRawStreams) {
	        try {
	            str = JSON.stringify(rec, safeCycles()) + '\n';
	        } catch (e) {
	            var dedupKey = e.stack.split(/\n/g, 2).join('\n');
	            _warn('bunyan: ERROR: Exception in ' +
	                    '`JSON.stringify(rec)`. You can install the ' +
	                    '"safe-json-stringify" module to have Bunyan fallback ' +
	                    'to safer stringification. Record:\n' +
	                    _indent(format('%s\n%s', rec, e.stack)),
	                dedupKey);
	            str = format('(Exception in JSON.stringify(rec): %j. See stderr for details.)\n', e.message);
	
	        }
	    }
	
	    if (noemit) {
	        return str;
	    }
	
	
	    var level = rec.level;
	    for (i = 0; i < this.streams.length; i++) {
	        var s = this.streams[i];
	        if (s.level <= level) {
	            s.stream.write(s.raw ? rec : str);
	        }
	    }
	
	    return str;
	};
	
	
	/**
	 * Build a log emitter function for level minLevel. I.e. this is the
	 * creator of `log.info`, `log.error`, etc.
	 */
	function mkLogEmitter(minLevel) {
	    return function () {
	        var log = this;
	
	        function mkRecord(args) {
	            var excludeFields;
	            if (args[0] instanceof Error) {
	                // `log.<level>(err, ...)`
	                fields = {
	                    // Use this Logger's err serializer, if defined.
	                    err: (log.serializers && log.serializers.err ? log.serializers.err(args[0]) : Logger.stdSerializers.err(args[0]))
	                };
	                excludeFields = {err: true};
	                if (args.length === 1) {
	                    msgArgs = [fields.err.message];
	                } else {
	                    msgArgs = Array.prototype.slice.call(args, 1);
	                }
	            } else if (typeof (args[0]) !== 'object' && args[0] !== null ||
	                Array.isArray(args[0])) {
	                // `log.<level>(msg, ...)`
	                fields = null;
	                msgArgs = Array.prototype.slice.call(args);
	            } else {  // `log.<level>(fields, msg, ...)`
	                fields = args[0];
	                msgArgs = Array.prototype.slice.call(args, 1);
	            }
	
	            // Build up the record object.
	            var rec = objCopy(log.fields);
	            rec.level = minLevel;
	            var recFields = (fields ? objCopy(fields) : null);
	            if (recFields) {
	                if (log.serializers) {
	                    log._applySerializers(recFields, excludeFields);
	                }
	                Object.keys(recFields).forEach(function (k) {
	                    rec[k] = recFields[k];
	                });
	            }
	            rec.levelName = nameFromLevel[minLevel];
	            rec.msg = format.apply(log, msgArgs);
	            if (!rec.time) {
	                rec.time = (new Date());
	            }
	            // Get call source info
	            if (log.src && !rec.src) {
	                rec.src = getCaller3Info();
	            }
	            rec.v = LOG_VERSION;
	
	            return rec;
	        }
	
	        var fields = null;
	        var msgArgs = arguments;
	        var rec = null;
	        if (!this._emit) {
	            /*
	             * Show this invalid Bunyan usage warning *once*.
	             *
	             * See <https://github.com/trentm/node-bunyan/issues/100> for
	             * an example of how this can happen.
	             */
	            var dedupKey = 'unbound';
	            if (!_haveWarned[dedupKey]) {
	                var caller = getCaller3Info();
	                _warn(format('bunyan usage error: %s:%s: attempt to log with an unbound log method: `this` is: %s',
	                        caller.file, caller.line, this.toString()),
	                    dedupKey);
	            }
	            return;
	        } else if (arguments.length === 0) {   // `log.<level>()`
	            return (this._level <= minLevel);
	        } else if (this._level > minLevel) {
	            /* pass through */
	        } else {
	            rec = mkRecord(msgArgs);
	            this._emit(rec);
	        }
	    };
	}
	
	
	/**
	 * The functions below log a record at a specific level.
	 *
	 * Usages:
	 *    log.<level>()  -> boolean is-trace-enabled
	 *    log.<level>(<Error> err, [<string> msg, ...])
	 *    log.<level>(<string> msg, ...)
	 *    log.<level>(<object> fields, <string> msg, ...)
	 *
	 * where <level> is the lowercase version of the log level. E.g.:
	 *
	 *    log.info()
	 *
	 * @params fields {Object} Optional set of additional fields to log.
	 * @params msg {String} Log message. This can be followed by additional
	 *    arguments that are handled like
	 *    [util.format](http://nodejs.org/docs/latest/api/all.html#util.format).
	 */
	Logger.prototype.trace = mkLogEmitter(TRACE);
	Logger.prototype.debug = mkLogEmitter(DEBUG);
	Logger.prototype.info = mkLogEmitter(INFO);
	Logger.prototype.warn = mkLogEmitter(WARN);
	Logger.prototype.error = mkLogEmitter(ERROR);
	Logger.prototype.fatal = mkLogEmitter(FATAL);
	
	
	//---- Standard serializers
	// A serializer is a function that serializes a JavaScript object to a
	// JSON representation for logging. There is a standard set of presumed
	// interesting objects in node.js-land.
	
	Logger.stdSerializers = {};
	
	/*
	 * This function dumps long stack traces for exceptions having a cause()
	 * method. The error classes from
	 * [verror](https://github.com/davepacheco/node-verror) and
	 * [restify v2.0](https://github.com/mcavage/node-restify) are examples.
	 *
	 * Based on `dumpException` in
	 * https://github.com/davepacheco/node-extsprintf/blob/master/lib/extsprintf.js
	 */
	function getFullErrorStack(ex) {
	    var ret = ex.stack || ex.toString();
	    if (ex.cause && typeof (ex.cause) === 'function') {
	        var cex = ex.cause();
	        if (cex) {
	            ret += '\nCaused by: ' + getFullErrorStack(cex);
	        }
	    }
	    return (ret);
	}
	
	// Serialize an Error object
	// (Core error properties are enumerable in node 0.4, not in 0.6).
	Logger.stdSerializers.err = function(err) {
	    if (!err || !err.stack) {
	        return err;
	    }
	
	    var obj = {
	        message: err.message,
	        name: err.name,
	        stack: getFullErrorStack(err),
	        code: err.code,
	        signal: err.signal
	    };
	    return obj;
	};
	
	
	// A JSON stringifier that handles cycles safely.
	// Usage: JSON.stringify(obj, safeCycles())
	function safeCycles() {
	    var seen = [];
	    return function (key, val) {
	        if (!val || typeof (val) !== 'object') {
	            return val;
	        }
	        if (seen.indexOf(val) !== -1) {
	            return '[Circular]';
	        }
	        seen.push(val);
	        return val;
	    };
	}
	
	//---- Exports
	
	module.exports = Logger;
	
	module.exports.TRACE = TRACE;
	module.exports.DEBUG = DEBUG;
	module.exports.INFO = INFO;
	module.exports.WARN = WARN;
	module.exports.ERROR = ERROR;
	module.exports.FATAL = FATAL;
	module.exports.resolveLevel = resolveLevel;
	module.exports.levelFromName = levelFromName;
	module.exports.nameFromLevel = nameFromLevel;
	
	module.exports.VERSION = VERSION;
	module.exports.LOG_VERSION = LOG_VERSION;
	
	module.exports.createLogger = function createLogger(options) {
	    return new Logger(options);
	};
	
	// Useful for custom `type == 'raw'` streams that may do JSON stringification
	// of log records themselves. Usage:
	//    var str = JSON.stringify(rec, bunyan.safeCycles());
	module.exports.safeCycles = safeCycles;
	
	//streams
	module.exports.ConsoleFormattedStream = ConsoleFormattedStream;
	module.exports.ConsoleRawStream = ConsoleRawStream;

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RawStream = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _browserBunyan = __webpack_require__(300);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var RawStream = exports.RawStream = function () {
	  function RawStream() {
	    _classCallCheck(this, RawStream);
	  }
	
	  _createClass(RawStream, [{
	    key: 'write',
	    value: function write(rec) {
	      console.log('[%s] %s: %s',
	      //                rec.time.toISOString(),
	      rec.name, _browserBunyan.nameFromLevel[rec.level], rec.msg);
	    }
	  }]);

	  return RawStream;
	}();

/***/ },
/* 302 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var common = exports.common = Object.freeze({
	  CONNECT_SUCCESS: 'Connect.Success',
	  CONNECT_FAILURE: 'Connect.Failure',
	  PUBLISH_START: 'Publish.Start',
	  PUBLISH_FAIL: 'Publish.Fail',
	  PUBLISH_INVALID_NAME: 'Publish.InvalidName',
	  UNPUBLISH_SUCCESS: 'Unpublish.Success',
	  PUBLISH_METADATA: 'Publish.Metadata',
	  CONNECTION_CLOSED: 'Publisher.Connection.Closed'
	});
	
	var failover = exports.failover = Object.freeze({
	  PUBLISHER_REJECT: 'Publisher.Reject',
	  PUBLISHER_ACCEPT: 'Publisher.Accept'
	});
	
	var rtc = exports.rtc = Object.freeze({
	  MEDIA_STREAM_AVAILABLE: 'WebRTC.MediaStream.Available',
	  PEER_CONNECTION_AVAILABLE: 'WebRTC.PeerConnection.Available',
	  OFFER_START: 'WebRTC.Offer.Start',
	  OFFER_END: 'WebRTC.Offer.End',
	  ICE_TRICKLE_COMPLETE: 'WebRTC.IceTrickle.Complete'
	});
	
	var rtmp = exports.rtmp = Object.freeze({
	  EMBED_SUCCESS: 'FlashPlayer.Embed.Success',
	  EMBED_FAILURE: 'FlashPlayer.Embed.Failure'
	});

/***/ },
/* 303 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var common = exports.common = Object.freeze({
	  CONNECT_SUCCESS: 'Connect.Success',
	  CONNECT_FAILURE: 'Connect.Failure',
	  SUBSCRIBE_START: 'Subscribe.Start',
	  SUBSCRIBE_STOP: 'Subscribe.Stop',
	  SUBSCRIBE_FAIL: 'Subscribe.Fail',
	  SUBSCRIBE_INVALID_NAME: 'Subscribe.InvalidName',
	  SUBSCRIBE_METADATA: 'Subscribe.Metadata',
	  SUBSCRIBE_SEND_INVOKE: 'Subscriber.Send.Invoke',
	  PLAY_UNPUBLISH: 'Subscriber.Play.Unpublish',
	  CONNECTION_CLOSED: 'Subscriber.Connection.Closed'
	});
	
	var failover = exports.failover = Object.freeze({
	  SUBSCRIBER_REJECT: 'Subscriber.Reject',
	  SUBSCRIBER_ACCEPT: 'Subscriber.Accept'
	});
	
	var rtc = exports.rtc = Object.freeze({
	  PEER_CONNECTION_AVAILABLE: 'WebRTC.PeerConnection.Available',
	  OFFER_START: 'WebRTC.Offer.Start',
	  OFFER_END: 'WebRTC.Offer.End',
	  ANSWER_START: 'WebRTC.Answer.Start',
	  ANSWER_END: 'WebRTC.Answer.End',
	  CANDIDATE_START: 'WebRTC.Candidate.Start',
	  CANDIDATE_END: 'WebRTC.Candidate.End',
	  ICE_TRICKLE_COMPLETE: 'WebRTC.IceTrickle.Complete'
	});
	
	var rtmp = exports.rtmp = Object.freeze({
	  EMBED_SUCCESS: 'FlashPlayer.Embed.Success',
	  EMBED_FAILURE: 'FlashPlayer.Embed.Failure'
	});

/***/ },
/* 304 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var common = exports.common = Object.freeze({
	  CONNECT_SUCCESS: 'Connect.Success',
	  CONNECT_FAILURE: 'Connect.Failure',
	  PROPERTY_UPDATE: 'SharedObject.PropertyUpdate',
	  METHOD_UPDATE: 'SharedObject.MethodUpdate'
	});

/***/ },
/* 305 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var PlaybackTypes = exports.PlaybackTypes = Object.freeze({
	  RTMP: 'rtmp',
	  RTC: 'rtc',
	  HLS: 'hls'
	});
	
	var PlaybackAudioEncoder = exports.PlaybackAudioEncoder = Object.freeze({
	  OPUS: 'Opus',
	  PCMU: 'PCMU',
	  PCMA: 'PCMA',
	  SPEEX: 'Speex',
	  NONE: 'NONE'
	});
	
	var PlaybackVideoEncoder = exports.PlaybackVideoEncoder = Object.freeze({
	  VP8: 'VP8',
	  H264: 'H264',
	  NONE: 'NONE'
	});

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Main entry for failover support of all subscriber implementations.
	 */
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RTMPSubscriber = exports.R5LiveSubscriber = exports.VideoJSSubscriber = exports.HLSSubscriber = exports.RTCSubscriber = exports.Red5ProSubscriber = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _red5proRtc = __webpack_require__(308);
	
	var _red5proRtc2 = _interopRequireDefault(_red5proRtc);
	
	var _red5proHls = __webpack_require__(319);
	
	var _red5proHls2 = _interopRequireDefault(_red5proHls);
	
	var _red5proRtmp = __webpack_require__(322);
	
	var _red5proRtmp2 = _interopRequireDefault(_red5proRtmp);
	
	var _red5proRtmpLive = __webpack_require__(324);
	
	var _red5proRtmpLive2 = _interopRequireDefault(_red5proRtmpLive);
	
	var _red5proRtmpVideojs = __webpack_require__(323);
	
	var _red5proRtmpVideojs2 = _interopRequireDefault(_red5proRtmpVideojs);
	
	var _implFactoryOrder = __webpack_require__(328);
	
	var _implFactoryOrder2 = _interopRequireDefault(_implFactoryOrder);
	
	var _promise = __webpack_require__(310);
	
	var _playback = __webpack_require__(305);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProSubscriber';
	var playbackFactory = new _implFactoryOrder2.default();
	
	var playbackImpl = function () {
	  var map = new Map();
	  map.set(_playback.PlaybackTypes.RTC, _red5proRtc2.default);
	  map.set(_playback.PlaybackTypes.RTMP, _red5proRtmp2.default);
	  map.set(_playback.PlaybackTypes.HLS, _red5proHls2.default);
	  return map;
	}();
	
	var Red5ProSubscriber = function (_EventEmitter) {
	  _inherits(Red5ProSubscriber, _EventEmitter);
	
	  function Red5ProSubscriber() {
	    _classCallCheck(this, Red5ProSubscriber);
	
	    // Configuration options
	    var _this = _possibleConstructorReturn(this, (Red5ProSubscriber.__proto__ || Object.getPrototypeOf(Red5ProSubscriber)).call(this));
	
	    _this._options = undefined;
	    // The playback view
	    _this._view = undefined;
	    // Selected failover subscriber.
	    _this._currentSubscriber = undefined;
	    // Default order.
	    _this._order = [_playback.PlaybackTypes.RTC, _playback.PlaybackTypes.RTMP, _playback.PlaybackTypes.HLS];
	    _this._boundBubbleSubscriberEvent = _this.bubbleSubscriberEvent.bind(_this);
	    return _this;
	  }
	
	  _createClass(Red5ProSubscriber, [{
	    key: 'getPlaybackOrder',
	    value: function getPlaybackOrder() {
	      return this._order;
	    }
	  }, {
	    key: 'setPlaybackOrder',
	    value: function setPlaybackOrder(order) {
	      // Allow for string value to define single item in order.
	      order = typeof order === 'string' ? [order] : order;
	
	      // Filter out values not available in enumeration of playback types.
	      var t = order.filter(function (entry) {
	        var key = void 0;
	        for (key in _playback.PlaybackTypes) {
	          if (_playback.PlaybackTypes[key].toLowerCase() === entry.toLowerCase()) {
	            return true;
	          }
	        }
	        return false;
	      }).map(function (entry) {
	        return entry.toLowerCase();
	      });
	
	      // Define new order.
	      this._order = [].concat(_toConsumableArray(new Set(t)));
	      (0, _log.debug)(NAME, '[orderupdate]: ' + this._order);
	      return this;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(playbackView) {
	      this._view = playbackView;
	      return this;
	    }
	  }, {
	    key: 'getPlaybackFromOrder',
	    value: function getPlaybackFromOrder(order, options) {
	      return playbackFactory.create(order, playbackImpl, options, 'init');
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var _this2 = this;
	
	      this._options = options;
	      var deferred = new _promise.DeferredPromise();
	      (0, _log.debug)(NAME, '[play]');
	      this.getPlaybackFromOrder(this._order, this._options).then(function (subscriber) {
	        (0, _log.debug)(NAME, '[playsuccess]: subscriber found ' + subscriber.getType());
	        subscriber.on('*', _this2._boundBubbleSubscriberEvent);
	        _this2._currentSubscriber = subscriber;
	        if (_this2._view) {
	          _this2._currentSubscriber.setView(_this2._view);
	        }
	        deferred.resolve(_this2._currentSubscriber);
	      }).catch(function (err) {
	        (0, _log.warn)(NAME, '[playerror]: Could not implement a subscriber: ' + err);
	        deferred.reject(err);
	      });
	      return deferred.promise;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      var _this3 = this;
	
	      var deferred = new _promise.DeferredPromise();
	      if (!this._currentSubscriber) {
	        (0, _log.warn)(NAME, '[stop]: Could not invoke stop() on undefined subscriber.');
	        deferred.reject('A current subscriber is not available to issue a :stop() command to.');
	      } else {
	        (0, _log.debug)(NAME, '[stop]: Invoking stop on held subscriber.');
	        this._currentSubscriber.stop().then(function () {
	          (0, _log.debug)(NAME, '[stopsuccess]');
	          _this3._currentSubscriber.off('*', _this3._boundBubbleSubscriberEvent);
	          _this3._currentSubscriber = undefined;
	          deferred.resolve();
	        }).catch(function (err) {
	          (0, _log.debug)(NAME, '[stoperror]: ' + err);
	          if (_this3._currentSubscriber) {
	            _this3._currentSubscriber.off('*', _this3._boundBubbleSubscriberEvent);
	          }
	          _this3._currentSubscriber = undefined;
	          deferred.reject(err);
	        });
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'bubbleSubscriberEvent',
	    value: function bubbleSubscriberEvent(subscriberEvent) {
	      this.trigger.call(this, subscriberEvent);
	    }
	  }, {
	    key: 'playbackTypes',
	    get: function get() {
	      return _playback.PlaybackTypes;
	    }
	  }, {
	    key: 'currentSubscriber',
	    get: function get() {
	      return this._currentSubscriber;
	    }
	  }]);
	
	  return Red5ProSubscriber;
	}(_eventEmitter2.default);
	
	exports.Red5ProSubscriber = Red5ProSubscriber;
	exports.RTCSubscriber = _red5proRtc2.default;
	exports.HLSSubscriber = _red5proHls2.default;
	exports.VideoJSSubscriber = _red5proRtmpVideojs2.default;
	exports.R5LiveSubscriber = _red5proRtmpLive2.default;
	/**
	 * Using the RTMPSubscriber will determine the RTMP-based Subscriber
	 * to be used based on `options.useVideoJS` property.
	 *
	 * If `options.useVideoJS` is left undefined, it will default to `true`
	 * If `options.useVideoJs` is defined, it is required to be a boolean value
	 *
	 * true: VideoJSSubscriber - utilizes the videojs lib and custom SWF.
	 * false: R5LiveSubscriber - utilized the default "live" SWF shipped with Red5 Pro examples.
	*/
	
	var RTMPSubscriber = exports.RTMPSubscriber = _red5proRtmp2.default;

/***/ },
/* 307 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var WILDCARD = '*';
	var WILDCARD_KEY = 'RED5PRO';
	
	var EventEmitter = function () {
	  function EventEmitter() {
	    _classCallCheck(this, EventEmitter);
	
	    this._callbacks = {};
	    this._callbacks[WILDCARD_KEY] = [];
	  }
	
	  _createClass(EventEmitter, [{
	    key: '_notify',
	    value: function _notify(callbacks, event) {
	      var i = void 0,
	          length = callbacks.length;
	      for (i = 0; i < length; i++) {
	        callbacks[i](event);
	      }
	    }
	  }, {
	    key: 'on',
	    value: function on(type, fn) {
	      if (typeof fn !== 'function') {
	        return;
	      }
	
	      if (type === WILDCARD) {
	        this._callbacks[WILDCARD_KEY].push(fn);
	        return;
	      }
	
	      if (this._callbacks[type] === undefined) {
	        this._callbacks[type] = [];
	      }
	
	      if (this._callbacks[type].indexOf(fn) === -1) {
	        this._callbacks[type].push(fn);
	      }
	    }
	  }, {
	    key: 'off',
	    value: function off(type, fn) {
	      var map = this._callbacks[type];
	      if (type === WILDCARD) {
	        map = this._callbacks[WILDCARD_KEY];
	      }
	      if (map) {
	        var index = map.indexOf(fn);
	        if (index !== -1) {
	          map.splice(index, 1);
	        }
	      }
	    }
	  }, {
	    key: 'trigger',
	    value: function trigger(event) {
	      var type = event.type;
	      if (this._callbacks[type]) {
	        this._notify(this._callbacks[type], event);
	      }
	      this._notify(this._callbacks[WILDCARD_KEY], event);
	    }
	  }]);
	
	  return EventEmitter;
	}();
	
	exports.default = EventEmitter;

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _event = __webpack_require__(313);
	
	var _socketHelperSub = __webpack_require__(314);
	
	var _socketHelperSub2 = _interopRequireDefault(_socketHelperSub);
	
	var _webrtcHelperSub = __webpack_require__(317);
	
	var _webrtcHelperSub2 = _interopRequireDefault(_webrtcHelperSub);
	
	var _promise = __webpack_require__(310);
	
	var _webrtc = __webpack_require__(318);
	
	var webrtc = _interopRequireWildcard(_webrtc);
	
	var _websocket = __webpack_require__(316);
	
	var websocket = _interopRequireWildcard(_websocket);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProRTCSubscriber';
	var defaultOptions = {
	  streamType: 'webrtc'
	};
	var generateSubscriptionId = function generateSubscriptionId() {
	  var id = Math.floor(Math.random() * 0x10000).toString(16);
	  return 'subscriber-' + id;
	};
	var endpointFromOptions = function endpointFromOptions(options) {
	  var protocol = options.wsprotocol || options.protocol;
	  var port = options.wsport || options.port;
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  var endpoint = protocol + '://' + options.host + ':' + port + '/' + appEndpoint + '?id=' + options.subscriptionId;
	  if (typeof options.connectionParams !== 'undefined') {
	    (function () {
	      var params = [];
	      Object.keys(options.connectionParams).forEach(function (key, index) {
	        // eslint-disable-line no-unused-vars
	        params.push([key, options.connectionParams[key]].join('='));
	      });
	      if (params.length > 0) {
	        endpoint += '&' + params.join('&');
	      }
	    })();
	  }
	  return endpoint;
	};
	
	var RTCSubscriber = function (_EventEmitter) {
	  _inherits(RTCSubscriber, _EventEmitter);
	
	  function RTCSubscriber() {
	    _classCallCheck(this, RTCSubscriber);
	
	    var _this = _possibleConstructorReturn(this, (RTCSubscriber.__proto__ || Object.getPrototypeOf(RTCSubscriber)).call(this));
	
	    _this._view = undefined;
	    _this._options = undefined;
	    _this._peerHelper = undefined;
	    _this._socketHelper = undefined;
	    _this._orientation = 0;
	    return _this;
	  }
	
	  _createClass(RTCSubscriber, [{
	    key: 'init',
	    value: function init(options) {
	      var deferred = new _promise.DeferredPromise();
	      if (!webrtc.isSupported() || !websocket.isSupported()) {
	        deferred.reject('Cannot create WebRTC playback instance. Your environment does not support WebRTC and/or WebSockets.');
	      } else {
	        this._options = Object.assign({}, defaultOptions, options);
	        this._options.subscriptionId = this._options.subscriptionId || generateSubscriptionId();
	        this._peerHelper = new _webrtcHelperSub2.default(this);
	        this._socketHelper = new _socketHelperSub2.default(this);
	        deferred.resolve(this);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	      //  TODO: Normalize returns to either all be chainable or not be chainable
	      return this;
	    }
	  }, {
	    key: 'requestAvailability',
	    value: function requestAvailability(streamName, type) {
	      (0, _log.debug)(NAME, '[requestavailability]');
	      // message on socket returns -> onStream(Un)Available
	      this._socketHelper.post({
	        isAvailable: streamName,
	        type: type
	      });
	      //  TODO: Normalize returns to either all be chainable or not be chainable
	      return this;
	    }
	  }, {
	    key: 'requestOffer',
	    value: function requestOffer(streamName, subscriptionId) {
	      var vEncoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
	      var aEncoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
	
	      (0, _log.debug)(NAME, '[requestoffer]');
	      var offer = {
	        requestOffer: streamName,
	        requestId: subscriptionId
	      };
	      if (typeof vEncoding !== 'undefined') {
	        offer.videoEncoding = vEncoding;
	      }
	      if (typeof aEncoding !== 'undefined') {
	        offer.audioEncoding = aEncoding;
	      }
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.OFFER_START, this));
	      // message on socket returns -> onSDPOffer
	      this._socketHelper.post(offer);
	    }
	  }, {
	    key: 'requestAnswer',
	    value: function requestAnswer(sdp) {
	      var _this2 = this;
	
	      (0, _log.debug)(NAME, '[requestanswer]');
	      // invokes -> sendAnswer
	      this._peerHelper.createAnswer(sdp).then(function (sessionDescription) {
	        (0, _log.debug)(NAME, '[onanswercreated]');
	        if (_this2._options.bandwidth) {
	          sessionDescription.sdp = webrtc.updateBandwidth(_this2._options.bandwidth, sessionDescription.sdp);
	        }
	        (0, _log.debug)(NAME, '[> sendanswer]');
	        _this2.sendAnswer(_this2._options.streamName, _this2._options.subscriptionId, sessionDescription);
	      }).catch(function (error) {
	        _this2.onSDPError(error);
	      });
	    }
	  }, {
	    key: 'sendAnswer',
	    value: function sendAnswer(streamName, subscriptionId, sdp) {
	      (0, _log.debug)(NAME, '[sendanswer]: streamname(' + streamName + '), subscriptionid(' + subscriptionId + ')');
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.ANSWER_START, this, sdp));
	      // message on socket response -> onAddIceCandidate
	      // message on peer response -> onaddstream
	      this._socketHelper.post({
	        handleAnswer: streamName,
	        requestId: subscriptionId,
	        data: {
	          sdp: sdp
	        }
	      });
	    }
	  }, {
	    key: 'sendCandidate',
	    value: function sendCandidate(candidate) {
	      (0, _log.debug)(NAME, '[sendcandidate]');
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.CANDIDATE_START, this, candidate));
	      // message on peer response -> onicecandidate
	      this._socketHelper.post({
	        handleCandidate: this._options.streamName,
	        requestId: this._options.subscriptionId,
	        data: {
	          candidate: candidate
	        }
	      });
	    }
	  }, {
	    key: 'sendSubscribe',
	    value: function sendSubscribe() {
	      (0, _log.debug)(NAME, '[sendsubscribe]');
	      this._socketHelper.post({
	        subscribe: this._options.streamName,
	        requestId: this._options.subscriptionId
	      });
	    }
	  }, {
	    key: 'onStreamAvailable',
	    value: function onStreamAvailable(receipt) {
	      (0, _log.debug)(NAME, '[onstreamavailable]: ' + JSON.stringify(receipt, null, 2));
	      this._connect(this._options.iceServers);
	    }
	  }, {
	    key: 'onStreamUnavailable',
	    value: function onStreamUnavailable(receipt) {
	      (0, _log.debug)(NAME, 'Stream ' + this._options.streamName + ' does not exist.');
	      (0, _log.debug)(NAME, '[onstreamunavailable]: ' + JSON.stringify(receipt, null, 2));
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_INVALID_NAME, this));
	      this._disconnect();
	    }
	  }, {
	    key: 'onSDPSuccess',
	    value: function onSDPSuccess(receipt) {
	      (0, _log.debug)(NAME, '[onsdpsuccess]: ' + JSON.stringify(receipt, null, 2));
	    }
	  }, {
	    key: 'onSDPOffer',
	    value: function onSDPOffer(receipt) {
	      (0, _log.debug)(NAME, '[onsdpoffer]: ' + JSON.stringify(receipt, null, 2));
	      var sdp = new webrtc.RTCSessionDescription(receipt.sdp);
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.OFFER_END, this));
	      this.requestAnswer(sdp);
	    }
	  }, {
	    key: 'onSDPError',
	    value: function onSDPError(receipt) {
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL, this, receipt));
	      (0, _log.error)(NAME, '[onsdperror]');
	      (0, _log.error)(receipt);
	    }
	  }, {
	    key: 'onAnswerMediaStream',
	    value: function onAnswerMediaStream() {
	      var stream = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
	      // eslint-disable-line no-unused-vars
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.ANSWER_END, this));
	    }
	  }, {
	    key: 'onIceCandidate',
	    value: function onIceCandidate(candidate) {
	      (0, _log.debug)(NAME, '[onicecandidate]');
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.CANDIDATE_END, this));
	      this.sendCandidate(candidate);
	    }
	  }, {
	    key: 'onIceCandidateTrickleEnd',
	    value: function onIceCandidateTrickleEnd(stream) {
	      (0, _log.debug)(NAME, '[onicetrickleend]');
	      this._view.attachStream(stream, this._options.autoplay || true);
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_START, this));
	    }
	  }, {
	    key: 'onAddIceCandidate',
	    value: function onAddIceCandidate(candidate) {
	      (0, _log.debug)(NAME, '[onaddicecandidate]');
	      this._peerHelper.addIceCandidate(candidate);
	    }
	  }, {
	    key: 'onSocketIceCandidateEnd',
	    value: function onSocketIceCandidateEnd() {
	      (0, _log.debug)(NAME, '[onsocketicecandidateend]');
	      this.trigger(new _event.SubscriberEvent(_event.RTCSubscriberEventTypes.ICE_TRICKLE_COMPLETE, this));
	      this.sendSubscribe();
	    }
	  }, {
	    key: 'onSocketMessageError',
	    value: function onSocketMessageError(message) {
	      var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	
	      (0, _log.error)(NAME, 'Error in stream subscription: ' + message + '.\n[Optional detail]: ' + detail);
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL, this, message));
	    }
	  }, {
	    key: 'onUnpublish',
	    value: function onUnpublish() {
	      (0, _log.debug)(NAME, '[onunpublish]');
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.PLAY_UNPUBLISH, this));
	    }
	  }, {
	    key: 'onConnectionClosed',
	    value: function onConnectionClosed() {
	      (0, _log.debug)(NAME, '[onconnectionclosed]');
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECTION_CLOSED, this));
	    }
	  }, {
	    key: 'onSendReceived',
	    value: function onSendReceived(methodName, data) {
	      if (methodName === 'onMetaData') {
	        this.onMetaData(data);
	      } else {
	        // environment.invoke(methodName, data)
	        this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_SEND_INVOKE, this, {
	          methodName: methodName,
	          data: data
	        }));
	      }
	    }
	  }, {
	    key: 'onMetaData',
	    value: function onMetaData(metadata) {
	      if (typeof metadata.orientation !== 'undefined' && metadata.orientation !== this._orientation) {
	        _browser2.default.applyOrientation(this._view.view, metadata.orientation);
	        this._orientation = metadata.orientation;
	      }
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_METADATA, this, metadata));
	    }
	  }, {
	    key: '_disconnect',
	    value: function _disconnect() {
	      (0, _log.debug)(NAME, '[disconnect]');
	      if (this._socketHelper) {
	        this._socketHelper.tearDown();
	      }
	      if (this._peerHelper) {
	        this._peerHelper.tearDown();
	      }
	    }
	  }, {
	    key: '_connect',
	    value: function _connect(iceServers) {
	      var _this3 = this;
	
	      (0, _log.debug)(NAME, '[connect]');
	      this._options.iceServers = iceServers;
	      var p = this._peerHelper.setUp(this._options.iceServers);
	      p.then(function () {
	        _this3.requestOffer(_this3._options.streamName, _this3._options.subscriptionId, _this3._options.videoEncoding, _this3._options.audioEncoding);
	      }).catch(function () {
	        (0, _log.warn)(NAME, 'Could not establish RTCPeerConnection.');
	        _this3.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE, _this3));
	      });
	      //  TODO: Normalize returns to either all be chainable or not be chainable
	      return this;
	    }
	  }, {
	    key: 'play',
	    value: function play() {
	      var _this4 = this;
	
	      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	      (0, _log.debug)(NAME, '[play]');
	      this._options.streamName = streamName || this._options.streamName;
	      var p = promise || new _promise.DeferredPromise();
	      var socketPromise = new _promise.DeferredPromise();
	      var socketurl = endpointFromOptions(this._options);
	      this._socketHelper.setUp(socketurl, socketPromise);
	      socketPromise.promise.then(function () {
	        p.resolve(_this4);
	        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_SUCCESS, _this4));
	        _this4.requestAvailability(_this4._options.streamName, _this4._options.streamType);
	      }).catch(function (error) {
	        p.reject(error);
	        _this4.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE, _this4, error));
	      });
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      (0, _log.debug)(NAME, '[stop]');
	      var deferred = new _promise.DeferredPromise();
	      this._disconnect();
	      this._view.stop();
	      deferred.resolve(this);
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.UNSUBSCRIBE_SUCCESS, this));
	      return deferred.promise;
	    }
	  }, {
	    key: 'getConnection',
	    value: function getConnection() {
	      return this._socketHelper;
	    }
	  }, {
	    key: 'getPeerConnection',
	    value: function getPeerConnection() {
	      return this._peerHelper ? this._peerHelper.connection : undefined;
	    }
	  }, {
	    key: 'getOptions',
	    value: function getOptions() {
	      return this._options;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'RTC';
	    }
	  }]);
	
	  return RTCSubscriber;
	}(_eventEmitter2.default);
	
	exports.default = RTCSubscriber;

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _promise = __webpack_require__(310);
	
	var _errors = __webpack_require__(311);
	
	var _metadataUtil = __webpack_require__(312);
	
	var closeHandlers = [];
	function onwindowclose(e) {
	  // eslint-disable-line no-unused-vars
	  //  closeHandlers.forEach(h => h())
	  var i = void 0,
	      length = closeHandlers.length;
	  for (i = 0; i < length; i++) {
	    closeHandlers[i]();
	  }
	  // Returning a string value forces a leaving confirmation popup on the browser.
	  //  e.returnValue = 'goodbye'
	  //  return 'goodbye'
	}
	
	// https://github.com/videojs/video.js/blob/master/src/js/tech/flash.js#L476
	var flashVersion = function flashVersion() {
	  var version = '0,0,0';
	  // IE
	  try {
	    version = new window.ActiveXObject('ShockwaveFlash.ShockwaveFlash').GetVariable('$version').replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
	
	    // other browsers
	  } catch (e) {
	    try {
	      if (navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {
	        version = (navigator.plugins['Shockwave Flash 2.0'] || navigator.plugins['Shockwave Flash']).description.replace(/\D+/g, ',').match(/^,?(.+),?$/)[1];
	      }
	    } catch (err) {
	      // nada
	    }
	  }
	  return version.split(',');
	};
	
	var isMoz = !!navigator.mozGetUserMedia;
	navigator.getUserMedia = navigator.getUserMedia || navigator.mozGetUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia;
	
	var defaultUserMediaAudio = isMoz ? true : {
	  manditory: {
	    googAutoGainControl: true,
	    googHighpassFilter: true,
	    googEchoCancellation: true,
	    googNoiseSuppression: true
	  },
	  optional: [{
	    bandwidth: 50
	  }, {
	    echoCancellation: true
	  }]
	};
	var defaultUserMediaVideo = isMoz ? true : {
	  mandatory: {
	    minWidth: 320,
	    minHeight: 240,
	    minFrameRate: 4,
	    maxWidth: 640,
	    maxHeight: 480,
	    maxFrameRate: 24
	  },
	  optional: [{
	    bandwidth: 256
	  }]
	};
	
	var origin = ['webkitTransformOrigin', 'mozTransformOrigin', 'msTransformOrigin', 'oTransformOrigin', 'transformOrigin'];
	var styles = ['webkitTransform', 'mozTransform', 'msTransform', 'oTransform', 'transform'];
	var transition = ['webkitTransition', 'mozTransition', 'msTransition', 'oTransition', 'transition'];
	var rotationTranslations = {
	  '0': {
	    origin: 'center center',
	    transform: 'rotate(0deg)'
	  },
	  '90': {
	    origin: 'left top',
	    transform: 'rotate(90deg) translateY(-100%)'
	  },
	  '180': {
	    origin: 'center center',
	    transform: 'rotate(180deg)'
	  },
	  '270': {
	    origin: 'top left',
	    transform: 'rotate(270deg) translateX(-100%) translateY(0%)'
	  },
	  '-90': {
	    origin: 'left top',
	    transform: 'rotate(-90deg) translateX(-100%)'
	  },
	  '-180': {
	    origin: 'center center',
	    transform: 'rotate(-180deg)'
	  },
	  '-270': {
	    origin: 'top left',
	    transform: 'rotate(-270deg) translateY(-100%)'
	  }
	};
	
	exports.default = {
	  supportsWebSocket: function supportsWebSocket() {
	    return !!window.WebSocket;
	  },
	
	  supportsFlashVersion: function supportsFlashVersion(version) {
	    var delimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.';
	
	    return flashVersion()[0] >= version.split(delimiter)[0];
	  },
	
	  resolveElement: function resolveElement(id) {
	    try {
	      var el = document.getElementById(id);
	      if (!el) {
	        throw new _errors.NoElementFoundError('Element with id(' + id + ') could not be found.');
	      }
	      return el;
	    } catch (e) {
	      throw new _errors.NoElementFoundError('Error in accessing element with id(' + id + '). ' + e.message);
	    }
	  },
	
	  createWebSocket: function createWebSocket(url) {
	    return new window.WebSocket(url);
	  },
	
	  setVideoSource: function setVideoSource(videoElement, mediaStream) {
	    var autoplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	
	    if (isMoz) {
	      videoElement['mozSrcObject'] = mediaStream;
	    } else {
	      videoElement.src = window.URL.createObjectURL(mediaStream);
	    }
	    if (autoplay) {
	      videoElement.play();
	    }
	  },
	
	  injectScript: function injectScript(url) {
	    var dfd = new _promise.DeferredPromise();
	    var script = document.createElement('script');
	    script.type = 'text/javascript';
	    script.onload = function () {
	      dfd.resolve();
	    };
	    script.onreadystatechange = function () {
	      if (script.readyState === 'loaded' || script.readyState === 'complete') {
	        script.onreadystatechange = null;
	        dfd.resolve();
	      }
	    };
	    script.src = url;
	    document.getElementsByTagName('head')[0].appendChild(script);
	    return dfd.promise;
	  },
	
	  setGlobal: function setGlobal(prop, value) {
	    window[prop] = value;
	  },
	
	  getSwfObject: function getSwfObject() {
	    return window.swfobject;
	  },
	
	  getEmbedObject: function getEmbedObject(id) {
	    return document.getElementById(id);
	  },
	
	  getElementId: function getElementId(el) {
	    return el.getAttribute('id');
	  },
	
	  getVideoJs: function getVideoJs() {
	    return window.videojs;
	  },
	
	  getUserMedia: function getUserMedia() {
	    var audio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    var video = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	    var deferred = new _promise.DeferredPromise();
	    navigator.getUserMedia({
	      audio: audio || defaultUserMediaAudio,
	      video: video || defaultUserMediaVideo
	    }, deferred.resolve, deferred.reject);
	    return deferred.promise;
	  },
	
	  getDefaultPublishConstraints: function getDefaultPublishConstraints() {
	    var audio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	    var video = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	    if (isMoz) {
	      return {
	        offerToReceiveVideo: video,
	        offerToReceiveAudio: audio
	      };
	    }
	    return {
	      mandatory: {
	        offerToReceiveVideo: video,
	        offerToReceiveAudio: audio
	      }
	    };
	  },
	
	  getIsMoz: function getIsMoz() {
	    return isMoz;
	  },
	
	  addCloseHandler: function addCloseHandler(handler) {
	    var insertValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
	
	    closeHandlers.slice(insertValue === -1 ? closeHandlers.length : insertValue, 0, handler);
	    if (window.onbeforeunload !== onwindowclose) {
	      window.onbeforeunload = onwindowclose;
	      window.addEventListener('unload', onwindowclose);
	    }
	  },
	
	  removeCloseHandler: function removeCloseHandler(handler) {
	    var i = closeHandlers.length;
	    while (--i > -1) {
	      if (closeHandlers[i] === handler) {
	        closeHandlers.slice(i, 1);
	        break;
	      }
	    }
	  },
	
	  invoke: function invoke(methodName, data) {
	    if (window.hasOwnProperty(methodName)) {
	      window[methodName].call(window, data);
	    }
	  },
	
	  onOrientationMetadata: _metadataUtil.onOrientationMetadata,
	
	  applyOrientation: function applyOrientation(element, value) {
	    var i = void 0,
	        length = styles.length;
	    value = value % 360;
	    var translations = rotationTranslations[value.toString()];
	    for (i = 0; i < length; i++) {
	      element.style[origin[i]] = translations.origin;
	      element.style[styles[i]] = translations.transform;
	      element.style[transition[i]] = 'transform 0.0s linear';
	    }
	  }
	
	};

/***/ },
/* 310 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var _DeferredPromise = function _DeferredPromise() {
	  var _this = this;
	
	  _classCallCheck(this, _DeferredPromise);
	
	  this.resolve = undefined;
	  this.reject = undefined;
	  this.promise = new Promise(function (resolve, reject) {
	    _this.resolve = resolve;
	    _this.reject = reject;
	  });
	};
	
	var _Future = {
	  createIfNotExist: function createIfNotExist(deferredIfExist) {
	    var f = deferredIfExist;
	    if (!f) {
	      f = new _DeferredPromise();
	    }
	    return f;
	  }
	};
	
	var DeferredPromise = exports.DeferredPromise = _DeferredPromise;
	var Future = exports.Future = _Future;

/***/ },
/* 311 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NoElementFoundError = exports.NoElementFoundError = function NoElementFoundError(message) {
	  _classCallCheck(this, NoElementFoundError);
	
	  this.name = 'NoElementFound';
	  this.message = message;
	};

/***/ },
/* 312 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var jsonAttr = /['"](.*?)['"]:/gi;
	var jsonVal = /:['"](.*?)['"]/gi;
	
	function readUTF(data, start, len) {
	  var result = '',
	      offset = start,
	      end = start + len;
	  do {
	    result += String.fromCharCode(data[offset++]);
	  } while (offset < end);
	  return result;
	}
	
	function parseJSONForOrientation(text) {
	  try {
	    var value = JSON.parse(text);
	    if (value.hasOwnProperty('orientation')) {
	      return {
	        orientation: parseInt(value.orientation)
	      };
	    }
	    return undefined;
	  } catch (e) {
	    var match = jsonAttr.exec(text);
	    var match2 = void 0;
	    if (match && match.length > 1) {
	      match2 = jsonVal.exec(text);
	      if (match[1] === 'orientation' && match2 && match2.length > 1) {
	        return {
	          orientation: parseInt(match2[1])
	        };
	      }
	    }
	    return undefined;
	  }
	}
	
	var onOrientationMetadata = exports.onOrientationMetadata = function onOrientationMetadata(player, callback) {
	
	  var textTracks = typeof player.textTracks === 'function' ? player.textTracks() : player.textTracks;
	
	  if (textTracks) {
	
	    player.addTextTrack('metadata');
	
	    textTracks.addEventListener('addtrack', function (addTrackEvent) {
	
	      var track = addTrackEvent.track;
	      track.mode = 'hidden';
	      /**
	      var cue = new VTTCue(1.0, 0, 'Testing')
	      cue.id = 1
	      cue.pauseOnExit = false
	      track.addCue(cue)
	      */
	
	      track.addEventListener('cuechange', function (cueChangeEvent) {
	        var cues = void 0;
	        var i = void 0;
	        // Mostly Chrome.
	        if (cueChangeEvent && cueChangeEvent.currentTarget) {
	          cues = cueChangeEvent.currentTarget.cues;
	        } else if (undefined === undefined) {
	          cues = track.cues;
	          cues = cues && cues.length > 0 ? cues : track.activeCues;
	        } else if (undefined !== undefined) {
	          // Mostly Firefox & Safari.
	          cues = cues && cues.length > 0 ? cues : undefined.activeCues;
	        }
	        // Mostly failure.
	        cues = cues || [];
	        for (i = 0; i < cues.length; i++) {
	          var data = cues[i];
	          if (data.value) {
	            var text = typeof data.value.data === 'string' ? data.value.data : readUTF(data.value.data, 0, data.size);
	            var orientation = parseJSONForOrientation(text);
	            if (typeof orientation !== 'undefined') {
	              callback(orientation);
	              break;
	            }
	          }
	        }
	      });
	    });
	  }
	};

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _publisherEvent = __webpack_require__(302);
	
	Object.defineProperty(exports, 'PublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.common;
	  }
	});
	Object.defineProperty(exports, 'RTCPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.rtc;
	  }
	});
	Object.defineProperty(exports, 'RTMPPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.rtmp;
	  }
	});
	Object.defineProperty(exports, 'FailoverPublisherEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _publisherEvent.failover;
	  }
	});
	
	var _subscriberEvent = __webpack_require__(303);
	
	Object.defineProperty(exports, 'SubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.common;
	  }
	});
	Object.defineProperty(exports, 'RTCSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.rtc;
	  }
	});
	Object.defineProperty(exports, 'RTMPSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.rtmp;
	  }
	});
	Object.defineProperty(exports, 'FailoverSubscriberEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _subscriberEvent.failover;
	  }
	});
	
	var _sharedobjectEvent = __webpack_require__(304);
	
	Object.defineProperty(exports, 'SharedObjectEventTypes', {
	  enumerable: true,
	  get: function get() {
	    return _sharedobjectEvent.common;
	  }
	});
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Event = function () {
	  function Event(type) {
	    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
	
	    _classCallCheck(this, Event);
	
	    this._type = type;
	    this._data = data;
	  }
	
	  _createClass(Event, [{
	    key: 'type',
	    get: function get() {
	      return this._type;
	    }
	  }, {
	    key: 'data',
	    get: function get() {
	      return this._data;
	    }
	  }]);
	
	  return Event;
	}();
	
	var PublisherEvent = function (_Event) {
	  _inherits(PublisherEvent, _Event);
	
	  function PublisherEvent(type, publisher, data) {
	    _classCallCheck(this, PublisherEvent);
	
	    var _this = _possibleConstructorReturn(this, (PublisherEvent.__proto__ || Object.getPrototypeOf(PublisherEvent)).call(this, type, data));
	
	    _this._publisher = publisher;
	    return _this;
	  }
	
	  _createClass(PublisherEvent, [{
	    key: 'publisher',
	    get: function get() {
	      return this._publisher;
	    }
	  }]);
	
	  return PublisherEvent;
	}(Event);
	
	var SubscriberEvent = function (_Event2) {
	  _inherits(SubscriberEvent, _Event2);
	
	  function SubscriberEvent(type, subscriber, data) {
	    _classCallCheck(this, SubscriberEvent);
	
	    var _this2 = _possibleConstructorReturn(this, (SubscriberEvent.__proto__ || Object.getPrototypeOf(SubscriberEvent)).call(this, type, data));
	
	    _this2._subscriber = subscriber;
	    return _this2;
	  }
	
	  _createClass(SubscriberEvent, [{
	    key: 'subscriber',
	    get: function get() {
	      return this._subscriber;
	    }
	  }]);
	
	  return SubscriberEvent;
	}(Event);
	
	var SharedObjectEvent = function (_Event3) {
	  _inherits(SharedObjectEvent, _Event3);
	
	  function SharedObjectEvent(type, sharedObjectName, data) {
	    _classCallCheck(this, SharedObjectEvent);
	
	    var _this3 = _possibleConstructorReturn(this, (SharedObjectEvent.__proto__ || Object.getPrototypeOf(SharedObjectEvent)).call(this, type, data));
	
	    _this3._name = sharedObjectName;
	    return _this3;
	  }
	
	  _createClass(SharedObjectEvent, [{
	    key: 'name',
	    get: function get() {
	      return this._name;
	    }
	  }]);
	
	  return SharedObjectEvent;
	}(Event);
	
	exports.PublisherEvent = PublisherEvent;
	exports.SubscriberEvent = SubscriberEvent;
	exports.SharedObjectEvent = SharedObjectEvent;

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _socketHelper = __webpack_require__(315);
	
	var _socketHelper2 = _interopRequireDefault(_socketHelper);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProSubscriptionSocket';
	
	var SubscriptionSocketHelper = function (_SocketHelper) {
	  _inherits(SubscriptionSocketHelper, _SocketHelper);
	
	  function SubscriptionSocketHelper(responder) {
	    _classCallCheck(this, SubscriptionSocketHelper);
	
	    return _possibleConstructorReturn(this, (SubscriptionSocketHelper.__proto__ || Object.getPrototypeOf(SubscriptionSocketHelper)).call(this, responder, NAME));
	  }
	
	  _createClass(SubscriptionSocketHelper, [{
	    key: 'respond',
	    value: function respond(message) {
	      //    console.log(message)
	      if (message.data) {
	        var json = this.getJsonFromSocketMessage(message);
	        try {
	          if (!_get(SubscriptionSocketHelper.prototype.__proto__ || Object.getPrototypeOf(SubscriptionSocketHelper.prototype), 'respond', this).call(this, message)) {
	            if (json.data !== undefined) {
	              if (json.data.sdp !== undefined) {
	                if (json.data.sdp.type === 'offer') {
	                  this._responder.onSDPOffer(json.data);
	                }
	              }
	              if (json.data.candidate !== undefined) {
	                this._responder.onAddIceCandidate(json.data.candidate);
	              }
	              if (json.data.type === 'status') {
	                if (json.data.code === 'NetConnection.ICE.TricleCompleted' || json.data.code === 'NetConnection.ICE.TrickleCompleted') {
	                  this._responder.onSocketIceCandidateEnd();
	                } else if (json.data.code === 'NetStream.Play.UnpublishNotify') {
	                  this._responder.onUnpublish();
	                } else if (json.data.code === 'NetConnection.Connect.Closed') {
	                  this._responder.onConnectionClosed();
	                }
	              }
	              if (json.data.hasOwnProperty('status')) {
	                if (json.data.status === 'NetStream.Play.UnpublishNotify') {
	                  this._responder.onUnpublish();
	                }
	              }
	              if (json.type !== undefined) {
	                if (json.type === 'metadata') {
	                  // It is a `send` API invocation.
	                  if (json.method !== undefined) {
	                    this._responder.onSendReceived(json.method, json.data);
	                  }
	                  // Else it is normal metadata.
	                  else {
	                      this._responder.onMetaData(json.data);
	                    }
	                }
	              }
	            } else if (json.type !== undefined) {
	              if (json.type === 'metadata') {
	                this._responder.onMetaData(json.metadata);
	              }
	            }
	          }
	        } catch (e) {
	          (0, _log.error)(NAME, '[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
	          this._responder.onSocketMessageError('[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
	        }
	      } else {
	        (0, _log.warn)(NAME, '[ws.onmessage] - No Message Data.');
	      }
	    }
	  }]);
	
	  return SubscriptionSocketHelper;
	}(_socketHelper2.default);
	
	exports.default = SubscriptionSocketHelper;

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _websocket = __webpack_require__(316);
	
	var websocket = _interopRequireWildcard(_websocket);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SocketHelper = function () {
	  function SocketHelper(responder, name) {
	    _classCallCheck(this, SocketHelper);
	
	    this._responder = responder;
	    this._pendingPostRequests = [];
	    this._websocket = undefined;
	    this._connectionPromise = undefined;
	    this._name = name;
	    this._responseHandlers = [];
	    this._onclose = this.tearDown.bind(this);
	  }
	
	  _createClass(SocketHelper, [{
	    key: '_removeSocketHandlers',
	    value: function _removeSocketHandlers(ws) {
	      ws.onopen = undefined;
	      ws.onmessage = undefined;
	      ws.onerror = undefined;
	    }
	  }, {
	    key: '_addSocketHandlers',
	    value: function _addSocketHandlers(ws, promise) {
	      var _this = this;
	
	      ws.onopen = function () {
	        (0, _log.info)(_this._name, '[websocketopen]');
	        while (_this._pendingPostRequests.length > 0) {
	          _this.post(_this._pendingPostRequests.shift());
	        }
	      };
	
	      ws.onerror = function (error) {
	        _this.tearDown();
	        (0, _log.warn)(_this._name, '[websocketerror]: Error from WebSocket. ' + error.type);
	        promise.reject(error);
	      };
	
	      ws.onmessage = function (message) {
	        _this.respond(message);
	      };
	    }
	  }, {
	    key: 'setUp',
	    value: function setUp(url, setupPromise) {
	      this.tearDown();
	      this._connectionPromise = setupPromise;
	      _browser2.default.addCloseHandler(this._onclose);
	      this._websocket = websocket.create(url);
	      this._addSocketHandlers(this._websocket, this._connectionPromise);
	    }
	  }, {
	    key: 'tearDown',
	    value: function tearDown() {
	      this._pendingPostRequests.length = 0;
	      if (typeof this._websocket !== 'undefined') {
	        this._removeSocketHandlers(this._websocket);
	        this._websocket.close();
	      }
	      this._websocket = undefined;
	      while (this._responseHandlers.length > 0) {
	        this._responseHandlers.shift();
	      }
	      _browser2.default.removeCloseHandler(this._onclose);
	    }
	  }, {
	    key: 'getJsonFromSocketMessage',
	    value: function getJsonFromSocketMessage(message) {
	      try {
	        return typeof message.data === 'string' ? JSON.parse(message.data) : message.data;
	      } catch (e) {
	        (0, _log.warn)(this._name, 'Could not parse message as JSON. Message= ' + message.data + '. Error= ' + e.message);
	      }
	      return null;
	    }
	  }, {
	    key: 'addSharedObjectResponseHandler',
	    value: function addSharedObjectResponseHandler(handler) {
	      this._responseHandlers.push(handler);
	    }
	  }, {
	    key: 'removeSharedObjectResponseHandler',
	    value: function removeSharedObjectResponseHandler(handler) {
	      var i = this._responseHandlers.length;
	      var rHandler = void 0;
	      while (--i > -1) {
	        rHandler = this._responseHandlers[i];
	        if (rHandler === handler) {
	          this._responseHandlers.splice(i, 1);
	          return;
	        }
	      }
	    }
	  }, {
	    key: 'handleMessageResponse',
	    value: function handleMessageResponse(message) {
	      var i = void 0,
	          handler = void 0;
	      var length = this._responseHandlers.length;
	      for (i = 0; i < length; i++) {
	        handler = this._responseHandlers[i];
	        if (handler.respond(message)) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: 'post',
	    value: function post(sendRequest) {
	      if (this._websocket !== undefined && this._websocket.readyState === 1 /* WebSocket.OPEN */) {
	          try {
	            (0, _log.debug)(this._name, '[websocket-post]: ' + JSON.stringify(sendRequest, null, 2));
	            this._websocket.send(JSON.stringify(sendRequest));
	          } catch (e) {
	            (0, _log.debug)(this._name, 'Could not send request: ' + sendRequest + '. ' + e);
	          }
	        } else {
	        this._pendingPostRequests.push(sendRequest);
	      }
	    }
	  }, {
	    key: 'respond',
	    value: function respond(message) {
	      // eslint-disable-line no-unused-vars
	      var handled = this.handleMessageResponse(message);
	      if (!handled && message.data) {
	        var json = this.getJsonFromSocketMessage(message);
	        if (json === null) {
	          (0, _log.warn)(this._name, 'Determined websocket response not in correct format. Aborting message handle.');
	          return true;
	        }
	        (0, _log.debug)(this._name, '[websocket-response]: ' + JSON.stringify(json, null, 2));
	        if (json.isAvailable !== undefined) {
	          if (typeof json.isAvailable === 'boolean' && json.isAvailable) {
	            this._responder.onStreamAvailable(json);
	            return true;
	          } else {
	            this._responder.onStreamUnavailable(json);
	            return true;
	          }
	        } else if (json.data !== undefined) {
	          if (json.data.message !== undefined) {
	            if (json.data.type === 'error') {
	              this._responder.onSocketMessageError(json.data.message, json.data.detail);
	              return true;
	            }
	          } else if (json.data.type === 'status') {
	            if (json.data.code === 'NetConnection.Connect.Success') {
	              this._connectionPromise.resolve();
	              return true;
	            } else if (json.data.code === 'NetConnection.Connect.Rejected') {
	              this._connectionPromise.reject('NetConnection.Connect.Rejected');
	              return true;
	            }
	          } else if (json.data.type === 'error') {
	            if (json.data.code === 'NetConnection.Connect.Rejected') {
	              this._connectionPromise.reject('NetConnection.Connect.Rejected');
	              return true;
	            }
	          }
	        }
	      }
	      return handled;
	    }
	  }, {
	    key: 'getRemoteSharedObject',
	    value: function getRemoteSharedObject(name) {
	      this.post({
	        sharedObjectGetRemote: {
	          name: name
	        }
	      });
	    }
	  }, {
	    key: 'connectToSharedObject',
	    value: function connectToSharedObject(name) {
	      this.post({
	        sharedObjectConnect: {
	          name: name
	        }
	      });
	    }
	  }, {
	    key: 'sendToSharedObject',
	    value: function sendToSharedObject(name, callName, data) {
	      this.post({
	        sharedObjectSend: {
	          name: name,
	          call: callName,
	          params: [data]
	        }
	      });
	    }
	  }, {
	    key: 'sendPropertyToSharedObject',
	    value: function sendPropertyToSharedObject(name, key, value) {
	      this.post({
	        sharedObjectSetProperty: {
	          name: name,
	          key: key,
	          value: value
	        }
	      });
	    }
	  }, {
	    key: 'closeSharedObject',
	    value: function closeSharedObject(name) {
	      this.post({
	        sharedObjectClose: {
	          name: name
	        }
	      });
	    }
	  }]);
	
	  return SocketHelper;
	}();
	
	exports.default = SocketHelper;

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.create = exports.isSupported = undefined;
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var isSupported = exports.isSupported = function isSupported() {
	  return _browser2.default.supportsWebSocket();
	};
	
	var create = exports.create = function create(url) {
	  return _browser2.default.createWebSocket(url);
	};

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _webrtc = __webpack_require__(318);
	
	var webrtc = _interopRequireWildcard(_webrtc);
	
	var _promise = __webpack_require__(310);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProSubscriptionPeer';
	
	var SubscriptionPeerHelper = function () {
	  function SubscriptionPeerHelper(responder) {
	    _classCallCheck(this, SubscriptionPeerHelper);
	
	    this._responder = responder;
	    this._peerConnection = undefined;
	    this._pendingMediaStream = undefined;
	  }
	
	  _createClass(SubscriptionPeerHelper, [{
	    key: '_removeConnectionHandlers',
	    value: function _removeConnectionHandlers(connection) {
	      connection.onconnectionstatechange = undefined;
	      connection.onicecandidate = undefined;
	      connection.onaddstream = undefined;
	      connection.ontrack = undefined;
	    }
	  }, {
	    key: '_addConnectionHandlers',
	    value: function _addConnectionHandlers(connection, promise) {
	      var _this = this;
	
	      connection.onconnectionstatechange = function () {
	        if (connection.connectionState === 'connected') {
	          (0, _log.debug)(NAME, '[peerconnection:open]');
	          if (promise) {
	            promise.resolve(_this);
	          }
	        } else if (connection.connectionState === 'failed' || connection.connectionState === 'disconnected') {
	          (0, _log.warn)(NAME, '[peerconnection:error]');
	          if (promise) {
	            promise.reject();
	          }
	        }
	      };
	
	      connection.onicecandidate = function (event) {
	        (0, _log.debug)(NAME, '[peer.onicecandidate] - Peer Candidate: ' + event.candidate);
	        if (event.candidate) {
	          _this._responder.onIceCandidate(event.candidate);
	        } else if (event.candidate === null) {
	          // null means they have finished sending candidates back and forth?
	          _this._responder.onIceCandidateTrickleEnd(_this._pendingMediaStream);
	          _this._pendingMediaStream = undefined;
	        }
	      };
	
	      connection.onaddstream = function (event) {
	        (0, _log.debug)(NAME, 'Peer Add Stream: ' + event.stream);
	        if (event.stream) {
	          _this._pendingMediaStream = event.stream;
	          _this._responder.onAnswerMediaStream(event.stream);
	        }
	      };
	
	      connection.ontrack = function (event) {
	        (0, _log.debug)(NAME, 'Peer Add Stream: ' + event.streams);
	        if (event.streams && event.streams.length > 0) {
	          _this._pendingMediaStream = event.streams[0];
	        }
	      };
	    }
	  }, {
	    key: 'setUp',
	    value: function setUp(iceServers, setUpPromise) {
	      this.tearDown();
	      (0, _log.debug)(NAME, '[setup]');
	      var p = setUpPromise || new _promise.DeferredPromise();
	      try {
	        var peer = new webrtc.RTCPeerConnection({
	          iceServers: iceServers,
	          rtcpMuxPolicy: 'negotiate'
	        }, {
	          optional: [{ DtlsSrtpKeyAgreement: true }, { RtpDataChannels: false }, { googCpuOveruseDetection: true }]
	        });
	        this._peerConnection = peer;
	        this._addConnectionHandlers(peer);
	        p.resolve();
	      } catch (e) {
	        (0, _log.warn)(NAME, 'Could not create a RTCPeerConnection. Error: ' + e.message);
	        p.reject(e.message);
	      }
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'tearDown',
	    value: function tearDown() {
	      (0, _log.debug)(NAME, '[teardown]');
	      if (this._peerConnection) {
	        this._removeConnectionHandlers(this._peerConnection);
	        try {
	          this._peerConnection.close();
	        } catch (e) {
	          (0, _log.warn)(NAME, '[peerconnection.close] error: ' + e.message);
	        }
	      }
	      this._pendingMediaStream = undefined;
	      this._peerConnection = undefined;
	    }
	  }, {
	    key: 'createAnswer',
	    value: function createAnswer(sdp) {
	      var _this2 = this;
	
	      (0, _log.debug)(NAME, '[createanswer]');
	      var deferred = new _promise.DeferredPromise();
	
	      this._peerConnection.setRemoteDescription(sdp).then(this._responder.onSDPSuccess).catch(function (err) {
	        _this2._responder.onSDPError(err);
	      });
	
	      this._peerConnection.createAnswer().then(function (sessionDescription) {
	        _this2._peerConnection.setLocalDescription(sessionDescription).then(_this2._responder.onSDPSuccess).catch(function (err) {
	          _this2._responder.onSDPError(err);
	        });
	        deferred.resolve(sessionDescription);
	      }).catch(deferred.reject);
	
	      return deferred.promise;
	    }
	  }, {
	    key: 'addIceCandidate',
	    value: function addIceCandidate(candidate) {
	      (0, _log.debug)(NAME, '[addicecandidate]');
	      var iceCandidate = new webrtc.RTCIceCandidate({
	        sdpMLineIndex: candidate.sdpMLineIndex,
	        candidate: candidate.candidate
	      });
	      this._peerConnection.addIceCandidate(iceCandidate).then(function () {
	        // nada
	      }).catch(function (err) {
	        (0, _log.error)(NAME, 'Error in add of ICE Candidiate + ' + err);
	      });
	    }
	  }, {
	    key: 'connection',
	    get: function get() {
	      return this._peerConnection;
	    }
	  }]);
	
	  return SubscriptionPeerHelper;
	}();
	
	exports.default = SubscriptionPeerHelper;

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RTCSessionDescription = exports.RTCIceCandidate = exports.RTCPeerConnection = exports.updateBandwidth = exports.isSupported = undefined;
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/** -- handled by adapter.js -- */
	var _RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
	var _RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate || window.webkitRTCIceCandidate;
	var _RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription;
	
	var isSupported = exports.isSupported = function isSupported() {
	  return _RTCPeerConnection && _RTCIceCandidate && _RTCSessionDescription;
	};
	
	// https://github.com/muaz-khan/WebRTC-Experiment/blob/master/RTCPeerConnection/RTCPeerConnection-v1.6.js#L158
	// Muaz Khan     - github.com/muaz-khan
	// MIT License   - www.WebRTC-Experiment.com/licence
	// Documentation - github.com/muaz-khan/WebRTC-Experiment/tree/master/RTCPeerConnection
	var updateBandwidth = exports.updateBandwidth = function updateBandwidth(options, sdp) {
	  if (_browser2.default.getIsMoz()) {
	    return sdp;
	  }
	  sdp = sdp.replace(/b=AS([^\r\n]+\r\n)/g, '');
	  if (options.audio) {
	    sdp = sdp.replace(/a=mid:audio\r\n/g, 'a=mid:audio\r\nb=AS:' + options.audio + '\r\n');
	  }
	  if (options.video) {
	    sdp = sdp.replace(/a=mid:video\r\n/g, 'a=mid:video\r\nb=AS:' + options.video + '\r\n');
	  }
	  return sdp;
	};
	
	var RTCPeerConnection = exports.RTCPeerConnection = _RTCPeerConnection;
	var RTCIceCandidate = exports.RTCIceCandidate = _RTCIceCandidate;
	var RTCSessionDescription = exports.RTCSessionDescription = _RTCSessionDescription;

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(313);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _videojsSourceHandler = __webpack_require__(320);
	
	var _videojsSourceHandler2 = _interopRequireDefault(_videojsSourceHandler);
	
	var _promise = __webpack_require__(310);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProHLSSubscriber';
	var videojs = _browser2.default.getVideoJs();
	var defaultOptions = {
	  protocol: 'https',
	  port: 80,
	  mimeType: 'application/x-mpegURL',
	  swf: 'lib/red5pro/red5pro-video-js.swf'
	};
	var optionsToHlsURL = function optionsToHlsURL(options) {
	  var protocol = options.hlsprotocol ? options.hlsprotocol : options.protocol;
	  var port = options.hlsport ? options.hlsport : options.port;
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  return protocol + '://' + options.host + ':' + port + '/' + appEndpoint + '/' + options.streamName + '.m3u8';
	};
	
	var HLSSubscriber = function (_EventEmitter) {
	  _inherits(HLSSubscriber, _EventEmitter);
	
	  function HLSSubscriber() {
	    _classCallCheck(this, HLSSubscriber);
	
	    var _this = _possibleConstructorReturn(this, (HLSSubscriber.__proto__ || Object.getPrototypeOf(HLSSubscriber)).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._videojsHandler = undefined;
	    _this._boundBubbleSubscriberEvents = _this.bubbleSubscriberEvents.bind(_this);
	    return _this;
	  }
	
	  _createClass(HLSSubscriber, [{
	    key: 'bubbleSubscriberEvents',
	    value: function bubbleSubscriberEvents(event) {
	      this.trigger(new _event.SubscriberEvent(event.type, this, event.data));
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var deferred = new _promise.DeferredPromise();
	      if (!_browser2.default.getVideoJs()) {
	        deferred.reject('Could not resolve HLSSubscriber. Requires videojs library.');
	      } else {
	        this._options = Object.assign({}, defaultOptions, options);
	        deferred.resolve(this);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	      if (this._videojsHandler !== undefined) {
	        this._videojsHandler.off('*', this._boundBubbleSubscriberEvents);
	        this._videojsHandler.disconnect();
	        this._videojsHandler = undefined;
	      }
	      this._videojsHandler = new _videojsSourceHandler2.default(this._view.view, this.getType());
	      return this;
	    }
	  }, {
	    key: 'play',
	    value: function play() {
	      var _this2 = this;
	
	      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	      var p = promise || new _promise.DeferredPromise();
	      var urlRegex = /^http(|s).*\.m3u8/g;
	      this._options.streamName = streamName || this._options.streamName;
	      var url = this._options.streamName.match(urlRegex) ? this._options.streamName : optionsToHlsURL(this._options);
	      var type = this._options.mimeType;
	      var swfURL = this._options.swf;
	      if (_typeof(this._options) === 'object') {
	        type = this._options.rtmpMimeType || this._options.mimeType;
	      }
	      (0, _log.debug)(NAME, '[play]: URL(' + url + ').');
	      this._videojsHandler.on('*', this._boundBubbleSubscriberEvents);
	      this._videojsHandler.addSource(url, type, videojs, swfURL).then(function () {
	        p.resolve(_this2);
	        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_SUCCESS));
	      }).catch(function (error) {
	        p.reject(error);
	        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE));
	      });
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      (0, _log.debug)(NAME, '[stop]');
	      var deferred = new _promise.DeferredPromise();
	      try {
	        this._videojsHandler.off('*', this._boundBubbleSubscriberEvents);
	        this._videojsHandler.disconnect();
	        deferred.resolve();
	      } catch (e) {
	        deferred.reject(e.message);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'getConnection',
	    value: function getConnection() {
	      return this._videojsHandler;
	    }
	  }, {
	    key: 'getOptions',
	    value: function getOptions() {
	      return this._options;
	    }
	  }, {
	    key: 'getPlayer',
	    value: function getPlayer() {
	      return this._videojsHandler.getPlayer();
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'HLS';
	    }
	  }]);
	
	  return HLSSubscriber;
	}(_eventEmitter2.default);
	
	exports.default = HLSSubscriber;

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Base handler for utilizing the videojs
	 * library to intergate playback of live video.
	 *
	 * @see red5pro-hls
	 * @see red5pro-rtmp
	 */
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(313);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _object = __webpack_require__(321);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProBaseVideoJSHandler';
	
	var videojs = _browser2.default.getVideoJs();
	var mimeType = 'video/webm';
	var optionsToURL = function optionsToURL(options) {
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  return options.protocol + '://' + options.host + ':' + options.port + '/' + appEndpoint + '/' + options.streamName;
	};
	
	var BaseHandler = function (_EventEmitter) {
	  _inherits(BaseHandler, _EventEmitter);
	
	  function BaseHandler(video) {
	    var playerType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	    _classCallCheck(this, BaseHandler);
	
	    var _this = _possibleConstructorReturn(this, (BaseHandler.__proto__ || Object.getPrototypeOf(BaseHandler)).call(this));
	
	    _this.video = video;
	    _this.clone = _this.video.cloneNode(true);
	    _this.holder = _this.video.parentNode;
	    _this.videojs = null;
	    _this.source = null;
	    _this.playerType = playerType;
	    _this.hasAssignedEventListeners = false;
	
	    //  TODO: Temporary adjustment. Better to pass videojs up the chain so end users can set their own handlers.
	    _this.onVideoJSError = _this.onVideoJSError.bind(_this);
	    _this.onVideoJSLoadedData = _this.onVideoJSLoadedData.bind(_this);
	    _this.onVideoJSLoadedMetadata = _this.onVideoJSLoadedMetadata.bind(_this);
	    _this.onVideoJSTimeUpdate = _this.onVideoJSTimeUpdate.bind(_this);
	    _this.onVideoJSUserActive = _this.onVideoJSUserActive.bind(_this);
	    _this.onVideoJSUserInactive = _this.onVideoJSUserInactive.bind(_this);
	    _this.onVideoJSVolumeChange = _this.onVideoJSVolumeChange.bind(_this);
	    _this.onVideoJSEnded = _this.onVideoJSEnded.bind(_this);
	    return _this;
	  }
	
	  //  Assign all video.js listeners (those which are listed on http://docs.videojs.com/docs/api/player.html#events)
	
	
	  _createClass(BaseHandler, [{
	    key: 'addVideoJSEventListeners',
	    value: function addVideoJSEventListeners() {
	      if (this.hasAssignedEventListeners) {
	        return;
	      }
	      this.videojs.on('error', this.onVideoJSError);
	      this.videojs.on('loadeddata', this.onVideoJSLoadedData);
	      this.videojs.on('loadedmetadata', this.onVideoJSLoadedMetadata);
	      this.videojs.on('timeupdate', this.onVideoJSTimeUpdate);
	      this.videojs.on('useractive', this.onVideoJSUserActive);
	      this.videojs.on('userinactive', this.onVideoJSUserInactive);
	      this.videojs.on('volumechange', this.onVideoJSVolumeChange);
	      this.videojs.on('ended', this.onVideoJSEnded);
	      this.hasAssignedEventListeners = true;
	    }
	
	    //  Remove all video.js listeners (those which are listed on http://docs.videojs.com/docs/api/player.html#events)
	
	  }, {
	    key: 'removeVideoJSEventListeners',
	    value: function removeVideoJSEventListeners() {
	      if (!this.hasAssignedEventListeners) {
	        return;
	      }
	      this.videojs.off('error', this.onVideoJSError);
	      this.videojs.off('loadeddata', this.onVideoJSLoadedData);
	      this.videojs.off('loadedmetadata', this.onVideoJSLoadedMetadata);
	      this.videojs.off('timeupdate', this.onVideoJSTimeUpdate);
	      this.videojs.off('useractive', this.onVideoJSUserActive);
	      this.videojs.off('userinactive', this.onVideoJSUserInactive);
	      this.videojs.off('volumechange', this.onVideoJSVolumeChange);
	      this.videojs.off('ended', this.onVideoJSEnded);
	      this.hasAssignedEventListeners = false;
	    }
	
	    //  Cleanup our <source> if it exists
	
	  }, {
	    key: 'cleanup',
	    value: function cleanup() {
	      if (this.source) {
	        this.source.remove();
	      }
	      this.source = null;
	    }
	
	    //  Cleanup our video.js implementation
	
	  }, {
	    key: 'cleanupVideoJS',
	    value: function cleanupVideoJS() {
	      if (this.videojs) {
	        this.video.remove();
	        this.removeVideoJSEventListeners();
	        this.videojs.dispose();
	        //  This recreates our original <video> element and appends it to the original containing element
	        this.video = this.clone.cloneNode(true);
	        this.holder.appendChild(this.video);
	      }
	      this.videojs = null;
	    }
	
	    //  Add a new <source> for our <video> and startup video.js
	
	  }, {
	    key: 'addSource',
	    value: function addSource(src) {
	      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : mimeType;
	      var videoImpl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : videojs;
	      var swfURL = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	
	      var self = this;
	
	      function createSource(_src, _type) {
	        var sourceEl = document.createElement('source');
	        sourceEl.src = _src;
	        sourceEl.type = _type;
	        return sourceEl;
	      }
	
	      function insertSourceInto(_src, _type, _parent) {
	        var sourceEl = createSource(_src, _type);
	        if (_parent.firstChild) {
	          _parent.insertBefore(sourceEl, _parent.firstChild);
	        } else {
	          _parent.appendChild(sourceEl);
	        }
	        return sourceEl;
	      }
	
	      return new Promise(function (resolve, reject) {
	        try {
	          (function () {
	            //  If we have a current <source> element, remove it
	            self.cleanup();
	            //  If video.js has already been instantiated, dispose of it
	            self.cleanupVideoJS();
	
	            //  Create the new <source> element
	            var srcURL = typeof src === 'string' ? src : optionsToURL(src);
	            var mimeType = typeof src === 'string' ? type : src.mimeType ? src.mimeType : type;
	            (0, _log.debug)(NAME, '"' + self.playerType + '" loading ' + srcURL);
	            self.source = insertSourceInto(srcURL, mimeType, self.video);
	
	            //  Instantiate video.js
	            var opts = {
	              techOrder: ['html5', 'flash']
	            };
	            if (swfURL) {
	              (0, _object.deepDefine)(videoImpl, ['options', 'flash', 'swf'], swfURL);
	            }
	
	            var orientation = 0;
	            self.videojs = videoImpl(self.video, opts, function () {
	              (0, _log.debug)(NAME, 'videoJS embed complete.');
	              var player = self.getPlayer();
	              if (player) {
	                _browser2.default.onOrientationMetadata(player, function (metadata) {
	                  (0, _log.debug)(NAME, 'Metadata received: ' + JSON.stringify(metadata, null, 2));
	                  if (orientation !== metadata.orientation) {
	                    _browser2.default.applyOrientation(self.video, metadata.orientation);
	                    self.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_METADATA, undefined, metadata));
	                  }
	                  orientation = metadata.orientation;
	                });
	              }
	              resolve(self);
	            });
	            self.addVideoJSEventListeners();
	          })();
	        } catch (e) {
	          (0, _log.error)(NAME, 'Could not instantiate new VideoJS-based "' + self.playerType + '" Player.\nReason: ' + e.message);
	          reject('Could not instantiate new VideoJS-based "' + self.playerType + '" Player.\nReason: ' + e.message);
	        }
	      });
	    }
	  }, {
	    key: 'onVideoJSError',
	    value: function onVideoJSError(e) {
	      (0, _log.error)(NAME, 'onVideoJSError: ' + JSON.stringify(e, null, 2));
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL, null, e));
	    }
	  }, {
	    key: 'onVideoJSLoadedData',
	    value: function onVideoJSLoadedData() {
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_START));
	    }
	  }, {
	    key: 'onVideoJSEnded',
	    value: function onVideoJSEnded() {
	      this.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_STOP));
	    }
	  }, {
	    key: 'onVideoJSLoadedMetadata',
	    value: function onVideoJSLoadedMetadata() {}
	  }, {
	    key: 'onVideoJSTimeUpdate',
	    value: function onVideoJSTimeUpdate() {}
	  }, {
	    key: 'onVideoJSUserActive',
	    value: function onVideoJSUserActive() {}
	  }, {
	    key: 'onVideoJSUserInactive',
	    value: function onVideoJSUserInactive() {}
	  }, {
	    key: 'onVideoJSVolumeChange',
	    value: function onVideoJSVolumeChange() {}
	  }, {
	    key: 'addSharedObjectResponseHandler',
	    value: function addSharedObjectResponseHandler(handler) {// eslint-disable-line no-unused-vars
	      // unsupported at the moment.
	    }
	  }, {
	    key: 'removeSharedObjectResponseHandler',
	    value: function removeSharedObjectResponseHandler(handler) {// eslint-disable-line no-unused-vars
	      // unsupported at the moment.
	    }
	  }, {
	    key: 'sendToSharedObject',
	    value: function sendToSharedObject(name, callName, message) {// eslint-disable-line no-unused-vars
	      // unsupported at the moment.
	    }
	  }, {
	    key: 'sendPropertyToSharedObject',
	    value: function sendPropertyToSharedObject(name, key, value) {// eslint-disable-line no-unused-vars
	      // unsupported at the moment.
	    }
	  }, {
	    key: 'getRemoteSharedObject',
	    value: function getRemoteSharedObject(sharedObjectName) {// eslint-disable-line no-unused-vars
	      // unsupported at the moment.
	    }
	  }, {
	    key: 'connectToSharedObject',
	    value: function connectToSharedObject(sharedObjectName) {// eslint-disable-line no-unused-vars
	      // unsupported at the moment.
	    }
	  }, {
	    key: 'disconnectFromSharedObject',
	    value: function disconnectFromSharedObject(sharedObjectName) {// eslint-disable-line no-unused-vars
	      // unsupported at the moment.
	    }
	  }, {
	    key: 'getPlayer',
	    value: function getPlayer() {
	      return this.videojs;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return this.playerType;
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      try {
	        this.video.pause();
	      } catch (e) {
	        // nada.
	      }
	      this.cleanup();
	      this.cleanupVideoJS();
	    }
	  }]);
	
	  return BaseHandler;
	}(_eventEmitter2.default);
	
	exports.default = BaseHandler;

/***/ },
/* 321 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * Modifies target `object` in place with a namespaced value.
	 */
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var deepDefine = exports.deepDefine = function deepDefine(object, paths, value) {
	  var i = 0;
	  var tail = object;
	  var prop = paths.pop();
	  var length = paths.length;
	  for (i; i < length; i++) {
	    var path = paths[i];
	    tail[path] = tail[path] || {};
	    tail = tail[path];
	  }
	  tail[prop] = value;
	};

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _red5proRtmpVideojs = __webpack_require__(323);
	
	var _red5proRtmpVideojs2 = _interopRequireDefault(_red5proRtmpVideojs);
	
	var _red5proRtmpLive = __webpack_require__(324);
	
	var _red5proRtmpLive2 = _interopRequireDefault(_red5proRtmpLive);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProRTMPSubscriberProxy';
	
	var RTMPSubscriberProxy = function (_EventEmitter) {
	  _inherits(RTMPSubscriberProxy, _EventEmitter);
	
	  function RTMPSubscriberProxy() {
	    _classCallCheck(this, RTMPSubscriberProxy);
	
	    var _this = _possibleConstructorReturn(this, (RTMPSubscriberProxy.__proto__ || Object.getPrototypeOf(RTMPSubscriberProxy)).call(this));
	
	    _this._view = undefined;
	    _this._boundBubbleSubImplEvent = _this.bubbleSubscriberEvent.bind(_this);
	    return _this;
	  }
	
	  _createClass(RTMPSubscriberProxy, [{
	    key: 'init',
	    value: function init(options) {
	      var impl = void 0;
	      (0, _log.debug)(NAME, 'Options property for useVideoJS: ' + options.useVideoJS + '.');
	      if (options.hasOwnProperty('useVideoJS') && typeof options.useVideoJS === 'boolean' && options.useVideoJS) {
	        (0, _log.debug)(NAME, 'Default to RTMPSubscriber using videojs support.');
	        impl = new _red5proRtmpVideojs2.default();
	        impl.on('*', this._boundBubbleSubImplEvent);
	      } else {
	        (0, _log.debug)(NAME, 'Defaulting to RTMPSubscriber using custom live SWF.');
	        impl = new _red5proRtmpLive2.default();
	        impl.on('*', this._boundBubbleSubImplEvent);
	      }
	      if (this._view) {
	        impl.setView(this._view);
	        this._view = undefined;
	      }
	      return impl.init(options);
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	    }
	  }, {
	    key: 'bubbleSubscriberEvent',
	    value: function bubbleSubscriberEvent(subscriberEvent) {
	      this.trigger.call(this, subscriberEvent);
	    }
	  }, {
	    key: 'getOptions',
	    value: function getOptions() {
	      return this._options;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'RTMPSubscriberProxy';
	    }
	  }]);
	
	  return RTMPSubscriberProxy;
	}(_eventEmitter2.default);
	
	exports.default = RTMPSubscriberProxy;

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _videojsSourceHandler = __webpack_require__(320);
	
	var _videojsSourceHandler2 = _interopRequireDefault(_videojsSourceHandler);
	
	var _promise = __webpack_require__(310);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProRTMPSubscriber';
	var videojs = _browser2.default.getVideoJs();
	var defaultMimeType = 'rtmp/flv';
	var defaultFlashVersion = '10.0.0';
	var defaultSWF = 'lib/red5pro/red5pro-video-js.swf';
	var optionsToRtmpURL = function optionsToRtmpURL(options) {
	  var protocol = options.rtmpprotocol ? options.rtmpprotocol : options.protocol;
	  var port = options.rtmpport ? options.rtmpport : options.port;
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  return protocol + '://' + options.host + ':' + port + '/' + appEndpoint + '/' + options.streamName;
	};
	
	var VideoJSSubscriber = function (_EventEmitter) {
	  _inherits(VideoJSSubscriber, _EventEmitter);
	
	  function VideoJSSubscriber() {
	    _classCallCheck(this, VideoJSSubscriber);
	
	    var _this = _possibleConstructorReturn(this, (VideoJSSubscriber.__proto__ || Object.getPrototypeOf(VideoJSSubscriber)).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._videojsHandler = undefined;
	    _this._boundBubbleSubscriberEvents = _this.bubbleSubscriberEvents.bind(_this);
	    return _this;
	  }
	
	  _createClass(VideoJSSubscriber, [{
	    key: 'bubbleSubscriberEvents',
	    value: function bubbleSubscriberEvents(event) {
	      this.trigger.call(this, event);
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var deferred = new _promise.DeferredPromise();
	      if (!_browser2.default.supportsFlashVersion(defaultFlashVersion)) {
	        deferred.reject('Could not resolve RTMPSubscriber instance. Requires minimum Flash Player install of ' + defaultFlashVersion + '.');
	      } else if (!_browser2.default.getVideoJs()) {
	        deferred.reject('Could not resolve RTMPSubscriber instance. Requires videojs library.');
	      } else {
	        this._options = options;
	        deferred.resolve(this);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	      if (this._videojsHandler !== undefined) {
	        this._videojsHandler.off('*', this._boundBubbleSubscriberEvents);
	        this._videojsHandler.disconnect();
	        this._videojsHandler = undefined;
	      }
	      if (view) {
	        this._videojsHandler = new _videojsSourceHandler2.default(this._view.view, this.getType());
	      }
	      return this;
	    }
	  }, {
	    key: 'play',
	    value: function play() {
	      var _this2 = this;
	
	      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	      var p = promise || new _promise.DeferredPromise();
	      this._options.streamName = streamName || this._options.streamName;
	      var url = optionsToRtmpURL(this._options);
	      var type = defaultMimeType;
	      var swfURL = defaultSWF;
	      if (_typeof(this._options) === 'object') {
	        type = this._options.rtmpMimeType || this._options.mimeType || type;
	        swfURL = this._options.swf || swfURL;
	      }
	      (0, _log.debug)(NAME, '[play]: URL(' + url + ').');
	      this._videojsHandler.on('*', this._boundBubbleSubscriberEvents);
	      this._videojsHandler.addSource(url, type, videojs, swfURL).then(function () {
	        p.resolve(_this2);
	      }).catch(p.reject);
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      (0, _log.debug)(NAME, '[stop]');
	      var deferred = new _promise.DeferredPromise();
	      try {
	        this._videojsHandler.off('*', this._boundBubbleSubscriberEvents);
	        this._videojsHandler.disconnect();
	        deferred.resolve();
	      } catch (e) {
	        deferred.reject(e.message);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'getConnection',
	    value: function getConnection() {
	      return this._videojsHandler;
	    }
	  }, {
	    key: 'getOptions',
	    value: function getOptions() {
	      return this._options;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'RTMP - VideoJS';
	    }
	  }]);
	
	  return VideoJSSubscriber;
	}(_eventEmitter2.default);
	
	exports.default = VideoJSSubscriber;

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(313);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _promise = __webpack_require__(310);
	
	var _liveSourceHandler = __webpack_require__(325);
	
	var _liveSourceHandler2 = _interopRequireDefault(_liveSourceHandler);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProLiveRTMPSubcriber';
	var defaultOptions = {
	  protocol: 'rtmp',
	  port: 1935,
	  width: 320, // video playback
	  height: 240, // video playback
	  embedWidth: '100%', // DOM display style
	  embedHeight: '100%', // DOM display style
	  minFlashVersion: '10.0.0',
	  swf: 'lib/red5pro/red5pro-subscriber.swf',
	  swfobjectURL: 'lib/red5pro/red5pro-subscriber.swf',
	  productInstallUrl: 'lib/swfobject/playerProductInstall.swf'
	};
	
	var R5LiveSubscriber = function (_EventEmitter) {
	  _inherits(R5LiveSubscriber, _EventEmitter);
	
	  function R5LiveSubscriber() {
	    _classCallCheck(this, R5LiveSubscriber);
	
	    var _this = _possibleConstructorReturn(this, (R5LiveSubscriber.__proto__ || Object.getPrototypeOf(R5LiveSubscriber)).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._sourceHandler = undefined;
	    _this._elementId = undefined;
	    _this._playbackPromise = undefined;
	    return _this;
	  }
	
	  _createClass(R5LiveSubscriber, [{
	    key: 'init',
	    value: function init(options) {
	      var self = this;
	      var deferred = new _promise.DeferredPromise();
	      var version = options.minFlashVersion || defaultOptions.minFlashVersion;
	      if (!_browser2.default.supportsFlashVersion(version)) {
	        deferred.reject('Could not resolve LiveRTMPSubscriber instance. Requires minimum Flash Player install of ' + version + '.');
	      } else {
	        this._options = Object.assign({}, defaultOptions, options);
	        try {
	          _browser2.default.injectScript(this._options.swfobjectURL).then(function () {
	            (0, _log.debug)(NAME, 'SWFObject embedded.');
	            if (self._sourceHandler) {
	              return self._sourceHandler.addSource(self._elementId, self._options);
	            }
	            return true;
	          }).then(function () {
	            deferred.resolve(self);
	            self.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_SUCCESS, self));
	          }).catch(function (err) {
	            (0, _log.error)(NAME, 'Could not embed Flash-based RTMP Player. Reason: ' + err);
	            if (self._sourceHandler) {
	              self._sourceHandler.disconnect();
	            }
	            deferred.reject(err);
	            self.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_FAILURE, self));
	          });
	        } catch (e) {
	          deferred.reject('Could not inject Flash-based Player into the page. Reason: ' + e.message);
	          self.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_FAILURE, self));
	        }
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view, elementId) {
	      var self = this;
	      this._view = view;
	      this._elementId = elementId;
	      if (this._sourceHandler !== undefined) {
	        this._sourceHandler.disconnect();
	        this._sourceHandler = undefined;
	      }
	
	      if (view) {
	        this._sourceHandler = new _liveSourceHandler2.default(this._view.view, this.getType());
	        if (this._options) {
	          this._sourceHandler.addSource(this._elementId, this._options).catch(function () {
	            self.trigger(new _event.SubscriberEvent(_event.RTMPSubscriberEventTypes.EMBED_FAILURE, self));
	          });
	        }
	      }
	      return this;
	    }
	  }, {
	    key: '_establishExtIntHandlers',
	    value: function _establishExtIntHandlers() {
	      var _this2 = this;
	
	      var id = this._options.streamName;
	      var invokeFn = function invokeFn(label) {
	        return ['subscriber', label, id].join('_');
	      };
	      window[invokeFn('r5proConnectClosed')] = function () {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECTION_CLOSED, _this2));
	      };
	      window[invokeFn('r5proConnectSuccess')] = function () {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_SUCCESS, _this2));
	      };
	      window[invokeFn('r5proSubscribeStop')] = function () {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_STOP, _this2));
	      };
	      window[invokeFn('r5proSubscribeMetadata')] = function (metadata) {
	        return _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_METADATA, _this2, metadata));
	      };
	      window[invokeFn('r5proSubscribeSendInvoke')] = function (payload) {
	        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_SEND_INVOKE, _this2, typeof payload === 'string' ? JSON.parse(payload) : payload));
	      };
	      window[invokeFn('r5proSubscribeStart')] = function () {
	        _this2._playbackPromise.resolve(_this2);
	        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_START, _this2));
	      };
	      window[invokeFn('r5proConnectFailure')] = function () {
	        _this2._playbackPromise.reject(_event.SubscriberEventTypes.CONNECT_FAILURE);
	        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.CONNECT_FAILURE, _this2));
	      };
	      window[invokeFn('r5proSubscribeInvalidName')] = function () {
	        _this2._playbackPromise.reject(_event.SubscriberEventTypes.SUBSCRIBE_INVALID_NAME);
	        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_INVALID_NAME, _this2));
	      };
	      window[invokeFn('r5proSubscribeFail')] = function () {
	        _this2._playbackPromise.reject("Failed to start playback stream.");
	        _this2.trigger(new _event.SubscriberEvent(_event.SubscriberEventTypes.SUBSCRIBE_FAIL, _this2));
	      };
	    }
	  }, {
	    key: 'play',
	    value: function play() {
	      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      // eslint-disable-line no-unused-vars
	      this._playbackPromise = new _promise.DeferredPromise();
	      this._establishExtIntHandlers();
	      return this._playbackPromise.promise;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      var _this3 = this;
	
	      var cb = function cb(resolve, reject) {
	        try {
	          _this3._sourceHandler.disconnect();
	          resolve();
	        } catch (e) {
	          reject(e.message);
	        }
	      };
	      this._playbackPromise = undefined;
	      return new Promise(cb);
	    }
	  }, {
	    key: 'getConnection',
	    value: function getConnection() {
	      return this._sourceHandler;
	    }
	  }, {
	    key: 'getOptions',
	    value: function getOptions() {
	      return this._options;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return 'RTMP';
	    }
	  }]);
	
	  return R5LiveSubscriber;
	}(_eventEmitter2.default);
	
	exports.default = R5LiveSubscriber;

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	'use script';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _embed = __webpack_require__(326);
	
	var embed = _interopRequireWildcard(_embed);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _promise = __webpack_require__(310);
	
	var _log = __webpack_require__(299);
	
	var _sharedobjectHelperRtmp = __webpack_require__(327);
	
	var _sharedobjectHelperRtmp2 = _interopRequireDefault(_sharedobjectHelperRtmp);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'RTMPLiveSourceHandler';
	var toInt = function toInt(value) {
	  if (typeof value === 'string') {
	    return value.parseInt(10);
	  } else {
	    return Math.round(value);
	  }
	};
	
	var LiveSourceHandler = function () {
	  function LiveSourceHandler(video, type) {
	    var soResponder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
	
	    _classCallCheck(this, LiveSourceHandler);
	
	    this.video = video;
	    this.clone = this.video.cloneNode(true);
	    this.holder = this.video.parentNode;
	    this.playerType = type;
	    this._swfId = null;
	    this._soResponder = soResponder || new _sharedobjectHelperRtmp2.default();
	  }
	
	  _createClass(LiveSourceHandler, [{
	    key: 'cleanUp',
	    value: function cleanUp() {
	      // Return to prior DOM manipulation.
	      this.video.remove();
	      this.video = this.clone.cloneNode(true);
	      this.holder.appendChild(this.video);
	    }
	  }, {
	    key: '_setUpInitCallback',
	    value: function _setUpInitCallback(promise) {
	      var _this = this;
	
	      window.setSubscriberId = function (successId) {
	        // successId === _options.streamName
	        (0, _log.debug)(NAME, 'Embed and init() complete for subscriber swf. successId(' + successId + ').');
	        promise.resolve(successId);
	        _this._tearDownInitCallback();
	      };
	      // TODO: Setup timeout to reject?
	    }
	  }, {
	    key: '_tearDownInitCallback',
	    value: function _tearDownInitCallback() {
	      window.setActiveId = undefined;
	    }
	  }, {
	    key: 'addSource',
	    value: function addSource(swfId, options) {
	      var swfUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	      var minFlashVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	
	      (0, _log.debug)(NAME, '[addsource]');
	      this._swfId = swfId;
	      var soResponder = this._soResponder;
	      var deferred = new _promise.DeferredPromise();
	      options.swf = swfUrl || options.swf;
	      options.minFlashVersion = minFlashVersion || options.minFlashVersion;
	      this._setUpInitCallback(deferred);
	      embed.defineEmbedElement(this.video, this.holder).then(function (elementId) {
	        var flashvars = {
	          stream: options.streamName,
	          app: options.context ? options.app + '/' + options.context : options.app,
	          host: options.host
	        };
	        if (options.buffer && !isNaN(Number(options.buffer))) {
	          flashvars.buffer = options.buffer;
	        }
	        if (options.width && !isNaN(options.width)) {
	          flashvars.width = toInt(options.width);
	        }
	        if (options.height && !isNaN(options.height)) {
	          flashvars.height = toInt(options.height);
	        }
	        if (options.embedWidth === '100%' || options.embedHeight === '100%') {
	          flashvars.autosize = true;
	        }
	        if (typeof options.connectionParams !== 'undefined') {
	          flashvars.connectionParams = encodeURIComponent(JSON.stringify(options.connectionParams));
	        }
	        return embed.embedSwfObject(swfId, options, flashvars, _browser2.default.getSwfObject(), elementId);
	      }).then(function () {
	        soResponder.connect(swfId);
	        return true;
	      }).catch(function (e) {
	        return deferred.reject(e);
	      });
	      return deferred.promise;
	    }
	  }, {
	    key: 'connect',
	    value: function connect() {
	      (0, _log.debug)(NAME, '[connect]');
	      try {
	        _browser2.default.getEmbedObject(this._swfId).connect();
	      } catch (e) {
	        // nada.
	      }
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      (0, _log.debug)(NAME, '[disconnect]');
	      try {
	        _browser2.default.getEmbedObject().disconnect();
	      } catch (e) {
	        // nada.
	      }
	      this.cleanUp();
	      this._soResponder.disconnect();
	    }
	  }, {
	    key: 'addSharedObjectResponseHandler',
	    value: function addSharedObjectResponseHandler(handler) {
	      this._soResponder.addResponseHandler(handler);
	    }
	  }, {
	    key: 'removeSharedObjectResponseHandler',
	    value: function removeSharedObjectResponseHandler(handler) {
	      this._soResponder.removeResponseHandler(handler);
	    }
	  }, {
	    key: 'sendToSharedObject',
	    value: function sendToSharedObject(name, callName, message) {
	      this._soResponder.sendToSharedObject(name, callName, message);
	    }
	  }, {
	    key: 'sendPropertyToSharedObject',
	    value: function sendPropertyToSharedObject(name, key, value) {
	      this._soResponder.sendPropertyToSharedObject(name, key, value);
	    }
	  }, {
	    key: 'getRemoteSharedObject',
	    value: function getRemoteSharedObject(sharedObjectName) {
	      this._soResponder.getRemoteSharedObject(sharedObjectName);
	    }
	  }, {
	    key: 'connectToSharedObject',
	    value: function connectToSharedObject(sharedObjectName) {
	      this._soResponder.connectToSharedObject(sharedObjectName);
	    }
	  }, {
	    key: 'closeSharedObject',
	    value: function closeSharedObject(sharedObjectName) {
	      this._soResponder.closeSharedObject(sharedObjectName);
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return this.playerType;
	    }
	  }]);
	
	  return LiveSourceHandler;
	}();
	
	exports.default = LiveSourceHandler;

/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.embedSwfObject = exports.defineEmbedElement = undefined;
	
	var _promise = __webpack_require__(310);
	
	var defineEmbedElement = exports.defineEmbedElement = function defineEmbedElement(targetElement, targetParent) {
	  var dfd = new _promise.DeferredPromise();
	  var elementId = targetElement.id;
	  if (targetElement.nodeName.toLowerCase() === 'video') {
	    var div = document.createElement('div');
	    div.id = elementId + '_rtmp';
	    targetParent.appendChild(div);
	    targetElement.remove();
	    dfd.resolve(div.id);
	  } else {
	    dfd.resolve(elementId);
	  }
	  return dfd.promise;
	};
	
	var embedSwfObject = exports.embedSwfObject = function embedSwfObject(idName, options, flashvars, swfobject, elementId) {
	  var dfd = new _promise.DeferredPromise();
	  var params = {
	    quality: 'high',
	    bgcolor: '#000',
	    allowscriptaccess: 'always',
	    allowfullscreen: 'true'
	  };
	  var attributes = {
	    id: idName,
	    name: idName,
	    align: 'middle'
	  };
	  if (swfobject.hasFlashPlayerVersion(options.minFlashVersion)) {
	    swfobject.embedSWF(options.swf, elementId, options.embedWidth || options.width, options.embedHeight || options.height, options.minFlashVersion, options.productInstallURL, flashvars, params, attributes, dfd.resolve);
	  } else {
	    dfd.reject('Flash Player Version is not supported.');
	  }
	  return dfd.promise;
	};

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProRTMPSharedObjectHandler';
	
	var RTMPSharedObjectHandler = function () {
	  function RTMPSharedObjectHandler() {
	    _classCallCheck(this, RTMPSharedObjectHandler);
	
	    this._element = undefined;
	    this._responseHandlers = [];
	  }
	
	  _createClass(RTMPSharedObjectHandler, [{
	    key: 'addResponseHandler',
	    value: function addResponseHandler(handler) {
	      this._responseHandlers.push(handler);
	    }
	  }, {
	    key: 'removeResponseHandler',
	    value: function removeResponseHandler(handler) {
	      var i = this._responseHandlers.length;
	      var rHandler = void 0;
	      while (--i > -1) {
	        rHandler = this._responseHandlers[i];
	        if (rHandler === handler) {
	          this._responseHandlers.splice(i, 1);
	          return;
	        }
	      }
	    }
	  }, {
	    key: 'handleSharedObjectEvent',
	    value: function handleSharedObjectEvent(event) {
	      (0, _log.debug)(NAME, '[sharedobject:event]');
	      var i = void 0;
	      var length = this._responseHandlers.length;
	      var handler = void 0;
	      for (i = 0; i < length; i++) {
	        handler = this._responseHandlers[i];
	        if (handler.respond(JSON.parse(event))) {
	          break;
	        }
	      }
	    }
	  }, {
	    key: 'assignSharedObjectResponder',
	    value: function assignSharedObjectResponder(name, el) {
	      var _handleSharedObjectEvent = this.handleSharedObjectEvent.bind(this);
	      var elId = el.id.split('-').join('_');
	      var handlerName = ['handleSharedObjectEvent', elId].join('_');
	      (0, _log.debug)(NAME, '[assign:sharedobject:responder] :: ' + elId);
	      (0, _log.debug)(NAME, '[sharedoject:responder] :: ' + handlerName);
	      el.setSharedObjectResponder(name, handlerName);
	      _browser2.default.setGlobal(handlerName, _handleSharedObjectEvent);
	    }
	  }, {
	    key: 'connect',
	    value: function connect(swfId) {
	      this._element = _browser2.default.getEmbedObject(swfId);
	      if (!this._element) {
	        (0, _log.warn)('Could not locate embedded Flash object for id: ' + swfId);
	      }
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      while (this._responseHandlers.length > 0) {
	        this._responseHandlers.shift();
	      }
	    }
	  }, {
	    key: 'sendToSharedObject',
	    value: function sendToSharedObject(name, callName, message) {
	      (0, _log.debug)(NAME, '[sendToSharedObject]');
	      try {
	        this._element.sharedObjectSend(name, callName, typeof message === 'string' ? message : JSON.stringify(message));
	      } catch (e) {
	        (0, _log.warn)('Could not send to shared object (' + name + '). Error: ' + e.message);
	      }
	    }
	  }, {
	    key: 'sendPropertyToSharedObject',
	    value: function sendPropertyToSharedObject(name, key, value) {
	      (0, _log.debug)(NAME, '[sendPropertyToSharedObject]');
	      try {
	        this._element.sharedObjectSendProperty(name, key, value);
	      } catch (e) {
	        (0, _log.warn)('Could not send to shared object (' + name + '). Error: ' + e.message);
	      }
	    }
	  }, {
	    key: 'getRemoteSharedObject',
	    value: function getRemoteSharedObject(sharedObjectName) {
	      (0, _log.debug)(NAME, '[getRemoteSharedObject]');
	      try {
	        this.assignSharedObjectResponder(sharedObjectName, this._element);
	        this._element.getRemoteSharedObject(sharedObjectName);
	      } catch (e) {
	        (0, _log.warn)('Could not get remote shared object (' + name + '). Error: ' + e.message);
	      }
	    }
	  }, {
	    key: 'connectToSharedObject',
	    value: function connectToSharedObject(sharedObjectName) {
	      (0, _log.debug)(NAME, '[connectToSharedObject]');
	      try {
	        this._element.connectToSharedObject(sharedObjectName);
	      } catch (e) {
	        (0, _log.warn)('Could not connect to shared object (' + name + '). Error: ' + e.message);
	      }
	    }
	  }, {
	    key: 'closeSharedObject',
	    value: function closeSharedObject(sharedObjectName) {
	      (0, _log.debug)(NAME, '[disconnectToSharedObject]');
	      try {
	        this._element.disconnectFromSharedObject(sharedObjectName);
	      } catch (e) {
	        (0, _log.warn)('Could not disconnect to shared object (' + name + '). Error: ' + e.message);
	      }
	    }
	  }]);
	
	  return RTMPSharedObjectHandler;
	}();
	
	exports.default = RTMPSharedObjectHandler;

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.ImplFactoryOrder = undefined;
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _promise = __webpack_require__(310);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var map = new WeakMap();
	
	var pvt = function pvt(ctx) {
	  if (!map.has(ctx)) {
	    map.set(ctx, {});
	  }
	
	  return map.get(ctx);
	};
	
	var ImplFactoryOrder = exports.ImplFactoryOrder = function () {
	  function ImplFactoryOrder() {
	    var _this = this;
	
	    _classCallCheck(this, ImplFactoryOrder);
	
	    this.listorder = function () {
	      return regeneratorRuntime.mark(function listorder(list) {
	        return regeneratorRuntime.wrap(function listorder$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (!(list.length > 0)) {
	                  _context.next = 5;
	                  break;
	                }
	
	                _context.next = 3;
	                return list.shift();
	
	              case 3:
	                _context.next = 0;
	                break;
	
	              case 5:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, listorder, this);
	      });
	    }();
	
	    pvt(this).find = function (iterator, map, options, promise) {
	      var initFn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
	
	      var _pvt$next = pvt(_this).next(iterator, map),
	          _pvt$next2 = _slicedToArray(_pvt$next, 2),
	          type = _pvt$next2[0],
	          Impl = _pvt$next2[1];
	
	      if (!Impl) {
	        promise.reject();
	      } else {
	        var p = void 0;
	        var src = options[type];
	        src = src || options;
	        if (initFn) {
	          p = new Impl()[initFn](src);
	        } else {
	          p = new Impl(src);
	        }
	        p.then(function (concrete) {
	          promise.resolve(concrete);
	        }).catch(function () {
	          // eslint-disable-line no-unused-vars
	          pvt(_this).find(iterator, map, options, promise, initFn);
	        });
	      }
	    };
	
	    pvt(this).next = function (order, map) {
	      var Impl = void 0;
	      var key = void 0;
	      var next = order.next();
	      if (!next.done) {
	        key = next.value;
	        Impl = map.get(key);
	      }
	      return [key, Impl];
	    };
	  }
	
	  _createClass(ImplFactoryOrder, [{
	    key: 'create',
	    value: function create(order, map, options) {
	      var initFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	
	      var promise = new _promise.DeferredPromise();
	      pvt(this).find(this.listorder(order.slice()), map, options, promise, initFn);
	      return promise.promise;
	    }
	  }]);
	
	  return ImplFactoryOrder;
	}();
	
	exports.default = ImplFactoryOrder;

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Main entry for failover support of all publisher implementations.
	 */
	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.RTCPublisher = exports.RTMPPublisher = exports.Red5ProPublisher = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _implFactoryOrder = __webpack_require__(328);
	
	var _implFactoryOrder2 = _interopRequireDefault(_implFactoryOrder);
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _red5proRtmp = __webpack_require__(330);
	
	var _red5proRtmp2 = _interopRequireDefault(_red5proRtmp);
	
	var _red5proRtc = __webpack_require__(333);
	
	var _red5proRtc2 = _interopRequireDefault(_red5proRtc);
	
	var _promise = __webpack_require__(310);
	
	var _publish = __webpack_require__(331);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProPublisher';
	var publishFactory = new _implFactoryOrder2.default();
	var publisherImpl = function () {
	  var map = new Map();
	  map.set(_publish.PublishTypes.RTC, _red5proRtc2.default);
	  map.set(_publish.PublishTypes.RTMP, _red5proRtmp2.default);
	  return map;
	}();
	
	var Red5ProPublisher = function (_EventEmitter) {
	  _inherits(Red5ProPublisher, _EventEmitter);
	
	  function Red5ProPublisher() {
	    _classCallCheck(this, Red5ProPublisher);
	
	    var _this = _possibleConstructorReturn(this, (Red5ProPublisher.__proto__ || Object.getPrototypeOf(Red5ProPublisher)).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._currentPublisher = undefined;
	    _this._boundBubblePublisherEvent = _this.bubblePublisherEvent.bind(_this);
	    _this._order = [_publish.PublishTypes.RTC, _publish.PublishTypes.RTMP];
	    return _this;
	  }
	
	  _createClass(Red5ProPublisher, [{
	    key: 'getPublishOrder',
	    value: function getPublishOrder() {
	      return this._order;
	    }
	  }, {
	    key: 'setPublishOrder',
	    value: function setPublishOrder(order) {
	      // Allow for string value to define single item in order.
	      order = typeof order === 'string' ? [order] : order;
	
	      // Filter out values not available in enumeration of playback types.
	      var t = order.filter(function (entry) {
	        var key = void 0;
	        for (key in _publish.PublishTypes) {
	          if (_publish.PublishTypes[key].toLowerCase() === entry.toLowerCase()) {
	            return true;
	          }
	        }
	        return false;
	      }).map(function (entry) {
	        return entry.toLowerCase();
	      });
	
	      // Define new order.
	      this._order = [].concat(_toConsumableArray(new Set(t)));
	      (0, _log.debug)(NAME, '[orderupdate]: ' + this._order);
	      return this;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(publishView) {
	      this._view = publishView;
	      return this;
	    }
	  }, {
	    key: 'getPublisherFromOrder',
	    value: function getPublisherFromOrder(order, options) {
	      return publishFactory.create(order, publisherImpl, options, 'init');
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var _this2 = this;
	
	      var deferred = new _promise.DeferredPromise();
	      (0, _log.debug)(NAME, '[publish]');
	      this._options = options;
	      this.getPublisherFromOrder(this._order, this._options).then(function (publisher) {
	        _this2._currentPublisher = publisher;
	        _this2._currentPublisher.setView(_this2._view);
	        _this2._currentPublisher.on('*', _this2._boundBubblePublisherEvent);
	        deferred.resolve(_this2._currentPublisher);
	      }).catch(function (err) {
	        (0, _log.warn)(NAME, '[publisherror]: Could not implement a publisher: ' + err);
	        deferred.reject(err);
	      });
	      return deferred.promise;
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      var _this3 = this;
	
	      var deferred = new _promise.DeferredPromise();
	      if (!this._currentPublisher) {
	        (0, _log.warn)(NAME, '[stop]: Could not invoke stop() on undefined publisher.');
	        deferred.reject('A current publisher is not available to issue a :stop() command to.');
	      } else {
	        (0, _log.debug)(NAME, '[stop]: Invoking stop on held publisher');
	        this._currentPublisher.unpublish().then(function () {
	          (0, _log.debug)(NAME, '[stopsuccess]');
	          _this3._currentPublisher.off('*', _this3._boundBubblePublisherEvent);
	          _this3._currentPublisher = undefined;
	          deferred.resolve();
	        }).catch(function (err) {
	          (0, _log.debug)(NAME, '[stoperror]: ' + err);
	          if (_this3._currentPublisher) {
	            _this3._currentPublisher.off('*', _this3._boundBubblePublisherEvent);
	          }
	          _this3._currentPublisher = undefined;
	          deferred.reject(err);
	        });
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'bubblePublisherEvent',
	    value: function bubblePublisherEvent(publisherEvent) {
	      this.trigger.call(this, publisherEvent);
	    }
	  }, {
	    key: 'publishTypes',
	    get: function get() {
	      return _publish.PublishTypes;
	    }
	  }, {
	    key: 'currentPublisher',
	    get: function get() {
	      return this._currentPublisher;
	    }
	  }]);
	
	  return Red5ProPublisher;
	}(_eventEmitter2.default);
	
	exports.Red5ProPublisher = Red5ProPublisher;
	exports.RTMPPublisher = _red5proRtmp2.default;
	exports.RTCPublisher = _red5proRtc2.default;

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(313);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _promise = __webpack_require__(310);
	
	var _publish = __webpack_require__(331);
	
	var _pubSourceHandler = __webpack_require__(332);
	
	var _pubSourceHandler2 = _interopRequireDefault(_pubSourceHandler);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProRTMPPublisher';
	var defaultOptions = {
	  protocol: 'rtmp',
	  port: 1935,
	  streamMode: 'live',
	  width: 320, // camera/video
	  height: 240, // camera/video
	  embedWidth: '100%', // DOM display style
	  embedHeight: '100%', // DOM display style
	  minFlashVersion: '10.0.0',
	  swf: 'lib/red5pro/red5pro-publisher.swf',
	  swfobjectURL: 'lib/swfobject/swfobject.js',
	  productInstallURL: 'lib/swfobject/playerProductInstall.swf'
	};
	
	var RTMPPublisher = function (_EventEmitter) {
	  _inherits(RTMPPublisher, _EventEmitter);
	
	  function RTMPPublisher() {
	    _classCallCheck(this, RTMPPublisher);
	
	    var _this = _possibleConstructorReturn(this, (RTMPPublisher.__proto__ || Object.getPrototypeOf(RTMPPublisher)).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._sourceHandler = undefined;
	    _this._elementId = undefined;
	    _this._connectFuture = undefined;
	    return _this;
	  }
	
	  _createClass(RTMPPublisher, [{
	    key: 'init',
	    value: function init(options) {
	      var self = this;
	      var deferred = new _promise.DeferredPromise();
	      var version = options.minFlashVersion || defaultOptions.minFlashVersion;
	      if (!_browser2.default.supportsFlashVersion(version)) {
	        deferred.reject('Could not resolve RTMPPublisher instance. Requires minimum Flash Player install of ' + version);
	      } else {
	        this._options = Object.assign({}, defaultOptions, options);
	        try {
	          _browser2.default.injectScript(this._options.swfobjectURL).then(function () {
	            (0, _log.debug)(NAME, 'SWFObject embedded.');
	            if (self._sourceHandler) {
	              (0, _log.debug)(NAME, 'Publish handler established.');
	              return self._sourceHandler.addSource(self._elementId, self._options);
	            } else {
	              (0, _log.debug)(NAME, 'Publish handler not established.');
	              return true;
	            }
	          }).then(function () {
	            return deferred.resolve(self);
	          }).catch(function (err) {
	            (0, _log.error)(NAME, 'Could not embed Flash-based RTMP Publisher. Reason: ' + err);
	            if (self._sourceHandler) {
	              self._sourceHandler.disconnect();
	            }
	            deferred.reject(err);
	            self.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_FAILURE, self));
	          });
	        } catch (e) {
	          deferred.reject('Could not inject Flash-based Publisher into the page. Reason: ' + e.message);
	          self.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_FAILURE, self));
	        }
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: '_setUpConnectCallback',
	    value: function _setUpConnectCallback(promise) {
	      var _this2 = this;
	
	      window.setActiveId = function (successId) {
	        // successId === _options.streamName
	        (0, _log.debug)(NAME, 'Embed and connect() complete for publisher swf. successId(' + successId + ').');
	        promise.resolve(successId);
	        _this2.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_SUCCESS, _this2));
	        _this2._tearDownConnectCallback();
	      };
	      // TODO: Setup timeout to reject?
	    }
	  }, {
	    key: '_tearDownConnectCallback',
	    value: function _tearDownConnectCallback() {
	      window.setActiveId = undefined;
	    }
	  }, {
	    key: '_establishExtIntHandlers',
	    value: function _establishExtIntHandlers() {
	      var _this3 = this;
	
	      var id = this._options.streamName;
	      var invokeFn = function invokeFn(label) {
	        return ['publisher', label, id].join('_');
	      };
	      window[invokeFn('r5proConnectClosed')] = function () {
	        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECTION_CLOSED, _this3));
	      };
	      window[invokeFn('r5proConnectSuccess')] = function () {
	        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_SUCCESS, _this3));
	      };
	      window[invokeFn('r5proUnpublishSuccess')] = function () {
	        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.UNPUBLISH_SUCCESS, _this3));
	      };
	      window[invokeFn('r5proPublishStart')] = function () {
	        _this3._connectFuture.resolve(_this3);
	        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_START, _this3));
	      };
	      window[invokeFn('r5proPublishMetadata')] = function (metadata) {
	        return _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_METADATA, _this3, metadata));
	      };
	      window[invokeFn('r5proConnectFailure')] = function () {
	        _this3._connectFuture.reject(_event.PublisherEventTypes.CONNECT_FAILURE);
	        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, _this3));
	      };
	      window[invokeFn('r5proPublishFail')] = function () {
	        _this3._connectFuture.reject(_event.PublisherEventTypes.PUBLISH_FAIL);
	        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_FAIL, _this3));
	      };
	      window[invokeFn('r5proPublishInvalidName')] = function () {
	        _this3._connectFuture.reject(_event.PublisherEventTypes.PUBLISH_INVALID_NAME);
	        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_INVALID_NAME, _this3));
	      };
	    }
	  }, {
	    key: 'publish',
	    value: function publish() {
	      var _this4 = this;
	
	      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
	      // eslint-disable-line no-unused-vars
	      var dfd = new _promise.DeferredPromise();
	      this._setUpConnectCallback(dfd);
	      this._options.streamName = streamName || this._options.streamName;
	      var publishOptions = this._options;
	      try {
	        (function () {
	          var srcHandler = _this4._sourceHandler;
	          _this4._sourceHandler.getEmbedOperation().then(function () {
	            (0, _log.debug)(NAME, '[handler:embed:complete]');
	            var el = _browser2.default.getEmbedObject(_this4._elementId);
	            if (el) {
	              _this4._establishExtIntHandlers();
	            }
	            var count = 0;
	            var limit = 100;
	            var tryConnect = function tryConnect() {
	              var timeout = void 0;
	              timeout = setTimeout(function () {
	                try {
	                  clearTimeout(timeout);
	                  srcHandler.connect(JSON.stringify(publishOptions));
	                } catch (e) {
	                  if (count++ > limit) {
	                    throw e;
	                  } else {
	                    tryConnect();
	                  }
	                }
	              }, 300);
	            };
	            tryConnect();
	          }).catch(function (err) {
	            dfd.reject(err);
	            _this4.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, _this4));
	          });
	        })();
	      } catch (e) {
	        (0, _log.error)(NAME, '[handler:embed:error]');
	        dfd.reject('Could not initiate connection sequence. Reason: ' + e.message);
	        this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, this));
	        this._tearDownConnectCallback();
	      }
	      this._connectFuture = dfd;
	      return dfd.promise;
	    }
	  }, {
	    key: 'unpublish',
	    value: function unpublish() {
	      var deferred = new _promise.DeferredPromise();
	      try {
	        _browser2.default.getEmbedObject(this._elementId).disconnect();
	        deferred.resolve();
	      } catch (e) {
	        (0, _log.error)(NAME, 'Could not initiate disconnection sequence. Reason: ' + e.message);
	        deferred.reject(e.message);
	      }
	      this._connectFuture = undefined;
	      return deferred.promise;
	    }
	  }, {
	    key: 'send',
	    value: function send(methodName, data) {
	      this._sourceHandler.send(methodName, typeof data === 'string' ? data : JSON.stringify(data));
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view, elementId) {
	      var _this5 = this;
	
	      this._view = view;
	      this._elementId = elementId;
	      if (this._sourceHandler !== undefined) {
	        this._sourceHandler.disconnect();
	        this._sourceHandler = undefined;
	      }
	      if (this._view) {
	        this._sourceHandler = new _pubSourceHandler2.default(this._view.view, this.getType());
	      }
	      if (this._options && this._sourceHandler) {
	        this._sourceHandler.addSource(this._elementId, this._options).catch(function (err) {
	          (0, _log.error)(NAME, 'Could not establish proper RTMP publisher: ' + err);
	          _this5.trigger(new _event.PublisherEvent(_event.RTMPPublisherEventTypes.EMBED_FAILURE, _this5));
	        });
	      }
	      return this;
	    }
	  }, {
	    key: 'setMediaQuality',
	    value: function setMediaQuality(quality) {
	      if (this._sourceHandler) {
	        this._sourceHandler.setMediaQuality(quality);
	      }
	    }
	  }, {
	    key: 'overlayOptions',
	    value: function overlayOptions(newOptions) {
	      this._options = Object.assign(this._options, newOptions);
	    }
	  }, {
	    key: 'getConnection',
	    value: function getConnection() {
	      return this._sourceHandler;
	    }
	  }, {
	    key: 'getOptions',
	    value: function getOptions() {
	      return this._options;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return _publish.PublishTypes.RTMP.toUpperCase();
	    }
	  }]);
	
	  return RTMPPublisher;
	}(_eventEmitter2.default);
	
	exports.default = RTMPPublisher;

/***/ },
/* 331 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var PublishTypes = exports.PublishTypes = Object.freeze({
	  RTMP: 'rtmp',
	  RTC: 'rtc'
	});
	
	var PublishModeTypes = exports.PublishModeTypes = Object.freeze({
	  LIVE: 'live',
	  RECORD: 'record',
	  APPEND: 'append'
	});

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _embed = __webpack_require__(326);
	
	var embed = _interopRequireWildcard(_embed);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _promise = __webpack_require__(310);
	
	var _log = __webpack_require__(299);
	
	var _sharedobjectHelperRtmp = __webpack_require__(327);
	
	var _sharedobjectHelperRtmp2 = _interopRequireDefault(_sharedobjectHelperRtmp);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProPublisherSourceHandler';
	var toInt = function toInt(value) {
	  if (typeof value === 'string') {
	    return value.parseInt(10);
	  } else {
	    return Math.round(value);
	  }
	};
	
	var PublisherSourceHandler = function () {
	  function PublisherSourceHandler(video, type) {
	    var soResponder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
	
	    _classCallCheck(this, PublisherSourceHandler);
	
	    this.video = video;
	    this.clone = this.video.cloneNode(true);
	    this.holder = this.video.parentNode;
	    this.publisherType = type;
	    this._swfId = null;
	    this._embedFuture = undefined;
	    this._soResponder = soResponder || new _sharedobjectHelperRtmp2.default();
	  }
	
	  _createClass(PublisherSourceHandler, [{
	    key: 'getEmbedOperation',
	    value: function getEmbedOperation() {
	      this._embedFuture = _promise.Future.createIfNotExist(this._embedFuture);
	      return this._embedFuture.promise;
	    }
	  }, {
	    key: 'cleanUp',
	    value: function cleanUp() {
	      // Return to prior DOM manipulation.
	      this.video.remove();
	      this.video = this.clone.cloneNode(true);
	      this.holder.appendChild(this.video);
	      this._embedFuture = undefined;
	    }
	  }, {
	    key: 'addSource',
	    value: function addSource(swfId, options) {
	      var swfUrl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	      var minFlashVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	
	      (0, _log.debug)(NAME, '[addsource]');
	      var self = this;
	      this._swfId = swfId;
	      this._embedFuture = _promise.Future.createIfNotExist(this._embedFuture);
	      var deferred = this._embedFuture;
	      options.swf = swfUrl || options.swf;
	      options.minFlashVersion = minFlashVersion || options.minFlashVersion;
	      embed.defineEmbedElement(this.video, this.holder).then(function (elementId) {
	        (0, _log.debug)(NAME, '[element:complete]');
	        var flashvars = {
	          buffer: options.buffer != null ? options.buffer : 2,
	          streamMode: options.streamMode,
	          streamName: options.streamName,
	          appName: options.app,
	          host: options.host
	        };
	        if (options.context) {
	          flashvars.roomName = options.context;
	        }
	        if (options.width && !isNaN(options.width)) {
	          flashvars.width = toInt(options.width);
	        }
	        if (options.height && !isNaN(options.height)) {
	          flashvars.height = toInt(options.height);
	        }
	        if (options.embedWidth === '100%' || options.embedHeight === '100%') {
	          flashvars.autosize = true;
	        }
	        if (typeof options.connectionParams !== 'undefined') {
	          flashvars.connectionParams = encodeURIComponent(JSON.stringify(options.connectionParams));
	        }
	        return embed.embedSwfObject(swfId, options, flashvars, _browser2.default.getSwfObject(), elementId);
	      }).then(function () {
	        (0, _log.debug)(NAME, '[embed:complete]');
	        deferred.resolve(self);
	      }).catch(function (err) {
	        return deferred.reject(err);
	      });
	      return deferred.promise;
	    }
	  }, {
	    key: 'connect',
	    value: function connect(publishOptions) {
	      (0, _log.debug)(NAME, '[connect]');
	      var el = _browser2.default.getEmbedObject(this._swfId);
	      if (el) {
	        el.connect(publishOptions);
	        this._soResponder.connect(this._swfId);
	      } else {
	        (0, _log.warn)(NAME, 'Could not determine embedded element with swf id: ' + this._swfId + '.');
	      }
	    }
	  }, {
	    key: 'disconnect',
	    value: function disconnect() {
	      (0, _log.debug)(NAME, '[disconnect]');
	      try {
	        // No invocable API for custom live flash publisher from Red5 Pro at the time.
	      } catch (e) {
	        // nada.
	      }
	      this.cleanUp();
	      this._soResponder.disconnect();
	    }
	  }, {
	    key: 'send',
	    value: function send(methodName, data) {
	      var el = _browser2.default.getEmbedObject(this._swfId);
	      if (el) {
	        el.send(methodName, data);
	      }
	    }
	  }, {
	    key: 'addSharedObjectResponseHandler',
	    value: function addSharedObjectResponseHandler(handler) {
	      this._soResponder.addResponseHandler(handler);
	    }
	  }, {
	    key: 'removeSharedObjectResponseHandler',
	    value: function removeSharedObjectResponseHandler(handler) {
	      this._soResponder.removeResponseHandler(handler);
	    }
	  }, {
	    key: 'sendToSharedObject',
	    value: function sendToSharedObject(name, callName, message) {
	      this._soResponder.sendToSharedObject(name, callName, message);
	    }
	  }, {
	    key: 'sendPropertyToSharedObject',
	    value: function sendPropertyToSharedObject(name, key, value) {
	      this._soResponder.sendPropertyToSharedObject(name, key, value);
	    }
	  }, {
	    key: 'getRemoteSharedObject',
	    value: function getRemoteSharedObject(sharedObjectName) {
	      this._soResponder.getRemoteSharedObject(sharedObjectName);
	    }
	  }, {
	    key: 'connectToSharedObject',
	    value: function connectToSharedObject(sharedObjectName) {
	      this._soResponder.connectToSharedObject(sharedObjectName);
	    }
	  }, {
	    key: 'closeSharedObject',
	    value: function closeSharedObject(sharedObjectName) {
	      this._soResponder.closeSharedObject(sharedObjectName);
	    }
	  }, {
	    key: 'setMediaQuality',
	    value: function setMediaQuality(quality) {
	      var el = _browser2.default.getEmbedObject(this._swfId);
	      if (el) {
	        if (quality.video && typeof quality.video !== 'boolean') {
	          var w = !isNaN(quality.video.width) ? toInt(quality.video.width) : Number.isNaN;
	          var h = !isNaN(quality.video.height) ? toInt(quality.video.height) : Number.isNaN;
	          el.updateResolution(w, h);
	        }
	      }
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return this.publisherType;
	    }
	  }]);
	
	  return PublisherSourceHandler;
	}();
	
	exports.default = PublisherSourceHandler;

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _event = __webpack_require__(313);
	
	var _socketHelperPub = __webpack_require__(334);
	
	var _socketHelperPub2 = _interopRequireDefault(_socketHelperPub);
	
	var _webrtcHelperPub = __webpack_require__(335);
	
	var _webrtcHelperPub2 = _interopRequireDefault(_webrtcHelperPub);
	
	var _publish = __webpack_require__(331);
	
	var _promise = __webpack_require__(310);
	
	var _webrtc = __webpack_require__(318);
	
	var webrtc = _interopRequireWildcard(_webrtc);
	
	var _websocket = __webpack_require__(316);
	
	var websocket = _interopRequireWildcard(_websocket);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// Default to secure settings.
	var defaultOptions = {
	  protocol: 'wss',
	  port: 8083,
	  streamType: 'webrtc',
	  streamMode: _publish.PublishModeTypes.LIVE,
	  bandwidth: {
	    audio: 56,
	    video: 512
	  }
	};
	var endpointFromOptions = function endpointFromOptions(options) {
	  var protocol = options.wsprotocol || options.protocol;
	  var port = options.wsport || options.port;
	  var appEndpoint = options.context ? [options.app, options.context].join('/') : options.app;
	  var endpoint = protocol + '://' + options.host + ':' + port + '/' + appEndpoint + '?id=' + options.streamName;
	  if (typeof options.connectionParams !== 'undefined') {
	    (function () {
	      var params = [];
	      Object.keys(options.connectionParams).forEach(function (key, index) {
	        // eslint-disable-line no-unused-vars
	        params.push([key, options.connectionParams[key]].join('='));
	      });
	      if (params.length > 0) {
	        endpoint += '&' + params.join('&');
	      }
	    })();
	  }
	  return endpoint;
	};
	
	var pubStartRegex = /(.*) starting/gi;
	var pubStopRegex = /(.*) stopping/gi;
	var NAME = 'RTCPublisher';
	var debug = function debug(message) {
	  (0, _log.debug)(NAME, message);
	};
	var warn = function warn(message) {
	  (0, _log.warn)(NAME, message);
	};
	var error = function error(message) {
	  (0, _log.error)(NAME, message);
	};
	
	var RTCPublisher = function (_EventEmitter) {
	  _inherits(RTCPublisher, _EventEmitter);
	
	  function RTCPublisher() {
	    _classCallCheck(this, RTCPublisher);
	
	    var _this = _possibleConstructorReturn(this, (RTCPublisher.__proto__ || Object.getPrototypeOf(RTCPublisher)).call(this));
	
	    _this._options = undefined;
	    _this._view = undefined;
	    _this._peerHelper = undefined;
	    _this._socketHelper = undefined;
	    _this._mediaStream = undefined;
	
	    _this._streamFuture = undefined;
	    _this._availableFuture = undefined;
	    _this._peerFuture = undefined;
	    _this._offerFuture = undefined;
	    _this._sendOfferFuture = undefined;
	    _this._trickleEndFuture = undefined;
	    _this._publishFuture = undefined;
	    _this._unpublishFuture = undefined;
	    return _this;
	  }
	
	  _createClass(RTCPublisher, [{
	    key: '_getMediaStream',
	    value: function _getMediaStream() {
	      this._streamFuture = _promise.Future.createIfNotExist(this._streamFuture);
	      return this._streamFuture.promise;
	    }
	  }, {
	    key: '_getTrickleEnd',
	    value: function _getTrickleEnd() {
	      return _promise.Future.createIfNotExist(this._trickleEndFuture);
	    }
	  }, {
	    key: 'init',
	    value: function init(options) {
	      var deferred = new _promise.DeferredPromise();
	      if (!webrtc.isSupported() || !websocket.isSupported()) {
	        deferred.reject('Cannot create WebRTC playback instance. Your environment does not support WebRTC and/or WebSockets.');
	      } else {
	        this._options = Object.assign({}, defaultOptions, options);
	        this._peerHelper = new _webrtcHelperPub2.default(this);
	        this._socketHelper = new _socketHelperPub2.default(this);
	        deferred.resolve(this);
	      }
	      return deferred.promise;
	    }
	  }, {
	    key: 'setView',
	    value: function setView(view) {
	      this._view = view;
	      return this;
	    }
	  }, {
	    key: 'attachStream',
	    value: function attachStream(media) {
	      this._streamFuture = _promise.Future.createIfNotExist(this._streamFuture);
	      this._streamFuture.resolve(media);
	      return this;
	    }
	  }, {
	    key: 'detachStream',
	    value: function detachStream() {
	      if (this._mediaStream && this._mediaStream.stop) {
	        this._mediaStream.stop();
	      } else if (this._mediaStream && this._mediaStream.getTracks) {
	        var tracks = this._mediaStream.getTracks();
	        var trackLength = tracks.length;
	        while (--trackLength > -1) {
	          if (tracks[trackLength].stop) {
	            tracks[trackLength].stop();
	          }
	        }
	      }
	      this._streamFuture = undefined;
	      this._mediaStream = undefined;
	      return this;
	    }
	  }, {
	    key: 'requestAvailability',
	    value: function requestAvailability(streamName, type) {
	      debug('[requestavailability]');
	      this._availableFuture = undefined;
	      this._availableFuture = _promise.Future.createIfNotExist(this._availableFuture);
	      // message on socket returns -> onStream(Un)Available
	      this._socketHelper.post({
	        isAvailable: streamName,
	        type: type,
	        bundle: false
	      });
	      return this._availableFuture.promise;
	    }
	  }, {
	    key: 'createPeerConnection',
	    value: function createPeerConnection(iceServers) {
	      debug('[createpeeer]');
	      this._peerFuture = undefined;
	      this._peerFuture = _promise.Future.createIfNotExist(this._peerFuture);
	      this._peerHelper.setUp(iceServers, this._peerFuture);
	      return this._peerFuture.promise;
	    }
	  }, {
	    key: 'createOffer',
	    value: function createOffer() {
	      var bandwidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	
	      debug('[createoffer]');
	      this._offerFuture = undefined;
	      this._offerFuture = _promise.Future.createIfNotExist(this._offerFuture);
	      this._peerHelper.createOffer(bandwidth, this._offerFuture);
	      return this._offerFuture.promise;
	    }
	  }, {
	    key: 'setRemoteDescription',
	    value: function setRemoteDescription(sdp) {
	      debug('[setremotedescription]');
	      return this._peerHelper.setRemoteDescription(sdp);
	    }
	  }, {
	    key: 'sendOffer',
	    value: function sendOffer(sdp, streamName) {
	      debug('[sendoffer]');
	      this._sendOfferFuture = undefined;
	      this._sendOfferFuture = _promise.Future.createIfNotExist(this._sendOffFuture);
	      this._socketHelper.post({
	        handleOffer: streamName,
	        data: {
	          sdp: sdp
	        }
	      });
	      return this._sendOfferFuture.promise;
	    }
	  }, {
	    key: 'sendCandidate',
	    value: function sendCandidate(candidate, streamName) {
	      debug('[sendcandidate]');
	      this._socketHelper.post({
	        handleCandidate: streamName,
	        data: {
	          candidate: candidate
	        }
	      });
	    }
	  }, {
	    key: 'requestPublish',
	    value: function requestPublish(streamName, streamMode) {
	      debug('[requestpublish]');
	      this._publishFuture = undefined;
	      this._publishFuture = _promise.Future.createIfNotExist(this._publishFuture);
	      this._socketHelper.post({
	        publish: streamName,
	        mode: streamMode
	      });
	      return this._publishFuture.promise;
	    }
	  }, {
	    key: 'requestUnpublish',
	    value: function requestUnpublish(streamName) {
	      this._unpublishFuture = undefined;
	      this._unpublishFuture = _promise.Future.createIfNotExist(this._unpublishFuture);
	      this._socketHelper.post({
	        unpublish: streamName
	      });
	      return this._unpublishFuture.promise;
	    }
	  }, {
	    key: 'publish',
	    value: function publish() {
	      var _this2 = this;
	
	      var streamName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	      debug('[publish]');
	      this._options.streamName = streamName || this._options.streamName;
	      var p = promise || new _promise.DeferredPromise();
	      var socketPromise = new _promise.DeferredPromise();
	      var socketurl = endpointFromOptions(this._options);
	      this._trickleEndFuture = this._getTrickleEnd();
	      this._socketHelper.setUp(socketurl, socketPromise);
	      // 0. Establish socket connection.
	      socketPromise.promise
	      // 1. Wait for stream attach
	      .then(function () {
	        _this2.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_SUCCESS, _this2));
	        return _this2._getMediaStream();
	      })
	      // 2. Request available stream to publish on
	      .then(function (mediaStream) {
	        _this2._mediaStream = mediaStream;
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.MEDIA_STREAM_AVAILABLE, _this2, mediaStream));
	        return _this2.requestAvailability(_this2._options.streamName, _this2._options.streamType);
	      })
	      // 3. Create Peer Connection
	      .then(function () {
	        return _this2.createPeerConnection(_this2._options.iceServers);
	      })
	      // 4. Make Offer on Peer Connection
	      .then(function (connection) {
	        connection.addStream(_this2._mediaStream);
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.PEER_CONNECTION_AVAILABLE, _this2, connection));
	        return _this2.createOffer(_this2._options.bandwidth);
	      })
	      // 5. Send Offer
	      .then(function (sessionDescription) {
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.OFFER_START, _this2, sessionDescription));
	        return _this2.sendOffer(sessionDescription, _this2._options.streamName);
	      })
	      // 6. Set the session description remotely
	      .then(function (sdp) {
	        return _this2.setRemoteDescription(sdp.sdp);
	      })
	      // 7. Wait until ice trickle end
	      .then(function (sdp) {
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.OFFER_END, _this2, sdp));
	        return _this2._getTrickleEnd().promise;
	      })
	      // 8. Request to publish stream
	      .then(function () {
	        _this2.trigger(new _event.PublisherEvent(_event.RTCPublisherEventTypes.ICE_TRICKLE_COMPLETE, _this2));
	        return _this2.requestPublish(_this2._options.streamName, _this2._options.streamMode);
	      })
	      // 9. Results in socket message of publish (see :onPublishStatus)
	      .then(function () {
	        p.resolve(_this2);
	        _this2.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_START, _this2));
	      }).catch(function (error) {
	        p.reject(error);
	        _this2.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.CONNECT_FAILURE, _this2, error));
	      });
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'unpublish',
	    value: function unpublish() {
	      var _this3 = this;
	
	      debug('[unpublish]');
	      var clearHelpers = function clearHelpers() {
	        if (_this3._socketHelper) {
	          _this3._socketHelper.tearDown();
	        }
	        if (_this3._peerHelper) {
	          _this3._peerHelper.tearDown();
	        }
	      };
	      this._availableFuture = undefined;
	      this._peerFuture = undefined;
	      this._offerFuture = undefined;
	      this._sendOfferFuture = undefined;
	      this._trickleEndFuture = undefined;
	      this._publishFuture = undefined;
	      var f = this.requestUnpublish(this._options.streamName);
	      f.then(function () {
	        _this3._unpublishFuture = undefined;
	        clearHelpers();
	        _this3.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.UNPUBLISH_SUCCESS, _this3));
	      });
	      return f;
	    }
	  }, {
	    key: 'mute',
	    value: function mute() {
	      this._socketHelper.post({
	        mute: true
	      });
	    }
	  }, {
	    key: 'unmute',
	    value: function unmute() {
	      this._socketHelper.post({
	        mute: false
	      });
	    }
	  }, {
	    key: 'send',
	    value: function send(methodName, data) {
	      this._socketHelper.post({
	        send: {
	          method: methodName,
	          data: typeof data === 'string' ? JSON.parse(data) : data
	        }
	      });
	    }
	  }, {
	    key: 'onStreamAvailable',
	    value: function onStreamAvailable(receipt) {
	      debug('[onstreamavailable]: ' + JSON.stringify(receipt, null, 2));
	      this._availableFuture = _promise.Future.createIfNotExist(this._availableFuture);
	      this._availableFuture.reject('Stream with name ' + this._options.streamName + ' already has a broadcast session.');
	      this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_INVALID_NAME, this));
	    }
	  }, {
	    key: 'onStreamUnavailable',
	    value: function onStreamUnavailable(receipt) {
	      // Being unavailable, is a good thing for allowing to publish using `options.streamName`
	      debug('Stream ' + this._options.streamName + ' does not exist.');
	      debug('[onstreamunavailable]: ' + JSON.stringify(receipt, null, 2));
	      this._availableFuture = _promise.Future.createIfNotExist(this._availableFuture);
	      this._availableFuture.resolve(true);
	    }
	  }, {
	    key: 'onSocketMessageError',
	    value: function onSocketMessageError(message) {
	      var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	      error('Error in stream playback: ' + message + '.\n[Optional detail]: ' + detail);
	      if (this._publishFuture) {
	        this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_FAIL, this));
	        this._publishFuture.reject(message);
	      }
	    }
	  }, {
	    key: 'onSDPSuccess',
	    value: function onSDPSuccess(receipt) {
	      var info = receipt ? ': ' + JSON.stringify(receipt, null, 2) : '';
	      debug('[onsdpsuccess]' + info);
	    }
	  }, {
	    key: 'onSDPError',
	    value: function onSDPError(receipt) {
	      this.trigger(new _event.PublisherEvent(_event.PublisherEventTypes.PUBLISH_FAIL, this));
	      var error = receipt ? ': ' + JSON.stringify(receipt, null, 2) : '';
	      error('[onsdperror]' + error);
	    }
	  }, {
	    key: 'onSDPAnswer',
	    value: function onSDPAnswer(sdp) {
	      debug('[sdpanswer]:: ' + JSON.stringify(sdp, null, 2));
	      this._sendOfferFuture = _promise.Future.createIfNotExist(this._sendOfferFuture);
	      this._sendOfferFuture.resolve(sdp);
	    }
	  }, {
	    key: 'onAddIceCandidate',
	    value: function onAddIceCandidate(candidate) {
	      debug('[addicecandidate]');
	      this._peerHelper.addIceCandidate(candidate).then(function () {
	        debug('[addicecandidate:success]');
	      }).catch(function (err) {
	        warn('[addicecandidate:error] - ' + err);
	      });
	    }
	  }, {
	    key: 'onIceCandidate',
	    value: function onIceCandidate(candidate) {
	      debug('[icecandidatetrickle]');
	      this.sendCandidate(candidate, this._options.streamName);
	    }
	  }, {
	    key: 'onIceCandidateTrickleEnd',
	    value: function onIceCandidateTrickleEnd() {
	      debug('[icecandidatetrickle:end]');
	    }
	  }, {
	    key: 'onSocketIceCandidateEnd',
	    value: function onSocketIceCandidateEnd() {
	      debug('[socketicecandidate:end]');
	      this._getTrickleEnd().resolve();
	      // this._trickleEndFuture = undefined
	    }
	  }, {
	    key: 'onPublisherStatus',
	    value: function onPublisherStatus(status) {
	      debug('[publisherstatus] - ' + JSON.stringify(status, null, 2));
	      var stopResult = pubStopRegex.exec(status.message);
	      var startResult = pubStartRegex.exec(status.message);
	      if (stopResult && stopResult[1] === this._options.streamName) {
	        this._unpublishFuture.resolve();
	      } else if (startResult && startResult[1] === this._options.streamName) {
	        this._publishFuture.resolve();
	      } else {
	        warn('Publisher status received, but could not handle.');
	      }
	    }
	  }, {
	    key: 'overlayOptions',
	    value: function overlayOptions(newOptions) {
	      this._options = Object.assign(this._options, newOptions);
	    }
	  }, {
	    key: 'getConnection',
	    value: function getConnection() {
	      return this._socketHelper;
	    }
	  }, {
	    key: 'getPeerConnection',
	    value: function getPeerConnection() {
	      return this._peerHelper ? this._peerHelper.connection : undefined;
	    }
	  }, {
	    key: 'getMediaStream',
	    value: function getMediaStream() {
	      return this._mediaStream;
	    }
	  }, {
	    key: 'getOptions',
	    value: function getOptions() {
	      return this._options;
	    }
	  }, {
	    key: 'getType',
	    value: function getType() {
	      return _publish.PublishTypes.RTC.toUpperCase();
	    }
	  }]);
	
	  return RTCPublisher;
	}(_eventEmitter2.default);
	
	exports.default = RTCPublisher;

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _socketHelper = __webpack_require__(315);
	
	var _socketHelper2 = _interopRequireDefault(_socketHelper);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NAME = 'R5ProPublisherSocket';
	
	var PublisherSocketHelper = function (_SocketHelper) {
	  _inherits(PublisherSocketHelper, _SocketHelper);
	
	  function PublisherSocketHelper(responder) {
	    _classCallCheck(this, PublisherSocketHelper);
	
	    return _possibleConstructorReturn(this, (PublisherSocketHelper.__proto__ || Object.getPrototypeOf(PublisherSocketHelper)).call(this, responder, NAME));
	  }
	
	  _createClass(PublisherSocketHelper, [{
	    key: 'respond',
	    value: function respond(message) {
	      if (message.data) {
	        var json = this.getJsonFromSocketMessage(message);
	        try {
	          if (!_get(PublisherSocketHelper.prototype.__proto__ || Object.getPrototypeOf(PublisherSocketHelper.prototype), 'respond', this).call(this, message)) {
	            if (json.data !== undefined) {
	              if (json.data.sdp !== undefined) {
	                if (json.data.sdp.type === 'answer') {
	                  this._responder.onSDPAnswer(json.data);
	                }
	              }
	              if (json.data.candidate !== undefined) {
	                this._responder.onAddIceCandidate(json.data.candidate);
	              }
	              if (json.data.type === 'status') {
	                if (json.data.code === 'NetConnection.ICE.TricleCompleted' || json.data.code === 'NetConnection.ICE.TrickleCompleted') {
	                  this._responder.onSocketIceCandidateEnd();
	                } else {
	                  this._responder.onPublisherStatus(json.data);
	                }
	              }
	            }
	          }
	        } catch (e) {
	          (0, _log.error)(NAME, '[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
	          this._responder.onSocketMessageError('[ws.onmessage] - Error in accessing message data as JSON. ' + e.message);
	        }
	      } else {
	        (0, _log.warn)(NAME, '[ws.onmessage] - No Message Data.');
	      }
	    }
	  }]);
	
	  return PublisherSocketHelper;
	}(_socketHelper2.default);
	
	exports.default = PublisherSocketHelper;

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _webrtc = __webpack_require__(318);
	
	var webrtc = _interopRequireWildcard(_webrtc);
	
	var _promise = __webpack_require__(310);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProPublishPeer';
	
	var PublisherPeerHelper = function () {
	  function PublisherPeerHelper(responder) {
	    _classCallCheck(this, PublisherPeerHelper);
	
	    this._responder = responder;
	    this._peerConnection = undefined;
	  }
	
	  _createClass(PublisherPeerHelper, [{
	    key: '_removeConnectionHandlers',
	    value: function _removeConnectionHandlers(connection) {
	      connection.onconnectionstatechange = undefined;
	      connection.onicecandidate = undefined;
	    }
	  }, {
	    key: '_addConnectionHandlers',
	    value: function _addConnectionHandlers(connection, promise) {
	      var _this = this;
	
	      connection.onconnectionstatechange = function () {
	        if (connection.connectionState === 'connected') {
	          (0, _log.debug)(NAME, '[peerconnection:open]');
	          if (promise) {
	            promise.resolve(_this);
	          }
	        } else if (connection.connectionState === 'failed' || connection.connectionState === 'disconnected') {
	          (0, _log.warn)(NAME, '[peerconnection:error]');
	          if (promise) {
	            promise.reject();
	          }
	        }
	      };
	
	      connection.onicecandidate = function (event) {
	        (0, _log.debug)(NAME, '[peer.onicecandidate] - Peer Candidate: ' + event.candidate);
	        if (event.candidate) {
	          _this._responder.onIceCandidate(event.candidate);
	        } else if (event.candidate === null) {
	          // null means they have finished sending candidates back and forth?
	          // Moved to notification from server on trickle end event.
	          // this._responder.onIceCandidateTrickleEnd()
	        }
	      };
	    }
	  }, {
	    key: 'createOffer',
	    value: function createOffer() {
	      var _this2 = this;
	
	      var bandwidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var offerPromise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	      (0, _log.debug)(NAME, '[createoffer]');
	      var p = offerPromise || new _promise.DeferredPromise();
	      this._peerConnection.createOffer().then(function (sessionDescription) {
	        _this2.setLocalDescription(sessionDescription, bandwidth).then(function () {
	          if (bandwidth) {
	            sessionDescription.sdp = webrtc.updateBandwidth(bandwidth, sessionDescription.sdp);
	          }
	          _this2._responder.onSDPSuccess();
	          p.resolve(sessionDescription);
	        }).catch(function (err) {
	          _this2._responder.onSDPError(err);
	          p.reject(err);
	        });
	      }).catch(function (err) {
	        (0, _log.debug)(NAME, '[createoffer:error]');
	        p.reject(err);
	      });
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'setLocalDescription',
	    value: function setLocalDescription(sessionDescription) {
	      var bandwidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      // eslint-disable-line no-unused-vars
	      (0, _log.debug)(NAME, '[setlocaldescription]');
	      return this._peerConnection.setLocalDescription(sessionDescription);
	    }
	  }, {
	    key: 'setRemoteDescription',
	    value: function setRemoteDescription(sdp) {
	      (0, _log.debug)(NAME, '[setremotedescription]');
	      return this._peerConnection.setRemoteDescription(new webrtc.RTCSessionDescription(sdp));
	    }
	  }, {
	    key: 'addIceCandidate',
	    value: function addIceCandidate(candidate) {
	      (0, _log.debug)(NAME, '[addcandidate]');
	      return this._peerConnection.addIceCandidate(candidate);
	    }
	  }, {
	    key: 'setUp',
	    value: function setUp(iceServers) {
	      var setUpPromise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	
	      this.tearDown();
	      (0, _log.debug)(NAME, '[setup]');
	      var p = setUpPromise || new _promise.DeferredPromise();
	      try {
	        var peer = new webrtc.RTCPeerConnection({
	          iceServers: iceServers,
	          rtcpMuxPolicy: 'negotiate'
	        }, {
	          optional: [{ DtlsSrtpKeyAgreement: true }, { RtpDataChannels: false }, { googCpuOveruseDetection: true }]
	        });
	        this._addConnectionHandlers(peer);
	        this._peerConnection = peer;
	        p.resolve(peer);
	      } catch (e) {
	        (0, _log.warn)(NAME, 'Could not establish a PeerConnection. ' + e.message);
	        p.reject(e.message);
	      }
	      return p.hasOwnProperty('promise') ? p.promise : p;
	    }
	  }, {
	    key: 'tearDown',
	    value: function tearDown() {
	      (0, _log.debug)(NAME, '[teardown]');
	      if (this._peerConnection) {
	        this._removeConnectionHandlers(this._peerConnection);
	        try {
	          this._peerConnection.close();
	        } catch (e) {
	          (0, _log.warn)(NAME, '[peerconnection.close] error: ' + e.message);
	        }
	      }
	    }
	  }, {
	    key: 'connection',
	    get: function get() {
	      return this._peerConnection;
	    }
	  }]);
	
	  return PublisherPeerHelper;
	}();
	
	exports.default = PublisherPeerHelper;

/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Red5ProSharedObject = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _eventEmitter = __webpack_require__(307);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _index = __webpack_require__(313);
	
	var _sharedobjectEvent = __webpack_require__(304);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'Red5ProSharedObject';
	var debug = function debug(soName, message) {
	  (0, _log.debug)([NAME, soName].join(':'), message);
	};
	var warn = function warn(soName, message) {
	  (0, _log.warn)([NAME, soName].join(':'), message);
	};
	var error = function error(soName, message) {
	  (0, _log.error)([NAME, soName].join(':'), message);
	};
	
	var SO_SUBTYPE_PROPERTY = 4;
	var SO_SUBTYPE_METHOD = 6;
	
	var decodeMessageIfJSONString = function decodeMessageIfJSONString(message) {
	  return typeof message === 'string' ? JSON.parse(message) : message;
	};
	
	var PropertyData = function () {
	  function PropertyData(key, value) {
	    _classCallCheck(this, PropertyData);
	
	    this.key = key;
	    this.value = value;
	  }
	
	  _createClass(PropertyData, [{
	    key: 'toObject',
	    value: function toObject() {
	      var obj = {};
	      obj[this.key] = this.value;
	      return obj;
	    }
	  }]);
	
	  return PropertyData;
	}();
	
	var MethodData = function () {
	  function MethodData(methodName, message) {
	    _classCallCheck(this, MethodData);
	
	    this.methodName = methodName;
	    var messageList = void 0;
	    if (Object.prototype.toString.call(message) === '[object Array]') {
	      var i = void 0;
	      var msg = void 0;
	      var length = message.length;
	      messageList = [];
	      for (i = 0; i < length; i++) {
	        msg = decodeMessageIfJSONString(message[i]);
	        if (Object.prototype.toString.call(message) === '[object Array]') {
	          messageList = messageList.concat(msg);
	        } else {
	          messageList.push(msg);
	        }
	      }
	    } else {
	      messageList = [decodeMessageIfJSONString(message)];
	    }
	    this.message = messageList.length === 1 ? messageList[0] : messageList;
	  }
	
	  _createClass(MethodData, [{
	    key: 'toObject',
	    value: function toObject() {
	      return {
	        methodName: this.methodName,
	        message: this.message
	      };
	    }
	  }]);
	
	  return MethodData;
	}();
	
	var Red5ProSharedObject = function (_EventEmitter) {
	  _inherits(Red5ProSharedObject, _EventEmitter);
	
	  function Red5ProSharedObject(name, connection) {
	    _classCallCheck(this, Red5ProSharedObject);
	
	    var _this = _possibleConstructorReturn(this, (Red5ProSharedObject.__proto__ || Object.getPrototypeOf(Red5ProSharedObject)).call(this));
	
	    _this._name = name;
	    _this._socket = connection.getConnection();
	    _this._socket.addSharedObjectResponseHandler(_this);
	    _this._onclose = _this.close.bind(_this);
	    try {
	      debug(_this._name, '[sharedobject:connect:attempt]');
	      _this._socket.getRemoteSharedObject(_this._name);
	      _browser2.default.addCloseHandler(_this._onclose, 0);
	    } catch (e) {
	      error(_this._name, '[sharedobject:connect:error]: ' + e.message);
	    }
	    return _this;
	  }
	
	  _createClass(Red5ProSharedObject, [{
	    key: 'getJsonFromSocketMessage',
	    value: function getJsonFromSocketMessage(message) {
	      try {
	        return typeof message.data === 'string' ? JSON.parse(message.data) : message.data;
	      } catch (e) {
	        warn(this._name, 'Could not parse message as JSON. Message= ' + message.data + '. Error= ' + e.message);
	      }
	      return null;
	    }
	  }, {
	    key: 'notifyOfPropertyValues',
	    value: function notifyOfPropertyValues(valueObject) {
	      if (Object.keys(valueObject).length === 0) {
	        this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.PROPERTY_UPDATE, this._name, {}));
	      } else {
	        var key = void 0;
	        for (key in valueObject) {
	          this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.PROPERTY_UPDATE, this._name, new PropertyData(key, valueObject[key]).toObject()));
	        }
	      }
	    }
	  }, {
	    key: 'notifyOfEvents',
	    value: function notifyOfEvents(events) {
	      var i = void 0,
	          event = void 0;
	      var length = events.length;
	      for (i = 0; i < length; i++) {
	        event = events[i];
	        switch (event.subtype) {
	          case SO_SUBTYPE_PROPERTY:
	            this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.PROPERTY_UPDATE, this._name, new PropertyData(event.attribute, event.value).toObject()));
	            return true;
	          case SO_SUBTYPE_METHOD:
	            this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.METHOD_UPDATE, this._name, new MethodData(event.method, event.value).toObject()));
	            return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: 'respond',
	    value: function respond(message) {
	      if (message.data) {
	        var json = this.getJsonFromSocketMessage(message);
	        if (json === null) {
	          warn(this._name, 'Determined websocket response not in correct format. Aborting message handle.');
	          return true;
	        }
	        if (json.data !== undefined) {
	          if (json.data.name === this._name) {
	            debug(this._name, '[sharedobject-response]: ' + JSON.stringify(json, null, 2));
	            if (json.data.status === 'SharedObject.Status.GetRemote' && json.data.message === 'Success') {
	              this._socket.connectToSharedObject(this._name);
	              return true;
	            } else if (json.data.status === 'SharedObject.Status.GetRemote' && json.data.message === 'Fail') {
	              this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.CONNECT_FAILURE, this._name));
	              return true;
	            } else if (json.data.status === 'SharedObject.Status.Connect' && json.data.message === 'Success') {
	              this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.CONNECT_SUCCESS, this._name));
	              return true;
	            } else if (json.data.status === 'SharedObject.Status.Connect' && json.data.message === 'Fail') {
	              this.trigger(new _index.SharedObjectEvent(_sharedobjectEvent.common.CONNECT_FAILURE, this._name));
	              return true;
	            } else if (json.data.type === 'sharedobject') {
	              if (json.data.hasOwnProperty('events')) {
	                return this.notifyOfEvents(json.data.events);
	              } else if (json.data.hasOwnProperty('value')) {
	                return this.notifyOfPropertyValues(json.data.value);
	              }
	            }
	          } else {
	            debug('Unhandled Socket exchange: ' + JSON.stringify(json, null, 2));
	          }
	        }
	      }
	      return false;
	    }
	  }, {
	    key: 'send',
	    value: function send(messageName, data) {
	      this._socket.sendToSharedObject(this._name, messageName, data);
	    }
	  }, {
	    key: 'setProperty',
	    value: function setProperty(key, value) {
	      this._socket.sendPropertyToSharedObject(this._name, key, value);
	    }
	  }, {
	    key: 'close',
	    value: function close() {
	      if (this._socket === undefined) {
	        warn('Socket no longer exist to close shared object properly.');
	      }
	      this._socket.closeSharedObject(this._name);
	      if (this._socket) {
	        this._socket.removeSharedObjectResponseHandler(this);
	      }
	      this._socket = undefined;
	      this._name = undefined;
	      _browser2.default.removeCloseHandler(this._onclose);
	    }
	  }, {
	    key: 'getName',
	    value: function getName() {
	      return this._name;
	    }
	  }]);
	
	  return Red5ProSharedObject;
	}(_eventEmitter2.default);
	
	exports.Red5ProSharedObject = Red5ProSharedObject;

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	'use script';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.PlaybackView = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProPlaybackView';
	var playbackId = 'red5pro-subscriber';
	
	var PlaybackView = exports.PlaybackView = function () {
	  function PlaybackView() {
	    var elementId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : playbackId;
	
	    _classCallCheck(this, PlaybackView);
	
	    try {
	      // Target video element.
	      this._targetElement = _browser2.default.resolveElement(elementId);
	    } catch (e) {
	      (0, _log.error)(NAME, 'Could not instantiate a new instance of Red5ProSubscriber. Reason: ' + e.message);
	      throw e;
	    }
	  }
	
	  _createClass(PlaybackView, [{
	    key: 'attachSubscriber',
	    value: function attachSubscriber(subscriber) {
	      (0, _log.debug)(NAME, '[attachsubscriber]');
	      subscriber.setView(this, _browser2.default.getElementId(this._targetElement));
	    }
	  }, {
	    key: 'attachStream',
	    value: function attachStream(mediaStream) {
	      var autoplay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	      (0, _log.debug)(NAME, '[attachstream]: autoplay(' + autoplay + ')');
	      _browser2.default.setVideoSource(this._targetElement, mediaStream, autoplay);
	    }
	  }, {
	    key: 'stop',
	    value: function stop() {
	      (0, _log.debug)(NAME, '[stop]');
	      try {
	        this._targetElement.pause();
	      } catch (e) {
	        (0, _log.warn)(NAME, 'Could not stop video element: ' + e.message);
	      }
	    }
	  }, {
	    key: 'view',
	    get: function get() {
	      return this._targetElement;
	    }
	  }]);
	
	  return PlaybackView;
	}();
	
	exports.default = PlaybackView;

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _browser = __webpack_require__(309);
	
	var _browser2 = _interopRequireDefault(_browser);
	
	var _log = __webpack_require__(299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NAME = 'R5ProPublishView';
	
	var publisherId = 'red5pro-publisher';
	
	var PublishView = function () {
	  function PublishView() {
	    var elementId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : publisherId;
	
	    _classCallCheck(this, PublishView);
	
	    try {
	      this._targetElement = _browser2.default.resolveElement(elementId);
	    } catch (e) {
	      (0, _log.error)(NAME, 'Could not instantiate a new instance of Red5ProPublisher. Reason: ' + e.message);
	      throw e;
	    }
	  }
	
	  _createClass(PublishView, [{
	    key: 'attachPublisher',
	    value: function attachPublisher(publisher) {
	      (0, _log.debug)(NAME, '[attachpublisher]');
	      publisher.setView(this, _browser2.default.getElementId(this._targetElement));
	    }
	  }, {
	    key: 'preview',
	    value: function preview(mediaStream) {
	      var autoplay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	
	      (0, _log.debug)(NAME, '[preview]: autoplay(' + autoplay + ')');
	      _browser2.default.setVideoSource(this._targetElement, mediaStream, autoplay);
	    }
	  }, {
	    key: 'view',
	    get: function get() {
	      return this._targetElement;
	    }
	  }]);
	
	  return PublishView;
	}();
	
	exports.default = PublishView;

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAzNmRjYjBiOTRiNmNiNDg3ODI1MSIsIndlYnBhY2s6Ly8vLi9+L2JhYmVsLXBvbHlmaWxsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2N0eC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19rZXlvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXNhcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2VhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc2FtZS12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NldC1wcm90by5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtaW50LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcGFyc2UtZmxvYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hLW51bWJlci12YWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hY29zaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2x6MzIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY29zaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1leHBtMS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5mcm91bmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxMC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cxcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnNpZ24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRydW5jLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuY29kZS1wb2ludC1hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLXJlZ2V4cC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdGFydHMtd2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5iaWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN0cmlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1cC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmpvaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb3J0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1maWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLWluZGV4LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19mbGFncy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc2VhcmNoLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2FuLWluc3RhbmNlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3Rhc2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX21pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstbWFwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXdlYWsuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5hdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXBhZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1mb3JjZWQtcGFtLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1mcm9tLWl0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaXN1YmguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaW11bGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgudW11bGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYnNlcnZhYmxlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnRpYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvX3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovLy8uL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9jb3JlLWpzL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlLmpzIiwid2VicGFjazovLy8uL34vY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xvZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jyb3dzZXItYnVueWFuL2xpYi9idW55YW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xvZy9idW55YW4td3JpdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9ldmVudC9wdWJsaXNoZXItZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2V2ZW50L3N1YnNjcmliZXItZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2V2ZW50L3NoYXJlZG9iamVjdC1ldmVudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZW51bS9wbGF5YmFjay5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3Vic2NyaWJlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29yZS9ldmVudC1lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRjLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9lbnYvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbC9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9leGNlcHRpb24vZXJyb3JzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9lbnYvbWV0YWRhdGEtdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZXZlbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2hlbHBlci9zb2NrZXQtaGVscGVyLXN1Yi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvaGVscGVyL3NvY2tldC1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2FkYXB0ZXIvd2Vic29ja2V0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9oZWxwZXIvd2VicnRjLWhlbHBlci1zdWIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2FkYXB0ZXIvd2VicnRjLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8taGxzLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL3ZpZGVvanMtc291cmNlLWhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWwvb2JqZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRtcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3Vic2NyaWJlci9yZWQ1cHJvLXJ0bXAtdmlkZW9qcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3Vic2NyaWJlci9yZWQ1cHJvLXJ0bXAtbGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc3Vic2NyaWJlci9saXZlLXNvdXJjZS1oYW5kbGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9lbnYvZW1iZWQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2hlbHBlci9zaGFyZWRvYmplY3QtaGVscGVyLXJ0bXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3V0aWwvaW1wbC1mYWN0b3J5LW9yZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9wdWJsaXNoZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3B1Ymxpc2hlci9yZWQ1cHJvLXJ0bXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2VudW0vcHVibGlzaC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcHVibGlzaGVyL3B1Yi1zb3VyY2UtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcHVibGlzaGVyL3JlZDVwcm8tcnRjLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9oZWxwZXIvc29ja2V0LWhlbHBlci1wdWIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2hlbHBlci93ZWJydGMtaGVscGVyLXB1Yi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2hhcmVkb2JqZWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy92aWV3L3BsYXliYWNrLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy92aWV3L3B1Ymxpc2guanMiXSwibmFtZXMiOlsiTEVWRUxTIiwiZ2V0TG9nZ2VyIiwiY29tbW9uIiwicnRjIiwiZmFpbG92ZXIiLCJQbGF5YmFja0F1ZGlvRW5jb2RlciIsIlBsYXliYWNrVmlkZW9FbmNvZGVyIiwic3Vic2NyaWJlckxpYiIsInB1Ymxpc2hlckxpYiIsInNoYXJlZE9iamVjdExpYiIsIlJlZDVQcm9TdWJzY3JpYmVyIiwiUlRDU3Vic2NyaWJlciIsIkhMU1N1YnNjcmliZXIiLCJWaWRlb0pTU3Vic2NyaWJlciIsIlI1TGl2ZVN1YnNjcmliZXIiLCJSVE1QU3Vic2NyaWJlciIsIlBsYXliYWNrVmlldyIsIlJlZDVQcm9QdWJsaXNoZXIiLCJSVE1QUHVibGlzaGVyIiwiUlRDUHVibGlzaGVyIiwiUHVibGlzaGVyVmlldyIsIlJlZDVQcm9TaGFyZWRPYmplY3QiLCJERUJVRyIsImRlYnVnIiwic2V0TG9nTGV2ZWwiLCJsZXZlbCIsImhhc093blByb3BlcnR5IiwidG9VcHBlckNhc2UiLCJsb2dnZXIiLCJmb3JtYXRNZXNzYWdlIiwiZGlzcGF0Y2hlciIsIm1lc3NhZ2UiLCJkZWNvcmF0ZSIsInNvdXJjZSIsIlRSQUNFIiwiSU5GTyIsIldBUk4iLCJFUlJPUiIsIkZBVEFMIiwiZXN0YWJsaXNoTG9nZ2VyIiwic3RyZWFtTGlzdCIsInVuZGVmaW5lZCIsInN0cmVhbXMiLCJwdXNoIiwic3RyZWFtIiwidHlwZSIsImxpc3QiLCJtYXAiLCJpdGVtIiwiY29uY2F0IiwibmFtZSIsInRyYWNlIiwiaW5mbyIsIndhcm4iLCJlcnJvciIsImZhdGFsIiwiUmF3U3RyZWFtIiwicmVjIiwiY29uc29sZSIsImxvZyIsIm1zZyIsIk9iamVjdCIsImZyZWV6ZSIsIkNPTk5FQ1RfU1VDQ0VTUyIsIkNPTk5FQ1RfRkFJTFVSRSIsIlBVQkxJU0hfU1RBUlQiLCJQVUJMSVNIX0ZBSUwiLCJQVUJMSVNIX0lOVkFMSURfTkFNRSIsIlVOUFVCTElTSF9TVUNDRVNTIiwiUFVCTElTSF9NRVRBREFUQSIsIkNPTk5FQ1RJT05fQ0xPU0VEIiwiUFVCTElTSEVSX1JFSkVDVCIsIlBVQkxJU0hFUl9BQ0NFUFQiLCJNRURJQV9TVFJFQU1fQVZBSUxBQkxFIiwiUEVFUl9DT05ORUNUSU9OX0FWQUlMQUJMRSIsIk9GRkVSX1NUQVJUIiwiT0ZGRVJfRU5EIiwiSUNFX1RSSUNLTEVfQ09NUExFVEUiLCJydG1wIiwiRU1CRURfU1VDQ0VTUyIsIkVNQkVEX0ZBSUxVUkUiLCJTVUJTQ1JJQkVfU1RBUlQiLCJTVUJTQ1JJQkVfU1RPUCIsIlNVQlNDUklCRV9GQUlMIiwiU1VCU0NSSUJFX0lOVkFMSURfTkFNRSIsIlNVQlNDUklCRV9NRVRBREFUQSIsIlNVQlNDUklCRV9TRU5EX0lOVk9LRSIsIlBMQVlfVU5QVUJMSVNIIiwiU1VCU0NSSUJFUl9SRUpFQ1QiLCJTVUJTQ1JJQkVSX0FDQ0VQVCIsIkFOU1dFUl9TVEFSVCIsIkFOU1dFUl9FTkQiLCJDQU5ESURBVEVfU1RBUlQiLCJDQU5ESURBVEVfRU5EIiwiUFJPUEVSVFlfVVBEQVRFIiwiTUVUSE9EX1VQREFURSIsIlBsYXliYWNrVHlwZXMiLCJSVE1QIiwiUlRDIiwiSExTIiwiT1BVUyIsIlBDTVUiLCJQQ01BIiwiU1BFRVgiLCJOT05FIiwiVlA4IiwiSDI2NCIsIk5BTUUiLCJwbGF5YmFja0ZhY3RvcnkiLCJwbGF5YmFja0ltcGwiLCJNYXAiLCJzZXQiLCJfb3B0aW9ucyIsIl92aWV3IiwiX2N1cnJlbnRTdWJzY3JpYmVyIiwiX29yZGVyIiwiX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50IiwiYnViYmxlU3Vic2NyaWJlckV2ZW50IiwiYmluZCIsIm9yZGVyIiwidCIsImZpbHRlciIsImtleSIsInRvTG93ZXJDYXNlIiwiZW50cnkiLCJTZXQiLCJwbGF5YmFja1ZpZXciLCJvcHRpb25zIiwiY3JlYXRlIiwiZGVmZXJyZWQiLCJnZXRQbGF5YmFja0Zyb21PcmRlciIsInRoZW4iLCJzdWJzY3JpYmVyIiwiZ2V0VHlwZSIsIm9uIiwic2V0VmlldyIsInJlc29sdmUiLCJjYXRjaCIsImVyciIsInJlamVjdCIsInByb21pc2UiLCJzdG9wIiwib2ZmIiwic3Vic2NyaWJlckV2ZW50IiwidHJpZ2dlciIsImNhbGwiLCJXSUxEQ0FSRCIsIldJTERDQVJEX0tFWSIsIkV2ZW50RW1pdHRlciIsIl9jYWxsYmFja3MiLCJjYWxsYmFja3MiLCJldmVudCIsImkiLCJsZW5ndGgiLCJmbiIsImluZGV4T2YiLCJpbmRleCIsInNwbGljZSIsIl9ub3RpZnkiLCJ3ZWJydGMiLCJ3ZWJzb2NrZXQiLCJkZWZhdWx0T3B0aW9ucyIsInN0cmVhbVR5cGUiLCJnZW5lcmF0ZVN1YnNjcmlwdGlvbklkIiwiaWQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJ0b1N0cmluZyIsImVuZHBvaW50RnJvbU9wdGlvbnMiLCJwcm90b2NvbCIsIndzcHJvdG9jb2wiLCJwb3J0Iiwid3Nwb3J0IiwiYXBwRW5kcG9pbnQiLCJjb250ZXh0IiwiYXBwIiwiam9pbiIsImVuZHBvaW50IiwiaG9zdCIsInN1YnNjcmlwdGlvbklkIiwiY29ubmVjdGlvblBhcmFtcyIsInBhcmFtcyIsImtleXMiLCJmb3JFYWNoIiwiX3BlZXJIZWxwZXIiLCJfc29ja2V0SGVscGVyIiwiX29yaWVudGF0aW9uIiwiaXNTdXBwb3J0ZWQiLCJhc3NpZ24iLCJ2aWV3Iiwic3RyZWFtTmFtZSIsInBvc3QiLCJpc0F2YWlsYWJsZSIsInZFbmNvZGluZyIsImFFbmNvZGluZyIsIm9mZmVyIiwicmVxdWVzdE9mZmVyIiwicmVxdWVzdElkIiwidmlkZW9FbmNvZGluZyIsImF1ZGlvRW5jb2RpbmciLCJzZHAiLCJjcmVhdGVBbnN3ZXIiLCJiYW5kd2lkdGgiLCJzZXNzaW9uRGVzY3JpcHRpb24iLCJ1cGRhdGVCYW5kd2lkdGgiLCJzZW5kQW5zd2VyIiwib25TRFBFcnJvciIsImhhbmRsZUFuc3dlciIsImRhdGEiLCJjYW5kaWRhdGUiLCJoYW5kbGVDYW5kaWRhdGUiLCJzdWJzY3JpYmUiLCJyZWNlaXB0IiwiSlNPTiIsInN0cmluZ2lmeSIsIl9jb25uZWN0IiwiaWNlU2VydmVycyIsIl9kaXNjb25uZWN0IiwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIiwicmVxdWVzdEFuc3dlciIsInNlbmRDYW5kaWRhdGUiLCJhdHRhY2hTdHJlYW0iLCJhdXRvcGxheSIsImFkZEljZUNhbmRpZGF0ZSIsInNlbmRTdWJzY3JpYmUiLCJkZXRhaWwiLCJtZXRob2ROYW1lIiwib25NZXRhRGF0YSIsIm1ldGFkYXRhIiwib3JpZW50YXRpb24iLCJhcHBseU9yaWVudGF0aW9uIiwidGVhckRvd24iLCJwIiwic2V0VXAiLCJzb2NrZXRQcm9taXNlIiwic29ja2V0dXJsIiwicmVxdWVzdEF2YWlsYWJpbGl0eSIsIlVOU1VCU0NSSUJFX1NVQ0NFU1MiLCJjb25uZWN0aW9uIiwiY2xvc2VIYW5kbGVycyIsIm9ud2luZG93Y2xvc2UiLCJlIiwiZmxhc2hWZXJzaW9uIiwidmVyc2lvbiIsIndpbmRvdyIsIkFjdGl2ZVhPYmplY3QiLCJHZXRWYXJpYWJsZSIsInJlcGxhY2UiLCJtYXRjaCIsIm5hdmlnYXRvciIsIm1pbWVUeXBlcyIsImVuYWJsZWRQbHVnaW4iLCJwbHVnaW5zIiwiZGVzY3JpcHRpb24iLCJzcGxpdCIsImlzTW96IiwibW96R2V0VXNlck1lZGlhIiwiZ2V0VXNlck1lZGlhIiwid2Via2l0R2V0VXNlck1lZGlhIiwibXNHZXRVc2VyTWVkaWEiLCJkZWZhdWx0VXNlck1lZGlhQXVkaW8iLCJtYW5kaXRvcnkiLCJnb29nQXV0b0dhaW5Db250cm9sIiwiZ29vZ0hpZ2hwYXNzRmlsdGVyIiwiZ29vZ0VjaG9DYW5jZWxsYXRpb24iLCJnb29nTm9pc2VTdXBwcmVzc2lvbiIsIm9wdGlvbmFsIiwiZWNob0NhbmNlbGxhdGlvbiIsImRlZmF1bHRVc2VyTWVkaWFWaWRlbyIsIm1hbmRhdG9yeSIsIm1pbldpZHRoIiwibWluSGVpZ2h0IiwibWluRnJhbWVSYXRlIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJtYXhGcmFtZVJhdGUiLCJvcmlnaW4iLCJzdHlsZXMiLCJ0cmFuc2l0aW9uIiwicm90YXRpb25UcmFuc2xhdGlvbnMiLCJ0cmFuc2Zvcm0iLCJzdXBwb3J0c1dlYlNvY2tldCIsIldlYlNvY2tldCIsInN1cHBvcnRzRmxhc2hWZXJzaW9uIiwiZGVsaW1pdGVyIiwicmVzb2x2ZUVsZW1lbnQiLCJlbCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjcmVhdGVXZWJTb2NrZXQiLCJ1cmwiLCJzZXRWaWRlb1NvdXJjZSIsInZpZGVvRWxlbWVudCIsIm1lZGlhU3RyZWFtIiwic3JjIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicGxheSIsImluamVjdFNjcmlwdCIsImRmZCIsInNjcmlwdCIsImNyZWF0ZUVsZW1lbnQiLCJvbmxvYWQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJhcHBlbmRDaGlsZCIsInNldEdsb2JhbCIsInByb3AiLCJ2YWx1ZSIsImdldFN3Zk9iamVjdCIsInN3Zm9iamVjdCIsImdldEVtYmVkT2JqZWN0IiwiZ2V0RWxlbWVudElkIiwiZ2V0QXR0cmlidXRlIiwiZ2V0VmlkZW9KcyIsInZpZGVvanMiLCJhdWRpbyIsInZpZGVvIiwiZ2V0RGVmYXVsdFB1Ymxpc2hDb25zdHJhaW50cyIsIm9mZmVyVG9SZWNlaXZlVmlkZW8iLCJvZmZlclRvUmVjZWl2ZUF1ZGlvIiwiZ2V0SXNNb3oiLCJhZGRDbG9zZUhhbmRsZXIiLCJoYW5kbGVyIiwiaW5zZXJ0VmFsdWUiLCJzbGljZSIsIm9uYmVmb3JldW5sb2FkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUNsb3NlSGFuZGxlciIsImludm9rZSIsIm9uT3JpZW50YXRpb25NZXRhZGF0YSIsImVsZW1lbnQiLCJ0cmFuc2xhdGlvbnMiLCJzdHlsZSIsIl9EZWZlcnJlZFByb21pc2UiLCJQcm9taXNlIiwiX0Z1dHVyZSIsImNyZWF0ZUlmTm90RXhpc3QiLCJkZWZlcnJlZElmRXhpc3QiLCJmIiwiRGVmZXJyZWRQcm9taXNlIiwiRnV0dXJlIiwiTm9FbGVtZW50Rm91bmRFcnJvciIsImpzb25BdHRyIiwianNvblZhbCIsInJlYWRVVEYiLCJzdGFydCIsImxlbiIsInJlc3VsdCIsIm9mZnNldCIsImVuZCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInBhcnNlSlNPTkZvck9yaWVudGF0aW9uIiwidGV4dCIsInBhcnNlIiwicGFyc2VJbnQiLCJleGVjIiwibWF0Y2gyIiwicGxheWVyIiwiY2FsbGJhY2siLCJ0ZXh0VHJhY2tzIiwiYWRkVGV4dFRyYWNrIiwidHJhY2siLCJhZGRUcmFja0V2ZW50IiwibW9kZSIsImN1ZXMiLCJjdWVDaGFuZ2VFdmVudCIsImN1cnJlbnRUYXJnZXQiLCJhY3RpdmVDdWVzIiwic2l6ZSIsIkV2ZW50IiwiX3R5cGUiLCJfZGF0YSIsIlB1Ymxpc2hlckV2ZW50IiwicHVibGlzaGVyIiwiX3B1Ymxpc2hlciIsIlN1YnNjcmliZXJFdmVudCIsIl9zdWJzY3JpYmVyIiwiU2hhcmVkT2JqZWN0RXZlbnQiLCJzaGFyZWRPYmplY3ROYW1lIiwiX25hbWUiLCJTdWJzY3JpcHRpb25Tb2NrZXRIZWxwZXIiLCJyZXNwb25kZXIiLCJqc29uIiwiZ2V0SnNvbkZyb21Tb2NrZXRNZXNzYWdlIiwiX3Jlc3BvbmRlciIsIm9uU0RQT2ZmZXIiLCJvbkFkZEljZUNhbmRpZGF0ZSIsImNvZGUiLCJvblNvY2tldEljZUNhbmRpZGF0ZUVuZCIsIm9uVW5wdWJsaXNoIiwib25Db25uZWN0aW9uQ2xvc2VkIiwic3RhdHVzIiwibWV0aG9kIiwib25TZW5kUmVjZWl2ZWQiLCJvblNvY2tldE1lc3NhZ2VFcnJvciIsIlNvY2tldEhlbHBlciIsIl9wZW5kaW5nUG9zdFJlcXVlc3RzIiwiX3dlYnNvY2tldCIsIl9jb25uZWN0aW9uUHJvbWlzZSIsIl9yZXNwb25zZUhhbmRsZXJzIiwiX29uY2xvc2UiLCJ3cyIsIm9ub3BlbiIsIm9ubWVzc2FnZSIsIm9uZXJyb3IiLCJzaGlmdCIsInJlc3BvbmQiLCJzZXR1cFByb21pc2UiLCJfYWRkU29ja2V0SGFuZGxlcnMiLCJfcmVtb3ZlU29ja2V0SGFuZGxlcnMiLCJjbG9zZSIsInJIYW5kbGVyIiwic2VuZFJlcXVlc3QiLCJzZW5kIiwiaGFuZGxlZCIsImhhbmRsZU1lc3NhZ2VSZXNwb25zZSIsIm9uU3RyZWFtQXZhaWxhYmxlIiwib25TdHJlYW1VbmF2YWlsYWJsZSIsInNoYXJlZE9iamVjdEdldFJlbW90ZSIsInNoYXJlZE9iamVjdENvbm5lY3QiLCJjYWxsTmFtZSIsInNoYXJlZE9iamVjdFNlbmQiLCJzaGFyZWRPYmplY3RTZXRQcm9wZXJ0eSIsInNoYXJlZE9iamVjdENsb3NlIiwiU3Vic2NyaXB0aW9uUGVlckhlbHBlciIsIl9wZWVyQ29ubmVjdGlvbiIsIl9wZW5kaW5nTWVkaWFTdHJlYW0iLCJvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsIm9uaWNlY2FuZGlkYXRlIiwib25hZGRzdHJlYW0iLCJvbnRyYWNrIiwiY29ubmVjdGlvblN0YXRlIiwib25JY2VDYW5kaWRhdGUiLCJvbkljZUNhbmRpZGF0ZVRyaWNrbGVFbmQiLCJvbkFuc3dlck1lZGlhU3RyZWFtIiwic2V0VXBQcm9taXNlIiwicGVlciIsIlJUQ1BlZXJDb25uZWN0aW9uIiwicnRjcE11eFBvbGljeSIsIkR0bHNTcnRwS2V5QWdyZWVtZW50IiwiUnRwRGF0YUNoYW5uZWxzIiwiZ29vZ0NwdU92ZXJ1c2VEZXRlY3Rpb24iLCJfYWRkQ29ubmVjdGlvbkhhbmRsZXJzIiwiX3JlbW92ZUNvbm5lY3Rpb25IYW5kbGVycyIsInNldFJlbW90ZURlc2NyaXB0aW9uIiwib25TRFBTdWNjZXNzIiwic2V0TG9jYWxEZXNjcmlwdGlvbiIsImljZUNhbmRpZGF0ZSIsIlJUQ0ljZUNhbmRpZGF0ZSIsInNkcE1MaW5lSW5kZXgiLCJfUlRDUGVlckNvbm5lY3Rpb24iLCJtb3pSVENQZWVyQ29ubmVjdGlvbiIsIndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uIiwiX1JUQ0ljZUNhbmRpZGF0ZSIsIm1velJUQ0ljZUNhbmRpZGF0ZSIsIndlYmtpdFJUQ0ljZUNhbmRpZGF0ZSIsIl9SVENTZXNzaW9uRGVzY3JpcHRpb24iLCJtb3pSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJ3ZWJraXRSVENTZXNzaW9uRGVzY3JpcHRpb24iLCJtaW1lVHlwZSIsInN3ZiIsIm9wdGlvbnNUb0hsc1VSTCIsImhsc3Byb3RvY29sIiwiaGxzcG9ydCIsIl92aWRlb2pzSGFuZGxlciIsIl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudHMiLCJidWJibGVTdWJzY3JpYmVyRXZlbnRzIiwiZGlzY29ubmVjdCIsInVybFJlZ2V4Iiwic3dmVVJMIiwicnRtcE1pbWVUeXBlIiwiYWRkU291cmNlIiwiZ2V0UGxheWVyIiwib3B0aW9uc1RvVVJMIiwiQmFzZUhhbmRsZXIiLCJwbGF5ZXJUeXBlIiwiY2xvbmUiLCJjbG9uZU5vZGUiLCJob2xkZXIiLCJwYXJlbnROb2RlIiwiaGFzQXNzaWduZWRFdmVudExpc3RlbmVycyIsIm9uVmlkZW9KU0Vycm9yIiwib25WaWRlb0pTTG9hZGVkRGF0YSIsIm9uVmlkZW9KU0xvYWRlZE1ldGFkYXRhIiwib25WaWRlb0pTVGltZVVwZGF0ZSIsIm9uVmlkZW9KU1VzZXJBY3RpdmUiLCJvblZpZGVvSlNVc2VySW5hY3RpdmUiLCJvblZpZGVvSlNWb2x1bWVDaGFuZ2UiLCJvblZpZGVvSlNFbmRlZCIsInJlbW92ZSIsInJlbW92ZVZpZGVvSlNFdmVudExpc3RlbmVycyIsImRpc3Bvc2UiLCJ2aWRlb0ltcGwiLCJzZWxmIiwiY3JlYXRlU291cmNlIiwiX3NyYyIsInNvdXJjZUVsIiwiaW5zZXJ0U291cmNlSW50byIsIl9wYXJlbnQiLCJmaXJzdENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwiY2xlYW51cCIsImNsZWFudXBWaWRlb0pTIiwic3JjVVJMIiwib3B0cyIsInRlY2hPcmRlciIsImFkZFZpZGVvSlNFdmVudExpc3RlbmVycyIsInBhdXNlIiwiZGVlcERlZmluZSIsIm9iamVjdCIsInBhdGhzIiwidGFpbCIsInBvcCIsInBhdGgiLCJSVE1QU3Vic2NyaWJlclByb3h5IiwiX2JvdW5kQnViYmxlU3ViSW1wbEV2ZW50IiwiaW1wbCIsInVzZVZpZGVvSlMiLCJpbml0IiwiZGVmYXVsdE1pbWVUeXBlIiwiZGVmYXVsdEZsYXNoVmVyc2lvbiIsImRlZmF1bHRTV0YiLCJvcHRpb25zVG9SdG1wVVJMIiwicnRtcHByb3RvY29sIiwicnRtcHBvcnQiLCJ3aWR0aCIsImhlaWdodCIsImVtYmVkV2lkdGgiLCJlbWJlZEhlaWdodCIsIm1pbkZsYXNoVmVyc2lvbiIsInN3Zm9iamVjdFVSTCIsInByb2R1Y3RJbnN0YWxsVXJsIiwiX3NvdXJjZUhhbmRsZXIiLCJfZWxlbWVudElkIiwiX3BsYXliYWNrUHJvbWlzZSIsImVsZW1lbnRJZCIsImludm9rZUZuIiwibGFiZWwiLCJwYXlsb2FkIiwiX2VzdGFibGlzaEV4dEludEhhbmRsZXJzIiwiY2IiLCJlbWJlZCIsInRvSW50Iiwicm91bmQiLCJMaXZlU291cmNlSGFuZGxlciIsInNvUmVzcG9uZGVyIiwiX3N3ZklkIiwiX3NvUmVzcG9uZGVyIiwic2V0U3Vic2NyaWJlcklkIiwic3VjY2Vzc0lkIiwiX3RlYXJEb3duSW5pdENhbGxiYWNrIiwic2V0QWN0aXZlSWQiLCJzd2ZJZCIsInN3ZlVybCIsIl9zZXRVcEluaXRDYWxsYmFjayIsImRlZmluZUVtYmVkRWxlbWVudCIsImZsYXNodmFycyIsImJ1ZmZlciIsImlzTmFOIiwiTnVtYmVyIiwiYXV0b3NpemUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJlbWJlZFN3Zk9iamVjdCIsImNvbm5lY3QiLCJjbGVhblVwIiwiYWRkUmVzcG9uc2VIYW5kbGVyIiwicmVtb3ZlUmVzcG9uc2VIYW5kbGVyIiwic2VuZFRvU2hhcmVkT2JqZWN0Iiwic2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QiLCJnZXRSZW1vdGVTaGFyZWRPYmplY3QiLCJjb25uZWN0VG9TaGFyZWRPYmplY3QiLCJjbG9zZVNoYXJlZE9iamVjdCIsInRhcmdldEVsZW1lbnQiLCJ0YXJnZXRQYXJlbnQiLCJub2RlTmFtZSIsImRpdiIsImlkTmFtZSIsInF1YWxpdHkiLCJiZ2NvbG9yIiwiYWxsb3dzY3JpcHRhY2Nlc3MiLCJhbGxvd2Z1bGxzY3JlZW4iLCJhdHRyaWJ1dGVzIiwiYWxpZ24iLCJoYXNGbGFzaFBsYXllclZlcnNpb24iLCJlbWJlZFNXRiIsInByb2R1Y3RJbnN0YWxsVVJMIiwiUlRNUFNoYXJlZE9iamVjdEhhbmRsZXIiLCJfZWxlbWVudCIsIl9oYW5kbGVTaGFyZWRPYmplY3RFdmVudCIsImhhbmRsZVNoYXJlZE9iamVjdEV2ZW50IiwiZWxJZCIsImhhbmRsZXJOYW1lIiwic2V0U2hhcmVkT2JqZWN0UmVzcG9uZGVyIiwic2hhcmVkT2JqZWN0U2VuZFByb3BlcnR5IiwiYXNzaWduU2hhcmVkT2JqZWN0UmVzcG9uZGVyIiwiZGlzY29ubmVjdEZyb21TaGFyZWRPYmplY3QiLCJXZWFrTWFwIiwicHZ0IiwiY3R4IiwiaGFzIiwiZ2V0IiwiSW1wbEZhY3RvcnlPcmRlciIsImxpc3RvcmRlciIsImZpbmQiLCJpdGVyYXRvciIsImluaXRGbiIsIm5leHQiLCJJbXBsIiwiY29uY3JldGUiLCJkb25lIiwicHVibGlzaEZhY3RvcnkiLCJwdWJsaXNoZXJJbXBsIiwiX2N1cnJlbnRQdWJsaXNoZXIiLCJfYm91bmRCdWJibGVQdWJsaXNoZXJFdmVudCIsImJ1YmJsZVB1Ymxpc2hlckV2ZW50IiwicHVibGlzaFZpZXciLCJnZXRQdWJsaXNoZXJGcm9tT3JkZXIiLCJ1bnB1Ymxpc2giLCJwdWJsaXNoZXJFdmVudCIsInN0cmVhbU1vZGUiLCJfY29ubmVjdEZ1dHVyZSIsIl90ZWFyRG93bkNvbm5lY3RDYWxsYmFjayIsIl9zZXRVcENvbm5lY3RDYWxsYmFjayIsInB1Ymxpc2hPcHRpb25zIiwic3JjSGFuZGxlciIsImdldEVtYmVkT3BlcmF0aW9uIiwiY291bnQiLCJsaW1pdCIsInRyeUNvbm5lY3QiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInNldE1lZGlhUXVhbGl0eSIsIm5ld09wdGlvbnMiLCJQdWJsaXNoVHlwZXMiLCJQdWJsaXNoTW9kZVR5cGVzIiwiTElWRSIsIlJFQ09SRCIsIkFQUEVORCIsIlB1Ymxpc2hlclNvdXJjZUhhbmRsZXIiLCJwdWJsaXNoZXJUeXBlIiwiX2VtYmVkRnV0dXJlIiwiYXBwTmFtZSIsInJvb21OYW1lIiwidyIsImgiLCJ1cGRhdGVSZXNvbHV0aW9uIiwicHViU3RhcnRSZWdleCIsInB1YlN0b3BSZWdleCIsIl9tZWRpYVN0cmVhbSIsIl9zdHJlYW1GdXR1cmUiLCJfYXZhaWxhYmxlRnV0dXJlIiwiX3BlZXJGdXR1cmUiLCJfb2ZmZXJGdXR1cmUiLCJfc2VuZE9mZmVyRnV0dXJlIiwiX3RyaWNrbGVFbmRGdXR1cmUiLCJfcHVibGlzaEZ1dHVyZSIsIl91bnB1Ymxpc2hGdXR1cmUiLCJtZWRpYSIsImdldFRyYWNrcyIsInRyYWNrcyIsInRyYWNrTGVuZ3RoIiwiYnVuZGxlIiwiY3JlYXRlT2ZmZXIiLCJfc2VuZE9mZkZ1dHVyZSIsImhhbmRsZU9mZmVyIiwicHVibGlzaCIsIl9nZXRUcmlja2xlRW5kIiwiX2dldE1lZGlhU3RyZWFtIiwiY3JlYXRlUGVlckNvbm5lY3Rpb24iLCJhZGRTdHJlYW0iLCJzZW5kT2ZmZXIiLCJyZXF1ZXN0UHVibGlzaCIsImNsZWFySGVscGVycyIsInJlcXVlc3RVbnB1Ymxpc2giLCJtdXRlIiwic3RvcFJlc3VsdCIsInN0YXJ0UmVzdWx0IiwiUHVibGlzaGVyU29ja2V0SGVscGVyIiwib25TRFBBbnN3ZXIiLCJvblB1Ymxpc2hlclN0YXR1cyIsIlB1Ymxpc2hlclBlZXJIZWxwZXIiLCJvZmZlclByb21pc2UiLCJzb05hbWUiLCJTT19TVUJUWVBFX1BST1BFUlRZIiwiU09fU1VCVFlQRV9NRVRIT0QiLCJkZWNvZGVNZXNzYWdlSWZKU09OU3RyaW5nIiwiUHJvcGVydHlEYXRhIiwib2JqIiwiTWV0aG9kRGF0YSIsIm1lc3NhZ2VMaXN0IiwicHJvdG90eXBlIiwiX3NvY2tldCIsImdldENvbm5lY3Rpb24iLCJhZGRTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIiLCJ2YWx1ZU9iamVjdCIsInRvT2JqZWN0IiwiZXZlbnRzIiwic3VidHlwZSIsImF0dHJpYnV0ZSIsIm5vdGlmeU9mRXZlbnRzIiwibm90aWZ5T2ZQcm9wZXJ0eVZhbHVlcyIsIm1lc3NhZ2VOYW1lIiwicmVtb3ZlU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyIiwicGxheWJhY2tJZCIsIl90YXJnZXRFbGVtZW50IiwicHVibGlzaGVySWQiLCJQdWJsaXNoVmlldyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7OztBQzNCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNMRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ2pCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHOzs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDTkQ7QUFDQTs7QUFFQSw2QkFBNEIsZ0JBQWdCLDZCQUE2QixHQUFH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O0FDOUJ4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDZEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVELHNDOzs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDVEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDVEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxlOzs7Ozs7QUNORDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLGE7Ozs7OztBQ05EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVU7QUFDVixFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUM3QkQsMEM7Ozs7OztBQ0FBLHVDOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDbEJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDUkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxHOzs7Ozs7QUNmQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLDZEQUE2RDtBQUN2RztBQUNBLEVBQUMsRTs7Ozs7O0FDWEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsYUFBYTtBQUN6RDtBQUNBLEVBQUMsRTs7Ozs7O0FDTkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsNkRBQTZEO0FBQ3ZHO0FBQ0EsRUFBQyxFOzs7Ozs7QUNYRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUMsRTs7Ozs7O0FDakJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsRUFBQyxFOzs7Ozs7QUNqQkQ7QUFDQTs7QUFFQSx3Q0FBdUMsd0NBQWdELEU7Ozs7OztBQ0h2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDUkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ05BO0FBQ0E7O0FBRUEsd0NBQXVDLHdDQUFnRCxFOzs7Ozs7QUNIdkY7QUFDQTs7QUFFQSwrQkFBOEIsK0JBQTZCLEU7Ozs7OztBQ0gzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDLEU7Ozs7OztBQ1ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNmRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDZkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0EsR0FBRSxFOzs7Ozs7QUNQRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBc0QsZ0JBQWdCLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFLEU7Ozs7OztBQ2RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0EsR0FBRSxFOzs7Ozs7QUNoQkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0EsR0FBRSxFOzs7Ozs7QUNsQkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0E7QUFDQSxHQUFFLEU7Ozs7OztBQ1JGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWM7QUFDZDtBQUNBLEdBQUUsRTs7Ozs7O0FDUEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBYztBQUNkO0FBQ0EsR0FBRSxFOzs7Ozs7QUNmRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBLEdBQUUsRTs7Ozs7O0FDUkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFLEU7Ozs7OztBQ2RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsRTs7Ozs7O0FDWEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBd0UsNEJBQTRCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBLHdDQUF1QztBQUN2Qyx1Q0FBc0MseUJBQXlCO0FBQy9ELEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGdEQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsUUFBTztBQUNQLHlCQUF3QixhQUFhO0FBQ3JDLE1BQUs7QUFDTCxJQUFHO0FBQ0g7QUFDQSwyREFBMEQsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLFFBQU87QUFDUCx5QkFBd0IsYUFBYTtBQUNyQyxNQUFLO0FBQ0w7QUFDQSxFQUFDOztBQUVELG9EQUFtRCxhQUFhLEVBQUU7O0FBRWxFLHFCQUFvQix3QkFBd0I7O0FBRTVDLHdDOzs7Ozs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNuQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDdEJBLHlDOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQyxFOzs7Ozs7QUNMRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUdBQXdHLE9BQU87QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2QsTUFBSztBQUNMLGVBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx5Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUEsWUFBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzcEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCLFVBQVU7Ozs7Ozs7QUNuTHRDO0FBQ0EsdUQ7Ozs7OztBQ0RBO0FBQ0E7QUFDQSwwREFBdUQ7O0FBRXZELCtCQUE4Qiw0QkFBNEIsZ0JBQWdCLEdBQUc7Ozs7Ozs7QUNKN0U7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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QUFDdEIscUJBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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WjtBQUNBLFdBQUk7QUFDRixjQUFLMGxCLGNBQUwsQ0FBb0J0TSxLQUFwQjtBQUNELFFBRkQsQ0FFRSxPQUFPN1EsQ0FBUCxFQUFVO0FBQ1Ysd0JBQUt2SSxJQUFMLHFDQUE0Q3VJLEVBQUVuTixPQUE5QztBQUNEO0FBQ0Y7Ozt5QkFFVztBQUNWLGNBQU8sS0FBS3NxQixjQUFaO0FBQ0Q7Ozs7OzttQkFJWXJyQixZOzs7Ozs7QUM3Q2Y7Ozs7Ozs7O0FBRUE7Ozs7QUFFQTs7Ozs7O0FBQ0EsS0FBTTJGLE9BQU8sa0JBQWI7O0FBRUEsS0FBTTJsQixjQUFjLG1CQUFwQjs7S0FFTUMsVztBQUVKLDBCQUFzQztBQUFBLFNBQXpCNUssU0FBeUIsdUVBQWIySyxXQUFhOztBQUFBOztBQUNwQyxTQUFJO0FBQ0YsWUFBS0QsY0FBTCxHQUFzQixrQkFBWXZhLGNBQVosQ0FBMkI2UCxTQUEzQixDQUF0QjtBQUNELE1BRkQsQ0FFRSxPQUFPelMsQ0FBUCxFQUFVO0FBQ1YsdUJBQU12SSxJQUFOLHlFQUFpRnVJLEVBQUVuTixPQUFuRjtBQUNBLGFBQU1tTixDQUFOO0FBQ0Q7QUFDRjs7OztxQ0FFZ0J1SSxTLEVBQVc7QUFDMUIsdUJBQU05USxJQUFOLEVBQVksbUJBQVo7QUFDQThRLGlCQUFVbFAsT0FBVixDQUFrQixJQUFsQixFQUF3QixrQkFBWW1MLFlBQVosQ0FBeUIsS0FBSzJZLGNBQTlCLENBQXhCO0FBQ0Q7Ozs2QkFFUS9aLFcsRUFBK0I7QUFBQSxXQUFsQnZFLFFBQWtCLHVFQUFQLEtBQU87O0FBQ3RDLHVCQUFNcEgsSUFBTiwyQkFBbUNvSCxRQUFuQztBQUNBLHlCQUFZcUUsY0FBWixDQUEyQixLQUFLaWEsY0FBaEMsRUFBZ0QvWixXQUFoRCxFQUE2RHZFLFFBQTdEO0FBQ0Q7Ozt5QkFFVztBQUNWLGNBQU8sS0FBS3NlLGNBQVo7QUFDRDs7Ozs7O21CQUlZRSxXIiwiZmlsZSI6InJlZDVwcm8tc2RrLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wicmVkNXByb3Nka1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJyZWQ1cHJvc2RrXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uXG4gKiovIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCAzNmRjYjBiOTRiNmNiNDg3ODI1MVxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9zaGltXCIpO1xuXG5yZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lXCIpO1xuXG5yZXF1aXJlKFwiY29yZS1qcy9mbi9yZWdleHAvZXNjYXBlXCIpO1xuXG5pZiAoZ2xvYmFsLl9iYWJlbFBvbHlmaWxsKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIm9ubHkgb25lIGluc3RhbmNlIG9mIGJhYmVsLXBvbHlmaWxsIGlzIGFsbG93ZWRcIik7XG59XG5nbG9iYWwuX2JhYmVsUG9seWZpbGwgPSB0cnVlO1xuXG52YXIgREVGSU5FX1BST1BFUlRZID0gXCJkZWZpbmVQcm9wZXJ0eVwiO1xuZnVuY3Rpb24gZGVmaW5lKE8sIGtleSwgdmFsdWUpIHtcbiAgT1trZXldIHx8IE9iamVjdFtERUZJTkVfUFJPUEVSVFldKE8sIGtleSwge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59XG5cbmRlZmluZShTdHJpbmcucHJvdG90eXBlLCBcInBhZExlZnRcIiwgXCJcIi5wYWRTdGFydCk7XG5kZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgXCJwYWRSaWdodFwiLCBcIlwiLnBhZEVuZCk7XG5cblwicG9wLHJldmVyc2Usc2hpZnQsa2V5cyx2YWx1ZXMsZW50cmllcyxpbmRleE9mLGV2ZXJ5LHNvbWUsZm9yRWFjaCxtYXAsZmlsdGVyLGZpbmQsZmluZEluZGV4LGluY2x1ZGVzLGpvaW4sc2xpY2UsY29uY2F0LHB1c2gsc3BsaWNlLHVuc2hpZnQsc29ydCxsYXN0SW5kZXhPZixyZWR1Y2UscmVkdWNlUmlnaHQsY29weVdpdGhpbixmaWxsXCIuc3BsaXQoXCIsXCIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBbXVtrZXldICYmIGRlZmluZShBcnJheSwga2V5LCBGdW5jdGlvbi5jYWxsLmJpbmQoW11ba2V5XSkpO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vYmFiZWwtcG9seWZpbGwvbGliL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5mcmVlemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNlYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1zZWFsZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uaGFzLWluc3RhbmNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnRvLWZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtbmFuJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLm1pbi1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmFzaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYXRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jYnJ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2x6MzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5jb3NoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5mcm91bmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5oeXBvdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmltdWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxMCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnNpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgudGFuaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRydW5jJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJhdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmVuZHMtd2l0aCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnJlcGVhdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmFuY2hvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5ibGluaycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYm9sZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZml4ZWQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udHNpemUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0YWxpY3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1YicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUubm93Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1wcmltaXRpdmUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaXMtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZnJvbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5qb2luJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnNvcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb21lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UtcmlnaHQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmluZC1pbmRleCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAubWF0Y2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnJlcGxhY2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucHJvbWlzZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LndlYWstc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5kYXRhLXZpZXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQzMi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuYXBwbHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5kZWxldGUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcuYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1sZWZ0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy50cmltLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5tYXRjaC1hbGwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC52YWx1ZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0LmRlZmluZS1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1nZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWFwLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5lcnJvci5pcy1lcnJvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlhZGRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaXN1YmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pbXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLnVtdWxoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVsZXRlLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW1ldGFkYXRhLWtleXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lm1ldGFkYXRhJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LmFzYXAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi50aW1lcnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21vZHVsZXMvX2NvcmUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL3NoaW0uanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBERVNDUklQVE9SUyAgICA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgTUVUQSAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuS0VZXG4gICwgJGZhaWxzICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgc2hhcmVkICAgICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIHVpZCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCB3a3MgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcbiAgLCB3a3NEZWZpbmUgICAgICA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKVxuICAsIGtleU9mICAgICAgICAgID0gcmVxdWlyZSgnLi9fa2V5b2YnKVxuICAsIGVudW1LZXlzICAgICAgID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJylcbiAgLCBpc0FycmF5ICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5JylcbiAgLCBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBfY3JlYXRlICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGdPUE5FeHQgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JylcbiAgLCAkR09QRCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCAkRFAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgJGtleXMgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QRCAgICAgICAgICAgPSAkR09QRC5mXG4gICwgZFAgICAgICAgICAgICAgPSAkRFAuZlxuICAsIGdPUE4gICAgICAgICAgID0gZ09QTkV4dC5mXG4gICwgJFN5bWJvbCAgICAgICAgPSBnbG9iYWwuU3ltYm9sXG4gICwgJEpTT04gICAgICAgICAgPSBnbG9iYWwuSlNPTlxuICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XG4gICwgUFJPVE9UWVBFICAgICAgPSAncHJvdG90eXBlJ1xuICAsIEhJRERFTiAgICAgICAgID0gd2tzKCdfaGlkZGVuJylcbiAgLCBUT19QUklNSVRJVkUgICA9IHdrcygndG9QcmltaXRpdmUnKVxuICAsIGlzRW51bSAgICAgICAgID0ge30ucHJvcGVydHlJc0VudW1lcmFibGVcbiAgLCBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5JylcbiAgLCBBbGxTeW1ib2xzICAgICA9IHNoYXJlZCgnc3ltYm9scycpXG4gICwgT1BTeW1ib2xzICAgICAgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKVxuICAsIE9iamVjdFByb3RvICAgID0gT2JqZWN0W1BST1RPVFlQRV1cbiAgLCBVU0VfTkFUSVZFICAgICA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbidcbiAgLCBRT2JqZWN0ICAgICAgICA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7dmFsdWU6IDd9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYocHJvdG9EZXNjKWRlbGV0ZSBPYmplY3RQcm90b1trZXldO1xuICBkUChpdCwga2V5LCBEKTtcbiAgaWYocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bylkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8pJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xuICAgIGlmKCFELmVudW1lcmFibGUpe1xuICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxuICAgICwgaSAgICA9IDBcbiAgICAsIGwgPSBrZXlzLmxlbmd0aFxuICAgICwga2V5O1xuICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZih0aGlzID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSlyZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgaXQgID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybjtcbiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpO1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnT1BOKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcbiAgdmFyIElTX09QICA9IGl0ID09PSBPYmplY3RQcm90b1xuICAgICwgbmFtZXMgID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKXtcbiAgICBpZihoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pXG5pZighVVNFX05BVElWRSl7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKXtcbiAgICBpZih0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmKHRoaXMgPT09IE9iamVjdFByb3RvKSRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZihERVNDUklQVE9SUyAmJiBzZXR0ZXIpc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7Y29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXR9KTtcbiAgICByZXR1cm4gd3JhcCh0YWcpO1xuICB9O1xuICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiAgID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5Jykpe1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHtTeW1ib2w6ICRTeW1ib2x9KTtcblxuZm9yKHZhciBzeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3Moc3ltYm9sc1tpKytdKTtcblxuZm9yKHZhciBzeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrc0RlZmluZShzeW1ib2xzW2krK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uKGtleSl7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihrZXkpe1xuICAgIGlmKGlzU3ltYm9sKGtleSkpcmV0dXJuIGtleU9mKFN5bWJvbFJlZ2lzdHJ5LCBrZXkpO1xuICAgIHRocm93IFR5cGVFcnJvcihrZXkgKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uKCl7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHZhciBTID0gJFN5bWJvbCgpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcbiAgLy8gVjggdGhyb3dzIG9uIGJveGVkIHN5bWJvbHNcbiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHthOiBTfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KXtcbiAgICBpZihpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSlyZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICB2YXIgYXJncyA9IFtpdF1cbiAgICAgICwgaSAgICA9IDFcbiAgICAgICwgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZih0eXBlb2YgcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICBpZigkcmVwbGFjZXIgfHwgIWlzQXJyYXkocmVwbGFjZXIpKXJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSl7XG4gICAgICBpZigkcmVwbGFjZXIpdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmKCFpc1N5bWJvbCh2YWx1ZSkpcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBfc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmdzKTtcbiAgfVxufSk7XG5cbi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludClcbiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IHJlcXVpcmUoJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faGFzLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSlcbiAgICAsIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZih0YXJnZXQpcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYoZXhwb3J0c1trZXldICE9IG91dCloaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZihJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dClleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYml0bWFwLCB2YWx1ZSl7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZSAgOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWUgICAgICAgOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBTUkMgICAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJylcbiAgLCBUT19TVFJJTkcgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXVxuICAsIFRQTCAgICAgICA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBrZXksIHZhbCwgc2FmZSl7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYoT1trZXldID09PSB2YWwpcmV0dXJuO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZihPID09PSBnbG9iYWwpe1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBpZighc2FmZSl7XG4gICAgICBkZWxldGUgT1trZXldO1xuICAgICAgaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKE9ba2V5XSlPW2tleV0gPSB2YWw7XG4gICAgICBlbHNlIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaWQgPSAwXG4gICwgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3VpZC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgTUVUQSAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpXG4gICwgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGhhcyAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBzZXREZXNjICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBpZCAgICAgICA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbihpdCl7XG4gIHNldERlc2MoaXQsIE1FVEEsIHt2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH19KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgaWYoIWhhcyhpdCwgTUVUQSkpe1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYoIWlzRXh0ZW5zaWJsZShpdCkpcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24oaXQpe1xuICBpZihGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6ICAgICAgTUVUQSxcbiAgTkVFRDogICAgIGZhbHNlLFxuICBmYXN0S2V5OiAgZmFzdEtleSxcbiAgZ2V0V2VhazogIGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX21ldGEuanNcbiAqKiBtb2R1bGUgaWQgPSAyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIHRhZywgc3RhdCl7XG4gIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc3RvcmUgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKVxuICAsIHVpZCAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIFN5bWJvbCAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2xcbiAgLCBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1xuICoqIG1vZHVsZSBpZCA9IDI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgd2tzRXh0ICAgICAgICAgPSByZXF1aXJlKCcuL193a3MtZXh0JylcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG5hbWUpe1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2tleW9mLmpzXG4gKiogbW9kdWxlIGlkID0gMjlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qc1xuICoqIG1vZHVsZSBpZCA9IDM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgdG9JbmRleCAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLWxlbmd0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtYXggICAgICAgPSBNYXRoLm1heFxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL190by1pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbiAqKiBtb2R1bGUgaWQgPSA0MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHJlc3VsdCAgICAgPSBnZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gcElFLmZcbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanNcbiAqKiBtb2R1bGUgaWQgPSA0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBkUHMgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBFbXB0eSAgICAgICA9IGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovIH1cbiAgLCBQUk9UT1RZUEUgICA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uKCl7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpXG4gICAgLCBpICAgICAgPSBlbnVtQnVnS2V5cy5sZW5ndGhcbiAgICAsIGx0ICAgICA9ICc8J1xuICAgICwgZ3QgICAgID0gJz4nXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpe1xuICB2YXIgcmVzdWx0O1xuICBpZihPICE9PSBudWxsKXtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5O1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIFA7XG4gIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGdPUE4gICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24oaXQpe1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpe1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qc1xuICoqIG1vZHVsZSBpZCA9IDUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgcElFICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCBnT1BEICAgICAgICAgICA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApe1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoaGFzKE8sIFApKXJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1xuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2NyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjMgLyAxNS4yLjMuNyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0aWVzOiByZXF1aXJlKCcuL19vYmplY3QtZHBzJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0lPYmplY3QoaXQpLCBrZXkpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcbiAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KXtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gNTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcbiAgLCBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmKGhhcyhPLCBJRV9QUk9UTykpcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1xuICoqIG1vZHVsZSBpZCA9IDU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGtleXMgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5TmFtZXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0JykuZjtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktbmFtZXMuanNcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjUgT2JqZWN0LmZyZWV6ZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdmcmVlemUnLCBmdW5jdGlvbigkZnJlZXplKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZyZWV6ZShpdCl7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgaXNPYmplY3QoaXQpID8gJGZyZWV6ZShtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmZyZWV6ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDYyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMTcgT2JqZWN0LnNlYWwoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgbWV0YSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnc2VhbCcsIGZ1bmN0aW9uKCRzZWFsKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYWwoaXQpe1xuICAgIHJldHVybiAkc2VhbCAmJiBpc09iamVjdChpdCkgPyAkc2VhbChtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanNcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjE1IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdwcmV2ZW50RXh0ZW5zaW9ucycsIGZ1bmN0aW9uKCRwcmV2ZW50RXh0ZW5zaW9ucyl7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhpdCl7XG4gICAgcmV0dXJuICRwcmV2ZW50RXh0ZW5zaW9ucyAmJiBpc09iamVjdChpdCkgPyAkcHJldmVudEV4dGVuc2lvbnMobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjEyIE9iamVjdC5pc0Zyb3plbihPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNGcm96ZW4nLCBmdW5jdGlvbigkaXNGcm96ZW4pe1xuICByZXR1cm4gZnVuY3Rpb24gaXNGcm96ZW4oaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNGcm96ZW4gPyAkaXNGcm96ZW4oaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZnJvemVuLmpzXG4gKiogbW9kdWxlIGlkID0gNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMi4xMyBPYmplY3QuaXNTZWFsZWQoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzU2VhbGVkJywgZnVuY3Rpb24oJGlzU2VhbGVkKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzU2VhbGVkKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzU2VhbGVkID8gJGlzU2VhbGVkKGl0KSA6IGZhbHNlIDogdHJ1ZTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLXNlYWxlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMTEgT2JqZWN0LmlzRXh0ZW5zaWJsZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNFeHRlbnNpYmxlJywgZnVuY3Rpb24oJGlzRXh0ZW5zaWJsZSl7XG4gIHJldHVybiBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNFeHRlbnNpYmxlID8gJGlzRXh0ZW5zaWJsZShpdCkgOiB0cnVlIDogZmFsc2U7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZ09QUyAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJylcbiAgLCB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSU9iamVjdCAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCAkYXNzaWduICA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBBID0ge31cbiAgICAsIEIgPSB7fVxuICAgICwgUyA9IFN5bWJvbCgpXG4gICAgLCBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oayl7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgICAgID0gdG9PYmplY3QodGFyZ2V0KVxuICAgICwgYUxlbiAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBpbmRleCA9IDFcbiAgICAsIGdldFN5bWJvbHMgPSBnT1BTLmZcbiAgICAsIGlzRW51bSAgICAgPSBwSUUuZjtcbiAgd2hpbGUoYUxlbiA+IGluZGV4KXtcbiAgICB2YXIgUyAgICAgID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pXG4gICAgICAsIGtleXMgICA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaiAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gailpZihpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKVRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qc1xuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjMuMTAgT2JqZWN0LmlzKHZhbHVlMSwgdmFsdWUyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2lzOiByZXF1aXJlKCcuL19zYW1lLXZhbHVlJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy5qc1xuICoqIG1vZHVsZSBpZCA9IDcwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjIuOSBTYW1lVmFsdWUoeCwgeSlcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uIGlzKHgsIHkpe1xuICByZXR1cm4geCA9PT0geSA/IHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5IDogeCAhPSB4ICYmIHkgIT0geTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzXG4gKiogbW9kdWxlIGlkID0gNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldH0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24oTywgcHJvdG8pe1xuICBhbk9iamVjdChPKTtcbiAgaWYoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCl0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbih0ZXN0LCBidWdneSwgc2V0KXtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoKGUpeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90byl7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYoYnVnZ3kpTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzXG4gKiogbW9kdWxlIGlkID0gNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCB0ZXN0ICAgID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXG4gIC8vIEVTMyB3cm9uZyBoZXJlXG4gICwgQVJHID0gY29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24oaXQsIGtleSl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdGdW5jdGlvbicsIHtiaW5kOiByZXF1aXJlKCcuL19iaW5kJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanNcbiAqKiBtb2R1bGUgaWQgPSA3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2VcbiAgLCBmYWN0b3JpZXMgID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbihGLCBsZW4sIGFyZ3Mpe1xuICBpZighKGxlbiBpbiBmYWN0b3JpZXMpKXtcbiAgICBmb3IodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKyluW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyosIGFyZ3MuLi4gKi8pe1xuICB2YXIgZm4gICAgICAgPSBhRnVuY3Rpb24odGhpcylcbiAgICAsIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uKC8qIGFyZ3MuLi4gKi8pe1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuICBpZihpc09iamVjdChmbi5wcm90b3R5cGUpKWJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanNcbiAqKiBtb2R1bGUgaWQgPSA3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzXG4gKiogbW9kdWxlIGlkID0gNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBoYXMgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBGUHJvdG8gICAgID0gRnVuY3Rpb24ucHJvdG90eXBlXG4gICwgbmFtZVJFICAgICA9IC9eXFxzKmZ1bmN0aW9uIChbXiAoXSopL1xuICAsIE5BTUUgICAgICAgPSAnbmFtZSc7XG5cbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gMTkuMi40LjIgbmFtZVxuTkFNRSBpbiBGUHJvdG8gfHwgcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiBkUChGUHJvdG8sIE5BTUUsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgICAsIG5hbWUgPSAoJycgKyB0aGF0KS5tYXRjaChuYW1lUkUpWzFdO1xuICAgICAgaGFzKHRoYXQsIE5BTUUpIHx8ICFpc0V4dGVuc2libGUodGhhdCkgfHwgZFAodGhhdCwgTkFNRSwgY3JlYXRlRGVzYyg1LCBuYW1lKSk7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBIQVNfSU5TVEFOQ0UgICA9IHJlcXVpcmUoJy4vX3drcycpKCdoYXNJbnN0YW5jZScpXG4gICwgRnVuY3Rpb25Qcm90byAgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyAxOS4yLjMuNiBGdW5jdGlvbi5wcm90b3R5cGVbQEBoYXNJbnN0YW5jZV0oVilcbmlmKCEoSEFTX0lOU1RBTkNFIGluIEZ1bmN0aW9uUHJvdG8pKXJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoRnVuY3Rpb25Qcm90bywgSEFTX0lOU1RBTkNFLCB7dmFsdWU6IGZ1bmN0aW9uKE8pe1xuICBpZih0eXBlb2YgdGhpcyAhPSAnZnVuY3Rpb24nIHx8ICFpc09iamVjdChPKSlyZXR1cm4gZmFsc2U7XG4gIGlmKCFpc09iamVjdCh0aGlzLnByb3RvdHlwZSkpcmV0dXJuIE8gaW5zdGFuY2VvZiB0aGlzO1xuICAvLyBmb3IgZW52aXJvbm1lbnQgdy9vIG5hdGl2ZSBgQEBoYXNJbnN0YW5jZWAgbG9naWMgZW5vdWdoIGBpbnN0YW5jZW9mYCwgYnV0IGFkZCB0aGlzOlxuICB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpaWYodGhpcy5wcm90b3R5cGUgPT09IE8pcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn19KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qc1xuICoqIG1vZHVsZSBpZCA9IDgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDE4LjIuNSBwYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VJbnQgIT0gJHBhcnNlSW50KSwge3BhcnNlSW50OiAkcGFyc2VJbnR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qc1xuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VJbnRcbiAgLCAkdHJpbSAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW1cbiAgLCB3cyAgICAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKVxuICAsIGhleCAgICAgICA9IC9eW1xcLStdPzBbeFhdLztcblxubW9kdWxlLmV4cG9ydHMgPSAkcGFyc2VJbnQod3MgKyAnMDgnKSAhPT0gOCB8fCAkcGFyc2VJbnQod3MgKyAnMHgxNicpICE9PSAyMiA/IGZ1bmN0aW9uIHBhcnNlSW50KHN0ciwgcmFkaXgpe1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpO1xuICByZXR1cm4gJHBhcnNlSW50KHN0cmluZywgKHJhZGl4ID4+PiAwKSB8fCAoaGV4LnRlc3Qoc3RyaW5nKSA/IDE2IDogMTApKTtcbn0gOiAkcGFyc2VJbnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19wYXJzZS1pbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIHNwYWNlcyAgPSByZXF1aXJlKCcuL19zdHJpbmctd3MnKVxuICAsIHNwYWNlICAgPSAnWycgKyBzcGFjZXMgKyAnXSdcbiAgLCBub24gICAgID0gJ1xcdTIwMGJcXHUwMDg1J1xuICAsIGx0cmltICAgPSBSZWdFeHAoJ14nICsgc3BhY2UgKyBzcGFjZSArICcqJylcbiAgLCBydHJpbSAgID0gUmVnRXhwKHNwYWNlICsgc3BhY2UgKyAnKiQnKTtcblxudmFyIGV4cG9ydGVyID0gZnVuY3Rpb24oS0VZLCBleGVjLCBBTElBUyl7XG4gIHZhciBleHAgICA9IHt9O1xuICB2YXIgRk9SQ0UgPSBmYWlscyhmdW5jdGlvbigpe1xuICAgIHJldHVybiAhIXNwYWNlc1tLRVldKCkgfHwgbm9uW0tFWV0oKSAhPSBub247XG4gIH0pO1xuICB2YXIgZm4gPSBleHBbS0VZXSA9IEZPUkNFID8gZXhlYyh0cmltKSA6IHNwYWNlc1tLRVldO1xuICBpZihBTElBUylleHBbQUxJQVNdID0gZm47XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0UsICdTdHJpbmcnLCBleHApO1xufTtcblxuLy8gMSAtPiBTdHJpbmcjdHJpbUxlZnRcbi8vIDIgLT4gU3RyaW5nI3RyaW1SaWdodFxuLy8gMyAtPiBTdHJpbmcjdHJpbVxudmFyIHRyaW0gPSBleHBvcnRlci50cmltID0gZnVuY3Rpb24oc3RyaW5nLCBUWVBFKXtcbiAgc3RyaW5nID0gU3RyaW5nKGRlZmluZWQoc3RyaW5nKSk7XG4gIGlmKFRZUEUgJiAxKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gIGlmKFRZUEUgJiAyKXN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVyO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXRyaW0uanNcbiAqKiBtb2R1bGUgaWQgPSA4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzXG4gKiogbW9kdWxlIGlkID0gODRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlRmxvYXQgPSByZXF1aXJlKCcuL19wYXJzZS1mbG9hdCcpO1xuLy8gMTguMi40IHBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VGbG9hdCAhPSAkcGFyc2VGbG9hdCksIHtwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdH0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucGFyc2UtZmxvYXQuanNcbiAqKiBtb2R1bGUgaWQgPSA4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucGFyc2VGbG9hdFxuICAsICR0cmltICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltO1xuXG5tb2R1bGUuZXhwb3J0cyA9IDEgLyAkcGFyc2VGbG9hdChyZXF1aXJlKCcuL19zdHJpbmctd3MnKSArICctMCcpICE9PSAtSW5maW5pdHkgPyBmdW5jdGlvbiBwYXJzZUZsb2F0KHN0cil7XG4gIHZhciBzdHJpbmcgPSAkdHJpbShTdHJpbmcoc3RyKSwgMylcbiAgICAsIHJlc3VsdCA9ICRwYXJzZUZsb2F0KHN0cmluZyk7XG4gIHJldHVybiByZXN1bHQgPT09IDAgJiYgc3RyaW5nLmNoYXJBdCgwKSA9PSAnLScgPyAtMCA6IHJlc3VsdDtcbn0gOiAkcGFyc2VGbG9hdDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWZsb2F0LmpzXG4gKiogbW9kdWxlIGlkID0gODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIGNvZiAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKVxuICAsIHRvUHJpbWl0aXZlICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBmYWlscyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBnT1BOICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIGdPUEQgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mXG4gICwgZFAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgJHRyaW0gICAgICAgICAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctdHJpbScpLnRyaW1cbiAgLCBOVU1CRVIgICAgICAgICAgICA9ICdOdW1iZXInXG4gICwgJE51bWJlciAgICAgICAgICAgPSBnbG9iYWxbTlVNQkVSXVxuICAsIEJhc2UgICAgICAgICAgICAgID0gJE51bWJlclxuICAsIHByb3RvICAgICAgICAgICAgID0gJE51bWJlci5wcm90b3R5cGVcbiAgLy8gT3BlcmEgfjEyIGhhcyBicm9rZW4gT2JqZWN0I3RvU3RyaW5nXG4gICwgQlJPS0VOX0NPRiAgICAgICAgPSBjb2YocmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpKHByb3RvKSkgPT0gTlVNQkVSXG4gICwgVFJJTSAgICAgICAgICAgICAgPSAndHJpbScgaW4gU3RyaW5nLnByb3RvdHlwZTtcblxuLy8gNy4xLjMgVG9OdW1iZXIoYXJndW1lbnQpXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbihhcmd1bWVudCl7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBmYWxzZSk7XG4gIGlmKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKXtcbiAgICBpdCA9IFRSSU0gPyBpdC50cmltKCkgOiAkdHJpbShpdCwgMyk7XG4gICAgdmFyIGZpcnN0ID0gaXQuY2hhckNvZGVBdCgwKVxuICAgICAgLCB0aGlyZCwgcmFkaXgsIG1heENvZGU7XG4gICAgaWYoZmlyc3QgPT09IDQzIHx8IGZpcnN0ID09PSA0NSl7XG4gICAgICB0aGlyZCA9IGl0LmNoYXJDb2RlQXQoMik7XG4gICAgICBpZih0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMClyZXR1cm4gTmFOOyAvLyBOdW1iZXIoJysweDEnKSBzaG91bGQgYmUgTmFOLCBvbGQgVjggZml4XG4gICAgfSBlbHNlIGlmKGZpcnN0ID09PSA0OCl7XG4gICAgICBzd2l0Y2goaXQuY2hhckNvZGVBdCgxKSl7XG4gICAgICAgIGNhc2UgNjYgOiBjYXNlIDk4ICA6IHJhZGl4ID0gMjsgbWF4Q29kZSA9IDQ5OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBiWzAxXSskL2lcbiAgICAgICAgY2FzZSA3OSA6IGNhc2UgMTExIDogcmFkaXggPSA4OyBtYXhDb2RlID0gNTU7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMG9bMC03XSskL2lcbiAgICAgICAgZGVmYXVsdCA6IHJldHVybiAraXQ7XG4gICAgICB9XG4gICAgICBmb3IodmFyIGRpZ2l0cyA9IGl0LnNsaWNlKDIpLCBpID0gMCwgbCA9IGRpZ2l0cy5sZW5ndGgsIGNvZGU7IGkgPCBsOyBpKyspe1xuICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIHBhcnNlSW50IHBhcnNlcyBhIHN0cmluZyB0byBhIGZpcnN0IHVuYXZhaWxhYmxlIHN5bWJvbFxuICAgICAgICAvLyBidXQgVG9OdW1iZXIgc2hvdWxkIHJldHVybiBOYU4gaWYgYSBzdHJpbmcgY29udGFpbnMgdW5hdmFpbGFibGUgc3ltYm9sc1xuICAgICAgICBpZihjb2RlIDwgNDggfHwgY29kZSA+IG1heENvZGUpcmV0dXJuIE5hTjtcbiAgICAgIH0gcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfSByZXR1cm4gK2l0O1xufTtcblxuaWYoISROdW1iZXIoJyAwbzEnKSB8fCAhJE51bWJlcignMGIxJykgfHwgJE51bWJlcignKzB4MScpKXtcbiAgJE51bWJlciA9IGZ1bmN0aW9uIE51bWJlcih2YWx1ZSl7XG4gICAgdmFyIGl0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyAwIDogdmFsdWVcbiAgICAgICwgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoYXQgaW5zdGFuY2VvZiAkTnVtYmVyXG4gICAgICAvLyBjaGVjayBvbiAxLi5jb25zdHJ1Y3Rvcihmb28pIGNhc2VcbiAgICAgICYmIChCUk9LRU5fQ09GID8gZmFpbHMoZnVuY3Rpb24oKXsgcHJvdG8udmFsdWVPZi5jYWxsKHRoYXQpOyB9KSA6IGNvZih0aGF0KSAhPSBOVU1CRVIpXG4gICAgICAgID8gaW5oZXJpdElmUmVxdWlyZWQobmV3IEJhc2UodG9OdW1iZXIoaXQpKSwgdGhhdCwgJE51bWJlcikgOiB0b051bWJlcihpdCk7XG4gIH07XG4gIGZvcih2YXIga2V5cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BOKEJhc2UpIDogKFxuICAgIC8vIEVTMzpcbiAgICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArXG4gICAgLy8gRVM2IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVM2IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlcidcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKyl7XG4gICAgaWYoaGFzKEJhc2UsIGtleSA9IGtleXNbal0pICYmICFoYXMoJE51bWJlciwga2V5KSl7XG4gICAgICBkUCgkTnVtYmVyLCBrZXksIGdPUEQoQmFzZSwga2V5KSk7XG4gICAgfVxuICB9XG4gICROdW1iZXIucHJvdG90eXBlID0gcHJvdG87XG4gIHByb3RvLmNvbnN0cnVjdG9yID0gJE51bWJlcjtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShnbG9iYWwsIE5VTUJFUiwgJE51bWJlcik7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgdGFyZ2V0LCBDKXtcbiAgdmFyIFAsIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIGlmKFMgIT09IEMgJiYgdHlwZW9mIFMgPT0gJ2Z1bmN0aW9uJyAmJiAoUCA9IFMucHJvdG90eXBlKSAhPT0gQy5wcm90b3R5cGUgJiYgaXNPYmplY3QoUCkgJiYgc2V0UHJvdG90eXBlT2Ype1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JbnRlZ2VyICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKVxuICAsIHJlcGVhdCAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxuICAsICR0b0ZpeGVkICAgICA9IDEuLnRvRml4ZWRcbiAgLCBmbG9vciAgICAgICAgPSBNYXRoLmZsb29yXG4gICwgZGF0YSAgICAgICAgID0gWzAsIDAsIDAsIDAsIDAsIDBdXG4gICwgRVJST1IgICAgICAgID0gJ051bWJlci50b0ZpeGVkOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnXG4gICwgWkVSTyAgICAgICAgID0gJzAnO1xuXG52YXIgbXVsdGlwbHkgPSBmdW5jdGlvbihuLCBjKXtcbiAgdmFyIGkgID0gLTFcbiAgICAsIGMyID0gYztcbiAgd2hpbGUoKytpIDwgNil7XG4gICAgYzIgKz0gbiAqIGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGMyICUgMWU3O1xuICAgIGMyID0gZmxvb3IoYzIgLyAxZTcpO1xuICB9XG59O1xudmFyIGRpdmlkZSA9IGZ1bmN0aW9uKG4pe1xuICB2YXIgaSA9IDZcbiAgICAsIGMgPSAwO1xuICB3aGlsZSgtLWkgPj0gMCl7XG4gICAgYyArPSBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBmbG9vcihjIC8gbik7XG4gICAgYyA9IChjICUgbikgKiAxZTc7XG4gIH1cbn07XG52YXIgbnVtVG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgaSA9IDZcbiAgICAsIHMgPSAnJztcbiAgd2hpbGUoLS1pID49IDApe1xuICAgIGlmKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgZGF0YVtpXSAhPT0gMCl7XG4gICAgICB2YXIgdCA9IFN0cmluZyhkYXRhW2ldKTtcbiAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoWkVSTywgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgfVxuICB9IHJldHVybiBzO1xufTtcbnZhciBwb3cgPSBmdW5jdGlvbih4LCBuLCBhY2Mpe1xuICByZXR1cm4gbiA9PT0gMCA/IGFjYyA6IG4gJSAyID09PSAxID8gcG93KHgsIG4gLSAxLCBhY2MgKiB4KSA6IHBvdyh4ICogeCwgbiAvIDIsIGFjYyk7XG59O1xudmFyIGxvZyA9IGZ1bmN0aW9uKHgpe1xuICB2YXIgbiAgPSAwXG4gICAgLCB4MiA9IHg7XG4gIHdoaWxlKHgyID49IDQwOTYpe1xuICAgIG4gKz0gMTI7XG4gICAgeDIgLz0gNDA5NjtcbiAgfVxuICB3aGlsZSh4MiA+PSAyKXtcbiAgICBuICArPSAxO1xuICAgIHgyIC89IDI7XG4gIH0gcmV0dXJuIG47XG59O1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICghISR0b0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguLnRvRml4ZWQoMCkgIT09ICcxMDAwMDAwMDAwMDAwMDAwMTI4J1xuKSB8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9GaXhlZC5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cyl7XG4gICAgdmFyIHggPSBhTnVtYmVyVmFsdWUodGhpcywgRVJST1IpXG4gICAgICAsIGYgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpXG4gICAgICAsIHMgPSAnJ1xuICAgICAgLCBtID0gWkVST1xuICAgICAgLCBlLCB6LCBqLCBrO1xuICAgIGlmKGYgPCAwIHx8IGYgPiAyMCl0aHJvdyBSYW5nZUVycm9yKEVSUk9SKTtcbiAgICBpZih4ICE9IHgpcmV0dXJuICdOYU4nO1xuICAgIGlmKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKXJldHVybiBTdHJpbmcoeCk7XG4gICAgaWYoeCA8IDApe1xuICAgICAgcyA9ICctJztcbiAgICAgIHggPSAteDtcbiAgICB9XG4gICAgaWYoeCA+IDFlLTIxKXtcbiAgICAgIGUgPSBsb2coeCAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICB6ID0gZSA8IDAgPyB4ICogcG93KDIsIC1lLCAxKSA6IHggLyBwb3coMiwgZSwgMSk7XG4gICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7XG4gICAgICBlID0gNTIgLSBlO1xuICAgICAgaWYoZSA+IDApe1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgaiA9IGY7XG4gICAgICAgIHdoaWxlKGogPj0gNyl7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUoaiA+PSAyMyl7XG4gICAgICAgICAgZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgIH1cbiAgICAgICAgZGl2aWRlKDEgPDwgaik7XG4gICAgICAgIG11bHRpcGx5KDEsIDEpO1xuICAgICAgICBkaXZpZGUoMik7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIG11bHRpcGx5KDEgPDwgLWUsIDApO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKSArIHJlcGVhdC5jYWxsKFpFUk8sIGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihmID4gMCl7XG4gICAgICBrID0gbS5sZW5ndGg7XG4gICAgICBtID0gcyArIChrIDw9IGYgPyAnMC4nICsgcmVwZWF0LmNhbGwoWkVSTywgZiAtIGspICsgbSA6IG0uc2xpY2UoMCwgayAtIGYpICsgJy4nICsgbS5zbGljZShrIC0gZikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcyArIG07XG4gICAgfSByZXR1cm4gbTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIudG8tZml4ZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgbXNnKXtcbiAgaWYodHlwZW9mIGl0ICE9ICdudW1iZXInICYmIGNvZihpdCkgIT0gJ051bWJlcicpdGhyb3cgVHlwZUVycm9yKG1zZyk7XG4gIHJldHVybiAraXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanNcbiAqKiBtb2R1bGUgaWQgPSA5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpe1xuICB2YXIgc3RyID0gU3RyaW5nKGRlZmluZWQodGhpcykpXG4gICAgLCByZXMgPSAnJ1xuICAgICwgbiAgID0gdG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYobiA8IDAgfHwgbiA9PSBJbmZpbml0eSl0aHJvdyBSYW5nZUVycm9yKFwiQ291bnQgY2FuJ3QgYmUgbmVnYXRpdmVcIik7XG4gIGZvcig7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKWlmKG4gJiAxKXJlcyArPSBzdHI7XG4gIHJldHVybiByZXM7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qc1xuICoqIG1vZHVsZSBpZCA9IDkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmFpbHMgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKVxuICAsICR0b1ByZWNpc2lvbiA9IDEuLnRvUHJlY2lzaW9uO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICgkZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gSUU3LVxuICByZXR1cm4gJHRvUHJlY2lzaW9uLmNhbGwoMSwgdW5kZWZpbmVkKSAhPT0gJzEnO1xufSkgfHwgISRmYWlscyhmdW5jdGlvbigpe1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9QcmVjaXNpb24uY2FsbCh7fSk7XG59KSksICdOdW1iZXInLCB7XG4gIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pe1xuICAgIHZhciB0aGF0ID0gYU51bWJlclZhbHVlKHRoaXMsICdOdW1iZXIjdG9QcmVjaXNpb246IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICAgIHJldHVybiBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQpIDogJHRvUHJlY2lzaW9uLmNhbGwodGhhdCwgcHJlY2lzaW9uKTsgXG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnRvLXByZWNpc2lvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4xLjIuMSBOdW1iZXIuRVBTSUxPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7RVBTSUxPTjogTWF0aC5wb3coMiwgLTUyKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmVwc2lsb24uanNcbiAqKiBtb2R1bGUgaWQgPSA5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIF9pc0Zpbml0ZSA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmlzRmluaXRlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KXtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge2lzSW50ZWdlcjogcmVxdWlyZSgnLi9faXMtaW50ZWdlcicpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtaW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZmxvb3IgICAgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0ludGVnZXIoaXQpe1xuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjEuMi40IE51bWJlci5pc05hTihudW1iZXIpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcil7XG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc0ludGVnZXIgPSByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJylcbiAgLCBhYnMgICAgICAgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKXtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gMHgxZmZmZmZmZmZmZmZmZjtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjEuMi42IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtNQVhfU0FGRV9JTlRFR0VSOiAweDFmZmZmZmZmZmZmZmZmfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4xLjIuMTAgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge01JTl9TQUZFX0lOVEVHRVI6IC0weDFmZmZmZmZmZmZmZmZmfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWluLXNhZmUtaW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCAnTnVtYmVyJywge3BhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtZmxvYXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX3BhcnNlLWludCcpO1xuLy8gMjAuMS4yLjEzIE51bWJlci5wYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlSW50ICE9ICRwYXJzZUludCksICdOdW1iZXInLCB7cGFyc2VJbnQ6ICRwYXJzZUludH0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjMgTWF0aC5hY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGxvZzFwICAgPSByZXF1aXJlKCcuL19tYXRoLWxvZzFwJylcbiAgLCBzcXJ0ICAgID0gTWF0aC5zcXJ0XG4gICwgJGFjb3NoICA9IE1hdGguYWNvc2g7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYWNvc2hcbiAgLy8gVjggYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzUwOVxuICAmJiBNYXRoLmZsb29yKCRhY29zaChOdW1iZXIuTUFYX1ZBTFVFKSkgPT0gNzEwXG4gIC8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hY29zaChJbmZpbml0eSkgLT4gTmFOIFxuICAmJiAkYWNvc2goSW5maW5pdHkpID09IEluZmluaXR5XG4pLCAnTWF0aCcsIHtcbiAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpe1xuICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiB4ID4gOTQ5MDYyNjUuNjI0MjUxNTZcbiAgICAgID8gTWF0aC5sb2coeCkgKyBNYXRoLkxOMlxuICAgICAgOiBsb2cxcCh4IC0gMSArIHNxcnQoeCAtIDEpICogc3FydCh4ICsgMSkpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYWNvc2guanNcbiAqKiBtb2R1bGUgaWQgPSAxMDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMXAgfHwgZnVuY3Rpb24gbG9nMXAoeCl7XG4gIHJldHVybiAoeCA9ICt4KSA+IC0xZS04ICYmIHggPCAxZS04ID8geCAtIHggKiB4IC8gMiA6IE1hdGgubG9nKDEgKyB4KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLWxvZzFwLmpzXG4gKiogbW9kdWxlIGlkID0gMTA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGFzaW5oICA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpe1xuICByZXR1cm4gIWlzRmluaXRlKHggPSAreCkgfHwgeCA9PSAwID8geCA6IHggPCAwID8gLWFzaW5oKC14KSA6IE1hdGgubG9nKHggKyBNYXRoLnNxcnQoeCAqIHggKyAxKSk7XG59XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hc2luaCgwKSAtPiAtMCBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHthc2luaDogYXNpbmh9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXNpbmguanNcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi43IE1hdGguYXRhbmgoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkYXRhbmggID0gTWF0aC5hdGFuaDtcblxuLy8gVG9yIEJyb3dzZXIgYnVnOiBNYXRoLmF0YW5oKC0wKSAtPiAwIFxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKCRhdGFuaCAmJiAxIC8gJGF0YW5oKC0wKSA8IDApLCAnTWF0aCcsIHtcbiAgYXRhbmg6IGZ1bmN0aW9uIGF0YW5oKHgpe1xuICAgIHJldHVybiAoeCA9ICt4KSA9PSAwID8geCA6IE1hdGgubG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hdGFuaC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjkgTWF0aC5jYnJ0KHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2lnbiAgICA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGNicnQ6IGZ1bmN0aW9uIGNicnQoeCl7XG4gICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIE1hdGgucG93KE1hdGguYWJzKHgpLCAxIC8gMyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jYnJ0LmpzXG4gKiogbW9kdWxlIGlkID0gMTA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpe1xuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fbWF0aC1zaWduLmpzXG4gKiogbW9kdWxlIGlkID0gMTA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMTEgTWF0aC5jbHozMih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjbHozMjogZnVuY3Rpb24gY2x6MzIoeCl7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIE1hdGguZmxvb3IoTWF0aC5sb2coeCArIDAuNSkgKiBNYXRoLkxPRzJFKSA6IDMyO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY2x6MzIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4xMiBNYXRoLmNvc2goeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBleHAgICAgID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY29zaDogZnVuY3Rpb24gY29zaCh4KXtcbiAgICByZXR1cm4gKGV4cCh4ID0gK3gpICsgZXhwKC14KSkgLyAyO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguY29zaC5qc1xuICoqIG1vZHVsZSBpZCA9IDExMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjE0IE1hdGguZXhwbTEoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZXhwbTEgID0gcmVxdWlyZSgnLi9fbWF0aC1leHBtMScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICgkZXhwbTEgIT0gTWF0aC5leHBtMSksICdNYXRoJywge2V4cG0xOiAkZXhwbTF9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZXhwbTEuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG0xID0gTWF0aC5leHBtMTtcbm1vZHVsZS5leHBvcnRzID0gKCEkZXhwbTFcbiAgLy8gT2xkIEZGIGJ1Z1xuICB8fCAkZXhwbTEoMTApID4gMjIwMjUuNDY1Nzk0ODA2NzE5IHx8ICRleHBtMSgxMCkgPCAyMjAyNS40NjU3OTQ4MDY3MTY1MTY4XG4gIC8vIFRvciBCcm93c2VyIGJ1Z1xuICB8fCAkZXhwbTEoLTJlLTE3KSAhPSAtMmUtMTdcbikgPyBmdW5jdGlvbiBleHBtMSh4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogeCA+IC0xZS02ICYmIHggPCAxZS02ID8geCArIHggKiB4IC8gMiA6IE1hdGguZXhwKHgpIC0gMTtcbn0gOiAkZXhwbTE7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19tYXRoLWV4cG0xLmpzXG4gKiogbW9kdWxlIGlkID0gMTEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMTYgTWF0aC5mcm91bmQoeClcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNpZ24gICAgICA9IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpXG4gICwgcG93ICAgICAgID0gTWF0aC5wb3dcbiAgLCBFUFNJTE9OICAgPSBwb3coMiwgLTUyKVxuICAsIEVQU0lMT04zMiA9IHBvdygyLCAtMjMpXG4gICwgTUFYMzIgICAgID0gcG93KDIsIDEyNykgKiAoMiAtIEVQU0lMT04zMilcbiAgLCBNSU4zMiAgICAgPSBwb3coMiwgLTEyNik7XG5cbnZhciByb3VuZFRpZXNUb0V2ZW4gPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIG4gKyAxIC8gRVBTSUxPTiAtIDEgLyBFUFNJTE9OO1xufTtcblxuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGZyb3VuZDogZnVuY3Rpb24gZnJvdW5kKHgpe1xuICAgIHZhciAkYWJzICA9IE1hdGguYWJzKHgpXG4gICAgICAsICRzaWduID0gc2lnbih4KVxuICAgICAgLCBhLCByZXN1bHQ7XG4gICAgaWYoJGFicyA8IE1JTjMyKXJldHVybiAkc2lnbiAqIHJvdW5kVGllc1RvRXZlbigkYWJzIC8gTUlOMzIgLyBFUFNJTE9OMzIpICogTUlOMzIgKiBFUFNJTE9OMzI7XG4gICAgYSA9ICgxICsgRVBTSUxPTjMyIC8gRVBTSUxPTikgKiAkYWJzO1xuICAgIHJlc3VsdCA9IGEgLSAoYSAtICRhYnMpO1xuICAgIGlmKHJlc3VsdCA+IE1BWDMyIHx8IHJlc3VsdCAhPSByZXN1bHQpcmV0dXJuICRzaWduICogSW5maW5pdHk7XG4gICAgcmV0dXJuICRzaWduICogcmVzdWx0O1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzXG4gKiogbW9kdWxlIGlkID0gMTEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMTcgTWF0aC5oeXBvdChbdmFsdWUxWywgdmFsdWUyWywg4oCmIF1dXSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhYnMgICAgID0gTWF0aC5hYnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gID0gMFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBsYXJnID0gMFxuICAgICAgLCBhcmcsIGRpdjtcbiAgICB3aGlsZShpIDwgYUxlbil7XG4gICAgICBhcmcgPSBhYnMoYXJndW1lbnRzW2krK10pO1xuICAgICAgaWYobGFyZyA8IGFyZyl7XG4gICAgICAgIGRpdiAgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gID0gc3VtICogZGl2ICogZGl2ICsgMTtcbiAgICAgICAgbGFyZyA9IGFyZztcbiAgICAgIH0gZWxzZSBpZihhcmcgPiAwKXtcbiAgICAgICAgZGl2ICA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogTWF0aC5zcXJ0KHN1bSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5oeXBvdC5qc1xuICoqIG1vZHVsZSBpZCA9IDExNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjE4IE1hdGguaW11bCh4LCB5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbXVsICAgPSBNYXRoLmltdWw7XG5cbi8vIHNvbWUgV2ViS2l0IHZlcnNpb25zIGZhaWxzIHdpdGggYmlnIG51bWJlcnMsIHNvbWUgaGFzIHdyb25nIGFyaXR5XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICRpbXVsKDB4ZmZmZmZmZmYsIDUpICE9IC01IHx8ICRpbXVsLmxlbmd0aCAhPSAyO1xufSksICdNYXRoJywge1xuICBpbXVsOiBmdW5jdGlvbiBpbXVsKHgsIHkpe1xuICAgIHZhciBVSU5UMTYgPSAweGZmZmZcbiAgICAgICwgeG4gPSAreFxuICAgICAgLCB5biA9ICt5XG4gICAgICAsIHhsID0gVUlOVDE2ICYgeG5cbiAgICAgICwgeWwgPSBVSU5UMTYgJiB5bjtcbiAgICByZXR1cm4gMCB8IHhsICogeWwgKyAoKFVJTlQxNiAmIHhuID4+PiAxNikgKiB5bCArIHhsICogKFVJTlQxNiAmIHluID4+PiAxNikgPDwgMTYgPj4+IDApO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qc1xuICoqIG1vZHVsZSBpZCA9IDExNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjIxIE1hdGgubG9nMTAoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMTA6IGZ1bmN0aW9uIGxvZzEwKHgpe1xuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzEwLmpzXG4gKiogbW9kdWxlIGlkID0gMTE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMjAgTWF0aC5sb2cxcCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge2xvZzFwOiByZXF1aXJlKCcuL19tYXRoLWxvZzFwJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMXAuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4yMiBNYXRoLmxvZzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMjogZnVuY3Rpb24gbG9nMih4KXtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIwLjIuMi4yOCBNYXRoLnNpZ24oeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtzaWduOiByZXF1aXJlKCcuL19tYXRoLXNpZ24nKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzXG4gKiogbW9kdWxlIGlkID0gMTE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4yLjIuMzAgTWF0aC5zaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZXhwbTEgICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuLy8gVjggbmVhciBDaHJvbWl1bSAzOCBoYXMgYSBwcm9ibGVtIHdpdGggdmVyeSBzbWFsbCBudW1iZXJzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICFNYXRoLnNpbmgoLTJlLTE3KSAhPSAtMmUtMTc7XG59KSwgJ01hdGgnLCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCl7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggPSAreCkgPCAxXG4gICAgICA/IChleHBtMSh4KSAtIGV4cG0xKC14KSkgLyAyXG4gICAgICA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKE1hdGguRSAvIDIpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguc2luaC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjMzIE1hdGgudGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cG0xICAgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJylcbiAgLCBleHAgICAgID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KXtcbiAgICB2YXIgYSA9IGV4cG0xKHggPSAreClcbiAgICAgICwgYiA9IGV4cG0xKC14KTtcbiAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgudGFuaC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjAuMi4yLjM0IE1hdGgudHJ1bmMoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdHJ1bmM6IGZ1bmN0aW9uIHRydW5jKGl0KXtcbiAgICByZXR1cm4gKGl0ID4gMCA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWwpKGl0KTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLnRydW5jLmpzXG4gKiogbW9kdWxlIGlkID0gMTIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSW5kZXggICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIGZyb21DaGFyQ29kZSAgID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuICAsICRmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8vIGxlbmd0aCBzaG91bGQgYmUgMSwgb2xkIEZGIHByb2JsZW1cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCEhJGZyb21Db2RlUG9pbnQgJiYgJGZyb21Db2RlUG9pbnQubGVuZ3RoICE9IDEpLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuMiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jb2RlUG9pbnRzKVxuICBmcm9tQ29kZVBvaW50OiBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KHgpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHJlcyAgPSBbXVxuICAgICAgLCBhTGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBpICAgID0gMFxuICAgICAgLCBjb2RlO1xuICAgIHdoaWxlKGFMZW4gPiBpKXtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZih0b0luZGV4KGNvZGUsIDB4MTBmZmZmKSAhPT0gY29kZSl0aHJvdyBSYW5nZUVycm9yKGNvZGUgKyAnIGlzIG5vdCBhIHZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIHJlcy5wdXNoKGNvZGUgPCAweDEwMDAwXG4gICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweGQ4MDAsIGNvZGUgJSAweDQwMCArIDB4ZGMwMClcbiAgICAgICk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjQgU3RyaW5nLnJhdyhjYWxsU2l0ZSwgLi4uc3Vic3RpdHV0aW9ucylcbiAgcmF3OiBmdW5jdGlvbiByYXcoY2FsbFNpdGUpe1xuICAgIHZhciB0cGwgID0gdG9JT2JqZWN0KGNhbGxTaXRlLnJhdylcbiAgICAgICwgbGVuICA9IHRvTGVuZ3RoKHRwbC5sZW5ndGgpXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIHJlcyAgPSBbXVxuICAgICAgLCBpICAgID0gMDtcbiAgICB3aGlsZShsZW4gPiBpKXtcbiAgICAgIHJlcy5wdXNoKFN0cmluZyh0cGxbaSsrXSkpO1xuICAgICAgaWYoaSA8IGFMZW4pcmVzLnB1c2goU3RyaW5nKGFyZ3VtZW50c1tpXSkpO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmF3LmpzXG4gKiogbW9kdWxlIGlkID0gMTI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyAyMS4xLjMuMjUgU3RyaW5nLnByb3RvdHlwZS50cmltKClcbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW0nLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltKCl7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDMpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBJdGVyYXRvcnMgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgJGl0ZXJDcmVhdGUgICAgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgQlVHR1kgICAgICAgICAgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSkgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG4gICwgS0VZUyAgICAgICAgICAgPSAna2V5cydcbiAgLCBWQUxVRVMgICAgICAgICA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCl7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuICAgIGlmKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKXJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyAgICAgICAgPSBOQU1FICsgJyBJdGVyYXRvcidcbiAgICAsIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFU1xuICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG4gICAgLCBwcm90byAgICAgID0gQmFzZS5wcm90b3R5cGVcbiAgICAsICRuYXRpdmUgICAgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF1cbiAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuICAgICwgJGVudHJpZXMgICA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWRcbiAgICAsICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlXG4gICAgLCBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmKCRhbnlOYXRpdmUpe1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKSk7XG4gICAgaWYoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpe1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmKCFMSUJSQVJZICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSloaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKXtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiAgICBJU19TRVQgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMTI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMTI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKGZhbHNlKTtcbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcbiAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcyl7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0LmpzXG4gKiogbW9kdWxlIGlkID0gMTMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNvbnRleHQgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBFTkRTX1dJVEggPSAnZW5kc1dpdGgnXG4gICwgJGVuZHNXaXRoID0gJydbRU5EU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShFTkRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nIC8qLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pe1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIEVORFNfV0lUSClcbiAgICAgICwgZW5kUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBsZW4gICAgPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aClcbiAgICAgICwgZW5kICAgID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IE1hdGgubWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKVxuICAgICAgLCBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJGVuZHNXaXRoXG4gICAgICA/ICRlbmRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgZW5kKVxuICAgICAgOiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaC5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzXG4gKiogbW9kdWxlIGlkID0gMTMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBoZWxwZXIgZm9yIFN0cmluZyN7c3RhcnRzV2l0aCwgZW5kc1dpdGgsIGluY2x1ZGVzfVxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJylcbiAgLCBkZWZpbmVkICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBzZWFyY2hTdHJpbmcsIE5BTUUpe1xuICBpZihpc1JlZ0V4cChzZWFyY2hTdHJpbmcpKXRocm93IFR5cGVFcnJvcignU3RyaW5nIycgKyBOQU1FICsgXCIgZG9lc24ndCBhY2NlcHQgcmVnZXghXCIpO1xuICByZXR1cm4gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMTMzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjIuOCBJc1JlZ0V4cChhcmd1bWVudClcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgY29mICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIE1BVENIICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzXG4gKiogbW9kdWxlIGlkID0gMTM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgTUFUQ0ggPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIHJlID0gLy4vO1xuICB0cnkge1xuICAgICcvLi8nW0tFWV0ocmUpO1xuICB9IGNhdGNoKGUpe1xuICAgIHRyeSB7XG4gICAgICByZVtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAhJy8uLydbS0VZXShyZSk7XG4gICAgfSBjYXRjaChmKXsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjEuMS4zLjcgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyhzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMClcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29udGV4dCAgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpXG4gICwgSU5DTFVERVMgPSAnaW5jbHVkZXMnO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKElOQ0xVREVTKSwgJ1N0cmluZycsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiwgcG9zaXRpb24gPSAwICovKXtcbiAgICByZXR1cm4gISF+Y29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIElOQ0xVREVTKVxuICAgICAgLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxuICByZXBlYXQ6IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcucmVwZWF0LmpzXG4gKiogbW9kdWxlIGlkID0gMTM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyBbLCBwb3NpdGlvbiBdKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgY29udGV4dCAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpXG4gICwgU1RBUlRTX1dJVEggPSAnc3RhcnRzV2l0aCdcbiAgLCAkc3RhcnRzV2l0aCA9ICcnW1NUQVJUU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShTVEFSVFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xuICAgIHZhciB0aGF0ICAgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpXG4gICAgICAsIGluZGV4ICA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpXG4gICAgICAsIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkc3RhcnRzV2l0aFxuICAgICAgPyAkc3RhcnRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgaW5kZXgpXG4gICAgICA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanNcbiAqKiBtb2R1bGUgaWQgPSAxMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjIgU3RyaW5nLnByb3RvdHlwZS5hbmNob3IobmFtZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2FuY2hvcicsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYW5jaG9yKG5hbWUpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ25hbWUnLCBuYW1lKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgcXVvdCAgICA9IC9cIi9nO1xuLy8gQi4yLjMuMi4xIENyZWF0ZUhUTUwoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpXG52YXIgY3JlYXRlSFRNTCA9IGZ1bmN0aW9uKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gIHZhciBTICA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpXG4gICAgLCBwMSA9ICc8JyArIHRhZztcbiAgaWYoYXR0cmlidXRlICE9PSAnJylwMSArPSAnICcgKyBhdHRyaWJ1dGUgKyAnPVwiJyArIFN0cmluZyh2YWx1ZSkucmVwbGFjZShxdW90LCAnJnF1b3Q7JykgKyAnXCInO1xuICByZXR1cm4gcDEgKyAnPicgKyBTICsgJzwvJyArIHRhZyArICc+Jztcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5BTUUsIGV4ZWMpe1xuICB2YXIgTyA9IHt9O1xuICBPW05BTUVdID0gZXhlYyhjcmVhdGVIVE1MKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpe1xuICAgIHZhciB0ZXN0ID0gJydbTkFNRV0oJ1wiJyk7XG4gICAgcmV0dXJuIHRlc3QgIT09IHRlc3QudG9Mb3dlckNhc2UoKSB8fCB0ZXN0LnNwbGl0KCdcIicpLmxlbmd0aCA+IDM7XG4gIH0pLCAnU3RyaW5nJywgTyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjMgU3RyaW5nLnByb3RvdHlwZS5iaWcoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmlnJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBiaWcoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmlnJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmlnLmpzXG4gKiogbW9kdWxlIGlkID0gMTQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy40IFN0cmluZy5wcm90b3R5cGUuYmxpbmsoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYmxpbmsnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJsaW5rKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JsaW5rJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjUgU3RyaW5nLnByb3RvdHlwZS5ib2xkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JvbGQnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvbGQoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYicsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjYgU3RyaW5nLnByb3RvdHlwZS5maXhlZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmaXhlZCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZml4ZWQoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAndHQnLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5maXhlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNyBTdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvcihjb2xvcilcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRjb2xvcicsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gZm9udGNvbG9yKGNvbG9yKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdjb2xvcicsIGNvbG9yKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZm9udGNvbG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy44IFN0cmluZy5wcm90b3R5cGUuZm9udHNpemUoc2l6ZSlcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZvbnRzaXplJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBmb250c2l6ZShzaXplKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdzaXplJywgc2l6ZSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy45IFN0cmluZy5wcm90b3R5cGUuaXRhbGljcygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdpdGFsaWNzJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBpdGFsaWNzKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2knLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMCBTdHJpbmcucHJvdG90eXBlLmxpbmsodXJsKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnbGluaycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gbGluayh1cmwpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ2hyZWYnLCB1cmwpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMSBTdHJpbmcucHJvdG90eXBlLnNtYWxsKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3NtYWxsJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzbWFsbCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzbWFsbCcsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnNtYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4xMiBTdHJpbmcucHJvdG90eXBlLnN0cmlrZSgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzdHJpa2UnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0cmlrZSgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdHJpa2UnLCAnJywgJycpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdHJpa2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjEzIFN0cmluZy5wcm90b3R5cGUuc3ViKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ3N1YicsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc3ViKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1YicsICcnLCAnJyk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qc1xuICoqIG1vZHVsZSBpZCA9IDE1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5zdXAoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3VwJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzdXAoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3VwJywgJycsICcnKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3VwLmpzXG4gKiogbW9kdWxlIGlkID0gMTUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMC4zLjMuMSAvIDE1LjkuNC40IERhdGUubm93KClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRGF0ZScsIHtub3c6IGZ1bmN0aW9uKCl7IHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTsgfX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gbmV3IERhdGUoTmFOKS50b0pTT04oKSAhPT0gbnVsbCB8fCBEYXRlLnByb3RvdHlwZS50b0pTT04uY2FsbCh7dG9JU09TdHJpbmc6IGZ1bmN0aW9uKCl7IHJldHVybiAxOyB9fSkgIT09IDE7XG59KSwgJ0RhdGUnLCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKGtleSl7XG4gICAgdmFyIE8gID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgcHYgPSB0b1ByaW1pdGl2ZShPKTtcbiAgICByZXR1cm4gdHlwZW9mIHB2ID09ICdudW1iZXInICYmICFpc0Zpbml0ZShwdikgPyBudWxsIDogTy50b0lTT1N0cmluZygpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tanNvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjAuMy40LjM2IC8gMTUuOS41LjQzIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGdldFRpbWUgPSBEYXRlLnByb3RvdHlwZS5nZXRUaW1lO1xuXG52YXIgbHogPSBmdW5jdGlvbihudW0pe1xuICByZXR1cm4gbnVtID4gOSA/IG51bSA6ICcwJyArIG51bTtcbn07XG5cbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5ldyBEYXRlKC01ZTEzIC0gMSkudG9JU09TdHJpbmcoKSAhPSAnMDM4NS0wNy0yNVQwNzowNjozOS45OTlaJztcbn0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xuICBuZXcgRGF0ZShOYU4pLnRvSVNPU3RyaW5nKCk7XG59KSksICdEYXRlJywge1xuICB0b0lTT1N0cmluZzogZnVuY3Rpb24gdG9JU09TdHJpbmcoKXtcbiAgICBpZighaXNGaW5pdGUoZ2V0VGltZS5jYWxsKHRoaXMpKSl0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgICB2YXIgZCA9IHRoaXNcbiAgICAgICwgeSA9IGQuZ2V0VVRDRnVsbFllYXIoKVxuICAgICAgLCBtID0gZC5nZXRVVENNaWxsaXNlY29uZHMoKVxuICAgICAgLCBzID0geSA8IDAgPyAnLScgOiB5ID4gOTk5OSA/ICcrJyA6ICcnO1xuICAgIHJldHVybiBzICsgKCcwMDAwMCcgKyBNYXRoLmFicyh5KSkuc2xpY2UocyA/IC02IDogLTQpICtcbiAgICAgICctJyArIGx6KGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICsgbHooZC5nZXRVVENEYXRlKCkpICtcbiAgICAgICdUJyArIGx6KGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBseihkLmdldFVUQ01pbnV0ZXMoKSkgK1xuICAgICAgJzonICsgbHooZC5nZXRVVENTZWNvbmRzKCkpICsgJy4nICsgKG0gPiA5OSA/IG0gOiAnMCcgKyBseihtKSkgKyAnWic7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nLmpzXG4gKiogbW9kdWxlIGlkID0gMTU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgRGF0ZVByb3RvICAgID0gRGF0ZS5wcm90b3R5cGVcbiAgLCBJTlZBTElEX0RBVEUgPSAnSW52YWxpZCBEYXRlJ1xuICAsIFRPX1NUUklORyAgICA9ICd0b1N0cmluZydcbiAgLCAkdG9TdHJpbmcgICAgPSBEYXRlUHJvdG9bVE9fU1RSSU5HXVxuICAsIGdldFRpbWUgICAgICA9IERhdGVQcm90by5nZXRUaW1lO1xuaWYobmV3IERhdGUoTmFOKSArICcnICE9IElOVkFMSURfREFURSl7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoRGF0ZVByb3RvLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgdmFyIHZhbHVlID0gZ2V0VGltZS5jYWxsKHRoaXMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyAkdG9TdHJpbmcuY2FsbCh0aGlzKSA6IElOVkFMSURfREFURTtcbiAgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXN0cmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFRPX1BSSU1JVElWRSA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1ByaW1pdGl2ZScpXG4gICwgcHJvdG8gICAgICAgID0gRGF0ZS5wcm90b3R5cGU7XG5cbmlmKCEoVE9fUFJJTUlUSVZFIGluIHByb3RvKSlyZXF1aXJlKCcuL19oaWRlJykocHJvdG8sIFRPX1BSSU1JVElWRSwgcmVxdWlyZSgnLi9fZGF0ZS10by1wcmltaXRpdmUnKSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgTlVNQkVSICAgICAgPSAnbnVtYmVyJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihoaW50KXtcbiAgaWYoaGludCAhPT0gJ3N0cmluZycgJiYgaGludCAhPT0gTlVNQkVSICYmIGhpbnQgIT09ICdkZWZhdWx0Jyl0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBoaW50Jyk7XG4gIHJldHVybiB0b1ByaW1pdGl2ZShhbk9iamVjdCh0aGlzKSwgaGludCAhPSBOVU1CRVIpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2RhdGUtdG8tcHJpbWl0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gMTU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMi4xLjIuMiAvIDE1LjQuMy4yIEFycmF5LmlzQXJyYXkoYXJnKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdBcnJheScsIHtpc0FycmF5OiByZXF1aXJlKCcuL19pcy1hcnJheScpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qc1xuICoqIG1vZHVsZSBpZCA9IDE1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGN0eCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIGNhbGwgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJylcbiAgLCBpc0FycmF5SXRlciAgICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpXG4gICwgZ2V0SXRlckZuICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uKGl0ZXIpeyBBcnJheS5mcm9tKGl0ZXIpOyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlLyosIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKi8pe1xuICAgIHZhciBPICAgICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBDICAgICAgID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheVxuICAgICAgLCBhTGVuICAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCBtYXBmbiAgID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICAgICwgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWRcbiAgICAgICwgaW5kZXggICA9IDBcbiAgICAgICwgaXRlckZuICA9IGdldEl0ZXJGbihPKVxuICAgICAgLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3I7XG4gICAgaWYobWFwcGluZyltYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyKGl0ZXJGbikpKXtcbiAgICAgIGZvcihpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQzsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IocmVzdWx0ID0gbmV3IEMobGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzXG4gKiogbW9kdWxlIGlkID0gMTYwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaChlKXtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmKHJldCAhPT0gdW5kZWZpbmVkKWFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY2FsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIElURVJBVE9SICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGluZGV4LCB2YWx1ZSl7XG4gIGlmKGluZGV4IGluIG9iamVjdCkkZGVmaW5lUHJvcGVydHkuZihvYmplY3QsIGluZGV4LCBjcmVhdGVEZXNjKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIElURVJBVE9SICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpXG4gICwgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciByaXRlciA9IFs3XVtJVEVSQVRPUl0oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24oKXsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24oKXsgdGhyb3cgMjsgfSk7XG59IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYywgc2tpcENsb3Npbmcpe1xuICBpZighc2tpcENsb3NpbmcgJiYgIVNBRkVfQ0xPU0lORylyZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciAgPSBbN11cbiAgICAgICwgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbigpeyByZXR1cm4ge2RvbmU6IHNhZmUgPSB0cnVlfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBzYWZlO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gRigpe31cbiAgcmV0dXJuICEoQXJyYXkub2YuY2FsbChGKSBpbnN0YW5jZW9mIEYpO1xufSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjMgQXJyYXkub2YoIC4uLml0ZW1zKVxuICBvZjogZnVuY3Rpb24gb2YoLyogLi4uYXJncyAqLyl7XG4gICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICwgYUxlbiAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXkpKGFMZW4pO1xuICAgIHdoaWxlKGFMZW4gPiBpbmRleCljcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBhTGVuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkub2YuanNcbiAqKiBtb2R1bGUgaWQgPSAxNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUuam9pbihzZXBhcmF0b3IpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUpvaW4gPSBbXS5qb2luO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2Ugc3RyaW5nc1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAocmVxdWlyZSgnLi9faW9iamVjdCcpICE9IE9iamVjdCB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKGFycmF5Sm9pbikpLCAnQXJyYXknLCB7XG4gIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKXtcbiAgICByZXR1cm4gYXJyYXlKb2luLmNhbGwodG9JT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qc1xuICoqIG1vZHVsZSBpZCA9IDE2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIGFyZyl7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uKCl7fSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc3RyaWN0LW1ldGhvZC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGh0bWwgICAgICAgPSByZXF1aXJlKCcuL19odG1sJylcbiAgLCBjb2YgICAgICAgID0gcmVxdWlyZSgnLi9fY29mJylcbiAgLCB0b0luZGV4ICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcblxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIGlmKGh0bWwpYXJyYXlTbGljZS5jYWxsKGh0bWwpO1xufSksICdBcnJheScsIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKGJlZ2luLCBlbmQpe1xuICAgIHZhciBsZW4gICA9IHRvTGVuZ3RoKHRoaXMubGVuZ3RoKVxuICAgICAgLCBrbGFzcyA9IGNvZih0aGlzKTtcbiAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZDtcbiAgICBpZihrbGFzcyA9PSAnQXJyYXknKXJldHVybiBhcnJheVNsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdmFyIHN0YXJ0ICA9IHRvSW5kZXgoYmVnaW4sIGxlbilcbiAgICAgICwgdXBUbyAgID0gdG9JbmRleChlbmQsIGxlbilcbiAgICAgICwgc2l6ZSAgID0gdG9MZW5ndGgodXBUbyAtIHN0YXJ0KVxuICAgICAgLCBjbG9uZWQgPSBBcnJheShzaXplKVxuICAgICAgLCBpICAgICAgPSAwO1xuICAgIGZvcig7IGkgPCBzaXplOyBpKyspY2xvbmVkW2ldID0ga2xhc3MgPT0gJ1N0cmluZydcbiAgICAgID8gdGhpcy5jaGFyQXQoc3RhcnQgKyBpKVxuICAgICAgOiB0aGlzW3N0YXJ0ICsgaV07XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zbGljZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9PYmplY3QgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBmYWlscyAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgJHNvcnQgICAgID0gW10uc29ydFxuICAsIHRlc3QgICAgICA9IFsxLCAyLCAzXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gSUU4LVxuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xuICAvLyBWOCBidWdcbiAgdGVzdC5zb3J0KG51bGwpO1xuICAvLyBPbGQgV2ViS2l0XG59KSB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRzb3J0KSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjI1IEFycmF5LnByb3RvdHlwZS5zb3J0KGNvbXBhcmVmbilcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pe1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZFxuICAgICAgPyAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpKVxuICAgICAgOiAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29ydC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZm9yRWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKVxuICAsIFNUUklDVCAgID0gcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmZvckVhY2gsIHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFTVFJJQ1QsICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjEwIC8gMTUuNC40LjE4IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoLmpzXG4gKiogbW9kdWxlIGlkID0gMTcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhc2MgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRZUEUsICRjcmVhdGUpe1xuICB2YXIgSVNfTUFQICAgICAgICA9IFRZUEUgPT0gMVxuICAgICwgSVNfRklMVEVSICAgICA9IFRZUEUgPT0gMlxuICAgICwgSVNfU09NRSAgICAgICA9IFRZUEUgPT0gM1xuICAgICwgSVNfRVZFUlkgICAgICA9IFRZUEUgPT0gNFxuICAgICwgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNlxuICAgICwgTk9fSE9MRVMgICAgICA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYXG4gICAgLCBjcmVhdGUgICAgICAgID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCl7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KCR0aGlzKVxuICAgICAgLCBzZWxmICAgPSBJT2JqZWN0KE8pXG4gICAgICAsIGYgICAgICA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMFxuICAgICAgLCByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkXG4gICAgICAsIHZhbCwgcmVzO1xuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZil7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZihUWVBFKXtcbiAgICAgICAgaWYoSVNfTUFQKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaChUWVBFKXtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmKElTX0VWRVJZKXJldHVybiBmYWxzZTsgICAgICAgICAgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzXG4gKiogbW9kdWxlIGlkID0gMTcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsLCBsZW5ndGgpe1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGlzQXJyYXkgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIFNQRUNJRVMgID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCl7XG4gIHZhciBDO1xuICBpZihpc0FycmF5KG9yaWdpbmFsKSl7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKUMgPSB1bmRlZmluZWQ7XG4gICAgaWYoaXNPYmplY3QoQykpe1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZihDID09PSBudWxsKUMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRtYXAgICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5tYXAsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNSAvIDE1LjQuNC4xOSBBcnJheS5wcm90b3R5cGUubWFwKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lm1hcC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMik7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5maWx0ZXIsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy43IC8gMTUuNC40LjIwIEFycmF5LnByb3RvdHlwZS5maWx0ZXIoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMTc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHNvbWUgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgzKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnNvbWUsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yMyAvIDE1LjQuNC4xNyBBcnJheS5wcm90b3R5cGUuc29tZShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zb21lLmpzXG4gKiogbW9kdWxlIGlkID0gMTc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGV2ZXJ5ICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSg0KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLmV2ZXJ5LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNSAvIDE1LjQuNC4xNiBBcnJheS5wcm90b3R5cGUuZXZlcnkoY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGV2ZXJ5KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZXZlcnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLyl7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCBmYWxzZSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLmpzXG4gKiogbW9kdWxlIGlkID0gMTc5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9PYmplY3QgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICAgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aGF0LCBjYWxsYmFja2ZuLCBhTGVuLCBtZW1vLCBpc1JpZ2h0KXtcbiAgYUZ1bmN0aW9uKGNhbGxiYWNrZm4pO1xuICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhhdClcbiAgICAsIHNlbGYgICA9IElPYmplY3QoTylcbiAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgaW5kZXggID0gaXNSaWdodCA/IGxlbmd0aCAtIDEgOiAwXG4gICAgLCBpICAgICAgPSBpc1JpZ2h0ID8gLTEgOiAxO1xuICBpZihhTGVuIDwgMilmb3IoOzspe1xuICAgIGlmKGluZGV4IGluIHNlbGYpe1xuICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgaW5kZXggKz0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpbmRleCArPSBpO1xuICAgIGlmKGlzUmlnaHQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgfVxuICB9XG4gIGZvcig7aXNSaWdodCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSlpZihpbmRleCBpbiBzZWxmKXtcbiAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICB9XG4gIHJldHVybiBtZW1vO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXJlZHVjZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZVJpZ2h0LCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTkgLyAxNS40LjQuMjIgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pe1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0LmpzXG4gKiogbW9kdWxlIGlkID0gMTgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGluZGV4T2YgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXG4gICwgJG5hdGl2ZSAgICAgICA9IFtdLmluZGV4T2ZcbiAgLCBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0uaW5kZXhPZigxLCAtMCkgPCAwO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChORUdBVElWRV9aRVJPIHx8ICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoJG5hdGl2ZSkpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMSAvIDE1LjQuNC4xNCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ID0gMCAqLyl7XG4gICAgcmV0dXJuIE5FR0FUSVZFX1pFUk9cbiAgICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICAgID8gJG5hdGl2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDBcbiAgICAgIDogJGluZGV4T2YodGhpcywgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pbmRleC1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvSU9iamVjdCAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b0ludGVnZXIgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgdG9MZW5ndGggICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgJG5hdGl2ZSAgICAgICA9IFtdLmxhc3RJbmRleE9mXG4gICwgTkVHQVRJVkVfWkVSTyA9ICEhJG5hdGl2ZSAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE0IC8gMTUuNC40LjE1IEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IFssIGZyb21JbmRleF0pXG4gIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggPSBAWyotMV0gKi8pe1xuICAgIC8vIGNvbnZlcnQgLTAgdG8gKzBcbiAgICBpZihORUdBVElWRV9aRVJPKXJldHVybiAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMDtcbiAgICB2YXIgTyAgICAgID0gdG9JT2JqZWN0KHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSBsZW5ndGggLSAxO1xuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKWluZGV4ID0gTWF0aC5taW4oaW5kZXgsIHRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcbiAgICBpZihpbmRleCA8IDApaW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgICBmb3IoO2luZGV4ID49IDA7IGluZGV4LS0paWYoaW5kZXggaW4gTylpZihPW2luZGV4XSA9PT0gc2VhcmNoRWxlbWVudClyZXR1cm4gaW5kZXggfHwgMDtcbiAgICByZXR1cm4gLTE7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkubGFzdC1pbmRleC1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDE4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjIuMS4zLjMgQXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge2NvcHlXaXRoaW46IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJyl9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2NvcHlXaXRoaW4nKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmNvcHktd2l0aGluLmpzXG4gKiogbW9kdWxlIGlkID0gMTg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9JbmRleCAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBbXS5jb3B5V2l0aGluIHx8IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0Lyo9IDAqLywgc3RhcnQvKj0gMCwgZW5kID0gQGxlbmd0aCovKXtcbiAgdmFyIE8gICAgID0gdG9PYmplY3QodGhpcylcbiAgICAsIGxlbiAgID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCB0byAgICA9IHRvSW5kZXgodGFyZ2V0LCBsZW4pXG4gICAgLCBmcm9tICA9IHRvSW5kZXgoc3RhcnQsIGxlbilcbiAgICAsIGVuZCAgID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWRcbiAgICAsIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9JbmRleChlbmQsIGxlbikpIC0gZnJvbSwgbGVuIC0gdG8pXG4gICAgLCBpbmMgICA9IDE7XG4gIGlmKGZyb20gPCB0byAmJiB0byA8IGZyb20gKyBjb3VudCl7XG4gICAgaW5jICA9IC0xO1xuICAgIGZyb20gKz0gY291bnQgLSAxO1xuICAgIHRvICAgKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlKGNvdW50LS0gPiAwKXtcbiAgICBpZihmcm9tIGluIE8pT1t0b10gPSBPW2Zyb21dO1xuICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgIHRvICAgKz0gaW5jO1xuICAgIGZyb20gKz0gaW5jO1xuICB9IHJldHVybiBPO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzXG4gKiogbW9kdWxlIGlkID0gMTg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKVxuICAsIEFycmF5UHJvdG8gID0gQXJyYXkucHJvdG90eXBlO1xuaWYoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKXJlcXVpcmUoJy4vX2hpZGUnKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtmaWxsOiByZXF1aXJlKCcuL19hcnJheS1maWxsJyl9KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2ZpbGwnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAxODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDIyLjEuMy42IEFycmF5LnByb3RvdHlwZS5maWxsKHZhbHVlLCBzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKVxuJ3VzZSBzdHJpY3QnO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b0luZGV4ICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pe1xuICB2YXIgTyAgICAgID0gdG9PYmplY3QodGhpcylcbiAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICwgYUxlbiAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgaW5kZXggID0gdG9JbmRleChhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoKVxuICAgICwgZW5kICAgID0gYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWRcbiAgICAsIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbmRleChlbmQsIGxlbmd0aCk7XG4gIHdoaWxlKGVuZFBvcyA+IGluZGV4KU9baW5kZXgrK10gPSB2YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZmlsbC5qc1xuICoqIG1vZHVsZSBpZCA9IDE4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaW5kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNSlcbiAgLCBLRVkgICAgID0gJ2ZpbmQnXG4gICwgZm9yY2VkICA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYoS0VZIGluIFtdKUFycmF5KDEpW0tFWV0oZnVuY3Rpb24oKXsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQuanNcbiAqKiBtb2R1bGUgaWQgPSAxODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIDIyLjEuMy45IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaW5kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNilcbiAgLCBLRVkgICAgID0gJ2ZpbmRJbmRleCdcbiAgLCBmb3JjZWQgID0gdHJ1ZTtcbi8vIFNob3VsZG4ndCBza2lwIGhvbGVzXG5pZihLRVkgaW4gW10pQXJyYXkoMSlbS0VZXShmdW5jdGlvbigpeyBmb3JjZWQgPSBmYWxzZTsgfSk7XG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZvcmNlZCwgJ0FycmF5Jywge1xuICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ0FycmF5Jyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzXG4gKiogbW9kdWxlIGlkID0gMTkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBTUEVDSUVTICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSlkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGtpbmQgID0gdGhpcy5fa1xuICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRvbmUsIHZhbHVlKXtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZX07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzXG4gKiogbW9kdWxlIGlkID0gMTk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpXG4gICwgZFAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgZ09QTiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBpc1JlZ0V4cCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgJGZsYWdzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgJFJlZ0V4cCAgICAgICAgICAgPSBnbG9iYWwuUmVnRXhwXG4gICwgQmFzZSAgICAgICAgICAgICAgPSAkUmVnRXhwXG4gICwgcHJvdG8gICAgICAgICAgICAgPSAkUmVnRXhwLnByb3RvdHlwZVxuICAsIHJlMSAgICAgICAgICAgICAgID0gL2EvZ1xuICAsIHJlMiAgICAgICAgICAgICAgID0gL2EvZ1xuICAvLyBcIm5ld1wiIGNyZWF0ZXMgYSBuZXcgb2JqZWN0LCBvbGQgd2Via2l0IGJ1Z2d5IGhlcmVcbiAgLCBDT1JSRUNUX05FVyAgICAgICA9IG5ldyAkUmVnRXhwKHJlMSkgIT09IHJlMTtcblxuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAoIUNPUlJFQ1RfTkVXIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmUyW3JlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpXSA9IGZhbHNlO1xuICAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIGFsdGVyIGZsYWdzIGFuZCBJc1JlZ0V4cCB3b3JrcyBjb3JyZWN0IHdpdGggQEBtYXRjaFxuICByZXR1cm4gJFJlZ0V4cChyZTEpICE9IHJlMSB8fCAkUmVnRXhwKHJlMikgPT0gcmUyIHx8ICRSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbn0pKSl7XG4gICRSZWdFeHAgPSBmdW5jdGlvbiBSZWdFeHAocCwgZil7XG4gICAgdmFyIHRpUkUgPSB0aGlzIGluc3RhbmNlb2YgJFJlZ0V4cFxuICAgICAgLCBwaVJFID0gaXNSZWdFeHAocClcbiAgICAgICwgZmlVICA9IGYgPT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gIXRpUkUgJiYgcGlSRSAmJiBwLmNvbnN0cnVjdG9yID09PSAkUmVnRXhwICYmIGZpVSA/IHBcbiAgICAgIDogaW5oZXJpdElmUmVxdWlyZWQoQ09SUkVDVF9ORVdcbiAgICAgICAgPyBuZXcgQmFzZShwaVJFICYmICFmaVUgPyBwLnNvdXJjZSA6IHAsIGYpXG4gICAgICAgIDogQmFzZSgocGlSRSA9IHAgaW5zdGFuY2VvZiAkUmVnRXhwKSA/IHAuc291cmNlIDogcCwgcGlSRSAmJiBmaVUgPyAkZmxhZ3MuY2FsbChwKSA6IGYpXG4gICAgICAsIHRpUkUgPyB0aGlzIDogcHJvdG8sICRSZWdFeHApO1xuICB9O1xuICB2YXIgcHJveHkgPSBmdW5jdGlvbihrZXkpe1xuICAgIGtleSBpbiAkUmVnRXhwIHx8IGRQKCRSZWdFeHAsIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gQmFzZVtrZXldOyB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihpdCl7IEJhc2Vba2V5XSA9IGl0OyB9XG4gICAgfSk7XG4gIH07XG4gIGZvcih2YXIga2V5cyA9IGdPUE4oQmFzZSksIGkgPSAwOyBrZXlzLmxlbmd0aCA+IGk7IClwcm94eShrZXlzW2krK10pO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICRSZWdFeHA7XG4gICRSZWdFeHAucHJvdG90eXBlID0gcHJvdG87XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCAnUmVnRXhwJywgJFJlZ0V4cCk7XG59XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ1JlZ0V4cCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmNvbnN0cnVjdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCl7XG4gIHZhciB0aGF0ICAgPSBhbk9iamVjdCh0aGlzKVxuICAgICwgcmVzdWx0ID0gJyc7XG4gIGlmKHRoYXQuZ2xvYmFsKSAgICAgcmVzdWx0ICs9ICdnJztcbiAgaWYodGhhdC5pZ25vcmVDYXNlKSByZXN1bHQgKz0gJ2knO1xuICBpZih0aGF0Lm11bHRpbGluZSkgIHJlc3VsdCArPSAnbSc7XG4gIGlmKHRoYXQudW5pY29kZSkgICAgcmVzdWx0ICs9ICd1JztcbiAgaWYodGhhdC5zdGlja3kpICAgICByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzXG4gKiogbW9kdWxlIGlkID0gMTk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJGZsYWdzICAgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgVE9fU1RSSU5HICAgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nICAgPSAvLi9bVE9fU1RSSU5HXTtcblxudmFyIGRlZmluZSA9IGZ1bmN0aW9uKGZuKXtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZuLCB0cnVlKTtcbn07XG5cbi8vIDIxLjIuNS4xNCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nKClcbmlmKHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXsgcmV0dXJuICR0b1N0cmluZy5jYWxsKHtzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJ30pICE9ICcvYS9iJzsgfSkpe1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHJldHVybiAnLycuY29uY2F0KFIuc291cmNlLCAnLycsXG4gICAgICAnZmxhZ3MnIGluIFIgPyBSLmZsYWdzIDogIURFU0NSSVBUT1JTICYmIFIgaW5zdGFuY2VvZiBSZWdFeHAgPyAkZmxhZ3MuY2FsbChSKSA6IHVuZGVmaW5lZCk7XG4gIH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbn0gZWxzZSBpZigkdG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkcpe1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZy5qc1xuICoqIG1vZHVsZSBpZCA9IDE5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3MoKVxuaWYocmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAvLi9nLmZsYWdzICE9ICdnJylyZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IHJlcXVpcmUoJy4vX2ZsYWdzJylcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmZsYWdzLmpzXG4gKiogbW9kdWxlIGlkID0gMTk4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBAQG1hdGNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ21hdGNoJywgMSwgZnVuY3Rpb24oZGVmaW5lZCwgTUFUQ0gsICRtYXRjaCl7XG4gIC8vIDIxLjEuMy4xMSBTdHJpbmcucHJvdG90eXBlLm1hdGNoKHJlZ2V4cClcbiAgcmV0dXJuIFtmdW5jdGlvbiBtYXRjaChyZWdleHApe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtNQVRDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbTUFUQ0hdKFN0cmluZyhPKSk7XG4gIH0sICRtYXRjaF07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGhpZGUgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgZmFpbHMgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZGVmaW5lZCAgPSByZXF1aXJlKCcuL19kZWZpbmVkJylcbiAgLCB3a3MgICAgICA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEtFWSwgbGVuZ3RoLCBleGVjKXtcbiAgdmFyIFNZTUJPTCAgID0gd2tzKEtFWSlcbiAgICAsIGZucyAgICAgID0gZXhlYyhkZWZpbmVkLCBTWU1CT0wsICcnW0tFWV0pXG4gICAgLCBzdHJmbiAgICA9IGZuc1swXVxuICAgICwgcnhmbiAgICAgPSBmbnNbMV07XG4gIGlmKGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgdmFyIE8gPSB7fTtcbiAgICBPW1NZTUJPTF0gPSBmdW5jdGlvbigpeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KSl7XG4gICAgcmVkZWZpbmUoU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBzdHJmbik7XG4gICAgaGlkZShSZWdFeHAucHJvdG90eXBlLCBTWU1CT0wsIGxlbmd0aCA9PSAyXG4gICAgICAvLyAyMS4yLjUuOCBSZWdFeHAucHJvdG90eXBlW0BAcmVwbGFjZV0oc3RyaW5nLCByZXBsYWNlVmFsdWUpXG4gICAgICAvLyAyMS4yLjUuMTEgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XShzdHJpbmcsIGxpbWl0KVxuICAgICAgPyBmdW5jdGlvbihzdHJpbmcsIGFyZyl7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24oc3RyaW5nKXsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMpOyB9XG4gICAgKTtcbiAgfVxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIEBAcmVwbGFjZSBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdyZXBsYWNlJywgMiwgZnVuY3Rpb24oZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2Upe1xuICAvLyAyMS4xLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpXG4gIHJldHVybiBbZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHNlYXJjaFZhbHVlID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlYXJjaFZhbHVlW1JFUExBQ0VdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgIDogJHJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICB9LCAkcmVwbGFjZV07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzXG4gKiogbW9kdWxlIGlkID0gMjAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBAQHNlYXJjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdzZWFyY2gnLCAxLCBmdW5jdGlvbihkZWZpbmVkLCBTRUFSQ0gsICRzZWFyY2gpe1xuICAvLyAyMS4xLjMuMTUgU3RyaW5nLnByb3RvdHlwZS5zZWFyY2gocmVnZXhwKVxuICByZXR1cm4gW2Z1bmN0aW9uIHNlYXJjaChyZWdleHApe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gcmVnZXhwID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlZ2V4cFtTRUFSQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW1NFQVJDSF0oU3RyaW5nKE8pKTtcbiAgfSwgJHNlYXJjaF07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2guanNcbiAqKiBtb2R1bGUgaWQgPSAyMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIEBAc3BsaXQgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc3BsaXQnLCAyLCBmdW5jdGlvbihkZWZpbmVkLCBTUExJVCwgJHNwbGl0KXtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgaXNSZWdFeHAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICAgLCBfc3BsaXQgICAgID0gJHNwbGl0XG4gICAgLCAkcHVzaCAgICAgID0gW10ucHVzaFxuICAgICwgJFNQTElUICAgICA9ICdzcGxpdCdcbiAgICAsIExFTkdUSCAgICAgPSAnbGVuZ3RoJ1xuICAgICwgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuICBpZihcbiAgICAnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fFxuICAgICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fFxuICAgICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fFxuICAgICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHxcbiAgICAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF1cbiAgKXtcbiAgICB2YXIgTlBDRyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdW5kZWZpbmVkOyAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgIC8vIGJhc2VkIG9uIGVzNS1zaGltIGltcGxlbWVudGF0aW9uLCBuZWVkIHRvIHJld29yayBpdFxuICAgICRzcGxpdCA9IGZ1bmN0aW9uKHNlcGFyYXRvciwgbGltaXQpe1xuICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIGlmKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKXJldHVybiBbXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZighaXNSZWdFeHAoc2VwYXJhdG9yKSlyZXR1cm4gX3NwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyA0Mjk0OTY3Mjk1IDogbGltaXQgPj4+IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoLCBpO1xuICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICBpZighTlBDRylzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3JDb3B5LnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgd2hpbGUobWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKSl7XG4gICAgICAgIC8vIGBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICBpZihsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KXtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3IgTlBDR1xuICAgICAgICAgIGlmKCFOUENHICYmIG1hdGNoW0xFTkdUSF0gPiAxKW1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGZvcihpID0gMTsgaSA8IGFyZ3VtZW50c1tMRU5HVEhdIC0gMjsgaSsrKWlmKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKW1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZihvdXRwdXRbTEVOR1RIXSA+PSBzcGxpdExpbWl0KWJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KXNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0rKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pe1xuICAgICAgICBpZihsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKW91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dFtMRU5HVEhdID4gc3BsaXRMaW1pdCA/IG91dHB1dC5zbGljZSgwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZignMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pe1xuICAgICRzcGxpdCA9IGZ1bmN0aW9uKHNlcGFyYXRvciwgbGltaXQpe1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9XG4gIC8vIDIxLjEuMy4xNyBTdHJpbmcucHJvdG90eXBlLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpXG4gIHJldHVybiBbZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChzZXBhcmF0b3IsIE8sIGxpbWl0KSA6ICRzcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gIH0sICRzcGxpdF07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qc1xuICoqIG1vZHVsZSBpZCA9IDIwM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIGdsb2JhbCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY3R4ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjbGFzc29mICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5JbnN0YW5jZSAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGZvck9mICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fc3BlY2llcy1jb25zdHJ1Y3RvcicpXG4gICwgdGFzayAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIG1pY3JvdGFzayAgICAgICAgICA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBQUk9NSVNFICAgICAgICAgICAgPSAnUHJvbWlzZSdcbiAgLCBUeXBlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuVHlwZUVycm9yXG4gICwgcHJvY2VzcyAgICAgICAgICAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCAkUHJvbWlzZSAgICAgICAgICAgPSBnbG9iYWxbUFJPTUlTRV1cbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIGlzTm9kZSAgICAgICAgICAgICA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnXG4gICwgZW1wdHkgICAgICAgICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIEludGVybmFsLCBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIFdyYXBwZXI7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIC8vIGNvcnJlY3Qgc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICAgIHZhciBwcm9taXNlICAgICA9ICRQcm9taXNlLnJlc29sdmUoMSlcbiAgICAgICwgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtyZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpXSA9IGZ1bmN0aW9uKGV4ZWMpeyBleGVjKGVtcHR5LCBlbXB0eSk7IH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJykgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBzYW1lQ29uc3RydWN0b3IgPSBmdW5jdGlvbihhLCBiKXtcbiAgLy8gd2l0aCBsaWJyYXJ5IHdyYXBwZXIgc3BlY2lhbCBjYXNlXG4gIHJldHVybiBhID09PSBiIHx8IGEgPT09ICRQcm9taXNlICYmIGIgPT09IFdyYXBwZXI7XG59O1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHJldHVybiBzYW1lQ29uc3RydWN0b3IoJFByb21pc2UsIEMpXG4gICAgPyBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICA6IG5ldyBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gR2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oQyl7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uKCQkcmVzb2x2ZSwgJCRyZWplY3Qpe1xuICAgIGlmKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBhRnVuY3Rpb24ocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ICA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbnZhciBwZXJmb3JtID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB7ZXJyb3I6IGV9O1xuICB9XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uKHByb21pc2UsIGlzUmVqZWN0KXtcbiAgaWYocHJvbWlzZS5fbilyZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIG9rICAgID0gcHJvbWlzZS5fcyA9PSAxXG4gICAgICAsIGkgICAgID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24ocmVhY3Rpb24pe1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbFxuICAgICAgICAsIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlXG4gICAgICAgICwgcmVqZWN0ICA9IHJlYWN0aW9uLnJlamVjdFxuICAgICAgICAsIGRvbWFpbiAgPSByZWFjdGlvbi5kb21haW5cbiAgICAgICAgLCByZXN1bHQsIHRoZW47XG4gICAgICB0cnkge1xuICAgICAgICBpZihoYW5kbGVyKXtcbiAgICAgICAgICBpZighb2spe1xuICAgICAgICAgICAgaWYocHJvbWlzZS5faCA9PSAyKW9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhhbmRsZXIgPT09IHRydWUpcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZihkb21haW4pZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZXhpdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihyZXN1bHQgPT09IHJlYWN0aW9uLnByb21pc2Upe1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSl7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSlydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZihpc1JlamVjdCAmJiAhcHJvbWlzZS5faClvblVuaGFuZGxlZChwcm9taXNlKTtcbiAgfSk7XG59O1xudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZhbHVlID0gcHJvbWlzZS5fdlxuICAgICAgLCBhYnJ1cHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYoaXNVbmhhbmRsZWQocHJvbWlzZSkpe1xuICAgICAgYWJydXB0ID0gcGVyZm9ybShmdW5jdGlvbigpe1xuICAgICAgICBpZihpc05vZGUpe1xuICAgICAgICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbil7XG4gICAgICAgICAgaGFuZGxlcih7cHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiB2YWx1ZX0pO1xuICAgICAgICB9IGVsc2UgaWYoKGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZSkgJiYgY29uc29sZS5lcnJvcil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEJyb3dzZXJzIHNob3VsZCBub3QgdHJpZ2dlciBgcmVqZWN0aW9uSGFuZGxlZGAgZXZlbnQgaWYgaXQgd2FzIGhhbmRsZWQgaGVyZSwgTm9kZUpTIC0gc2hvdWxkXG4gICAgICBwcm9taXNlLl9oID0gaXNOb2RlIHx8IGlzVW5oYW5kbGVkKHByb21pc2UpID8gMiA6IDE7XG4gICAgfSBwcm9taXNlLl9hID0gdW5kZWZpbmVkO1xuICAgIGlmKGFicnVwdCl0aHJvdyBhYnJ1cHQuZXJyb3I7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uKHByb21pc2Upe1xuICBpZihwcm9taXNlLl9oID09IDEpcmV0dXJuIGZhbHNlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9hIHx8IHByb21pc2UuX2NcbiAgICAsIGkgICAgID0gMFxuICAgICwgcmVhY3Rpb247XG4gIHdoaWxlKGNoYWluLmxlbmd0aCA+IGkpe1xuICAgIHJlYWN0aW9uID0gY2hhaW5baSsrXTtcbiAgICBpZihyZWFjdGlvbi5mYWlsIHx8ICFpc1VuaGFuZGxlZChyZWFjdGlvbi5wcm9taXNlKSlyZXR1cm4gZmFsc2U7XG4gIH0gcmV0dXJuIHRydWU7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYoaXNOb2RlKXtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCl7XG4gICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHByb21pc2UuX3Z9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24odmFsdWUpe1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIGlmKHByb21pc2UuX2QpcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmKCFwcm9taXNlLl9hKXByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpc1xuICAgICwgdGhlbjtcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgdHJ5IHtcbiAgICBpZihwcm9taXNlID09PSB2YWx1ZSl0aHJvdyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTtcbiAgICBpZih0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpe1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3cmFwcGVyID0ge193OiBwcm9taXNlLCBfZDogZmFsc2V9OyAvLyB3cmFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBjdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBjdHgoJHJlamVjdCwgd3JhcHBlciwgMSkpO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2goZSl7XG4gICAgJHJlamVjdC5jYWxsKHtfdzogcHJvbWlzZSwgX2Q6IGZhbHNlfSwgZSk7IC8vIHdyYXBcbiAgfVxufTtcblxuLy8gY29uc3RydWN0b3IgcG9seWZpbGxcbmlmKCFVU0VfTkFUSVZFKXtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICRQcm9taXNlLCBQUk9NSVNFLCAnX2gnKTtcbiAgICBhRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKGN0eCgkcmVzb2x2ZSwgdGhpcywgMSksIGN0eCgkcmVqZWN0LCB0aGlzLCAxKSk7XG4gICAgfSBjYXRjaChlcnIpe1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICBJbnRlcm5hbCA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpKCRQcm9taXNlLnByb3RvdHlwZSwge1xuICAgIC8vIDI1LjQuNS4zIFByb21pc2UucHJvdG90eXBlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpXG4gICAgdGhlbjogZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCl7XG4gICAgICB2YXIgcmVhY3Rpb24gICAgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rICAgICA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiB0cnVlO1xuICAgICAgcmVhY3Rpb24uZmFpbCAgID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fYSl0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYodGhpcy5fcylub3RpZnkodGhpcywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyAyNS40LjUuMSBQcm9taXNlLnByb3RvdHlwZS5jYXRjaChvblJlamVjdGVkKVxuICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0ZWQpe1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcHJvbWlzZSAgPSBuZXcgSW50ZXJuYWw7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ICA9IGN0eCgkcmVqZWN0LCBwcm9taXNlLCAxKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1Byb21pc2U6ICRQcm9taXNlfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpe1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkodGhpcylcbiAgICAgICwgJCRyZWplY3QgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCl7XG4gICAgLy8gaW5zdGFuY2VvZiBpbnN0ZWFkIG9mIGludGVybmFsIHNsb3QgY2hlY2sgYmVjYXVzZSB3ZSBzaG91bGQgZml4IGl0IHdpdGhvdXQgcmVwbGFjZW1lbnQgbmF0aXZlIFByb21pc2UgY29yZVxuICAgIGlmKHggaW5zdGFuY2VvZiAkUHJvbWlzZSAmJiBzYW1lQ29uc3RydWN0b3IoeC5jb25zdHJ1Y3RvciwgdGhpcykpcmV0dXJuIHg7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlc29sdmUgID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgICQkcmVzb2x2ZSh4KTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24oaXRlcil7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKXtcbiAgICB2YXIgQyAgICAgICAgICA9IHRoaXNcbiAgICAgICwgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICAsIHJlc29sdmUgICAgPSBjYXBhYmlsaXR5LnJlc29sdmVcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdmFsdWVzICAgID0gW11cbiAgICAgICAgLCBpbmRleCAgICAgPSAwXG4gICAgICAgICwgcmVtYWluaW5nID0gMTtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIHZhciAkaW5kZXggICAgICAgID0gaW5kZXgrK1xuICAgICAgICAgICwgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICAgIGlmKGFscmVhZHlDYWxsZWQpcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbJGluZGV4XSA9IHZhbHVlO1xuICAgICAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9LFxuICAvLyAyNS40LjQuNCBQcm9taXNlLnJhY2UoaXRlcmFibGUpXG4gIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVqZWN0ICAgICA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICBmb3JPZihpdGVyYWJsZSwgZmFsc2UsIGZ1bmN0aW9uKHByb21pc2Upe1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZihhYnJ1cHQpcmVqZWN0KGFicnVwdC5lcnJvcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5wcm9taXNlLmpzXG4gKiogbW9kdWxlIGlkID0gMjA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpe1xuICBpZighKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSl7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjdHggICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgY2FsbCAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKVxuICAsIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBnZXRJdGVyRm4gICA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJylcbiAgLCBCUkVBSyAgICAgICA9IHt9XG4gICwgUkVUVVJOICAgICAgPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKXtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24oKXsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKVxuICAgICwgZiAgICAgID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpXG4gICAgLCBpbmRleCAgPSAwXG4gICAgLCBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmKGlzQXJyYXlJdGVyKGl0ZXJGbikpZm9yKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7ICl7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTilyZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyAgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fZm9yLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gMjA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIFNQRUNJRVMgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE8sIEQpe1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yLCBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1xuICoqIG1vZHVsZSBpZCA9IDIwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGN0eCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaW52b2tlICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBodG1sICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19odG1sJylcbiAgLCBjZWwgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJylcbiAgLCBnbG9iYWwgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgc2V0VGFzayAgICAgICAgICAgID0gZ2xvYmFsLnNldEltbWVkaWF0ZVxuICAsIGNsZWFyVGFzayAgICAgICAgICA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZVxuICAsIE1lc3NhZ2VDaGFubmVsICAgICA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbFxuICAsIGNvdW50ZXIgICAgICAgICAgICA9IDBcbiAgLCBxdWV1ZSAgICAgICAgICAgICAgPSB7fVxuICAsIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnXG4gICwgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIGlkID0gK3RoaXM7XG4gIGlmKHF1ZXVlLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcnVuLmNhbGwoZXZlbnQuZGF0YSk7XG59O1xuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYoIXNldFRhc2sgfHwgIWNsZWFyVGFzayl7XG4gIHNldFRhc2sgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pe1xuICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcXVldWVbKytjb3VudGVyXSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpe1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZihyZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcycpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIEJyb3dzZXJzIHdpdGggTWVzc2FnZUNoYW5uZWwsIGluY2x1ZGVzIFdlYldvcmtlcnNcbiAgfSBlbHNlIGlmKE1lc3NhZ2VDaGFubmVsKXtcbiAgICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsO1xuICAgIHBvcnQgICAgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCAnKicpO1xuICAgIH07XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZihPTlJFQURZU1RBVEVDSEFOR0UgaW4gY2VsKCdzY3JpcHQnKSl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNlbCgnc2NyaXB0JykpW09OUkVBRFlTVEFURUNIQU5HRV0gPSBmdW5jdGlvbigpe1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4uY2FsbChpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogICBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdGFzay5qc1xuICoqIG1vZHVsZSBpZCA9IDIwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgbWFjcm90YXNrID0gcmVxdWlyZSgnLi9fdGFzaycpLnNldFxuICAsIE9ic2VydmVyICA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyXG4gICwgcHJvY2VzcyAgID0gZ2xvYmFsLnByb2Nlc3NcbiAgLCBQcm9taXNlICAgPSBnbG9iYWwuUHJvbWlzZVxuICAsIGlzTm9kZSAgICA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzLmRvbWFpbikpcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZShoZWFkKXtcbiAgICAgIGZuICAgPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICBpZihoZWFkKW5vdGlmeSgpO1xuICAgICAgICBlbHNlIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmKHBhcmVudClwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmKGlzTm9kZSl7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlclxuICB9IGVsc2UgaWYoT2JzZXJ2ZXIpe1xuICAgIHZhciB0b2dnbGUgPSB0cnVlXG4gICAgICAsIG5vZGUgICA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpe1xuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICAvLyBzdHJhbmdlIElFICsgd2VicGFjayBkZXYgc2VydmVyIGJ1ZyAtIHVzZSAuY2FsbChnbG9iYWwpXG4gICAgICBtYWNyb3Rhc2suY2FsbChnbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZuKXtcbiAgICB2YXIgdGFzayA9IHtmbjogZm4sIG5leHQ6IHVuZGVmaW5lZH07XG4gICAgaWYobGFzdClsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmKCFoZWFkKXtcbiAgICAgIGhlYWQgPSB0YXNrO1xuICAgICAgbm90aWZ5KCk7XG4gICAgfSBsYXN0ID0gdGFzaztcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19taWNyb3Rhc2suanNcbiAqKiBtb2R1bGUgaWQgPSAyMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgc3JjLCBzYWZlKXtcbiAgZm9yKHZhciBrZXkgaW4gc3JjKXJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgc2FmZSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMjEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gMjMuMSBNYXAgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ01hcCcsIGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICB2YXIgZW50cnkgPSBzdHJvbmcuZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudjtcbiAgfSxcbiAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSl7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcsIHRydWUpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYubWFwLmpzXG4gKiogbW9kdWxlIGlkID0gMjExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgZFAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgY3JlYXRlICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgY3R4ICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGFuSW5zdGFuY2UgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGRlZmluZWQgICAgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgZm9yT2YgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKVxuICAsIHN0ZXAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJylcbiAgLCBzZXRTcGVjaWVzICA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBmYXN0S2V5ICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5XG4gICwgU0laRSAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uKHRoYXQsIGtleSl7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSksIGVudHJ5O1xuICBpZihpbmRleCAhPT0gJ0YnKXJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvcihlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pe1xuICAgIGlmKGVudHJ5LmsgPT0ga2V5KXJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKXtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgaXRlcmFibGUpe1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpe1xuICAgICAgICBmb3IodmFyIHRoYXQgPSB0aGlzLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihlbnRyeS5wKWVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgICAsIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYoZW50cnkpe1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkublxuICAgICAgICAgICAgLCBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZihwcmV2KXByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYobmV4dCluZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmKHRoYXQuX2YgPT0gZW50cnkpdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYodGhhdC5fbCA9PSBlbnRyeSl0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhhdCA9IHVuZGVmaW5lZCAqLyl7XG4gICAgICAgIGFuSW5zdGFuY2UodGhpcywgQywgJ2ZvckVhY2gnKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpXG4gICAgICAgICAgLCBlbnRyeTtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKXtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmKERFU0NSSVBUT1JTKWRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIGRlZmluZWQodGhpc1tTSVpFXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24odGhhdCwga2V5LCB2YWx1ZSl7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KVxuICAgICAgLCBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZihlbnRyeSl7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZighdGhhdC5fZil0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZihwcmV2KXByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZihpbmRleCAhPT0gJ0YnKXRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uKEMsIE5BTUUsIElTX01BUCl7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgICAgIHRoaXMuX3QgPSBpdGVyYXRlZDsgIC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgdmFyIHRoYXQgID0gdGhpc1xuICAgICAgICAsIGtpbmQgID0gdGhhdC5fa1xuICAgICAgICAsIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUoZW50cnkgJiYgZW50cnkucillbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSl7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnICwgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXN0cm9uZy5qc1xuICoqIG1vZHVsZSBpZCA9IDIxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgcmVkZWZpbmVBbGwgICAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIG1ldGEgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpXG4gICwgZm9yT2YgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIGFuSW5zdGFuY2UgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmYWlscyAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCAkaXRlckRldGVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JylcbiAgLCBzZXRUb1N0cmluZ1RhZyAgICA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSyl7XG4gIHZhciBCYXNlICA9IGdsb2JhbFtOQU1FXVxuICAgICwgQyAgICAgPSBCYXNlXG4gICAgLCBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCdcbiAgICAsIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZVxuICAgICwgTyAgICAgPSB7fTtcbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uKEtFWSl7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZWRlZmluZShwcm90bywgS0VZLFxuICAgICAgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24oYSl7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnaGFzJyA/IGZ1bmN0aW9uIGhhcyhhKXtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpe1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyB1bmRlZmluZWQgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdhZGQnID8gZnVuY3Rpb24gYWRkKGEpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gc2V0KGEsIGIpeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7IHJldHVybiB0aGlzOyB9XG4gICAgKTtcbiAgfTtcbiAgaWYodHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSl7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbnN0YW5jZSAgICAgICAgICAgICA9IG5ldyBDXG4gICAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgICAsIEhBU05UX0NIQUlOSU5HICAgICAgID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZVxuICAgICAgLy8gVjggfiAgQ2hyb21pdW0gNDAtIHdlYWstY29sbGVjdGlvbnMgdGhyb3dzIG9uIHByaW1pdGl2ZXMsIGJ1dCBzaG91bGQgcmV0dXJuIGZhbHNlXG4gICAgICAsIFRIUk9XU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24oKXsgaW5zdGFuY2UuaGFzKDEpOyB9KVxuICAgICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgICAgLCBBQ0NFUFRfSVRFUkFCTEVTICAgICA9ICRpdGVyRGV0ZWN0KGZ1bmN0aW9uKGl0ZXIpeyBuZXcgQyhpdGVyKTsgfSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIC8vIGZvciBlYXJseSBpbXBsZW1lbnRhdGlvbnMgLTAgYW5kICswIG5vdCB0aGUgc2FtZVxuICAgICAgLCBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gVjggfiBDaHJvbWl1bSA0Mi0gZmFpbHMgb25seSB3aXRoIDUrIGVsZW1lbnRzXG4gICAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgQygpXG4gICAgICAgICAgLCBpbmRleCAgICAgPSA1O1xuICAgICAgICB3aGlsZShpbmRleC0tKSRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICAgIH0pO1xuICAgIGlmKCFBQ0NFUFRfSVRFUkFCTEVTKXsgXG4gICAgICBDID0gd3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIGl0ZXJhYmxlKXtcbiAgICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlLCB0YXJnZXQsIEMpO1xuICAgICAgICBpZihpdGVyYWJsZSAhPSB1bmRlZmluZWQpZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgICAgQy5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgIHByb3RvLmNvbnN0cnVjdG9yID0gQztcbiAgICB9XG4gICAgaWYoVEhST1dTX09OX1BSSU1JVElWRVMgfHwgQlVHR1lfWkVSTyl7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cbiAgICBpZihCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKWZpeE1ldGhvZChBRERFUik7XG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZihJU19XRUFLICYmIHByb3RvLmNsZWFyKWRlbGV0ZSBwcm90by5jbGVhcjtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqIChDICE9IEJhc2UpLCBPKTtcblxuICBpZighSVNfV0VBSyljb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCl7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiBzdHJvbmcuZGVmKHRoaXMsIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgc3Ryb25nKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnNldC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKVxuICAsIHJlZGVmaW5lICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBtZXRhICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhJylcbiAgLCBhc3NpZ24gICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJylcbiAgLCB3ZWFrICAgICAgICAgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZ2V0V2VhayAgICAgID0gbWV0YS5nZXRXZWFrXG4gICwgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZVxuICAsIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmVcbiAgLCB0bXAgICAgICAgICAgPSB7fVxuICAsIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uKGdldCl7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCl7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KXtcbiAgICBpZihpc09iamVjdChrZXkpKXtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYoZGF0YSA9PT0gdHJ1ZSlyZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGlzKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gd2Vhay5kZWYodGhpcywga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnV2Vha01hcCcsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZihuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3KXtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIpO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBwcm90byAgPSAkV2Vha01hcC5wcm90b3R5cGVcbiAgICAgICwgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbihhLCBiKXtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSl7XG4gICAgICAgIGlmKCF0aGlzLl9mKXRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXA7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBnZXRXZWFrICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrXG4gICwgYW5PYmplY3QgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbkluc3RhbmNlICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBmb3JPZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJylcbiAgLCAkaGFzICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgYXJyYXlGaW5kICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg1KVxuICAsIGFycmF5RmluZEluZGV4ICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNilcbiAgLCBpZCAgICAgICAgICAgICAgICA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbih0aGF0KXtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbigpe1xuICB0aGlzLmEgPSBbXTtcbn07XG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24oc3RvcmUsIGtleSl7XG4gIHJldHVybiBhcnJheUZpbmQoc3RvcmUuYSwgZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmKGVudHJ5KXJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmKGVudHJ5KWVudHJ5WzFdID0gdmFsdWU7XG4gICAgZWxzZSB0aGlzLmEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uKGl0KXtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmKH5pbmRleCl0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gaWQrKzsgICAgICAvLyBjb2xsZWN0aW9uIGlkXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpICYmIGRlbGV0ZSBkYXRhW3RoaXMuX2ldO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZihkYXRhID09PSB0cnVlKXVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIGVsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzXG4gKiogbW9kdWxlIGlkID0gMjE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xuXG4vLyAyMy40IFdlYWtTZXQgT2JqZWN0c1xucmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKCdXZWFrU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKXsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjQuMy4xIFdlYWtTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpe1xuICAgIHJldHVybiB3ZWFrLmRlZih0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG4gIH1cbn0sIHdlYWssIGZhbHNlLCB0cnVlKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzXG4gKiogbW9kdWxlIGlkID0gMjE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdHlwZWQgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICwgYnVmZmVyICAgICAgID0gcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJylcbiAgLCBhbk9iamVjdCAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIHRvSW5kZXggICAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCB0b0xlbmd0aCAgICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGlzT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgQXJyYXlCdWZmZXIgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuQXJyYXlCdWZmZXJcbiAgLCBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCAkQXJyYXlCdWZmZXIgPSBidWZmZXIuQXJyYXlCdWZmZXJcbiAgLCAkRGF0YVZpZXcgICAgPSBidWZmZXIuRGF0YVZpZXdcbiAgLCAkaXNWaWV3ICAgICAgPSAkdHlwZWQuQUJWICYmIEFycmF5QnVmZmVyLmlzVmlld1xuICAsICRzbGljZSAgICAgICA9ICRBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2VcbiAgLCBWSUVXICAgICAgICAgPSAkdHlwZWQuVklFV1xuICAsIEFSUkFZX0JVRkZFUiA9ICdBcnJheUJ1ZmZlcic7XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKEFycmF5QnVmZmVyICE9PSAkQXJyYXlCdWZmZXIpLCB7QXJyYXlCdWZmZXI6ICRBcnJheUJ1ZmZlcn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICEkdHlwZWQuQ09OU1RSLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS4zLjEgQXJyYXlCdWZmZXIuaXNWaWV3KGFyZylcbiAgaXNWaWV3OiBmdW5jdGlvbiBpc1ZpZXcoaXQpe1xuICAgIHJldHVybiAkaXNWaWV3ICYmICRpc1ZpZXcoaXQpIHx8IGlzT2JqZWN0KGl0KSAmJiBWSUVXIGluIGl0O1xuICB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlUgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhbmV3ICRBcnJheUJ1ZmZlcigyKS5zbGljZSgxLCB1bmRlZmluZWQpLmJ5dGVMZW5ndGg7XG59KSwgQVJSQVlfQlVGRkVSLCB7XG4gIC8vIDI0LjEuNC4zIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZShzdGFydCwgZW5kKVxuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCl7XG4gICAgaWYoJHNsaWNlICE9PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQpcmV0dXJuICRzbGljZS5jYWxsKGFuT2JqZWN0KHRoaXMpLCBzdGFydCk7IC8vIEZGIGZpeFxuICAgIHZhciBsZW4gICAgPSBhbk9iamVjdCh0aGlzKS5ieXRlTGVuZ3RoXG4gICAgICAsIGZpcnN0ICA9IHRvSW5kZXgoc3RhcnQsIGxlbilcbiAgICAgICwgZmluYWwgID0gdG9JbmRleChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IGVuZCwgbGVuKVxuICAgICAgLCByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkQXJyYXlCdWZmZXIpKSh0b0xlbmd0aChmaW5hbCAtIGZpcnN0KSlcbiAgICAgICwgdmlld1MgID0gbmV3ICREYXRhVmlldyh0aGlzKVxuICAgICAgLCB2aWV3VCAgPSBuZXcgJERhdGFWaWV3KHJlc3VsdClcbiAgICAgICwgaW5kZXggID0gMDtcbiAgICB3aGlsZShmaXJzdCA8IGZpbmFsKXtcbiAgICAgIHZpZXdULnNldFVpbnQ4KGluZGV4KyssIHZpZXdTLmdldFVpbnQ4KGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKEFSUkFZX0JVRkZFUik7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgVFlQRUQgID0gdWlkKCd0eXBlZF9hcnJheScpXG4gICwgVklFVyAgID0gdWlkKCd2aWV3JylcbiAgLCBBQlYgICAgPSAhIShnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZ2xvYmFsLkRhdGFWaWV3KVxuICAsIENPTlNUUiA9IEFCVlxuICAsIGkgPSAwLCBsID0gOSwgVHlwZWQ7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzID0gKFxuICAnSW50OEFycmF5LFVpbnQ4QXJyYXksVWludDhDbGFtcGVkQXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXknXG4pLnNwbGl0KCcsJyk7XG5cbndoaWxlKGkgPCBsKXtcbiAgaWYoVHlwZWQgPSBnbG9iYWxbVHlwZWRBcnJheUNvbnN0cnVjdG9yc1tpKytdXSl7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFRZUEVELCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCVjogICAgQUJWLFxuICBDT05TVFI6IENPTlNUUixcbiAgVFlQRUQ6ICBUWVBFRCxcbiAgVklFVzogICBWSUVXXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fdHlwZWQuanNcbiAqKiBtb2R1bGUgaWQgPSAyMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgLCAkdHlwZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkJylcbiAgLCBoaWRlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lQWxsICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBmYWlscyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBhbkluc3RhbmNlICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCB0b0ludGVnZXIgICAgICA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIHRvTGVuZ3RoICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBnT1BOICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZlxuICAsIGRQICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGFycmF5RmlsbCAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktZmlsbCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgQVJSQVlfQlVGRkVSICAgPSAnQXJyYXlCdWZmZXInXG4gICwgREFUQV9WSUVXICAgICAgPSAnRGF0YVZpZXcnXG4gICwgUFJPVE9UWVBFICAgICAgPSAncHJvdG90eXBlJ1xuICAsIFdST05HX0xFTkdUSCAgID0gJ1dyb25nIGxlbmd0aCEnXG4gICwgV1JPTkdfSU5ERVggICAgPSAnV3JvbmcgaW5kZXghJ1xuICAsICRBcnJheUJ1ZmZlciAgID0gZ2xvYmFsW0FSUkFZX0JVRkZFUl1cbiAgLCAkRGF0YVZpZXcgICAgICA9IGdsb2JhbFtEQVRBX1ZJRVddXG4gICwgTWF0aCAgICAgICAgICAgPSBnbG9iYWwuTWF0aFxuICAsIFJhbmdlRXJyb3IgICAgID0gZ2xvYmFsLlJhbmdlRXJyb3JcbiAgLCBJbmZpbml0eSAgICAgICA9IGdsb2JhbC5JbmZpbml0eVxuICAsIEJhc2VCdWZmZXIgICAgID0gJEFycmF5QnVmZmVyXG4gICwgYWJzICAgICAgICAgICAgPSBNYXRoLmFic1xuICAsIHBvdyAgICAgICAgICAgID0gTWF0aC5wb3dcbiAgLCBmbG9vciAgICAgICAgICA9IE1hdGguZmxvb3JcbiAgLCBsb2cgICAgICAgICAgICA9IE1hdGgubG9nXG4gICwgTE4yICAgICAgICAgICAgPSBNYXRoLkxOMlxuICAsIEJVRkZFUiAgICAgICAgID0gJ2J1ZmZlcidcbiAgLCBCWVRFX0xFTkdUSCAgICA9ICdieXRlTGVuZ3RoJ1xuICAsIEJZVEVfT0ZGU0VUICAgID0gJ2J5dGVPZmZzZXQnXG4gICwgJEJVRkZFUiAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfYicgOiBCVUZGRVJcbiAgLCAkTEVOR1RIICAgICAgICA9IERFU0NSSVBUT1JTID8gJ19sJyA6IEJZVEVfTEVOR1RIXG4gICwgJE9GRlNFVCAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfbycgOiBCWVRFX09GRlNFVDtcblxuLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcbnZhciBwYWNrSUVFRTc1NCA9IGZ1bmN0aW9uKHZhbHVlLCBtTGVuLCBuQnl0ZXMpe1xuICB2YXIgYnVmZmVyID0gQXJyYXkobkJ5dGVzKVxuICAgICwgZUxlbiAgID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gICAgLCBlTWF4ICAgPSAoMSA8PCBlTGVuKSAtIDFcbiAgICAsIGVCaWFzICA9IGVNYXggPj4gMVxuICAgICwgcnQgICAgID0gbUxlbiA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMFxuICAgICwgaSAgICAgID0gMFxuICAgICwgcyAgICAgID0gdmFsdWUgPCAwIHx8IHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDAgPyAxIDogMFxuICAgICwgZSwgbSwgYztcbiAgdmFsdWUgPSBhYnModmFsdWUpXG4gIGlmKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSBJbmZpbml0eSl7XG4gICAgbSA9IHZhbHVlICE9IHZhbHVlID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IGZsb29yKGxvZyh2YWx1ZSkgLyBMTjIpO1xuICAgIGlmKHZhbHVlICogKGMgPSBwb3coMiwgLWUpKSA8IDEpe1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZihlICsgZUJpYXMgPj0gMSl7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmKHZhbHVlICogYyA+PSAyKXtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG4gICAgaWYoZSArIGVCaWFzID49IGVNYXgpe1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYoZSArIGVCaWFzID49IDEpe1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIHBvdygyLCBlQmlhcyAtIDEpICogcG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG4gIGZvcig7IG1MZW4gPj0gODsgYnVmZmVyW2krK10gPSBtICYgMjU1LCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcbiAgZSA9IGUgPDwgbUxlbiB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yKDsgZUxlbiA+IDA7IGJ1ZmZlcltpKytdID0gZSAmIDI1NSwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG4gIGJ1ZmZlclstLWldIHw9IHMgKiAxMjg7XG4gIHJldHVybiBidWZmZXI7XG59O1xudmFyIHVucGFja0lFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIG1MZW4sIG5CeXRlcyl7XG4gIHZhciBlTGVuICA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICAgICwgZU1heCAgPSAoMSA8PCBlTGVuKSAtIDFcbiAgICAsIGVCaWFzID0gZU1heCA+PiAxXG4gICAgLCBuQml0cyA9IGVMZW4gLSA3XG4gICAgLCBpICAgICA9IG5CeXRlcyAtIDFcbiAgICAsIHMgICAgID0gYnVmZmVyW2ktLV1cbiAgICAsIGUgICAgID0gcyAmIDEyN1xuICAgICwgbTtcbiAgcyA+Pj0gNztcbiAgZm9yKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgZSA+Pj0gLW5CaXRzO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW2ldLCBpLS0sIG5CaXRzIC09IDgpO1xuICBpZihlID09PSAwKXtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYoZSA9PT0gZU1heCl7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiBzID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBwb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfSByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIHBvdygyLCBlIC0gbUxlbik7XG59O1xuXG52YXIgdW5wYWNrSTMyID0gZnVuY3Rpb24oYnl0ZXMpe1xuICByZXR1cm4gYnl0ZXNbM10gPDwgMjQgfCBieXRlc1syXSA8PCAxNiB8IGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbn07XG52YXIgcGFja0k4ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gW2l0ICYgMHhmZl07XG59O1xudmFyIHBhY2tJMTYgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZl07XG59O1xudmFyIHBhY2tJMzIgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBbaXQgJiAweGZmLCBpdCA+PiA4ICYgMHhmZiwgaXQgPj4gMTYgJiAweGZmLCBpdCA+PiAyNCAmIDB4ZmZdO1xufTtcbnZhciBwYWNrRjY0ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gcGFja0lFRUU3NTQoaXQsIDUyLCA4KTtcbn07XG52YXIgcGFja0YzMiA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCAyMywgNCk7XG59O1xuXG52YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24oQywga2V5LCBpbnRlcm5hbCl7XG4gIGRQKENbUFJPVE9UWVBFXSwga2V5LCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpc1tpbnRlcm5hbF07IH19KTtcbn07XG5cbnZhciBnZXQgPSBmdW5jdGlvbih2aWV3LCBieXRlcywgaW5kZXgsIGlzTGl0dGxlRW5kaWFuKXtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4XG4gICAgLCBpbnRJbmRleCA9IHRvSW50ZWdlcihudW1JbmRleCk7XG4gIGlmKG51bUluZGV4ICE9IGludEluZGV4IHx8IGludEluZGV4IDwgMCB8fCBpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSl0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYlxuICAgICwgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF1cbiAgICAsIHBhY2sgID0gc3RvcmUuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpO1xuICByZXR1cm4gaXNMaXR0bGVFbmRpYW4gPyBwYWNrIDogcGFjay5yZXZlcnNlKCk7XG59O1xudmFyIHNldCA9IGZ1bmN0aW9uKHZpZXcsIGJ5dGVzLCBpbmRleCwgY29udmVyc2lvbiwgdmFsdWUsIGlzTGl0dGxlRW5kaWFuKXtcbiAgdmFyIG51bUluZGV4ID0gK2luZGV4XG4gICAgLCBpbnRJbmRleCA9IHRvSW50ZWdlcihudW1JbmRleCk7XG4gIGlmKG51bUluZGV4ICE9IGludEluZGV4IHx8IGludEluZGV4IDwgMCB8fCBpbnRJbmRleCArIGJ5dGVzID4gdmlld1skTEVOR1RIXSl0aHJvdyBSYW5nZUVycm9yKFdST05HX0lOREVYKTtcbiAgdmFyIHN0b3JlID0gdmlld1skQlVGRkVSXS5fYlxuICAgICwgc3RhcnQgPSBpbnRJbmRleCArIHZpZXdbJE9GRlNFVF1cbiAgICAsIHBhY2sgID0gY29udmVyc2lvbigrdmFsdWUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYnl0ZXM7IGkrKylzdG9yZVtzdGFydCArIGldID0gcGFja1tpc0xpdHRsZUVuZGlhbiA/IGkgOiBieXRlcyAtIGkgLSAxXTtcbn07XG5cbnZhciB2YWxpZGF0ZUFycmF5QnVmZmVyQXJndW1lbnRzID0gZnVuY3Rpb24odGhhdCwgbGVuZ3RoKXtcbiAgYW5JbnN0YW5jZSh0aGF0LCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG4gIHZhciBudW1iZXJMZW5ndGggPSArbGVuZ3RoXG4gICAgLCBieXRlTGVuZ3RoICAgPSB0b0xlbmd0aChudW1iZXJMZW5ndGgpO1xuICBpZihudW1iZXJMZW5ndGggIT0gYnl0ZUxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gIHJldHVybiBieXRlTGVuZ3RoO1xufTtcblxuaWYoISR0eXBlZC5BQlYpe1xuICAkQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiBBcnJheUJ1ZmZlcihsZW5ndGgpe1xuICAgIHZhciBieXRlTGVuZ3RoID0gdmFsaWRhdGVBcnJheUJ1ZmZlckFyZ3VtZW50cyh0aGlzLCBsZW5ndGgpO1xuICAgIHRoaXMuX2IgICAgICAgPSBhcnJheUZpbGwuY2FsbChBcnJheShieXRlTGVuZ3RoKSwgMCk7XG4gICAgdGhpc1skTEVOR1RIXSA9IGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgJERhdGFWaWV3ID0gZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKXtcbiAgICBhbkluc3RhbmNlKHRoaXMsICREYXRhVmlldywgREFUQV9WSUVXKTtcbiAgICBhbkluc3RhbmNlKGJ1ZmZlciwgJEFycmF5QnVmZmVyLCBEQVRBX1ZJRVcpO1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBidWZmZXJbJExFTkdUSF1cbiAgICAgICwgb2Zmc2V0ICAgICAgID0gdG9JbnRlZ2VyKGJ5dGVPZmZzZXQpO1xuICAgIGlmKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKXRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG9mZnNldCEnKTtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gYnVmZmVyTGVuZ3RoIC0gb2Zmc2V0IDogdG9MZW5ndGgoYnl0ZUxlbmd0aCk7XG4gICAgaWYob2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlckxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgdGhpc1skQlVGRkVSXSA9IGJ1ZmZlcjtcbiAgICB0aGlzWyRPRkZTRVRdID0gb2Zmc2V0O1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gIGlmKERFU0NSSVBUT1JTKXtcbiAgICBhZGRHZXR0ZXIoJEFycmF5QnVmZmVyLCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQlVGRkVSLCAnX2InKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCBCWVRFX0xFTkdUSCwgJ19sJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9PRkZTRVQsICdfbycpO1xuICB9XG5cbiAgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpe1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXSA8PCAyNCA+PiAyNDtcbiAgICB9LFxuICAgIGdldFVpbnQ4OiBmdW5jdGlvbiBnZXRVaW50OChieXRlT2Zmc2V0KXtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG4gICAgfSxcbiAgICBnZXRJbnQxNjogZnVuY3Rpb24gZ2V0SW50MTYoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pO1xuICAgICAgcmV0dXJuIGJ5dGVzWzFdIDw8IDggfCBieXRlc1swXTtcbiAgICB9LFxuICAgIGdldEludDMyOiBmdW5jdGlvbiBnZXRJbnQzMihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSk7XG4gICAgfSxcbiAgICBnZXRVaW50MzI6IGZ1bmN0aW9uIGdldFVpbnQzMihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgcmV0dXJuIHVucGFja0kzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSkgPj4+IDA7XG4gICAgfSxcbiAgICBnZXRGbG9hdDMyOiBmdW5jdGlvbiBnZXRGbG9hdDMyKGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKSwgMjMsIDQpO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDUyLCA4KTtcbiAgICB9LFxuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpe1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJOCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKXtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJMTYsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0kzMiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tGMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQ2NDogZnVuY3Rpb24gc2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBwYWNrRjY0LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgaWYoIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3ICRBcnJheUJ1ZmZlcjsgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyAkQXJyYXlCdWZmZXIoLjUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSl7XG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKXtcbiAgICAgIHJldHVybiBuZXcgQmFzZUJ1ZmZlcih2YWxpZGF0ZUFycmF5QnVmZmVyQXJndW1lbnRzKHRoaXMsIGxlbmd0aCkpO1xuICAgIH07XG4gICAgdmFyIEFycmF5QnVmZmVyUHJvdG8gPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXSA9IEJhc2VCdWZmZXJbUFJPVE9UWVBFXTtcbiAgICBmb3IodmFyIGtleXMgPSBnT1BOKEJhc2VCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7ICl7XG4gICAgICBpZighKChrZXkgPSBrZXlzW2orK10pIGluICRBcnJheUJ1ZmZlcikpaGlkZSgkQXJyYXlCdWZmZXIsIGtleSwgQmFzZUJ1ZmZlcltrZXldKTtcbiAgICB9O1xuICAgIGlmKCFMSUJSQVJZKUFycmF5QnVmZmVyUHJvdG8uY29uc3RydWN0b3IgPSAkQXJyYXlCdWZmZXI7XG4gIH1cbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXG4gIHZhciB2aWV3ID0gbmV3ICREYXRhVmlldyhuZXcgJEFycmF5QnVmZmVyKDIpKVxuICAgICwgJHNldEludDggPSAkRGF0YVZpZXdbUFJPVE9UWVBFXS5zZXRJbnQ4O1xuICB2aWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYodmlldy5nZXRJbnQ4KDApIHx8ICF2aWV3LmdldEludDgoMSkpcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKXtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKXtcbiAgICAgICRzZXRJbnQ4LmNhbGwodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG59XG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5oaWRlKCREYXRhVmlld1tQUk9UT1RZUEVdLCAkdHlwZWQuVklFVywgdHJ1ZSk7XG5leHBvcnRzW0FSUkFZX0JVRkZFUl0gPSAkQXJyYXlCdWZmZXI7XG5leHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL190eXBlZC1idWZmZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL190eXBlZCcpLkFCViwge1xuICBEYXRhVmlldzogcmVxdWlyZSgnLi9fdHlwZWQtYnVmZmVyJykuRGF0YVZpZXdcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3LmpzXG4gKiogbW9kdWxlIGlkID0gMjIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQ4JywgMSwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQ4LWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG5pZihyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpKXtcbiAgdmFyIExJQlJBUlkgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgICAsIGdsb2JhbCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAgICwgZmFpbHMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgICAsICRleHBvcnQgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAgICwgJHR5cGVkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkJylcbiAgICAsICRidWZmZXIgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKVxuICAgICwgY3R4ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICAgLCBhbkluc3RhbmNlICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAgICwgcHJvcGVydHlEZXNjICAgICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAgICwgaGlkZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAgICwgcmVkZWZpbmVBbGwgICAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICAgLCB0b0ludGVnZXIgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICAgLCB0b0xlbmd0aCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgICAsIHRvSW5kZXggICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICAgLCB0b1ByaW1pdGl2ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgICAsIGhhcyAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAgICwgc2FtZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3NhbWUtdmFsdWUnKVxuICAgICwgY2xhc3NvZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAgICwgaXNPYmplY3QgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICAgLCB0b09iamVjdCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgICAsIGlzQXJyYXlJdGVyICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgICAsIGNyZWF0ZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgICAsIGdldFByb3RvdHlwZU9mICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgICAsIGdPUE4gICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgICAsIGdldEl0ZXJGbiAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpXG4gICAgLCB1aWQgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgICAsIHdrcyAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAgICwgY3JlYXRlQXJyYXlNZXRob2QgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKVxuICAgICwgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJylcbiAgICAsIHNwZWNpZXNDb25zdHJ1Y3RvciAgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgICAsIEFycmF5SXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpXG4gICAgLCBJdGVyYXRvcnMgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgICAsICRpdGVyRGV0ZWN0ICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpXG4gICAgLCBzZXRTcGVjaWVzICAgICAgICAgID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKVxuICAgICwgYXJyYXlGaWxsICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKVxuICAgICwgYXJyYXlDb3B5V2l0aGluICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJylcbiAgICAsICREUCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAgICwgJEdPUEQgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgICAsIGRQICAgICAgICAgICAgICAgICAgPSAkRFAuZlxuICAgICwgZ09QRCAgICAgICAgICAgICAgICA9ICRHT1BELmZcbiAgICAsIFJhbmdlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxuICAgICwgVHlwZUVycm9yICAgICAgICAgICA9IGdsb2JhbC5UeXBlRXJyb3JcbiAgICAsIFVpbnQ4QXJyYXkgICAgICAgICAgPSBnbG9iYWwuVWludDhBcnJheVxuICAgICwgQVJSQVlfQlVGRkVSICAgICAgICA9ICdBcnJheUJ1ZmZlcidcbiAgICAsIFNIQVJFRF9CVUZGRVIgICAgICAgPSAnU2hhcmVkJyArIEFSUkFZX0JVRkZFUlxuICAgICwgQllURVNfUEVSX0VMRU1FTlQgICA9ICdCWVRFU19QRVJfRUxFTUVOVCdcbiAgICAsIFBST1RPVFlQRSAgICAgICAgICAgPSAncHJvdG90eXBlJ1xuICAgICwgQXJyYXlQcm90byAgICAgICAgICA9IEFycmF5W1BST1RPVFlQRV1cbiAgICAsICRBcnJheUJ1ZmZlciAgICAgICAgPSAkYnVmZmVyLkFycmF5QnVmZmVyXG4gICAgLCAkRGF0YVZpZXcgICAgICAgICAgID0gJGJ1ZmZlci5EYXRhVmlld1xuICAgICwgYXJyYXlGb3JFYWNoICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDApXG4gICAgLCBhcnJheUZpbHRlciAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoMilcbiAgICAsIGFycmF5U29tZSAgICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCgzKVxuICAgICwgYXJyYXlFdmVyeSAgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDQpXG4gICAgLCBhcnJheUZpbmQgICAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNSlcbiAgICAsIGFycmF5RmluZEluZGV4ICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg2KVxuICAgICwgYXJyYXlJbmNsdWRlcyAgICAgICA9IGNyZWF0ZUFycmF5SW5jbHVkZXModHJ1ZSlcbiAgICAsIGFycmF5SW5kZXhPZiAgICAgICAgPSBjcmVhdGVBcnJheUluY2x1ZGVzKGZhbHNlKVxuICAgICwgYXJyYXlWYWx1ZXMgICAgICAgICA9IEFycmF5SXRlcmF0b3JzLnZhbHVlc1xuICAgICwgYXJyYXlLZXlzICAgICAgICAgICA9IEFycmF5SXRlcmF0b3JzLmtleXNcbiAgICAsIGFycmF5RW50cmllcyAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzXG4gICAgLCBhcnJheUxhc3RJbmRleE9mICAgID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZlxuICAgICwgYXJyYXlSZWR1Y2UgICAgICAgICA9IEFycmF5UHJvdG8ucmVkdWNlXG4gICAgLCBhcnJheVJlZHVjZVJpZ2h0ICAgID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodFxuICAgICwgYXJyYXlKb2luICAgICAgICAgICA9IEFycmF5UHJvdG8uam9pblxuICAgICwgYXJyYXlTb3J0ICAgICAgICAgICA9IEFycmF5UHJvdG8uc29ydFxuICAgICwgYXJyYXlTbGljZSAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2VcbiAgICAsIGFycmF5VG9TdHJpbmcgICAgICAgPSBBcnJheVByb3RvLnRvU3RyaW5nXG4gICAgLCBhcnJheVRvTG9jYWxlU3RyaW5nID0gQXJyYXlQcm90by50b0xvY2FsZVN0cmluZ1xuICAgICwgSVRFUkFUT1IgICAgICAgICAgICA9IHdrcygnaXRlcmF0b3InKVxuICAgICwgVEFHICAgICAgICAgICAgICAgICA9IHdrcygndG9TdHJpbmdUYWcnKVxuICAgICwgVFlQRURfQ09OU1RSVUNUT1IgICA9IHVpZCgndHlwZWRfY29uc3RydWN0b3InKVxuICAgICwgREVGX0NPTlNUUlVDVE9SICAgICA9IHVpZCgnZGVmX2NvbnN0cnVjdG9yJylcbiAgICAsIEFMTF9DT05TVFJVQ1RPUlMgICAgPSAkdHlwZWQuQ09OU1RSXG4gICAgLCBUWVBFRF9BUlJBWSAgICAgICAgID0gJHR5cGVkLlRZUEVEXG4gICAgLCBWSUVXICAgICAgICAgICAgICAgID0gJHR5cGVkLlZJRVdcbiAgICAsIFdST05HX0xFTkdUSCAgICAgICAgPSAnV3JvbmcgbGVuZ3RoISc7XG5cbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbihPLCBsZW5ndGgpe1xuICAgIHJldHVybiBhbGxvY2F0ZShzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGVuZ3RoKTtcbiAgfSk7XG5cbiAgdmFyIExJVFRMRV9FTkRJQU4gPSBmYWlscyhmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVWludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdID09PSAxO1xuICB9KTtcblxuICB2YXIgRk9SQ0VEX1NFVCA9ICEhVWludDhBcnJheSAmJiAhIVVpbnQ4QXJyYXlbUFJPVE9UWVBFXS5zZXQgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgc3RyaWN0VG9MZW5ndGggPSBmdW5jdGlvbihpdCwgU0FNRSl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB2YXIgbnVtYmVyID0gK2l0XG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKGl0KTtcbiAgICBpZihTQU1FICYmICFzYW1lKG51bWJlciwgbGVuZ3RoKSl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbihpdCwgQllURVMpe1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoaXQpO1xuICAgIGlmKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24oaXQpe1xuICAgIGlmKGlzT2JqZWN0KGl0KSAmJiBUWVBFRF9BUlJBWSBpbiBpdClyZXR1cm4gaXQ7XG4gICAgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSEnKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbihDLCBsZW5ndGgpe1xuICAgIGlmKCEoaXNPYmplY3QoQykgJiYgVFlQRURfQ09OU1RSVUNUT1IgaW4gQykpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9IHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbihPLCBsaXN0KXtcbiAgICByZXR1cm4gZnJvbUxpc3Qoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxpc3QpO1xuICB9O1xuXG4gIHZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uKEMsIGxpc3Qpe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoXG4gICAgICAsIHJlc3VsdCA9IGFsbG9jYXRlKEMsIGxlbmd0aCk7XG4gICAgd2hpbGUobGVuZ3RoID4gaW5kZXgpcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24oaXQsIGtleSwgaW50ZXJuYWwpe1xuICAgIGRQKGl0LCBrZXksIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9kW2ludGVybmFsXTsgfX0pO1xuICB9O1xuXG4gIHZhciAkZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qLCBtYXBmbiwgdGhpc0FyZyAqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChzb3VyY2UpXG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGksIGxlbmd0aCwgdmFsdWVzLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHZhbHVlcyA9IFtdLCBpID0gMDsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpKyspe1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH0gTyA9IHZhbHVlcztcbiAgICB9XG4gICAgaWYobWFwcGluZyAmJiBhTGVuID4gMiltYXBmbiA9IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICBmb3IoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKXtcbiAgICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyICRvZiA9IGZ1bmN0aW9uIG9mKC8qLi4uaXRlbXMqLyl7XG4gICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpO1xuICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG4gIHZhciBUT19MT0NBTEVfQlVHID0gISFVaW50OEFycmF5ICYmIGZhaWxzKGZ1bmN0aW9uKCl7IGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7IH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpe1xuICAgIHJldHVybiBhcnJheVRvTG9jYWxlU3RyaW5nLmFwcGx5KFRPX0xPQ0FMRV9CVUcgPyBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcykpIDogdmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHByb3RvID0ge1xuICAgIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCAvKiwgZW5kICovKXtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RXZlcnkodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0LCBlbmQgKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlGaWxsLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RmluZCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUgLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RmluZEluZGV4KHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXtcbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YodmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8pe1xuICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXModmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlMYXN0SW5kZXhPZi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcGZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiwgaW5pdGlhbFZhbHVlICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyosIGluaXRpYWxWYWx1ZSAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZVJpZ2h0LmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpe1xuICAgICAgdmFyIHRoYXQgICA9IHRoaXNcbiAgICAgICAgLCBsZW5ndGggPSB2YWxpZGF0ZSh0aGF0KS5sZW5ndGhcbiAgICAgICAgLCBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpXG4gICAgICAgICwgaW5kZXggID0gMFxuICAgICAgICAsIHZhbHVlO1xuICAgICAgd2hpbGUoaW5kZXggPCBtaWRkbGUpe1xuICAgICAgICB2YWx1ZSAgICAgICAgID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdICA9IHZhbHVlO1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9LFxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlTb21lKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbil7XG4gICAgICByZXR1cm4gYXJyYXlTb3J0LmNhbGwodmFsaWRhdGUodGhpcyksIGNvbXBhcmVmbik7XG4gICAgfSxcbiAgICBzdWJhcnJheTogZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCl7XG4gICAgICB2YXIgTyAgICAgID0gdmFsaWRhdGUodGhpcylcbiAgICAgICAgLCBsZW5ndGggPSBPLmxlbmd0aFxuICAgICAgICAsICRiZWdpbiA9IHRvSW5kZXgoYmVnaW4sIGxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSkoXG4gICAgICAgIE8uYnVmZmVyLFxuICAgICAgICBPLmJ5dGVPZmZzZXQgKyAkYmVnaW4gKiBPLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICB0b0xlbmd0aCgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKSkgLSAkYmVnaW4pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgJHNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCl7XG4gICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcyksIHN0YXJ0LCBlbmQpKTtcbiAgfTtcblxuICB2YXIgJHNldCA9IGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyosIG9mZnNldCAqLyl7XG4gICAgdmFsaWRhdGUodGhpcyk7XG4gICAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50c1sxXSwgMSlcbiAgICAgICwgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICAgICwgc3JjICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBsZW4gICAgPSB0b0xlbmd0aChzcmMubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwO1xuICAgIGlmKGxlbiArIG9mZnNldCA+IGxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgd2hpbGUoaW5kZXggPCBsZW4pdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG4gIH07XG5cbiAgdmFyICRpdGVyYXRvcnMgPSB7XG4gICAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpe1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKXtcbiAgICAgIHJldHVybiBhcnJheUtleXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpe1xuICAgICAgcmV0dXJuIGFycmF5VmFsdWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNUQUluZGV4ID0gZnVuY3Rpb24odGFyZ2V0LCBrZXkpe1xuICAgIHJldHVybiBpc09iamVjdCh0YXJnZXQpXG4gICAgICAmJiB0YXJnZXRbVFlQRURfQVJSQVldXG4gICAgICAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnXG4gICAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAmJiBTdHJpbmcoK2tleSkgPT0gU3RyaW5nKGtleSk7XG4gIH07XG4gIHZhciAkZ2V0RGVzYyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSl7XG4gICAgcmV0dXJuIGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICA/IHByb3BlcnR5RGVzYygyLCB0YXJnZXRba2V5XSlcbiAgICAgIDogZ09QRCh0YXJnZXQsIGtleSk7XG4gIH07XG4gIHZhciAkc2V0RGVzYyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjKXtcbiAgICBpZihpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgJiYgaXNPYmplY3QoZGVzYylcbiAgICAgICYmIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnZ2V0JylcbiAgICAgICYmICFoYXMoZGVzYywgJ3NldCcpXG4gICAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuICAgICAgJiYgIWRlc2MuY29uZmlndXJhYmxlXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnd3JpdGFibGUnKSB8fCBkZXNjLndyaXRhYmxlKVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ2VudW1lcmFibGUnKSB8fCBkZXNjLmVudW1lcmFibGUpXG4gICAgKXtcbiAgICAgIHRhcmdldFtrZXldID0gZGVzYy52YWx1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSBlbHNlIHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYoIUFMTF9DT05TVFJVQ1RPUlMpe1xuICAgICRHT1BELmYgPSAkZ2V0RGVzYztcbiAgICAkRFAuZiAgID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICAgICAgICAgICAkc2V0RGVzY1xuICB9KTtcblxuICBpZihmYWlscyhmdW5jdGlvbigpeyBhcnJheVRvU3RyaW5nLmNhbGwoe30pOyB9KSl7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciAkVHlwZWRBcnJheVByb3RvdHlwZSQgPSByZWRlZmluZUFsbCh7fSwgcHJvdG8pO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsICRpdGVyYXRvcnMpO1xuICBoaWRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgSVRFUkFUT1IsICRpdGVyYXRvcnMudmFsdWVzKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCB7XG4gICAgc2xpY2U6ICAgICAgICAgICRzbGljZSxcbiAgICBzZXQ6ICAgICAgICAgICAgJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogICAgZnVuY3Rpb24oKXsgLyogbm9vcCAqLyB9LFxuICAgIHRvU3RyaW5nOiAgICAgICBhcnJheVRvU3RyaW5nLFxuICAgIHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmdcbiAgfSk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdidWZmZXInLCAnYicpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZU9mZnNldCcsICdvJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlTGVuZ3RoJywgJ2wnKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2xlbmd0aCcsICdlJyk7XG4gIGRQKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgVEFHLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpc1tUWVBFRF9BUlJBWV07IH1cbiAgfSk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKXtcbiAgICBDTEFNUEVEID0gISFDTEFNUEVEO1xuICAgIHZhciBOQU1FICAgICAgID0gS0VZICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknXG4gICAgICAsIElTTlRfVUlOVDggPSBOQU1FICE9ICdVaW50OEFycmF5J1xuICAgICAgLCBHRVRURVIgICAgID0gJ2dldCcgKyBLRVlcbiAgICAgICwgU0VUVEVSICAgICA9ICdzZXQnICsgS0VZXG4gICAgICAsIFR5cGVkQXJyYXkgPSBnbG9iYWxbTkFNRV1cbiAgICAgICwgQmFzZSAgICAgICA9IFR5cGVkQXJyYXkgfHwge31cbiAgICAgICwgVEFDICAgICAgICA9IFR5cGVkQXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheSlcbiAgICAgICwgRk9SQ0VEICAgICA9ICFUeXBlZEFycmF5IHx8ICEkdHlwZWQuQUJWXG4gICAgICAsIE8gICAgICAgICAgPSB7fVxuICAgICAgLCBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheSAmJiBUeXBlZEFycmF5W1BST1RPVFlQRV07XG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uKHRoYXQsIGluZGV4KXtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbih0aGF0LCBpbmRleCwgdmFsdWUpe1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgaWYoQ0xBTVBFRCl2YWx1ZSA9ICh2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweGZmID8gMHhmZiA6IHZhbHVlICYgMHhmZjtcbiAgICAgIGRhdGEudltTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIHZhbHVlLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBhZGRFbGVtZW50ID0gZnVuY3Rpb24odGhhdCwgaW5kZXgpe1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKXtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpe1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUsICdfZCcpO1xuICAgICAgICB2YXIgaW5kZXggID0gMFxuICAgICAgICAgICwgb2Zmc2V0ID0gMFxuICAgICAgICAgICwgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuICAgICAgICBpZighaXNPYmplY3QoZGF0YSkpe1xuICAgICAgICAgIGxlbmd0aCAgICAgPSBzdHJpY3RUb0xlbmd0aChkYXRhLCB0cnVlKVxuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgICAgID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpe1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgb2Zmc2V0ID0gdG9PZmZzZXQoJG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmKCRsZW5ndGggPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBpZigkbGVuICUgQllURVMpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZihieXRlTGVuZ3RoIDwgMCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZihUWVBFRF9BUlJBWSBpbiBkYXRhKXtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlKGluZGV4IDwgbGVuZ3RoKWFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBjcmVhdGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheSk7XG4gICAgfSBlbHNlIGlmKCEkaXRlckRldGVjdChmdW5jdGlvbihpdGVyKXtcbiAgICAgIC8vIFY4IHdvcmtzIHdpdGggaXRlcmF0b3JzLCBidXQgZmFpbHMgaW4gbWFueSBvdGhlciBjYXNlc1xuICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQ1NTJcbiAgICAgIG5ldyBUeXBlZEFycmF5KG51bGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpe1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCl7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzcztcbiAgICAgICAgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcbiAgICAgICAgaWYoIWlzT2JqZWN0KGRhdGEpKXJldHVybiBuZXcgQmFzZShzdHJpY3RUb0xlbmd0aChkYXRhLCBJU05UX1VJTlQ4KSk7XG4gICAgICAgIGlmKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpe1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoVFlQRURfQVJSQVkgaW4gZGF0YSlyZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBhcnJheUZvckVhY2goVEFDICE9PSBGdW5jdGlvbi5wcm90b3R5cGUgPyBnT1BOKEJhc2UpLmNvbmNhdChnT1BOKFRBQykpIDogZ09QTihCYXNlKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgaWYoIShrZXkgaW4gVHlwZWRBcnJheSkpaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZighTElCUkFSWSlUeXBlZEFycmF5UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRBcnJheTtcbiAgICB9XG4gICAgdmFyICRuYXRpdmVJdGVyYXRvciAgID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl1cbiAgICAgICwgQ09SUkVDVF9JVEVSX05BTUUgPSAhISRuYXRpdmVJdGVyYXRvciAmJiAoJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKVxuICAgICAgLCAkaXRlcmF0b3IgICAgICAgICA9ICRpdGVyYXRvcnMudmFsdWVzO1xuICAgIGhpZGUoVHlwZWRBcnJheSwgVFlQRURfQ09OU1RSVUNUT1IsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVFlQRURfQVJSQVksIE5BTUUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBERUZfQ09OU1RSVUNUT1IsIFR5cGVkQXJyYXkpO1xuXG4gICAgaWYoQ0xBTVBFRCA/IG5ldyBUeXBlZEFycmF5KDEpW1RBR10gIT0gTkFNRSA6ICEoVEFHIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKXtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBOQU1FOyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPW05BTUVdID0gVHlwZWRBcnJheTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXkgIT0gQmFzZSksIE8pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMsIE5BTUUsIHtcbiAgICAgIEJZVEVTX1BFUl9FTEVNRU5UOiBCWVRFUyxcbiAgICAgIGZyb206ICRmcm9tLFxuICAgICAgb2Y6ICRvZlxuICAgIH0pO1xuXG4gICAgaWYoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSloaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCwgTkFNRSwgcHJvdG8pO1xuXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0VEX1NFVCwgTkFNRSwge3NldDogJHNldH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyAhPSBhcnJheVRvU3RyaW5nKSwgTkFNRSwge3RvU3RyaW5nOiBhcnJheVRvU3RyaW5nfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICBuZXcgVHlwZWRBcnJheSgxKS5zbGljZSgpO1xuICAgIH0pLCBOQU1FLCB7c2xpY2U6ICRzbGljZX0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKClcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwge3RvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmd9KTtcblxuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IENPUlJFQ1RfSVRFUl9OQU1FID8gJG5hdGl2ZUl0ZXJhdG9yIDogJGl0ZXJhdG9yO1xuICAgIGlmKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSloaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIElURVJBVE9SLCAkaXRlcmF0b3IpO1xuICB9O1xufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50OCcsIDEsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhDbGFtcGVkQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSwgdHJ1ZSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1jbGFtcGVkLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQxNicsIDIsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50MTZBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDE2LWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MTYnLCAyLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDE2LWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdJbnQzMicsIDQsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gSW50MzJBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDMyLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjI4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MzInLCA0LCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDMyJywgNCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDMyLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDY0QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMjMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgckFwcGx5ICAgID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmFwcGx5XG4gICwgZkFwcGx5ICAgID0gRnVuY3Rpb24uYXBwbHk7XG4vLyBNUyBFZGdlIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgckFwcGx5KGZ1bmN0aW9uKCl7fSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCl7XG4gICAgdmFyIFQgPSBhRnVuY3Rpb24odGFyZ2V0KVxuICAgICAgLCBMID0gYW5PYmplY3QoYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIHJBcHBseSA/IHJBcHBseShULCB0aGlzQXJndW1lbnQsIEwpIDogZkFwcGx5LmNhbGwoVCwgdGhpc0FyZ3VtZW50LCBMKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzXG4gKiogbW9kdWxlIGlkID0gMjMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjIgUmVmbGVjdC5jb25zdHJ1Y3QodGFyZ2V0LCBhcmd1bWVudHNMaXN0IFssIG5ld1RhcmdldF0pXG52YXIgJGV4cG9ydCAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY3JlYXRlICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBmYWlscyAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGJpbmQgICAgICAgPSByZXF1aXJlKCcuL19iaW5kJylcbiAgLCByQ29uc3RydWN0ID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmNvbnN0cnVjdDtcblxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyhmdW5jdGlvbigpe1xuICBmdW5jdGlvbiBGKCl7fVxuICByZXR1cm4gIShyQ29uc3RydWN0KGZ1bmN0aW9uKCl7fSwgW10sIEYpIGluc3RhbmNlb2YgRik7XG59KTtcbnZhciBBUkdTX0JVRyA9ICFmYWlscyhmdW5jdGlvbigpe1xuICByQ29uc3RydWN0KGZ1bmN0aW9uKCl7fSk7XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTkVXX1RBUkdFVF9CVUcgfHwgQVJHU19CVUcpLCAnUmVmbGVjdCcsIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qLCBuZXdUYXJnZXQqLyl7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYoQVJHU19CVUcgJiYgIU5FV19UQVJHRVRfQlVHKXJldHVybiByQ29uc3RydWN0KFRhcmdldCwgYXJncywgbmV3VGFyZ2V0KTtcbiAgICBpZihUYXJnZXQgPT0gbmV3VGFyZ2V0KXtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgVGFyZ2V0O1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgICRhcmdzLnB1c2guYXBwbHkoJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYmluZC5hcHBseShUYXJnZXQsICRhcmdzKSk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byAgICA9IG5ld1RhcmdldC5wcm90b3R5cGVcbiAgICAgICwgaW5zdGFuY2UgPSBjcmVhdGUoaXNPYmplY3QocHJvdG8pID8gcHJvdG8gOiBPYmplY3QucHJvdG90eXBlKVxuICAgICAgLCByZXN1bHQgICA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmNvbnN0cnVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS4zIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcylcbnZhciBkUCAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShkUC5mKHt9LCAxLCB7dmFsdWU6IDF9KSwgMSwge3ZhbHVlOiAyfSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUocHJvcGVydHlLZXksIHRydWUpO1xuICAgIGFuT2JqZWN0KGF0dHJpYnV0ZXMpO1xuICAgIHRyeSB7XG4gICAgICBkUC5mKHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5kZWZpbmUtcHJvcGVydHkuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuNCBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGdPUEQgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgdmFyIGRlc2MgPSBnT1BEKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgICByZXR1cm4gZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUgPyBmYWxzZSA6IGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlLZXldO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMjM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyAyNi4xLjUgUmVmbGVjdC5lbnVtZXJhdGUodGFyZ2V0KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIEVudW1lcmF0ZSA9IGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IGFuT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdmFyIGtleXMgPSB0aGlzLl9rID0gW10gICAgICAgLy8ga2V5c1xuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIGl0ZXJhdGVkKWtleXMucHVzaChrZXkpO1xufTtcbnJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJykoRW51bWVyYXRlLCAnT2JqZWN0JywgZnVuY3Rpb24oKXtcbiAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLCBrZXlzID0gdGhhdC5fa1xuICAgICwga2V5O1xuICBkbyB7XG4gICAgaWYodGhhdC5faSA+PSBrZXlzLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICB9IHdoaWxlKCEoKGtleSA9IGtleXNbdGhhdC5faSsrXSkgaW4gdGhhdC5fdCkpO1xuICByZXR1cm4ge3ZhbHVlOiBrZXksIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGVudW1lcmF0ZTogZnVuY3Rpb24gZW51bWVyYXRlKHRhcmdldCl7XG4gICAgcmV0dXJuIG5ldyBFbnVtZXJhdGUodGFyZ2V0KTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmVudW1lcmF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS42IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgWywgcmVjZWl2ZXJdKVxudmFyIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkvKiwgcmVjZWl2ZXIqLyl7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogYXJndW1lbnRzWzJdXG4gICAgLCBkZXNjLCBwcm90bztcbiAgaWYoYW5PYmplY3QodGFyZ2V0KSA9PT0gcmVjZWl2ZXIpcmV0dXJuIHRhcmdldFtwcm9wZXJ0eUtleV07XG4gIGlmKGRlc2MgPSBnT1BELmYodGFyZ2V0LCBwcm9wZXJ0eUtleSkpcmV0dXJuIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgID8gZGVzYy52YWx1ZVxuICAgIDogZGVzYy5nZXQgIT09IHVuZGVmaW5lZFxuICAgICAgPyBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIGlmKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpcmV0dXJuIGdldChwcm90bywgcHJvcGVydHlLZXksIHJlY2VpdmVyKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge2dldDogZ2V0fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC5qc1xuICoqIG1vZHVsZSBpZCA9IDIzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS43IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpXG52YXIgZ09QRCAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSl7XG4gICAgcmV0dXJuIGdPUEQuZihhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuOCBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldClcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZ2V0UHJvdG8gPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZih0YXJnZXQpe1xuICAgIHJldHVybiBnZXRQcm90byhhbk9iamVjdCh0YXJnZXQpKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1wcm90b3R5cGUtb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAyMzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KXtcbiAgICByZXR1cm4gcHJvcGVydHlLZXkgaW4gdGFyZ2V0O1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaGFzLmpzXG4gKiogbW9kdWxlIGlkID0gMjQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjEwIFJlZmxlY3QuaXNFeHRlbnNpYmxlKHRhcmdldClcbnZhciAkZXhwb3J0ICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKHRhcmdldCkgOiB0cnVlO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuaXMtZXh0ZW5zaWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMjYuMS4xMSBSZWZsZWN0Lm93bktleXModGFyZ2V0KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge293bktleXM6IHJlcXVpcmUoJy4vX293bi1rZXlzJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3Qub3duLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBnT1BOICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgUmVmbGVjdCAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KXtcbiAgdmFyIGtleXMgICAgICAgPSBnT1BOLmYoYW5PYmplY3QoaXQpKVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgcmV0dXJuIGdldFN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMjQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAyNi4xLjEyIFJlZmxlY3QucHJldmVudEV4dGVuc2lvbnModGFyZ2V0KVxudmFyICRleHBvcnQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCAkcHJldmVudEV4dGVuc2lvbnMgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnM7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCl7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICB0cnkge1xuICAgICAgaWYoJHByZXZlbnRFeHRlbnNpb25zKSRwcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuMTMgUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViBbLCByZWNlaXZlcl0pXG52YXIgZFAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGdPUEQgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgVi8qLCByZWNlaXZlciovKXtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDQgPyB0YXJnZXQgOiBhcmd1bWVudHNbM11cbiAgICAsIG93bkRlc2MgID0gZ09QRC5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KVxuICAgICwgZXhpc3RpbmdEZXNjcmlwdG9yLCBwcm90bztcbiAgaWYoIW93bkRlc2Mpe1xuICAgIGlmKGlzT2JqZWN0KHByb3RvID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpe1xuICAgICAgcmV0dXJuIHNldChwcm90bywgcHJvcGVydHlLZXksIFYsIHJlY2VpdmVyKTtcbiAgICB9XG4gICAgb3duRGVzYyA9IGNyZWF0ZURlc2MoMCk7XG4gIH1cbiAgaWYoaGFzKG93bkRlc2MsICd2YWx1ZScpKXtcbiAgICBpZihvd25EZXNjLndyaXRhYmxlID09PSBmYWxzZSB8fCAhaXNPYmplY3QocmVjZWl2ZXIpKXJldHVybiBmYWxzZTtcbiAgICBleGlzdGluZ0Rlc2NyaXB0b3IgPSBnT1BELmYocmVjZWl2ZXIsIHByb3BlcnR5S2V5KSB8fCBjcmVhdGVEZXNjKDApO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgZFAuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGV4aXN0aW5nRGVzY3JpcHRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG93bkRlc2Muc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtzZXQ6IHNldH0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIDI2LjEuMTQgUmVmbGVjdC5zZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzZXRQcm90byA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpO1xuXG5pZihzZXRQcm90bykkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIHNldFByb3RvdHlwZU9mOiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZih0YXJnZXQsIHByb3RvKXtcbiAgICBzZXRQcm90by5jaGVjayh0YXJnZXQsIHByb3RvKTtcbiAgICB0cnkge1xuICAgICAgc2V0UHJvdG8uc2V0KHRhcmdldCwgcHJvdG8pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5zZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gMjQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRpbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykodHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiwgZnJvbUluZGV4ID0gMCAqLyl7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoJ2luY2x1ZGVzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDI0N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRhdCAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIGF0OiBmdW5jdGlvbiBhdChwb3Mpe1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcuYXQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhZCAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIHBhZFN0YXJ0OiBmdW5jdGlvbiBwYWRTdGFydChtYXhMZW5ndGggLyosIGZpbGxTdHJpbmcgPSAnICcgKi8pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRydWUpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIHJlcGVhdCAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXJlcGVhdCcpXG4gICwgZGVmaW5lZCAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgbWF4TGVuZ3RoLCBmaWxsU3RyaW5nLCBsZWZ0KXtcbiAgdmFyIFMgICAgICAgICAgICA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICwgc3RyaW5nTGVuZ3RoID0gUy5sZW5ndGhcbiAgICAsIGZpbGxTdHIgICAgICA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IFN0cmluZyhmaWxsU3RyaW5nKVxuICAgICwgaW50TWF4TGVuZ3RoID0gdG9MZW5ndGgobWF4TGVuZ3RoKTtcbiAgaWYoaW50TWF4TGVuZ3RoIDw9IHN0cmluZ0xlbmd0aCB8fCBmaWxsU3RyID09ICcnKXJldHVybiBTO1xuICB2YXIgZmlsbExlbiA9IGludE1heExlbmd0aCAtIHN0cmluZ0xlbmd0aFxuICAgICwgc3RyaW5nRmlsbGVyID0gcmVwZWF0LmNhbGwoZmlsbFN0ciwgTWF0aC5jZWlsKGZpbGxMZW4gLyBmaWxsU3RyLmxlbmd0aCkpO1xuICBpZihzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbilzdHJpbmdGaWxsZXIgPSBzdHJpbmdGaWxsZXIuc2xpY2UoMCwgZmlsbExlbik7XG4gIHJldHVybiBsZWZ0ID8gc3RyaW5nRmlsbGVyICsgUyA6IFMgKyBzdHJpbmdGaWxsZXI7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcGFkLmpzXG4gKiogbW9kdWxlIGlkID0gMjUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYWQgICAgPSByZXF1aXJlKCcuL19zdHJpbmctcGFkJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICBwYWRFbmQ6IGZ1bmN0aW9uIHBhZEVuZChtYXhMZW5ndGggLyosIGZpbGxTdHJpbmcgPSAnICcgKi8pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGZhbHNlKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcucGFkLWVuZC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NlYm1hcmtiYWdlL2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxucmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKSgndHJpbUxlZnQnLCBmdW5jdGlvbigkdHJpbSl7XG4gIHJldHVybiBmdW5jdGlvbiB0cmltTGVmdCgpe1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAxKTtcbiAgfTtcbn0sICd0cmltU3RhcnQnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1SaWdodCcsIGZ1bmN0aW9uKCR0cmltKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1SaWdodCgpe1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAyKTtcbiAgfTtcbn0sICd0cmltRW5kJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qc1xuICoqIG1vZHVsZSBpZCA9IDI1M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9TdHJpbmcucHJvdG90eXBlLm1hdGNoQWxsL1xudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBkZWZpbmVkICAgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBpc1JlZ0V4cCAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgZ2V0RmxhZ3MgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgUmVnRXhwUHJvdG8gPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yID0gZnVuY3Rpb24ocmVnZXhwLCBzdHJpbmcpe1xuICB0aGlzLl9yID0gcmVnZXhwO1xuICB0aGlzLl9zID0gc3RyaW5nO1xufTtcblxucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKSgkUmVnRXhwU3RyaW5nSXRlcmF0b3IsICdSZWdFeHAgU3RyaW5nJywgZnVuY3Rpb24gbmV4dCgpe1xuICB2YXIgbWF0Y2ggPSB0aGlzLl9yLmV4ZWModGhpcy5fcyk7XG4gIHJldHVybiB7dmFsdWU6IG1hdGNoLCBkb25lOiBtYXRjaCA9PT0gbnVsbH07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIG1hdGNoQWxsOiBmdW5jdGlvbiBtYXRjaEFsbChyZWdleHApe1xuICAgIGRlZmluZWQodGhpcyk7XG4gICAgaWYoIWlzUmVnRXhwKHJlZ2V4cCkpdGhyb3cgVHlwZUVycm9yKHJlZ2V4cCArICcgaXMgbm90IGEgcmVnZXhwIScpO1xuICAgIHZhciBTICAgICA9IFN0cmluZyh0aGlzKVxuICAgICAgLCBmbGFncyA9ICdmbGFncycgaW4gUmVnRXhwUHJvdG8gPyBTdHJpbmcocmVnZXhwLmZsYWdzKSA6IGdldEZsYWdzLmNhbGwocmVnZXhwKVxuICAgICAgLCByeCAgICA9IG5ldyBSZWdFeHAocmVnZXhwLnNvdXJjZSwgfmZsYWdzLmluZGV4T2YoJ2cnKSA/IGZsYWdzIDogJ2cnICsgZmxhZ3MpO1xuICAgIHJ4Lmxhc3RJbmRleCA9IHRvTGVuZ3RoKHJlZ2V4cC5sYXN0SW5kZXgpO1xuICAgIHJldHVybiBuZXcgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yKHJ4LCBTKTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsLmpzXG4gKiogbW9kdWxlIGlkID0gMjU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDI1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbnZhciAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgb3duS2V5cyAgICAgICAgPSByZXF1aXJlKCcuL19vd24ta2V5cycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2NyZWF0ZS1wcm9wZXJ0eScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3Qpe1xuICAgIHZhciBPICAgICAgID0gdG9JT2JqZWN0KG9iamVjdClcbiAgICAgICwgZ2V0RGVzYyA9IGdPUEQuZlxuICAgICAgLCBrZXlzICAgID0gb3duS2V5cyhPKVxuICAgICAgLCByZXN1bHQgID0ge31cbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGtleXMubGVuZ3RoID4gaSljcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGtleSA9IGtleXNbaSsrXSwgZ2V0RGVzYyhPLCBrZXkpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMjU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdmFsdWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpe1xuICAgIHJldHVybiAkdmFsdWVzKGl0KTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzLmpzXG4gKiogbW9kdWxlIGlkID0gMjU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGlzRW51bSAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc0VudHJpZXMpe1xuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoaXQpXG4gICAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaSAgICAgID0gMFxuICAgICAgLCByZXN1bHQgPSBbXVxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChPLCBrZXkgPSBrZXlzW2krK10pKXtcbiAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19vYmplY3QtdG8tYXJyYXkuanNcbiAqKiBtb2R1bGUgaWQgPSAyNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZW50cmllcyA9IHJlcXVpcmUoJy4vX29iamVjdC10by1hcnJheScpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcyhpdCl7XG4gICAgcmV0dXJuICRlbnRyaWVzKGl0KTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZW50cmllcy5qc1xuICoqIG1vZHVsZSBpZCA9IDI2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMiBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lR2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lR2V0dGVyX18oUCwgZ2V0dGVyKXtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwge2dldDogYUZ1bmN0aW9uKGdldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBGb3JjZWQgcmVwbGFjZW1lbnQgcHJvdG90eXBlIGFjY2Vzc29ycyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKXx8ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHZhciBLID0gTWF0aC5yYW5kb20oKTtcbiAgLy8gSW4gRkYgdGhyb3dzIG9ubHkgZGVmaW5lIG1ldGhvZHNcbiAgX19kZWZpbmVTZXR0ZXJfXy5jYWxsKG51bGwsIEssIGZ1bmN0aW9uKCl7IC8qIGVtcHR5ICovfSk7XG4gIGRlbGV0ZSByZXF1aXJlKCcuL19nbG9iYWwnKVtLXTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWZvcmNlZC1wYW0uanNcbiAqKiBtb2R1bGUgaWQgPSAyNjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbi8vIEIuMi4yLjMgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcilcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2RlZmluZVNldHRlcl9fOiBmdW5jdGlvbiBfX2RlZmluZVNldHRlcl9fKFAsIHNldHRlcil7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHtzZXQ6IGFGdW5jdGlvbihzZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9KTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLXNldHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNCBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwR2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cEdldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cEdldHRlcl9fKFApe1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpXG4gICAgICAsIEQ7XG4gICAgZG8ge1xuICAgICAgaWYoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSlyZXR1cm4gRC5nZXQ7XG4gICAgfSB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMjY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG4vLyBCLjIuMi41IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBTZXR0ZXJfXyhQKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwU2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwU2V0dGVyX18oUCl7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSlcbiAgICAgICwgRDtcbiAgICBkbyB7XG4gICAgICBpZihEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKXJldHVybiBELnNldDtcbiAgICB9IHdoaWxlKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyNjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHt0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdNYXAnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWFwLnRvLWpzb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyNjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgZnJvbSAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXIsIElURVJBVE9SKXtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3JPZihpdGVyLCBmYWxzZSwgcmVzdWx0LnB1c2gsIHJlc3VsdCwgSVRFUkFUT1IpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI2OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnU2V0Jywge3RvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpfSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3lzdGVtJywge2dsb2JhbDogcmVxdWlyZSgnLi9fZ2xvYmFsJyl9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvcHJvcG9zYWwtaXMtZXJyb3JcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb2YgICAgID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRXJyb3InLCB7XG4gIGlzRXJyb3I6IGZ1bmN0aW9uIGlzRXJyb3IoaXQpe1xuICAgIHJldHVybiBjb2YoaXQpID09PSAnRXJyb3InO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmVycm9yLmlzLWVycm9yLmpzXG4gKiogbW9kdWxlIGlkID0gMjcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpYWRkaDogZnVuY3Rpb24gaWFkZGgoeDAsIHgxLCB5MCwgeTEpe1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMFxuICAgICAgLCAkeDEgPSB4MSA+Pj4gMFxuICAgICAgLCAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxICsgKHkxID4+PiAwKSArICgoJHgwICYgJHkwIHwgKCR4MCB8ICR5MCkgJiB+KCR4MCArICR5MCA+Pj4gMCkpID4+PiAzMSkgfCAwO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanNcbiAqKiBtb2R1bGUgaWQgPSAyNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0JyZW5kYW5FaWNoLzQyOTRkNWMyMTJhNmQyMjU0NzAzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGlzdWJoOiBmdW5jdGlvbiBpc3ViaCh4MCwgeDEsIHkwLCB5MSl7XG4gICAgdmFyICR4MCA9IHgwID4+PiAwXG4gICAgICAsICR4MSA9IHgxID4+PiAwXG4gICAgICAsICR5MCA9IHkwID4+PiAwO1xuICAgIHJldHVybiAkeDEgLSAoeTEgPj4+IDApIC0gKCh+JHgwICYgJHkwIHwgfigkeDAgXiAkeTApICYgJHgwIC0gJHkwID4+PiAwKSA+Pj4gMzEpIHwgMDtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoLmpzXG4gKiogbW9kdWxlIGlkID0gMjczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpbXVsaDogZnVuY3Rpb24gaW11bGgodSwgdil7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZlxuICAgICAgLCAkdSA9ICt1XG4gICAgICAsICR2ID0gK3ZcbiAgICAgICwgdTAgPSAkdSAmIFVJTlQxNlxuICAgICAgLCB2MCA9ICR2ICYgVUlOVDE2XG4gICAgICAsIHUxID0gJHUgPj4gMTZcbiAgICAgICwgdjEgPSAkdiA+PiAxNlxuICAgICAgLCB0ICA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+IDE2KTtcbiAgfVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzXG4gKiogbW9kdWxlIGlkID0gMjc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB1bXVsaDogZnVuY3Rpb24gdW11bGgodSwgdil7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZlxuICAgICAgLCAkdSA9ICt1XG4gICAgICAsICR2ID0gK3ZcbiAgICAgICwgdTAgPSAkdSAmIFVJTlQxNlxuICAgICAgLCB2MCA9ICR2ICYgVUlOVDE2XG4gICAgICAsIHUxID0gJHUgPj4+IDE2XG4gICAgICAsIHYxID0gJHYgPj4+IDE2XG4gICAgICAsIHQgID0gKHUxICogdjAgPj4+IDApICsgKHUwICogdjAgPj4+IDE2KTtcbiAgICByZXR1cm4gdTEgKiB2MSArICh0ID4+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+PiAxNik7XG4gIH1cbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC51bXVsaC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleVxuICAsIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5zZXQ7XG5cbm1ldGFkYXRhLmV4cCh7ZGVmaW5lTWV0YWRhdGE6IGZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHRhcmdldEtleSl7XG4gIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIGFuT2JqZWN0KHRhcmdldCksIHRvTWV0YUtleSh0YXJnZXRLZXkpKTtcbn19KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gMjc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgTWFwICAgICA9IHJlcXVpcmUoJy4vZXM2Lm1hcCcpXG4gICwgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgc2hhcmVkICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdtZXRhZGF0YScpXG4gICwgc3RvcmUgICA9IHNoYXJlZC5zdG9yZSB8fCAoc2hhcmVkLnN0b3JlID0gbmV3IChyZXF1aXJlKCcuL2VzNi53ZWFrLW1hcCcpKSk7XG5cbnZhciBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRLZXksIGNyZWF0ZSl7XG4gIHZhciB0YXJnZXRNZXRhZGF0YSA9IHN0b3JlLmdldCh0YXJnZXQpO1xuICBpZighdGFyZ2V0TWV0YWRhdGEpe1xuICAgIGlmKCFjcmVhdGUpcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBzdG9yZS5zZXQodGFyZ2V0LCB0YXJnZXRNZXRhZGF0YSA9IG5ldyBNYXApO1xuICB9XG4gIHZhciBrZXlNZXRhZGF0YSA9IHRhcmdldE1ldGFkYXRhLmdldCh0YXJnZXRLZXkpO1xuICBpZigha2V5TWV0YWRhdGEpe1xuICAgIGlmKCFjcmVhdGUpcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB0YXJnZXRNZXRhZGF0YS5zZXQodGFyZ2V0S2V5LCBrZXlNZXRhZGF0YSA9IG5ldyBNYXApO1xuICB9IHJldHVybiBrZXlNZXRhZGF0YTtcbn07XG52YXIgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IGZ1bmN0aW9uKE1ldGFkYXRhS2V5LCBPLCBQKXtcbiAgdmFyIG1ldGFkYXRhTWFwID0gZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCBmYWxzZSk7XG4gIHJldHVybiBtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBtZXRhZGF0YU1hcC5oYXMoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtZXRhZGF0YU1hcC5nZXQoTWV0YWRhdGFLZXkpO1xufTtcbnZhciBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUsIE8sIFApe1xuICBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIHRydWUpLnNldChNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSk7XG59O1xudmFyIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRLZXkpe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKHRhcmdldCwgdGFyZ2V0S2V5LCBmYWxzZSlcbiAgICAsIGtleXMgICAgICAgID0gW107XG4gIGlmKG1ldGFkYXRhTWFwKW1ldGFkYXRhTWFwLmZvckVhY2goZnVuY3Rpb24oXywga2V5KXsga2V5cy5wdXNoKGtleSk7IH0pO1xuICByZXR1cm4ga2V5cztcbn07XG52YXIgdG9NZXRhS2V5ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6IFN0cmluZyhpdCk7XG59O1xudmFyIGV4cCA9IGZ1bmN0aW9uKE8pe1xuICAkZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCBPKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdG9yZTogc3RvcmUsXG4gIG1hcDogZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCxcbiAgaGFzOiBvcmRpbmFyeUhhc093bk1ldGFkYXRhLFxuICBnZXQ6IG9yZGluYXJ5R2V0T3duTWV0YWRhdGEsXG4gIHNldDogb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSxcbiAga2V5czogb3JkaW5hcnlPd25NZXRhZGF0YUtleXMsXG4gIGtleTogdG9NZXRhS2V5LFxuICBleHA6IGV4cFxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvX21ldGFkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gMjc3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5XG4gICwgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IG1ldGFkYXRhLm1hcFxuICAsIHN0b3JlICAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5zdG9yZTtcblxubWV0YWRhdGEuZXhwKHtkZWxldGVNZXRhZGF0YTogZnVuY3Rpb24gZGVsZXRlTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgdmFyIHRhcmdldEtleSAgID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKVxuICAgICwgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKGFuT2JqZWN0KHRhcmdldCksIHRhcmdldEtleSwgZmFsc2UpO1xuICBpZihtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkIHx8ICFtZXRhZGF0YU1hcFsnZGVsZXRlJ10obWV0YWRhdGFLZXkpKXJldHVybiBmYWxzZTtcbiAgaWYobWV0YWRhdGFNYXAuc2l6ZSlyZXR1cm4gdHJ1ZTtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gIHRhcmdldE1ldGFkYXRhWydkZWxldGUnXSh0YXJnZXRLZXkpO1xuICByZXR1cm4gISF0YXJnZXRNZXRhZGF0YS5zaXplIHx8IHN0b3JlWydkZWxldGUnXSh0YXJnZXQpO1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSAyNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldFxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUdldE1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmKGhhc093bilyZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiB1bmRlZmluZWQ7XG59O1xuXG5tZXRhZGF0YS5leHAoe2dldE1ldGFkYXRhOiBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlHZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDI3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFNldCAgICAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9lczYuc2V0JylcbiAgLCBmcm9tICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKVxuICAsIG1ldGFkYXRhICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRQcm90b3R5cGVPZiAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG52YXIgb3JkaW5hcnlNZXRhZGF0YUtleXMgPSBmdW5jdGlvbihPLCBQKXtcbiAgdmFyIG9LZXlzICA9IG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApXG4gICAgLCBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgaWYocGFyZW50ID09PSBudWxsKXJldHVybiBvS2V5cztcbiAgdmFyIHBLZXlzICA9IG9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XG4gIHJldHVybiBwS2V5cy5sZW5ndGggPyBvS2V5cy5sZW5ndGggPyBmcm9tKG5ldyBTZXQob0tleXMuY29uY2F0KHBLZXlzKSkpIDogcEtleXMgOiBvS2V5cztcbn07XG5cbm1ldGFkYXRhLmV4cCh7Z2V0TWV0YWRhdGFLZXlzOiBmdW5jdGlvbiBnZXRNZXRhZGF0YUtleXModGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlNZXRhZGF0YUtleXMoYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzFdKSk7XG59fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMjgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0XG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHtnZXRPd25NZXRhZGF0YTogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gMjgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzID0gbWV0YWRhdGEua2V5c1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5O1xuXG5tZXRhZGF0YS5leHAoe2dldE93bk1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGFLZXlzKHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtb3duLW1ldGFkYXRhLWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAyODJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5SGFzTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYoaGFzT3duKXJldHVybiB0cnVlO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogZmFsc2U7XG59O1xuXG5tZXRhZGF0YS5leHAoe2hhc01ldGFkYXRhOiBmdW5jdGlvbiBoYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlIYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhc1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7aGFzT3duTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW93bi1tZXRhZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXlcbiAgLCBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhID0gbWV0YWRhdGEuc2V0O1xuXG5tZXRhZGF0YS5leHAoe21ldGFkYXRhOiBmdW5jdGlvbiBtZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSl7XG4gIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCB0YXJnZXRLZXkpe1xuICAgIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEoXG4gICAgICBtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSxcbiAgICAgICh0YXJnZXRLZXkgIT09IHVuZGVmaW5lZCA/IGFuT2JqZWN0IDogYUZ1bmN0aW9uKSh0YXJnZXQpLFxuICAgICAgdG9NZXRhS2V5KHRhcmdldEtleSlcbiAgICApO1xuICB9O1xufX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDI4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3J3YWxkcm9uL3RjMzktbm90ZXMvYmxvYi9tYXN0ZXIvZXM2LzIwMTQtMDkvc2VwdC0yNS5tZCM1MTAtZ2xvYmFsYXNhcC1mb3ItZW5xdWV1aW5nLWEtbWljcm90YXNrXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBtaWNyb3Rhc2sgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgcHJvY2VzcyAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykucHJvY2Vzc1xuICAsIGlzTm9kZSAgICA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHtcbiAgYXNhcDogZnVuY3Rpb24gYXNhcChmbil7XG4gICAgdmFyIGRvbWFpbiA9IGlzTm9kZSAmJiBwcm9jZXNzLmRvbWFpbjtcbiAgICBtaWNyb3Rhc2soZG9tYWluID8gZG9tYWluLmJpbmQoZm4pIDogZm4pO1xuICB9XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3LmFzYXAuanNcbiAqKiBtb2R1bGUgaWQgPSAyODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGVcbnZhciAkZXhwb3J0ICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZ2xvYmFsICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgbWljcm90YXNrICAgPSByZXF1aXJlKCcuL19taWNyb3Rhc2snKSgpXG4gICwgT0JTRVJWQUJMRSAgPSByZXF1aXJlKCcuL193a3MnKSgnb2JzZXJ2YWJsZScpXG4gICwgYUZ1bmN0aW9uICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgYW5JbnN0YW5jZSAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGhpZGUgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgZm9yT2YgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIFJFVFVSTiAgICAgID0gZm9yT2YuUkVUVVJOO1xuXG52YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oZm4pe1xuICByZXR1cm4gZm4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFGdW5jdGlvbihmbik7XG59O1xuXG52YXIgY2xlYW51cFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIHZhciBjbGVhbnVwID0gc3Vic2NyaXB0aW9uLl9jO1xuICBpZihjbGVhbnVwKXtcbiAgICBzdWJzY3JpcHRpb24uX2MgPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cCgpO1xuICB9XG59O1xuXG52YXIgc3Vic2NyaXB0aW9uQ2xvc2VkID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgcmV0dXJuIHN1YnNjcmlwdGlvbi5fbyA9PT0gdW5kZWZpbmVkO1xufTtcblxudmFyIGNsb3NlU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICB9XG59O1xuXG52YXIgU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24ob2JzZXJ2ZXIsIHN1YnNjcmliZXIpe1xuICBhbk9iamVjdChvYnNlcnZlcik7XG4gIHRoaXMuX2MgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX28gPSBvYnNlcnZlcjtcbiAgb2JzZXJ2ZXIgPSBuZXcgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIodGhpcyk7XG4gIHRyeSB7XG4gICAgdmFyIGNsZWFudXAgICAgICA9IHN1YnNjcmliZXIob2JzZXJ2ZXIpXG4gICAgICAsIHN1YnNjcmlwdGlvbiA9IGNsZWFudXA7XG4gICAgaWYoY2xlYW51cCAhPSBudWxsKXtcbiAgICAgIGlmKHR5cGVvZiBjbGVhbnVwLnVuc3Vic2NyaWJlID09PSAnZnVuY3Rpb24nKWNsZWFudXAgPSBmdW5jdGlvbigpeyBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTsgfTtcbiAgICAgIGVsc2UgYUZ1bmN0aW9uKGNsZWFudXApO1xuICAgICAgdGhpcy5fYyA9IGNsZWFudXA7XG4gICAgfVxuICB9IGNhdGNoKGUpe1xuICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgIHJldHVybjtcbiAgfSBpZihzdWJzY3JpcHRpb25DbG9zZWQodGhpcykpY2xlYW51cFN1YnNjcmlwdGlvbih0aGlzKTtcbn07XG5cblN1YnNjcmlwdGlvbi5wcm90b3R5cGUgPSByZWRlZmluZUFsbCh7fSwge1xuICB1bnN1YnNjcmliZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoKXsgY2xvc2VTdWJzY3JpcHRpb24odGhpcyk7IH1cbn0pO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICB0aGlzLl9zID0gc3Vic2NyaXB0aW9uO1xufTtcblxuU3Vic2NyaXB0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcbiAgbmV4dDogZnVuY3Rpb24gbmV4dCh2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLm5leHQpO1xuICAgICAgICBpZihtKXJldHVybiBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IodmFsdWUpe1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmKHN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXRocm93IHZhbHVlO1xuICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmVycm9yKTtcbiAgICAgIGlmKCFtKXRocm93IHZhbHVlO1xuICAgICAgdmFsdWUgPSBtLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZSh2YWx1ZSl7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuX3M7XG4gICAgaWYoIXN1YnNjcmlwdGlvbkNsb3NlZChzdWJzY3JpcHRpb24pKXtcbiAgICAgIHZhciBvYnNlcnZlciA9IHN1YnNjcmlwdGlvbi5fbztcbiAgICAgIHN1YnNjcmlwdGlvbi5fbyA9IHVuZGVmaW5lZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtID0gZ2V0TWV0aG9kKG9ic2VydmVyLmNvbXBsZXRlKTtcbiAgICAgICAgdmFsdWUgPSBtID8gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9IGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgJE9ic2VydmFibGUgPSBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpe1xuICBhbkluc3RhbmNlKHRoaXMsICRPYnNlcnZhYmxlLCAnT2JzZXJ2YWJsZScsICdfZicpLl9mID0gYUZ1bmN0aW9uKHN1YnNjcmliZXIpO1xufTtcblxucmVkZWZpbmVBbGwoJE9ic2VydmFibGUucHJvdG90eXBlLCB7XG4gIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKXtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbihvYnNlcnZlciwgdGhpcy5fZik7XG4gIH0sXG4gIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4pe1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IChjb3JlLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2UpKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgICBhRnVuY3Rpb24oZm4pO1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoYXQuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dCA6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICBjb21wbGV0ZTogcmVzb2x2ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5yZWRlZmluZUFsbCgkT2JzZXJ2YWJsZSwge1xuICBmcm9tOiBmdW5jdGlvbiBmcm9tKHgpe1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGU7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZChhbk9iamVjdCh4KVtPQlNFUlZBQkxFXSk7XG4gICAgaWYobWV0aG9kKXtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gYW5PYmplY3QobWV0aG9kLmNhbGwoeCkpO1xuICAgICAgcmV0dXJuIG9ic2VydmFibGUuY29uc3RydWN0b3IgPT09IEMgPyBvYnNlcnZhYmxlIDogbmV3IEMoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZS5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbihvYnNlcnZlcil7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCFkb25lKXtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYoZm9yT2YoeCwgZmFsc2UsIGZ1bmN0aW9uKGl0KXtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdCk7XG4gICAgICAgICAgICAgIGlmKGRvbmUpcmV0dXJuIFJFVFVSTjtcbiAgICAgICAgICAgIH0pID09PSBSRVRVUk4pcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICBpZihkb25lKXRocm93IGU7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7IGRvbmUgPSB0cnVlOyB9O1xuICAgIH0pO1xuICB9LFxuICBvZjogZnVuY3Rpb24gb2YoKXtcbiAgICBmb3IodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBBcnJheShsKTsgaSA8IGw7KWl0ZW1zW2ldID0gYXJndW1lbnRzW2krK107XG4gICAgcmV0dXJuIG5ldyAodHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogJE9ic2VydmFibGUpKGZ1bmN0aW9uKG9ic2VydmVyKXtcbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIWRvbmUpe1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2ldKTtcbiAgICAgICAgICAgIGlmKGRvbmUpcmV0dXJuO1xuICAgICAgICAgIH0gb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXsgZG9uZSA9IHRydWU7IH07XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5oaWRlKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwgT0JTRVJWQUJMRSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuRywge09ic2VydmFibGU6ICRPYnNlcnZhYmxlfSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ09ic2VydmFibGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL21vZHVsZXMvZXM3Lm9ic2VydmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbnZhciBnbG9iYWwgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCAkZXhwb3J0ICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBwYXJ0aWFsICAgID0gcmVxdWlyZSgnLi9fcGFydGlhbCcpXG4gICwgbmF2aWdhdG9yICA9IGdsb2JhbC5uYXZpZ2F0b3JcbiAgLCBNU0lFICAgICAgID0gISFuYXZpZ2F0b3IgJiYgL01TSUUgLlxcLi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gPC0gZGlydHkgaWU5LSBjaGVja1xudmFyIHdyYXAgPSBmdW5jdGlvbihzZXQpe1xuICByZXR1cm4gTVNJRSA/IGZ1bmN0aW9uKGZuLCB0aW1lIC8qLCAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gc2V0KGludm9rZShcbiAgICAgIHBhcnRpYWwsXG4gICAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICB0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pXG4gICAgKSwgdGltZSk7XG4gIH0gOiBzZXQ7XG59O1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIgKyAkZXhwb3J0LkYgKiBNU0lFLCB7XG4gIHNldFRpbWVvdXQ6ICB3cmFwKGdsb2JhbC5zZXRUaW1lb3V0KSxcbiAgc2V0SW50ZXJ2YWw6IHdyYXAoZ2xvYmFsLnNldEludGVydmFsKVxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL3dlYi50aW1lcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAyODhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXRoICAgICAgPSByZXF1aXJlKCcuL19wYXRoJylcbiAgLCBpbnZva2UgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oLyogLi4ucGFyZ3MgKi8pe1xuICB2YXIgZm4gICAgID0gYUZ1bmN0aW9uKHRoaXMpXG4gICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBwYXJncyAgPSBBcnJheShsZW5ndGgpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBfICAgICAgPSBwYXRoLl9cbiAgICAsIGhvbGRlciA9IGZhbHNlO1xuICB3aGlsZShsZW5ndGggPiBpKWlmKChwYXJnc1tpXSA9IGFyZ3VtZW50c1tpKytdKSA9PT0gXylob2xkZXIgPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGogPSAwLCBrID0gMCwgYXJncztcbiAgICBpZighaG9sZGVyICYmICFhTGVuKXJldHVybiBpbnZva2UoZm4sIHBhcmdzLCB0aGF0KTtcbiAgICBhcmdzID0gcGFyZ3Muc2xpY2UoKTtcbiAgICBpZihob2xkZXIpZm9yKDtsZW5ndGggPiBqOyBqKyspaWYoYXJnc1tqXSA9PT0gXylhcmdzW2pdID0gYXJndW1lbnRzW2srK107XG4gICAgd2hpbGUoYUxlbiA+IGspYXJncy5wdXNoKGFyZ3VtZW50c1trKytdKTtcbiAgICByZXR1cm4gaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19wYXJ0aWFsLmpzXG4gKiogbW9kdWxlIGlkID0gMjg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy9fcGF0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDI5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0YXNrICAgPSByZXF1aXJlKCcuL190YXNrJyk7XG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuQiwge1xuICBzZXRJbW1lZGlhdGU6ICAgJHRhc2suc2V0LFxuICBjbGVhckltbWVkaWF0ZTogJHRhc2suY2xlYXJcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIuaW1tZWRpYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMjkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGl0ZXJhdG9ycyAgICA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJylcbiAgLCByZWRlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGdsb2JhbCAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBJdGVyYXRvcnMgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB3a3MgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCBJVEVSQVRPUiAgICAgID0gd2tzKCdpdGVyYXRvcicpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKVxuICAsIEFycmF5VmFsdWVzICAgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmZvcih2YXIgY29sbGVjdGlvbnMgPSBbJ05vZGVMaXN0JywgJ0RPTVRva2VuTGlzdCcsICdNZWRpYUxpc3QnLCAnU3R5bGVTaGVldExpc3QnLCAnQ1NTUnVsZUxpc3QnXSwgaSA9IDA7IGkgPCA1OyBpKyspe1xuICB2YXIgTkFNRSAgICAgICA9IGNvbGxlY3Rpb25zW2ldXG4gICAgLCBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdXG4gICAgLCBwcm90byAgICAgID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZVxuICAgICwga2V5O1xuICBpZihwcm90byl7XG4gICAgaWYoIXByb3RvW0lURVJBVE9SXSloaWRlKHByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIGlmKCFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBmb3Ioa2V5IGluICRpdGVyYXRvcnMpaWYoIXByb3RvW2tleV0pcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMjkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBodHRwczovL3Jhdy5naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL21hc3Rlci9MSUNFTlNFIGZpbGUuIEFuXG4gKiBhZGRpdGlvbmFsIGdyYW50IG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW5cbiAqIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIjtcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xuICBpZiAocnVudGltZSkge1xuICAgIGlmIChpbk1vZHVsZSkge1xuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZSgob3V0ZXJGbiB8fCBHZW5lcmF0b3IpLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID0gR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgdmFsdWUgaW5zdGFuY2VvZiBBd2FpdEFyZ3VtZW50YCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC4gU29tZSBtYXkgY29uc2lkZXIgdGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgdG9vXG4gIC8vIGN1dGVzeSwgYnV0IHRoZXkgYXJlIGN1cm11ZGdlb25zLlxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBBd2FpdEFyZ3VtZW50KGFyZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQXdhaXRBcmd1bWVudChhcmcpIHtcbiAgICB0aGlzLmFyZyA9IGFyZztcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXdhaXRBcmd1bWVudCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuYXJnKS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICBpbnZva2UgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKGludm9rZSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIGlmIChtZXRob2QgPT09IFwicmV0dXJuXCIgfHxcbiAgICAgICAgICAgICAgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiICYmIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIC8vIEEgcmV0dXJuIG9yIHRocm93ICh3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gdGhyb3dcbiAgICAgICAgICAgIC8vIG1ldGhvZCkgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICAgIHZhciByZXR1cm5NZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5NZXRob2QpIHtcbiAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKHJldHVybk1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGFyZyk7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJldHVybiBtZXRob2QgdGhyZXcgYW4gZXhjZXB0aW9uLCBsZXQgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBwcmV2YWlsIG92ZXIgdGhlIG9yaWdpbmFsIHJldHVybiBvciB0aHJvdy5cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgICAgICAgYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG91dGVyIHJldHVybiwgbm93IHRoYXQgdGhlIGRlbGVnYXRlXG4gICAgICAgICAgICAgIC8vIGl0ZXJhdG9yIGhhcyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChcbiAgICAgICAgICAgIGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZF0sXG4gICAgICAgICAgICBkZWxlZ2F0ZS5pdGVyYXRvcixcbiAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIExpa2UgcmV0dXJuaW5nIGdlbmVyYXRvci50aHJvdyh1bmNhdWdodCksIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgLy8gb3ZlcmhlYWQgb2YgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbC5cbiAgICAgICAgICAgIG1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEZWxlZ2F0ZSBnZW5lcmF0b3IgcmFuIGFuZCBoYW5kbGVkIGl0cyBvd24gZXhjZXB0aW9ucyBzb1xuICAgICAgICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgbWV0aG9kIHdhcywgd2UgY29udGludWUgYXMgaWYgaXQgaXNcbiAgICAgICAgICAvLyBcIm5leHRcIiB3aXRoIGFuIHVuZGVmaW5lZCBhcmcuXG4gICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuICAgICAgICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuICAgICAgICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuICAgICAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGFyZykpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgICAgbWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgICBhcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC5kZWxlZ2F0ZSAmJiBtZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgICAgICAgYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihhcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgbWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEFtb25nIHRoZSB2YXJpb3VzIHRyaWNrcyBmb3Igb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWxcbiAgLy8gb2JqZWN0LCB0aGlzIHNlZW1zIHRvIGJlIHRoZSBtb3N0IHJlbGlhYmxlIHRlY2huaXF1ZSB0aGF0IGRvZXMgbm90XG4gIC8vIHVzZSBpbmRpcmVjdCBldmFsICh3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG4gIHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOlxuICB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDpcbiAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdGhpc1xuKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuUmVnRXhwLmVzY2FwZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jb3JlLWpzL2ZuL3JlZ2V4cC9lc2NhcGUuanNcbiAqKiBtb2R1bGUgaWQgPSAyOTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZW5qYW1pbmdyL1JleEV4cC5lc2NhcGVcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmUgICAgID0gcmVxdWlyZSgnLi9fcmVwbGFjZXInKSgvW1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWdFeHAnLCB7ZXNjYXBlOiBmdW5jdGlvbiBlc2NhcGUoaXQpeyByZXR1cm4gJHJlKGl0KTsgfX0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZS5qc1xuICoqIG1vZHVsZSBpZCA9IDI5NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyZWdFeHAsIHJlcGxhY2Upe1xuICB2YXIgcmVwbGFjZXIgPSByZXBsYWNlID09PSBPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbihwYXJ0KXtcbiAgICByZXR1cm4gcmVwbGFjZVtwYXJ0XTtcbiAgfSA6IHJlcGxhY2U7XG4gIHJldHVybiBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIFN0cmluZyhpdCkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY29yZS1qcy9tb2R1bGVzL19yZXBsYWNlci5qc1xuICoqIG1vZHVsZSBpZCA9IDI5N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gU0RLX1ZFUlNJT04sIExPR19MRVZFTCBpbmplY3RlZCBmcm9tIHdlYnBhY2sgYnVpbGQuXG5cbmltcG9ydCB7IExFVkVMUywgZXN0YWJsaXNoTG9nZ2VyLCBnZXRMb2dnZXIgfSBmcm9tICcuL2xvZydcbmV4cG9ydCB7IExFVkVMUyBhcyBMb2dMZXZlbHMgfSBmcm9tICcuL2xvZydcbmV4cG9ydCB7IGdldExvZ2dlciBhcyBnZXRMb2dnZXIgfSBmcm9tICcuL2xvZydcblxuaW1wb3J0ICogYXMgc3Vic2NyaWJlckxpYiBmcm9tICcuL3N1YnNjcmliZXIvaW5kZXgnXG5pbXBvcnQgKiBhcyBwdWJsaXNoZXJMaWIgZnJvbSAnLi9wdWJsaXNoZXIvaW5kZXgnXG5pbXBvcnQgKiBhcyBzaGFyZWRPYmplY3RMaWIgZnJvbSAnLi9zaGFyZWRvYmplY3QvaW5kZXgnXG5pbXBvcnQgUGxheWJhY2tWaWV3IGZyb20gJy4vdmlldy9wbGF5YmFjaydcbmltcG9ydCBQdWJsaXNoZXJWaWV3IGZyb20gJy4vdmlldy9wdWJsaXNoJ1xuXG4vKipcbiAqIFN1YnNjcmlwdGlvbiByZWxhdGVkIHJlZmVyZW5jZXMuXG4qL1xuZXhwb3J0IGNvbnN0IFJlZDVQcm9TdWJzY3JpYmVyID0gc3Vic2NyaWJlckxpYi5SZWQ1UHJvU3Vic2NyaWJlclxuZXhwb3J0IGNvbnN0IFJUQ1N1YnNjcmliZXIgPSBzdWJzY3JpYmVyTGliLlJUQ1N1YnNjcmliZXJcbmV4cG9ydCBjb25zdCBITFNTdWJzY3JpYmVyID0gc3Vic2NyaWJlckxpYi5ITFNTdWJzY3JpYmVyXG5leHBvcnQgY29uc3QgVmlkZW9KU1N1YnNjcmliZXIgPSBzdWJzY3JpYmVyTGliLlZpZGVvSlNTdWJzY3JpYmVyXG5leHBvcnQgY29uc3QgUjVMaXZlU3Vic2NyaWJlciA9IHN1YnNjcmliZXJMaWIuUjVMaXZlU3Vic2NyaWJlclxuZXhwb3J0IGNvbnN0IFJUTVBTdWJzY3JpYmVyID0gc3Vic2NyaWJlckxpYi5SVE1QU3Vic2NyaWJlclxuZXhwb3J0IHsgUGxheWJhY2tWaWV3IH1cblxuLyoqXG4gKiBCcm9hZGNhc3QgcmVsYXRlZCByZWZlcmVuY2VzLlxuICovXG5leHBvcnQgY29uc3QgUmVkNVByb1B1Ymxpc2hlciA9IHB1Ymxpc2hlckxpYi5SZWQ1UHJvUHVibGlzaGVyXG5leHBvcnQgY29uc3QgUlRNUFB1Ymxpc2hlciA9IHB1Ymxpc2hlckxpYi5SVE1QUHVibGlzaGVyXG5leHBvcnQgY29uc3QgUlRDUHVibGlzaGVyID0gcHVibGlzaGVyTGliLlJUQ1B1Ymxpc2hlclxuZXhwb3J0IHsgUHVibGlzaGVyVmlldyB9XG5cbi8qKlxuICogU2hhcmVkIE9iamVjdCByZWZlcmVuY2VzLlxuICovXG5leHBvcnQgY29uc3QgUmVkNVByb1NoYXJlZE9iamVjdCA9IHNoYXJlZE9iamVjdExpYi5SZWQ1UHJvU2hhcmVkT2JqZWN0XG5cbi8qKlxuICogRXZlbnRzXG4gKi9cbmV4cG9ydCB7IGNvbW1vbiBhcyBQdWJsaXNoZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9ldmVudC9wdWJsaXNoZXItZXZlbnQnXG5leHBvcnQgeyBydGMgYXMgUlRDUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vZXZlbnQvcHVibGlzaGVyLWV2ZW50J1xuZXhwb3J0IHsgZmFpbG92ZXIgYXMgRmFpbG92ZXJQdWJsaXNoZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9ldmVudC9wdWJsaXNoZXItZXZlbnQnXG5leHBvcnQgeyBjb21tb24gYXMgU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL2V2ZW50L3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBydGMgYXMgUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL2V2ZW50L3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBmYWlsb3ZlciBhcyBGYWlsb3ZlclN1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9ldmVudC9zdWJzY3JpYmVyLWV2ZW50J1xuZXhwb3J0IHsgY29tbW9uIGFzIFNoYXJlZE9iamVjdEV2ZW50VHlwZXMgfSBmcm9tICcuL2V2ZW50L3NoYXJlZG9iamVjdC1ldmVudCdcblxuLypcbiAqIEVudW1zXG4qL1xuZXhwb3J0IHsgUGxheWJhY2tBdWRpb0VuY29kZXIgYXMgUGxheWJhY2tBdWRpb0VuY29kZXIgfSBmcm9tICcuL2VudW0vcGxheWJhY2snXG5leHBvcnQgeyBQbGF5YmFja1ZpZGVvRW5jb2RlciBhcyBQbGF5YmFja1ZpZGVvRW5jb2RlciB9IGZyb20gJy4vZW51bS9wbGF5YmFjaydcblxuZXN0YWJsaXNoTG9nZ2VyKGAke0xPR19MRVZFTH1gIHx8IExFVkVMUy5ERUJVRykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuZ2V0TG9nZ2VyKCkuZGVidWcoYFJlZDUgUHJvIFNESyBWZXJzaW9uICR7U0RLX1ZFUlNJT059YCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5leHBvcnQgY29uc3Qgc2V0TG9nTGV2ZWwgPSAobGV2ZWwpID0+IHtcbiAgaWYgKExFVkVMUy5oYXNPd25Qcm9wZXJ0eShsZXZlbC50b1VwcGVyQ2FzZSgpKSkge1xuICAgIGVzdGFibGlzaExvZ2dlcihsZXZlbClcbiAgfVxufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBjcmVhdGVMb2dnZXIgfSBmcm9tICdicm93c2VyLWJ1bnlhbidcbmltcG9ydCB7IFJhd1N0cmVhbSB9IGZyb20gJy4vYnVueWFuLXdyaXRlcidcblxubGV0IGxvZ2dlclxuY29uc3QgZm9ybWF0TWVzc2FnZSA9IChkaXNwYXRjaGVyKSA9PiB7XG4gIHJldHVybiBtZXNzYWdlID0+IHtcbiAgICByZXR1cm4gYCgke2Rpc3BhdGNoZXJ9KSAke21lc3NhZ2V9YFxuICB9XG59XG5jb25zdCBkZWNvcmF0ZSA9IChsZXZlbCkgPT4ge1xuICByZXR1cm4gKHNvdXJjZSwgbWVzc2FnZSkgPT4ge1xuICAgIGxvZ2dlcltsZXZlbF0oZm9ybWF0TWVzc2FnZShzb3VyY2UpKG1lc3NhZ2UpKVxuICB9XG59XG5leHBvcnQgY29uc3QgTEVWRUxTID0ge1xuICBUUkFDRTogJ3RyYWNlJyxcbiAgSU5GTzogJ2luZm8nLFxuICBERUJVRzogJ2RlYnVnJyxcbiAgV0FSTjogJ3dhcm4nLFxuICBFUlJPUjogJ2Vycm9yJyxcbiAgRkFUQUw6ICdmYXRhbCdcbn1cblxuXG5leHBvcnQgY29uc3QgZXN0YWJsaXNoTG9nZ2VyID0gKGxldmVsLCBzdHJlYW1MaXN0ID0gdW5kZWZpbmVkKSA9PiB7XG4gIGxldCBzdHJlYW1zID0gW11cbiAgc3RyZWFtcy5wdXNoKHtcbiAgICBsZXZlbDogbGV2ZWwsXG4gICAgc3RyZWFtOiBuZXcgUmF3U3RyZWFtKCksXG4gICAgdHlwZTogJ3JhdydcbiAgfSlcbiAgaWYgKHN0cmVhbUxpc3QpIHtcbiAgICBjb25zdCBsaXN0ID0gc3RyZWFtTGlzdC5tYXAoaXRlbSA9PiB7XG4gICAgICBpdGVtLmxldmVsID0gbGV2ZWxcbiAgICB9KVxuICAgIHN0cmVhbXMgPSBzdHJlYW1zLmNvbmNhdChsaXN0KVxuICB9XG4gIGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgbGV2ZWw6IGxldmVsLFxuICAgIG5hbWU6ICdyZWQ1cHJvLXNkaycsXG4gICAgc3RyZWFtczogc3RyZWFtc1xuICB9KVxufVxuXG5leHBvcnQgY29uc3QgZ2V0TG9nZ2VyID0gKCkgPT4ge1xuICByZXR1cm4gbG9nZ2VyXG59XG5cbmV4cG9ydCBjb25zdCB0cmFjZSA9IGRlY29yYXRlKExFVkVMUy5UUkFDRSlcbmV4cG9ydCBjb25zdCBpbmZvID0gZGVjb3JhdGUoTEVWRUxTLklORk8pXG5leHBvcnQgY29uc3QgZGVidWcgPSBkZWNvcmF0ZShMRVZFTFMuREVCVUcpXG5leHBvcnQgY29uc3Qgd2FybiA9IGRlY29yYXRlKExFVkVMUy5XQVJOKVxuZXhwb3J0IGNvbnN0IGVycm9yID0gZGVjb3JhdGUoTEVWRUxTLkVSUk9SKVxuZXhwb3J0IGNvbnN0IGZhdGFsID0gZGVjb3JhdGUoTEVWRUxTLkZBVEFMKVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9sb2cvaW5kZXguanNcbiAqKi8iLCIvKipcbiAqICFUaGlzIGlzIGEgc3RyaXBwZWQgZG93biB2ZXJzaW9uIG9mIEJ1bnlhbiB0YXJnZXRlZCBzcGVjaWZpY2FsbHkgZm9yIHRoZSBicm93c2VyXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNCBUcmVudCBNaWNrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQ29weXJpZ2h0IChjKSAyMDE0IEpveWVudCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhlIGJ1bnlhbiBsb2dnaW5nIGxpYnJhcnkgZm9yIG5vZGUuanMuXG4gKlxuICogLSotIG1vZGU6IGpzIC0qLVxuICogdmltOiBleHBhbmR0YWI6dHM9NDpzdz00XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVkVSU0lPTiA9ICcwLjIuMyc7XG5cbi8vIEJ1bnlhbiBsb2cgZm9ybWF0IHZlcnNpb24uIFRoaXMgYmVjb21lcyB0aGUgJ3YnIGZpZWxkIG9uIGFsbCBsb2cgcmVjb3Jkcy5cbi8vIGAwYCBpcyB1bnRpbCBJIHJlbGVhc2UgYSB2ZXJzaW9uICcxLjAuMCcgb2Ygbm9kZS1idW55YW4uIFRoZXJlYWZ0ZXIsXG4vLyBzdGFydGluZyB3aXRoIGAxYCwgdGhpcyB3aWxsIGJlIGluY3JlbWVudGVkIGlmIHRoZXJlIGlzIGFueSBiYWNrd2FyZFxuLy8gaW5jb21wYXRpYmxlIGNoYW5nZSB0byB0aGUgbG9nIHJlY29yZCBmb3JtYXQuIERldGFpbHMgd2lsbCBiZSBpblxuLy8gJ0NIQU5HRVMubWQnICh0aGUgY2hhbmdlIGxvZykuXG52YXIgTE9HX1ZFUlNJT04gPSAwO1xuXG4vLy0tLS0gSW50ZXJuYWwgc3VwcG9ydCBzdHVmZlxuXG4vKipcbiAqIEEgc2hhbGxvdyBjb3B5IG9mIGFuIG9iamVjdC4gQnVueWFuIGxvZ2dpbmcgYXR0ZW1wdHMgdG8gbmV2ZXIgY2F1c2VcbiAqIGV4Y2VwdGlvbnMsIHNvIHRoaXMgZnVuY3Rpb24gYXR0ZW1wdHMgdG8gaGFuZGxlIG5vbi1vYmplY3RzIGdyYWNlZnVsbHkuXG4gKi9cbmZ1bmN0aW9uIG9iakNvcHkob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnIHx8IG9iaiA9PT0gbnVsbCkgeyAgLy8gbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgKG9iaikgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBjb3B5ID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgY29weVtrXSA9IG9ialtrXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxufVxuXG52YXIgZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuXG4gICAgaWYoZiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cblxuICAgIGlmKHR5cGVvZiBmICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZi50b1N0cmluZygpO1xuICAgIH1cbiAgICB2YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcblxuICAgIHZhciBpID0gMTtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gICAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoeCA9PT0gJyUlJykge1xuICAgICAgICAgICAgcmV0dXJuICclJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSBsZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoeCkge1xuICAgICAgICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICAgICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgICAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBHYXRoZXIgc29tZSBjYWxsZXIgaW5mbyAzIHN0YWNrIGxldmVscyB1cC5cbiAqIFNlZSA8aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L3dpa2kvSmF2YVNjcmlwdFN0YWNrVHJhY2VBcGk+LlxuICovXG5mdW5jdGlvbiBnZXRDYWxsZXIzSW5mbygpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgdmFyIHNhdmVMaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgICB2YXIgc2F2ZVByZXBhcmUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAzO1xuICAgIC8vRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgZ2V0Q2FsbGVyM0luZm8pO1xuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmdW5jdGlvbiAoXywgc3RhY2spIHtcbiAgICAgICAgdmFyIGNhbGxlciA9IHN0YWNrWzJdO1xuICAgICAgICBvYmouZmlsZSA9IGNhbGxlci5nZXRGaWxlTmFtZSgpO1xuICAgICAgICBvYmoubGluZSA9IGNhbGxlci5nZXRMaW5lTnVtYmVyKCk7XG4gICAgICAgIHZhciBmdW5jID0gY2FsbGVyLmdldEZ1bmN0aW9uTmFtZSgpO1xuICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgb2JqLmZ1bmMgPSBmdW5jO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBzYXZlTGltaXQ7XG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBzYXZlUHJlcGFyZTtcbiAgICByZXR1cm4gb2JqO1xufVxuXG5cbmZ1bmN0aW9uIF9pbmRlbnQocywgaW5kZW50KSB7XG4gICAgaWYgKCFpbmRlbnQpIHtcbiAgICAgICAgaW5kZW50ID0gJyAgICAnO1xuICAgIH1cbiAgICB2YXIgbGluZXMgPSBzLnNwbGl0KC9cXHI/XFxuL2cpO1xuICAgIHJldHVybiBpbmRlbnQgKyBsaW5lcy5qb2luKCdcXG4nICsgaW5kZW50KTtcbn1cblxuXG4vKipcbiAqIFdhcm4gYWJvdXQgYW4gYnVueWFuIHByb2Nlc3NpbmcgZXJyb3IuXG4gKlxuICogQHBhcmFtIG1zZyB7U3RyaW5nfSBNZXNzYWdlIHdpdGggd2hpY2ggdG8gd2Fybi5cbiAqIEBwYXJhbSBkZWR1cEtleSB7U3RyaW5nfSBPcHRpb25hbC4gQSBzaG9ydCBzdHJpbmcga2V5IGZvciB0aGlzIHdhcm5pbmcgdG9cbiAqICAgICAgaGF2ZSBpdHMgd2FybmluZyBvbmx5IHByaW50ZWQgb25jZS5cbiAqL1xuZnVuY3Rpb24gX3dhcm4obXNnLCBkZWR1cEtleSkge1xuICAgIGlmIChkZWR1cEtleSkge1xuICAgICAgICBpZiAoX3dhcm5lZFtkZWR1cEtleV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfd2FybmVkW2RlZHVwS2V5XSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IobXNnICsgJ1xcbicpO1xufVxuZnVuY3Rpb24gX2hhdmVXYXJuZWQoZGVkdXBLZXkpIHtcbiAgICByZXR1cm4gX3dhcm5lZFtkZWR1cEtleV07XG59XG52YXIgX3dhcm5lZCA9IHt9O1xuXG5cbmZ1bmN0aW9uIENvbnNvbGVSYXdTdHJlYW0oKSB7XG59XG5Db25zb2xlUmF3U3RyZWFtLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChyZWMpIHtcbiAgICBpZiAocmVjLmxldmVsIDwgSU5GTykge1xuICAgICAgICBjb25zb2xlLmxvZyhyZWMpO1xuICAgIH0gZWxzZSBpZiAocmVjLmxldmVsIDwgV0FSTikge1xuICAgICAgICBjb25zb2xlLmluZm8ocmVjKTtcbiAgICB9IGVsc2UgaWYgKHJlYy5sZXZlbCA8IEVSUk9SKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihyZWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IocmVjKTtcbiAgICB9XG5cbiAgICBpZihyZWMuZXJyICYmIHJlYy5lcnIuc3RhY2spIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihyZWMuZXJyLnN0YWNrKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBDb25zb2xlRm9ybWF0dGVkU3RyZWFtKCkge31cbkNvbnNvbGVGb3JtYXR0ZWRTdHJlYW0ucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHJlYykge1xuXG4gICAgdmFyIGxldmVsQ3NzLCBkZWZhdWx0Q3NzID0gJ2NvbG9yOiBEaW1HcmF5JywgbXNnQ3NzID0gJ2NvbG9yOiBTdGVlbEJsdWUnO1xuXG4gICAgaWYgKHJlYy5sZXZlbCA8IERFQlVHKSB7XG4gICAgICAgIGxldmVsQ3NzID0gJ2NvbG9yOiBEZWVwUGluayc7XG4gICAgfSBlbHNlIGlmIChyZWMubGV2ZWwgPCBJTkZPKSB7XG4gICAgICAgIGxldmVsQ3NzID0gJ2NvbG9yOiBHb2xkZW5Sb2QnO1xuICAgIH0gZWxzZSBpZiAocmVjLmxldmVsIDwgV0FSTikge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogRGFya1R1cnF1b2lzZSc7XG4gICAgfSBlbHNlIGlmIChyZWMubGV2ZWwgPCBFUlJPUikge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogUHVycGxlJztcbiAgICB9IGVsc2UgaWYgKHJlYy5sZXZlbCA8IEZBVEFMKSB7XG4gICAgICAgIGxldmVsQ3NzID0gJ2NvbG9yOiBDcmltc29uJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbENzcyA9ICdjb2xvcjogQmxhY2snO1xuICAgIH1cblxuICAgIHZhciBsb2dnZXJOYW1lID0gcmVjLmNoaWxkTmFtZSA/IHJlYy5uYW1lICsgJy8nICsgcmVjLmNoaWxkTmFtZSA6IHJlYy5uYW1lO1xuXG4gICAgLy9nZXQgbGV2ZWwgbmFtZSBhbmQgcGFkIHN0YXJ0IHdpdGggc3BhY3NcbiAgICB2YXIgbGV2ZWxOYW1lID0gbmFtZUZyb21MZXZlbFtyZWMubGV2ZWxdLnRvVXBwZXJDYXNlKCk7XG4gICAgbGV2ZWxOYW1lID0gQXJyYXkoNiAtIGxldmVsTmFtZS5sZW5ndGgpLmpvaW4oJyAnKSArIGxldmVsTmFtZTtcblxuICAgIGZ1bmN0aW9uIHBhZFplcm9zKG51bWJlciwgbGVuKSB7XG4gICAgICAgIHJldHVybiBBcnJheSgobGVuICsgMSkgLSAobnVtYmVyICsgJycpLmxlbmd0aCkuam9pbignMCcpICsgbnVtYmVyO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdbJXM6JXM6JXM6JXNdICVjJXMlYzogJXM6ICVjJXMnLFxuICAgICAgICBwYWRaZXJvcyhyZWMudGltZS5nZXRIb3VycygpLCAyKSwgcGFkWmVyb3MocmVjLnRpbWUuZ2V0TWludXRlcygpLCAyKSxcbiAgICAgICAgcGFkWmVyb3MocmVjLnRpbWUuZ2V0U2Vjb25kcygpLCAyKSwgcGFkWmVyb3MocmVjLnRpbWUuZ2V0TWlsbGlzZWNvbmRzKCksIDQpLFxuICAgICAgICBsZXZlbENzcywgbGV2ZWxOYW1lLFxuICAgICAgICBkZWZhdWx0Q3NzLCBsb2dnZXJOYW1lLFxuICAgICAgICBtc2dDc3MsIHJlYy5tc2cpO1xuICAgIGlmKHJlYy5lcnIgJiYgcmVjLmVyci5zdGFjaykge1xuICAgICAgICBjb25zb2xlLmxvZygnJWMlcywnLCBsZXZlbENzcywgcmVjLmVyci5zdGFjayk7XG4gICAgfVxufTtcblxuLy8tLS0tIExldmVsc1xuXG52YXIgVFJBQ0UgPSAxMDtcbnZhciBERUJVRyA9IDIwO1xudmFyIElORk8gPSAzMDtcbnZhciBXQVJOID0gNDA7XG52YXIgRVJST1IgPSA1MDtcbnZhciBGQVRBTCA9IDYwO1xuXG52YXIgbGV2ZWxGcm9tTmFtZSA9IHtcbiAgICAndHJhY2UnOiBUUkFDRSxcbiAgICAnZGVidWcnOiBERUJVRyxcbiAgICAnaW5mbyc6IElORk8sXG4gICAgJ3dhcm4nOiBXQVJOLFxuICAgICdlcnJvcic6IEVSUk9SLFxuICAgICdmYXRhbCc6IEZBVEFMXG59O1xudmFyIG5hbWVGcm9tTGV2ZWwgPSB7fTtcbk9iamVjdC5rZXlzKGxldmVsRnJvbU5hbWUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBuYW1lRnJvbUxldmVsW2xldmVsRnJvbU5hbWVbbmFtZV1dID0gbmFtZTtcbn0pO1xuXG5cbi8qKlxuICogUmVzb2x2ZSBhIGxldmVsIG51bWJlciwgbmFtZSAodXBwZXIgb3IgbG93ZXJjYXNlKSB0byBhIGxldmVsIG51bWJlciB2YWx1ZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiByZXNvbHZlTGV2ZWwobmFtZU9yTnVtKSB7XG4gICAgdmFyIGxldmVsID0gKHR5cGVvZiAobmFtZU9yTnVtKSA9PT0gJ3N0cmluZycgPyBsZXZlbEZyb21OYW1lW25hbWVPck51bS50b0xvd2VyQ2FzZSgpXSA6IG5hbWVPck51bSk7XG4gICAgcmV0dXJuIGxldmVsO1xufVxuXG5cbi8vLS0tLSBMb2dnZXIgY2xhc3NcblxuLyoqXG4gKiBDcmVhdGUgYSBMb2dnZXIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gU2VlIGRvY3VtZW50YXRpb24gZm9yIGZ1bGwgZGV0YWlscy4gQXQgbWluaW11bVxuICogICAgdGhpcyBtdXN0IGluY2x1ZGUgYSAnbmFtZScgc3RyaW5nIGtleS4gQ29uZmlndXJhdGlvbiBrZXlzOlxuICogICAgICAtIGBzdHJlYW1zYDogc3BlY2lmeSB0aGUgbG9nZ2VyIG91dHB1dCBzdHJlYW1zLiBUaGlzIGlzIGFuIGFycmF5IG9mXG4gKiAgICAgICAgb2JqZWN0cyB3aXRoIHRoZXNlIGZpZWxkczpcbiAqICAgICAgICAgIC0gYHR5cGVgOiBUaGUgc3RyZWFtIHR5cGUuIFNlZSBSRUFETUUubWQgZm9yIGZ1bGwgZGV0YWlscy5cbiAqICAgICAgICAgICAgT2Z0ZW4gdGhpcyBpcyBpbXBsaWVkIGJ5IHRoZSBvdGhlciBmaWVsZHMuIEV4YW1wbGVzIGFyZVxuICogICAgICAgICAgICAnZmlsZScsICdzdHJlYW0nIGFuZCBcInJhd1wiLlxuICogICAgICAgICAgLSBgbGV2ZWxgOiBEZWZhdWx0cyB0byAnaW5mbycuXG4gKiAgICAgICAgICAtIGBwYXRoYCBvciBgc3RyZWFtYDogVGhlIHNwZWNpZnkgdGhlIGZpbGUgcGF0aCBvciB3cml0ZWFibGVcbiAqICAgICAgICAgICAgc3RyZWFtIHRvIHdoaWNoIGxvZyByZWNvcmRzIGFyZSB3cml0dGVuLiBFLmcuXG4gKiAgICAgICAgICAgIGBzdHJlYW06IHByb2Nlc3Muc3Rkb3V0YC5cbiAqICAgICAgICAgIC0gYGNsb3NlT25FeGl0YCAoYm9vbGVhbik6IE9wdGlvbmFsLiBEZWZhdWx0IGlzIHRydWUgZm9yIGFcbiAqICAgICAgICAgICAgJ2ZpbGUnIHN0cmVhbSB3aGVuIGBwYXRoYCBpcyBnaXZlbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogICAgICAgIFNlZSBSRUFETUUubWQgZm9yIGZ1bGwgZGV0YWlscy5cbiAqICAgICAgLSBgbGV2ZWxgOiBzZXQgdGhlIGxldmVsIGZvciBhIHNpbmdsZSBvdXRwdXQgc3RyZWFtIChjYW5ub3QgYmUgdXNlZFxuICogICAgICAgIHdpdGggYHN0cmVhbXNgKVxuICogICAgICAtIGBzdHJlYW1gOiB0aGUgb3V0cHV0IHN0cmVhbSBmb3IgYSBsb2dnZXIgd2l0aCBqdXN0IG9uZSwgZS5nLlxuICogICAgICAgIGBwcm9jZXNzLnN0ZG91dGAgKGNhbm5vdCBiZSB1c2VkIHdpdGggYHN0cmVhbXNgKVxuICogICAgICAtIGBzZXJpYWxpemVyc2A6IG9iamVjdCBtYXBwaW5nIGxvZyByZWNvcmQgZmllbGQgbmFtZXMgdG9cbiAqICAgICAgICBzZXJpYWxpemluZyBmdW5jdGlvbnMuIFNlZSBSRUFETUUubWQgZm9yIGRldGFpbHMuXG4gKiAgICAgIC0gYHNyY2A6IEJvb2xlYW4gKGRlZmF1bHQgZmFsc2UpLiBTZXQgdHJ1ZSB0byBlbmFibGUgJ3NyYycgYXV0b21hdGljXG4gKiAgICAgICAgZmllbGQgd2l0aCBsb2cgY2FsbCBzb3VyY2UgaW5mby5cbiAqICAgIEFsbCBvdGhlciBrZXlzIGFyZSBsb2cgcmVjb3JkIGZpZWxkcy5cbiAqXG4gKiBBbiBhbHRlcm5hdGl2ZSAqaW50ZXJuYWwqIGNhbGwgc2lnbmF0dXJlIGlzIHVzZWQgZm9yIGNyZWF0aW5nIGEgY2hpbGQ6XG4gKiAgICBuZXcgTG9nZ2VyKDxwYXJlbnQgbG9nZ2VyPiwgPGNoaWxkIG9wdGlvbnM+WywgPGNoaWxkIG9wdHMgYXJlIHNpbXBsZT5dKTtcbiAqXG4gKiBAcGFyYW0gX2NoaWxkU2ltcGxlIChCb29sZWFuKSBBbiBhc3NlcnRpb24gdGhhdCB0aGUgZ2l2ZW4gYF9jaGlsZE9wdGlvbnNgXG4gKiAgICAoYSkgb25seSBhZGQgZmllbGRzIChubyBjb25maWcpIGFuZCAoYikgbm8gc2VyaWFsaXphdGlvbiBoYW5kbGluZyBpc1xuICogICAgcmVxdWlyZWQgZm9yIHRoZW0uIElPVywgdGhpcyBpcyBhIGZhc3QgcGF0aCBmb3IgZnJlcXVlbnQgY2hpbGRcbiAqICAgIGNyZWF0aW9uLlxuICovXG5mdW5jdGlvbiBMb2dnZXIob3B0aW9ucywgX2NoaWxkT3B0aW9ucywgX2NoaWxkU2ltcGxlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExvZ2dlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2dnZXIob3B0aW9ucywgX2NoaWxkT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gSW5wdXQgYXJnIHZhbGlkYXRpb24uXG4gICAgdmFyIHBhcmVudDtcbiAgICBpZiAoX2NoaWxkT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmVudCA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBfY2hpbGRPcHRpb25zO1xuICAgICAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBMb2dnZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICdpbnZhbGlkIExvZ2dlciBjcmVhdGlvbjogZG8gbm90IHBhc3MgYSBzZWNvbmQgYXJnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgKG9iamVjdCkgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMubmFtZSAoc3RyaW5nKSBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBvcHRpb25zLm5hbWU6IGNoaWxkIGNhbm5vdCBzZXQgbG9nZ2VyIG5hbWUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdHJlYW0gJiYgb3B0aW9ucy5zdHJlYW1zKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBtaXggXCJzdHJlYW1zXCIgYW5kIFwic3RyZWFtXCIgb3B0aW9ucycpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdHJlYW1zICYmICFBcnJheS5pc0FycmF5KG9wdGlvbnMuc3RyZWFtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBvcHRpb25zLnN0cmVhbXM6IG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2VyaWFsaXplcnMgJiYgKHR5cGVvZiAob3B0aW9ucy5zZXJpYWxpemVycykgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy5zZXJpYWxpemVycykpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgb3B0aW9ucy5zZXJpYWxpemVyczogbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG5cbiAgICB2YXIgZmllbGRzLCBuYW1lLCBpO1xuXG4gICAgLy8gRmFzdCBwYXRoIGZvciBzaW1wbGUgY2hpbGQgY3JlYXRpb24uXG4gICAgaWYgKHBhcmVudCAmJiBfY2hpbGRTaW1wbGUpIHtcbiAgICAgICAgLy8gYF9pc1NpbXBsZUNoaWxkYCBpcyBhIHNpZ25hbCB0byBzdHJlYW0gY2xvc2UgaGFuZGxpbmcgdGhhdCB0aGlzIGNoaWxkXG4gICAgICAgIC8vIG93bnMgbm9uZSBvZiBpdHMgc3RyZWFtcy5cbiAgICAgICAgdGhpcy5faXNTaW1wbGVDaGlsZCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBwYXJlbnQuX2xldmVsO1xuICAgICAgICB0aGlzLnN0cmVhbXMgPSBwYXJlbnQuc3RyZWFtcztcbiAgICAgICAgdGhpcy5zZXJpYWxpemVycyA9IHBhcmVudC5zZXJpYWxpemVycztcbiAgICAgICAgdGhpcy5zcmMgPSBwYXJlbnQuc3JjO1xuICAgICAgICBmaWVsZHMgPSB0aGlzLmZpZWxkcyA9IHt9O1xuICAgICAgICB2YXIgcGFyZW50RmllbGROYW1lcyA9IE9iamVjdC5rZXlzKHBhcmVudC5maWVsZHMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyZW50RmllbGROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmFtZSA9IHBhcmVudEZpZWxkTmFtZXNbaV07XG4gICAgICAgICAgICBmaWVsZHNbbmFtZV0gPSBwYXJlbnQuZmllbGRzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICAgIGZpZWxkc1tuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE51bGwgdmFsdWVzLlxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHRoaXMuX2xldmVsID0gcGFyZW50Ll9sZXZlbDtcbiAgICAgICAgdGhpcy5zdHJlYW1zID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJlbnQuc3RyZWFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHMgPSBvYmpDb3B5KHBhcmVudC5zdHJlYW1zW2ldKTtcbiAgICAgICAgICAgIHMuY2xvc2VPbkV4aXQgPSBmYWxzZTsgLy8gRG9uJ3Qgb3duIHBhcmVudCBzdHJlYW0uXG4gICAgICAgICAgICB0aGlzLnN0cmVhbXMucHVzaChzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcmlhbGl6ZXJzID0gb2JqQ29weShwYXJlbnQuc2VyaWFsaXplcnMpO1xuICAgICAgICB0aGlzLnNyYyA9IHBhcmVudC5zcmM7XG4gICAgICAgIHRoaXMuZmllbGRzID0gb2JqQ29weShwYXJlbnQuZmllbGRzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMubGV2ZWwob3B0aW9ucy5sZXZlbCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9sZXZlbCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgdGhpcy5zdHJlYW1zID0gW107XG4gICAgICAgIHRoaXMuc2VyaWFsaXplcnMgPSBudWxsO1xuICAgICAgICB0aGlzLnNyYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IHt9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSAqY29uZmlnKiBvcHRpb25zIChpLmUuIG9wdGlvbnMgdGhhdCBhcmUgbm90IGp1c3QgcGxhaW4gZGF0YVxuICAgIC8vIGZvciBsb2cgcmVjb3JkcykuXG4gICAgaWYgKG9wdGlvbnMuc3RyZWFtKSB7XG4gICAgICAgIHNlbGYuYWRkU3RyZWFtKHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJlYW0nLFxuICAgICAgICAgICAgc3RyZWFtOiBvcHRpb25zLnN0cmVhbSxcbiAgICAgICAgICAgIGNsb3NlT25FeGl0OiBmYWxzZSxcbiAgICAgICAgICAgIGxldmVsOiBvcHRpb25zLmxldmVsXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zdHJlYW1zKSB7XG4gICAgICAgIG9wdGlvbnMuc3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICBzZWxmLmFkZFN0cmVhbShzLCBvcHRpb25zLmxldmVsKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwYXJlbnQgJiYgb3B0aW9ucy5sZXZlbCkge1xuICAgICAgICB0aGlzLmxldmVsKG9wdGlvbnMubGV2ZWwpO1xuICAgIH0gZWxzZSBpZiAoIXBhcmVudCkge1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEluIHRoZSBicm93c2VyIHdlJ2xsIGJlIGVtaXR0aW5nIHRvIGNvbnNvbGUubG9nIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqIEFueSBjb25zb2xlLmxvZyB3b3J0aCBpdHMgc2FsdCB0aGVzZSBkYXlzIGNhbiBuaWNlbHkgcmVuZGVyXG4gICAgICAgICAqIGFuZCBpbnRyb3NwZWN0IG9iamVjdHMgKGUuZy4gdGhlIEZpcmVmb3ggYW5kIENocm9tZSBjb25zb2xlKVxuICAgICAgICAgKiBzbyBsZXQncyBlbWl0IHRoZSByYXcgbG9nIHJlY29yZC4gQXJlIHRoZXJlIGJyb3dzZXJzIGZvciB3aGljaFxuICAgICAgICAgKiB0aGF0IGJyZWFrcyB0aGluZ3M/XG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLmFkZFN0cmVhbSh7XG4gICAgICAgICAgICB0eXBlOiAncmF3JyxcbiAgICAgICAgICAgIHN0cmVhbTogbmV3IENvbnNvbGVSYXdTdHJlYW0oKSxcbiAgICAgICAgICAgIGNsb3NlT25FeGl0OiBmYWxzZSxcbiAgICAgICAgICAgIGxldmVsOiBvcHRpb25zLmxldmVsXG4gICAgICAgIH0pO1xuXG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNlcmlhbGl6ZXJzKSB7XG4gICAgICAgIHNlbGYuYWRkU2VyaWFsaXplcnMob3B0aW9ucy5zZXJpYWxpemVycyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNyYykge1xuICAgICAgICB0aGlzLnNyYyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmllbGRzLlxuICAgIC8vIFRoZXNlIGFyZSB0aGUgZGVmYXVsdCBmaWVsZHMgZm9yIGxvZyByZWNvcmRzIChtaW51cyB0aGUgYXR0cmlidXRlc1xuICAgIC8vIHJlbW92ZWQgaW4gdGhpcyBjb25zdHJ1Y3RvcikuIFRvIGFsbG93IHN0b3JpbmcgcmF3IGxvZyByZWNvcmRzXG4gICAgLy8gKHVucmVuZGVyZWQpLCBgdGhpcy5maWVsZHNgIG11c3QgbmV2ZXIgYmUgbXV0YXRlZC4gQ3JlYXRlIGEgY29weSBmb3JcbiAgICAvLyBhbnkgY2hhbmdlcy5cbiAgICBmaWVsZHMgPSBvYmpDb3B5KG9wdGlvbnMpO1xuICAgIGRlbGV0ZSBmaWVsZHMuc3RyZWFtO1xuICAgIGRlbGV0ZSBmaWVsZHMubGV2ZWw7XG4gICAgZGVsZXRlIGZpZWxkcy5zdHJlYW1zO1xuICAgIGRlbGV0ZSBmaWVsZHMuc2VyaWFsaXplcnM7XG4gICAgZGVsZXRlIGZpZWxkcy5zcmM7XG4gICAgaWYgKHRoaXMuc2VyaWFsaXplcnMpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlTZXJpYWxpemVycyhmaWVsZHMpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhmaWVsZHMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgc2VsZi5maWVsZHNba10gPSBmaWVsZHNba107XG4gICAgfSk7XG59XG5cbi8qKlxuICogQWRkIGEgc3RyZWFtXG4gKlxuICogQHBhcmFtIHN0cmVhbSB7T2JqZWN0fS4gT2JqZWN0IHdpdGggdGhlc2UgZmllbGRzOlxuICogICAgLSBgdHlwZWA6IFRoZSBzdHJlYW0gdHlwZS4gU2VlIFJFQURNRS5tZCBmb3IgZnVsbCBkZXRhaWxzLlxuICogICAgICBPZnRlbiB0aGlzIGlzIGltcGxpZWQgYnkgdGhlIG90aGVyIGZpZWxkcy4gRXhhbXBsZXMgYXJlXG4gKiAgICAgICdmaWxlJywgJ3N0cmVhbScgYW5kIFwicmF3XCIuXG4gKiAgICAtIGBwYXRoYCBvciBgc3RyZWFtYDogVGhlIHNwZWNpZnkgdGhlIGZpbGUgcGF0aCBvciB3cml0ZWFibGVcbiAqICAgICAgc3RyZWFtIHRvIHdoaWNoIGxvZyByZWNvcmRzIGFyZSB3cml0dGVuLiBFLmcuXG4gKiAgICAgIGBzdHJlYW06IHByb2Nlc3Muc3Rkb3V0YC5cbiAqICAgIC0gYGxldmVsYDogT3B0aW9uYWwuIEZhbGxzIGJhY2sgdG8gYGRlZmF1bHRMZXZlbGAuXG4gKiAgICAtIGBjbG9zZU9uRXhpdGAgKGJvb2xlYW4pOiBPcHRpb25hbC4gRGVmYXVsdCBpcyB0cnVlIGZvciBhXG4gKiAgICAgICdmaWxlJyBzdHJlYW0gd2hlbiBgcGF0aGAgaXMgZ2l2ZW4sIGZhbHNlIG90aGVyd2lzZS5cbiAqICAgIFNlZSBSRUFETUUubWQgZm9yIGZ1bGwgZGV0YWlscy5cbiAqIEBwYXJhbSBkZWZhdWx0TGV2ZWwge051bWJlcnxTdHJpbmd9IE9wdGlvbmFsLiBBIGxldmVsIHRvIHVzZSBpZlxuICogICAgICBgc3RyZWFtLmxldmVsYCBpcyBub3Qgc2V0LiBJZiBuZWl0aGVyIGlzIGdpdmVuLCB0aGlzIGRlZmF1bHRzIHRvIElORk8uXG4gKi9cbkxvZ2dlci5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHMsIGRlZmF1bHRMZXZlbCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoZGVmYXVsdExldmVsID09PSBudWxsIHx8IGRlZmF1bHRMZXZlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmF1bHRMZXZlbCA9IElORk87XG4gICAgfVxuXG4gICAgcyA9IG9iakNvcHkocyk7XG5cbiAgICAvLyBJbXBsaWNpdCAndHlwZScgZnJvbSBvdGhlciBhcmdzLlxuICAgIGlmICghcy50eXBlICYmIHMuc3RyZWFtKSB7XG4gICAgICAgIHMudHlwZSA9ICdyYXcnO1xuICAgIH1cbiAgICBzLnJhdyA9IChzLnR5cGUgPT09ICdyYXcnKTsgIC8vIFBFUkY6IEFsbG93IGZvciBmYXN0ZXIgY2hlY2sgaW4gYF9lbWl0YC5cblxuICAgIGlmIChzLmxldmVsKSB7XG4gICAgICAgIHMubGV2ZWwgPSByZXNvbHZlTGV2ZWwocy5sZXZlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcy5sZXZlbCA9IHJlc29sdmVMZXZlbChkZWZhdWx0TGV2ZWwpO1xuICAgIH1cbiAgICBpZiAocy5sZXZlbCA8IHNlbGYuX2xldmVsKSB7XG4gICAgICAgIHNlbGYuX2xldmVsID0gcy5sZXZlbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHMudHlwZSkge1xuICAgICAgICBjYXNlICdzdHJlYW0nOlxuICAgICAgICAgICAgaWYgKCFzLmNsb3NlT25FeGl0KSB7XG4gICAgICAgICAgICAgICAgcy5jbG9zZU9uRXhpdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICAgICAgICBpZiAoIXMuY2xvc2VPbkV4aXQpIHtcbiAgICAgICAgICAgICAgICBzLmNsb3NlT25FeGl0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Vua25vd24gc3RyZWFtIHR5cGUgXCInICsgcy50eXBlICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgc2VsZi5zdHJlYW1zLnB1c2gocyk7XG4gICAgZGVsZXRlIHNlbGYuaGF2ZU5vblJhd1N0cmVhbXM7ICAvLyByZXNldFxufTtcblxuXG4vKipcbiAqIEFkZCBzZXJpYWxpemVyc1xuICpcbiAqIEBwYXJhbSBzZXJpYWxpemVycyB7T2JqZWN0fSBPcHRpb25hbC4gT2JqZWN0IG1hcHBpbmcgbG9nIHJlY29yZCBmaWVsZCBuYW1lc1xuICogICAgdG8gc2VyaWFsaXppbmcgZnVuY3Rpb25zLiBTZWUgUkVBRE1FLm1kIGZvciBkZXRhaWxzLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLmFkZFNlcmlhbGl6ZXJzID0gZnVuY3Rpb24gYWRkU2VyaWFsaXplcnMoc2VyaWFsaXplcnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXNlbGYuc2VyaWFsaXplcnMpIHtcbiAgICAgICAgc2VsZi5zZXJpYWxpemVycyA9IHt9O1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhzZXJpYWxpemVycykuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyc1tmaWVsZF07XG4gICAgICAgIGlmICh0eXBlb2YgKHNlcmlhbGl6ZXIpICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZvcm1hdChcbiAgICAgICAgICAgICAgICAnaW52YWxpZCBzZXJpYWxpemVyIGZvciBcIiVzXCIgZmllbGQ6IG11c3QgYmUgYSBmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgZmllbGQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc2VyaWFsaXplcnNbZmllbGRdID0gc2VyaWFsaXplcjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZSBhIGNoaWxkIGxvZ2dlciwgdHlwaWNhbGx5IHRvIGFkZCBhIGZldyBsb2cgcmVjb3JkIGZpZWxkcy5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiBwYXNzaW5nIGEgbG9nZ2VyIHRvIGEgc3ViLWNvbXBvbmVudCwgZS5nLiBhXG4gKiAnd3V6emxlJyBjb21wb25lbnQgb2YgeW91ciBzZXJ2aWNlOlxuICpcbiAqICAgIHZhciB3dXp6bGVMb2cgPSBsb2cuY2hpbGQoe2NvbXBvbmVudDogJ3d1enpsZSd9KVxuICogICAgdmFyIHd1enpsZSA9IG5ldyBXdXp6bGUoey4uLiwgbG9nOiB3dXp6bGVMb2d9KVxuICpcbiAqIFRoZW4gbG9nIHJlY29yZHMgZnJvbSB0aGUgd3V6emxlIGNvZGUgd2lsbCBoYXZlIHRoZSBzYW1lIHN0cnVjdHVyZSBhc1xuICogdGhlIGFwcCBsb2csICpwbHVzIHRoZSBjb21wb25lbnQ9J3d1enpsZScgZmllbGQqLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IE9wdGlvbmFsLiBTZXQgb2Ygb3B0aW9ucyB0byBhcHBseSB0byB0aGUgY2hpbGQuXG4gKiAgICBBbGwgb2YgdGhlIHNhbWUgb3B0aW9ucyBmb3IgYSBuZXcgTG9nZ2VyIGFwcGx5IGhlcmUuIE5vdGVzOlxuICogICAgICAtIFRoZSBwYXJlbnQncyBzdHJlYW1zIGFyZSBpbmhlcml0ZWQgYW5kIGNhbm5vdCBiZSByZW1vdmVkIGluIHRoaXNcbiAqICAgICAgICBjYWxsLiBBbnkgZ2l2ZW4gYHN0cmVhbXNgIGFyZSAqYWRkZWQqIHRvIHRoZSBzZXQgaW5oZXJpdGVkIGZyb21cbiAqICAgICAgICB0aGUgcGFyZW50LlxuICogICAgICAtIFRoZSBwYXJlbnQncyBzZXJpYWxpemVycyBhcmUgaW5oZXJpdGVkLCB0aG91Z2ggY2FuIGVmZmVjdGl2ZWx5IGJlXG4gKiAgICAgICAgb3ZlcndyaXR0ZW4gYnkgdXNpbmcgZHVwbGljYXRlIGtleXMuXG4gKiAgICAgIC0gQ2FuIHVzZSBgbGV2ZWxgIHRvIHNldCB0aGUgbGV2ZWwgb2YgdGhlIHN0cmVhbXMgaW5oZXJpdGVkIGZyb21cbiAqICAgICAgICB0aGUgcGFyZW50LiBUaGUgbGV2ZWwgZm9yIHRoZSBwYXJlbnQgaXMgTk9UIGFmZmVjdGVkLlxuICogQHBhcmFtIHNpbXBsZSB7Qm9vbGVhbn0gT3B0aW9uYWwuIFNldCB0byB0cnVlIHRvIGFzc2VydCB0aGF0IGBvcHRpb25zYFxuICogICAgKGEpIG9ubHkgYWRkIGZpZWxkcyAobm8gY29uZmlnKSBhbmQgKGIpIG5vIHNlcmlhbGl6YXRpb24gaGFuZGxpbmcgaXNcbiAqICAgIHJlcXVpcmVkIGZvciB0aGVtLiBJT1csIHRoaXMgaXMgYSBmYXN0IHBhdGggZm9yIGZyZXF1ZW50IGNoaWxkXG4gKiAgICBjcmVhdGlvbi4gU2VlICd0b29scy90aW1lY2hpbGQuanMnIGZvciBudW1iZXJzLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNpbXBsZSkge1xuICAgIHJldHVybiBuZXcgKHRoaXMuY29uc3RydWN0b3IpKHRoaXMsIG9wdGlvbnMgfHwge30sIHNpbXBsZSk7XG59O1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIGxldmVsIG9mIGFsbCBzdHJlYW1zIG9uIHRoaXMgbG9nZ2VyLlxuICpcbiAqIEdldCBVc2FnZTpcbiAqICAgIC8vIFJldHVybnMgdGhlIGN1cnJlbnQgbG9nIGxldmVsIChsb3dlc3QgbGV2ZWwgb2YgYWxsIGl0cyBzdHJlYW1zKS5cbiAqICAgIGxvZy5sZXZlbCgpIC0+IElORk9cbiAqXG4gKiBTZXQgVXNhZ2U6XG4gKiAgICBsb2cubGV2ZWwoSU5GTykgICAgICAgLy8gc2V0IGFsbCBzdHJlYW1zIHRvIGxldmVsIElORk9cbiAqICAgIGxvZy5sZXZlbCgnaW5mbycpICAgICAvLyBjYW4gdXNlICdpbmZvJyBldCBhbCBhbGlhc2VzXG4gKi9cbkxvZ2dlci5wcm90b3R5cGUubGV2ZWwgPSBmdW5jdGlvbiBsZXZlbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgICB9XG4gICAgdmFyIG5ld0xldmVsID0gcmVzb2x2ZUxldmVsKHZhbHVlKTtcbiAgICB2YXIgbGVuID0gdGhpcy5zdHJlYW1zLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtc1tpXS5sZXZlbCA9IG5ld0xldmVsO1xuICAgIH1cbiAgICB0aGlzLl9sZXZlbCA9IG5ld0xldmVsO1xufTtcblxuXG4vKipcbiAqIEdldC9zZXQgdGhlIGxldmVsIG9mIGEgcGFydGljdWxhciBzdHJlYW0gb24gdGhpcyBsb2dnZXIuXG4gKlxuICogR2V0IFVzYWdlOlxuICogICAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgbGV2ZWxzIG9mIGVhY2ggc3RyZWFtLlxuICogICAgbG9nLmxldmVscygpIC0+IFtUUkFDRSwgSU5GT11cbiAqXG4gKiAgICAvLyBSZXR1cm5zIGEgbGV2ZWwgb2YgdGhlIGlkZW50aWZpZWQgc3RyZWFtLlxuICogICAgbG9nLmxldmVscygwKSAtPiBUUkFDRSAgICAgIC8vIGxldmVsIG9mIHN0cmVhbSBhdCBpbmRleCAwXG4gKiAgICBsb2cubGV2ZWxzKCdmb28nKSAgICAgICAgICAgLy8gbGV2ZWwgb2Ygc3RyZWFtIHdpdGggbmFtZSAnZm9vJ1xuICpcbiAqIFNldCBVc2FnZTpcbiAqICAgIGxvZy5sZXZlbHMoMCwgSU5GTykgICAgICAgICAvLyBzZXQgbGV2ZWwgb2Ygc3RyZWFtIDAgdG8gSU5GT1xuICogICAgbG9nLmxldmVscygwLCAnaW5mbycpICAgICAgIC8vIGNhbiB1c2UgJ2luZm8nIGV0IGFsIGFsaWFzZXNcbiAqICAgIGxvZy5sZXZlbHMoJ2ZvbycsIFdBUk4pICAgICAvLyBzZXQgc3RyZWFtIG5hbWVkICdmb28nIHRvIFdBUk5cbiAqXG4gKiBTdHJlYW0gbmFtZXM6IFdoZW4gc3RyZWFtcyBhcmUgZGVmaW5lZCwgdGhleSBjYW4gb3B0aW9uYWxseSBiZSBnaXZlblxuICogYSBuYW1lLiBGb3IgZXhhbXBsZSxcbiAqICAgICAgIGxvZyA9IG5ldyBMb2dnZXIoe1xuICogICAgICAgICBzdHJlYW1zOiBbXG4gKiAgICAgICAgICAge1xuICogICAgICAgICAgICAgbmFtZTogJ2ZvbycsXG4gKiAgICAgICAgICAgICBwYXRoOiAnL3Zhci9sb2cvbXktc2VydmljZS9mb28ubG9nJ1xuICogICAgICAgICAgICAgbGV2ZWw6ICd0cmFjZSdcbiAqICAgICAgICAgICB9LFxuICogICAgICAgICAuLi5cbiAqXG4gKiBAcGFyYW0gbmFtZSB7U3RyaW5nfE51bWJlcn0gVGhlIHN0cmVhbSBpbmRleCBvciBuYW1lLlxuICogQHBhcmFtIHZhbHVlIHtOdW1iZXJ8U3RyaW5nfSBUaGUgbGV2ZWwgdmFsdWUgKElORk8pIG9yIGFsaWFzICgnaW5mbycpLlxuICogICAgSWYgbm90IGdpdmVuLCB0aGlzIGlzIGEgJ2dldCcgb3BlcmF0aW9uLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIG5vIHN0cmVhbSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLmxldmVscyA9IGZ1bmN0aW9uIGxldmVscyhuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtcy5tYXAoXG4gICAgICAgICAgICBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzLmxldmVsO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBzdHJlYW07XG4gICAgaWYgKHR5cGVvZiAobmFtZSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHN0cmVhbSA9IHRoaXMuc3RyZWFtc1tuYW1lXTtcbiAgICAgICAgaWYgKHN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc3RyZWFtIGluZGV4OiAnICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5zdHJlYW1zLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnN0cmVhbXNbaV07XG4gICAgICAgICAgICBpZiAocy5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtID0gcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdCgnbm8gc3RyZWFtIHdpdGggbmFtZSBcIiVzXCInLCBuYW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5sZXZlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3TGV2ZWwgPSByZXNvbHZlTGV2ZWwodmFsdWUpO1xuICAgICAgICBzdHJlYW0ubGV2ZWwgPSBuZXdMZXZlbDtcbiAgICAgICAgaWYgKG5ld0xldmVsIDwgdGhpcy5fbGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuICogQXBwbHkgcmVnaXN0ZXJlZCBzZXJpYWxpemVycyB0byB0aGUgYXBwcm9wcmlhdGUga2V5cyBpbiB0aGUgZ2l2ZW4gZmllbGRzLlxuICpcbiAqIFByZS1jb25kaXRpb246IFRoaXMgaXMgb25seSBjYWxsZWQgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIHNlcmlhbGl6ZXIuXG4gKlxuICogQHBhcmFtIGZpZWxkcyAoT2JqZWN0KSBUaGUgbG9nIHJlY29yZCBmaWVsZHMuXG4gKiBAcGFyYW0gZXhjbHVkZUZpZWxkcyAoT2JqZWN0KSBPcHRpb25hbCBtYXBwaW5nIG9mIGtleXMgdG8gYHRydWVgIGZvclxuICogICAga2V5cyB0byBOT1QgYXBwbHkgYSBzZXJpYWxpemVyLlxuICovXG5Mb2dnZXIucHJvdG90eXBlLl9hcHBseVNlcmlhbGl6ZXJzID0gZnVuY3Rpb24gKGZpZWxkcywgZXhjbHVkZUZpZWxkcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIENoZWNrIGVhY2ggc2VyaWFsaXplciBhZ2FpbnN0IHRoZXNlIChwcmVzdW1pbmcgbnVtYmVyIG9mIHNlcmlhbGl6ZXJzXG4gICAgLy8gaXMgdHlwaWNhbGx5IGxlc3MgdGhhbiBudW1iZXIgb2YgZmllbGRzKS5cbiAgICBPYmplY3Qua2V5cyh0aGlzLnNlcmlhbGl6ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChmaWVsZHNbbmFtZV0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKGV4Y2x1ZGVGaWVsZHMgJiYgZXhjbHVkZUZpZWxkc1tuYW1lXSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmllbGRzW25hbWVdID0gc2VsZi5zZXJpYWxpemVyc1tuYW1lXShmaWVsZHNbbmFtZV0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF93YXJuKGZvcm1hdCgnYnVueWFuOiBFUlJPUjogRXhjZXB0aW9uIHRocm93biBmcm9tIHRoZSBcIiVzXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdCdW55YW4gc2VyaWFsaXplci4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiBUaGlzIGlzIGEgYnVnJyArXG4gICAgICAgICAgICAgICAgICAgICdpbiB0aGF0IHNlcmlhbGl6ZXIgZnVuY3Rpb24uXFxuJXMnLFxuICAgICAgICAgICAgICAgIG5hbWUsIGVyci5zdGFjayB8fCBlcnIpKTtcbiAgICAgICAgICAgIGZpZWxkc1tuYW1lXSA9IGZvcm1hdCgnKEVycm9yIGluIEJ1bnlhbiBsb2cgXCIlc1wiIHNlcmlhbGl6ZXIgYnJva2UgZmllbGQuIFNlZSBzdGRlcnIgZm9yIGRldGFpbHMuKScsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogRW1pdCBhIGxvZyByZWNvcmQuXG4gKlxuICogQHBhcmFtIHJlYyB7bG9nIHJlY29yZH1cbiAqIEBwYXJhbSBub2VtaXQge0Jvb2xlYW59IE9wdGlvbmFsLiBTZXQgdG8gdHJ1ZSB0byBza2lwIGVtaXNzaW9uXG4gKiAgICAgIGFuZCBqdXN0IHJldHVybiB0aGUgSlNPTiBzdHJpbmcuXG4gKi9cbkxvZ2dlci5wcm90b3R5cGUuX2VtaXQgPSBmdW5jdGlvbiAocmVjLCBub2VtaXQpIHtcbiAgICB2YXIgaTtcblxuICAgIC8vIExhemlseSBkZXRlcm1pbmUgaWYgdGhpcyBMb2dnZXIgaGFzIG5vbi0ncmF3JyBzdHJlYW1zLiBJZiB0aGVyZSBhcmVcbiAgICAvLyBhbnksIHRoZW4gd2UgbmVlZCB0byBzdHJpbmdpZnkgdGhlIGxvZyByZWNvcmQuXG4gICAgaWYgKHRoaXMuaGF2ZU5vblJhd1N0cmVhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmhhdmVOb25SYXdTdHJlYW1zID0gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnN0cmVhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdHJlYW1zW2ldLnJhdykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGF2ZU5vblJhd1N0cmVhbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RyaW5naWZ5IHRoZSBvYmplY3QuIEF0dGVtcHQgdG8gd2Fybi9yZWNvdmVyIG9uIGVycm9yLlxuICAgIHZhciBzdHI7XG4gICAgaWYgKG5vZW1pdCB8fCB0aGlzLmhhdmVOb25SYXdTdHJlYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdHIgPSBKU09OLnN0cmluZ2lmeShyZWMsIHNhZmVDeWNsZXMoKSkgKyAnXFxuJztcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdmFyIGRlZHVwS2V5ID0gZS5zdGFjay5zcGxpdCgvXFxuL2csIDIpLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgX3dhcm4oJ2J1bnlhbjogRVJST1I6IEV4Y2VwdGlvbiBpbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2BKU09OLnN0cmluZ2lmeShyZWMpYC4gWW91IGNhbiBpbnN0YWxsIHRoZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1wic2FmZS1qc29uLXN0cmluZ2lmeVwiIG1vZHVsZSB0byBoYXZlIEJ1bnlhbiBmYWxsYmFjayAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RvIHNhZmVyIHN0cmluZ2lmaWNhdGlvbi4gUmVjb3JkOlxcbicgK1xuICAgICAgICAgICAgICAgICAgICBfaW5kZW50KGZvcm1hdCgnJXNcXG4lcycsIHJlYywgZS5zdGFjaykpLFxuICAgICAgICAgICAgICAgIGRlZHVwS2V5KTtcbiAgICAgICAgICAgIHN0ciA9IGZvcm1hdCgnKEV4Y2VwdGlvbiBpbiBKU09OLnN0cmluZ2lmeShyZWMpOiAlai4gU2VlIHN0ZGVyciBmb3IgZGV0YWlscy4pXFxuJywgZS5tZXNzYWdlKTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZW1pdCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuXG4gICAgdmFyIGxldmVsID0gcmVjLmxldmVsO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnN0cmVhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnN0cmVhbXNbaV07XG4gICAgICAgIGlmIChzLmxldmVsIDw9IGxldmVsKSB7XG4gICAgICAgICAgICBzLnN0cmVhbS53cml0ZShzLnJhdyA/IHJlYyA6IHN0cik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xufTtcblxuXG4vKipcbiAqIEJ1aWxkIGEgbG9nIGVtaXR0ZXIgZnVuY3Rpb24gZm9yIGxldmVsIG1pbkxldmVsLiBJLmUuIHRoaXMgaXMgdGhlXG4gKiBjcmVhdG9yIG9mIGBsb2cuaW5mb2AsIGBsb2cuZXJyb3JgLCBldGMuXG4gKi9cbmZ1bmN0aW9uIG1rTG9nRW1pdHRlcihtaW5MZXZlbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2cgPSB0aGlzO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1rUmVjb3JkKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBleGNsdWRlRmllbGRzO1xuICAgICAgICAgICAgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIGBsb2cuPGxldmVsPihlcnIsIC4uLilgXG4gICAgICAgICAgICAgICAgZmllbGRzID0ge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhpcyBMb2dnZXIncyBlcnIgc2VyaWFsaXplciwgaWYgZGVmaW5lZC5cbiAgICAgICAgICAgICAgICAgICAgZXJyOiAobG9nLnNlcmlhbGl6ZXJzICYmIGxvZy5zZXJpYWxpemVycy5lcnIgPyBsb2cuc2VyaWFsaXplcnMuZXJyKGFyZ3NbMF0pIDogTG9nZ2VyLnN0ZFNlcmlhbGl6ZXJzLmVycihhcmdzWzBdKSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVGaWVsZHMgPSB7ZXJyOiB0cnVlfTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnQXJncyA9IFtmaWVsZHMuZXJyLm1lc3NhZ2VdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZ0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAoYXJnc1swXSkgIT09ICdvYmplY3QnICYmIGFyZ3NbMF0gIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gYGxvZy48bGV2ZWw+KG1zZywgLi4uKWBcbiAgICAgICAgICAgICAgICBmaWVsZHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIG1zZ0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7ICAvLyBgbG9nLjxsZXZlbD4oZmllbGRzLCBtc2csIC4uLilgXG4gICAgICAgICAgICAgICAgZmllbGRzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBtc2dBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEJ1aWxkIHVwIHRoZSByZWNvcmQgb2JqZWN0LlxuICAgICAgICAgICAgdmFyIHJlYyA9IG9iakNvcHkobG9nLmZpZWxkcyk7XG4gICAgICAgICAgICByZWMubGV2ZWwgPSBtaW5MZXZlbDtcbiAgICAgICAgICAgIHZhciByZWNGaWVsZHMgPSAoZmllbGRzID8gb2JqQ29weShmaWVsZHMpIDogbnVsbCk7XG4gICAgICAgICAgICBpZiAocmVjRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZy5zZXJpYWxpemVycykge1xuICAgICAgICAgICAgICAgICAgICBsb2cuX2FwcGx5U2VyaWFsaXplcnMocmVjRmllbGRzLCBleGNsdWRlRmllbGRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmVjRmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY1trXSA9IHJlY0ZpZWxkc1trXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYy5sZXZlbE5hbWUgPSBuYW1lRnJvbUxldmVsW21pbkxldmVsXTtcbiAgICAgICAgICAgIHJlYy5tc2cgPSBmb3JtYXQuYXBwbHkobG9nLCBtc2dBcmdzKTtcbiAgICAgICAgICAgIGlmICghcmVjLnRpbWUpIHtcbiAgICAgICAgICAgICAgICByZWMudGltZSA9IChuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBjYWxsIHNvdXJjZSBpbmZvXG4gICAgICAgICAgICBpZiAobG9nLnNyYyAmJiAhcmVjLnNyYykge1xuICAgICAgICAgICAgICAgIHJlYy5zcmMgPSBnZXRDYWxsZXIzSW5mbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjLnYgPSBMT0dfVkVSU0lPTjtcblxuICAgICAgICAgICAgcmV0dXJuIHJlYztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWVsZHMgPSBudWxsO1xuICAgICAgICB2YXIgbXNnQXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdmFyIHJlYyA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5fZW1pdCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFNob3cgdGhpcyBpbnZhbGlkIEJ1bnlhbiB1c2FnZSB3YXJuaW5nICpvbmNlKi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBTZWUgPGh0dHBzOi8vZ2l0aHViLmNvbS90cmVudG0vbm9kZS1idW55YW4vaXNzdWVzLzEwMD4gZm9yXG4gICAgICAgICAgICAgKiBhbiBleGFtcGxlIG9mIGhvdyB0aGlzIGNhbiBoYXBwZW4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBkZWR1cEtleSA9ICd1bmJvdW5kJztcbiAgICAgICAgICAgIGlmICghX2hhdmVXYXJuZWRbZGVkdXBLZXldKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhbGxlciA9IGdldENhbGxlcjNJbmZvKCk7XG4gICAgICAgICAgICAgICAgX3dhcm4oZm9ybWF0KCdidW55YW4gdXNhZ2UgZXJyb3I6ICVzOiVzOiBhdHRlbXB0IHRvIGxvZyB3aXRoIGFuIHVuYm91bmQgbG9nIG1ldGhvZDogYHRoaXNgIGlzOiAlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsZXIuZmlsZSwgY2FsbGVyLmxpbmUsIHRoaXMudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgICAgIGRlZHVwS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7ICAgLy8gYGxvZy48bGV2ZWw+KClgXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2xldmVsIDw9IG1pbkxldmVsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9sZXZlbCA+IG1pbkxldmVsKSB7XG4gICAgICAgICAgICAvKiBwYXNzIHRocm91Z2ggKi9cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYyA9IG1rUmVjb3JkKG1zZ0FyZ3MpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdChyZWMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG4vKipcbiAqIFRoZSBmdW5jdGlvbnMgYmVsb3cgbG9nIGEgcmVjb3JkIGF0IGEgc3BlY2lmaWMgbGV2ZWwuXG4gKlxuICogVXNhZ2VzOlxuICogICAgbG9nLjxsZXZlbD4oKSAgLT4gYm9vbGVhbiBpcy10cmFjZS1lbmFibGVkXG4gKiAgICBsb2cuPGxldmVsPig8RXJyb3I+IGVyciwgWzxzdHJpbmc+IG1zZywgLi4uXSlcbiAqICAgIGxvZy48bGV2ZWw+KDxzdHJpbmc+IG1zZywgLi4uKVxuICogICAgbG9nLjxsZXZlbD4oPG9iamVjdD4gZmllbGRzLCA8c3RyaW5nPiBtc2csIC4uLilcbiAqXG4gKiB3aGVyZSA8bGV2ZWw+IGlzIHRoZSBsb3dlcmNhc2UgdmVyc2lvbiBvZiB0aGUgbG9nIGxldmVsLiBFLmcuOlxuICpcbiAqICAgIGxvZy5pbmZvKClcbiAqXG4gKiBAcGFyYW1zIGZpZWxkcyB7T2JqZWN0fSBPcHRpb25hbCBzZXQgb2YgYWRkaXRpb25hbCBmaWVsZHMgdG8gbG9nLlxuICogQHBhcmFtcyBtc2cge1N0cmluZ30gTG9nIG1lc3NhZ2UuIFRoaXMgY2FuIGJlIGZvbGxvd2VkIGJ5IGFkZGl0aW9uYWxcbiAqICAgIGFyZ3VtZW50cyB0aGF0IGFyZSBoYW5kbGVkIGxpa2VcbiAqICAgIFt1dGlsLmZvcm1hdF0oaHR0cDovL25vZGVqcy5vcmcvZG9jcy9sYXRlc3QvYXBpL2FsbC5odG1sI3V0aWwuZm9ybWF0KS5cbiAqL1xuTG9nZ2VyLnByb3RvdHlwZS50cmFjZSA9IG1rTG9nRW1pdHRlcihUUkFDRSk7XG5Mb2dnZXIucHJvdG90eXBlLmRlYnVnID0gbWtMb2dFbWl0dGVyKERFQlVHKTtcbkxvZ2dlci5wcm90b3R5cGUuaW5mbyA9IG1rTG9nRW1pdHRlcihJTkZPKTtcbkxvZ2dlci5wcm90b3R5cGUud2FybiA9IG1rTG9nRW1pdHRlcihXQVJOKTtcbkxvZ2dlci5wcm90b3R5cGUuZXJyb3IgPSBta0xvZ0VtaXR0ZXIoRVJST1IpO1xuTG9nZ2VyLnByb3RvdHlwZS5mYXRhbCA9IG1rTG9nRW1pdHRlcihGQVRBTCk7XG5cblxuLy8tLS0tIFN0YW5kYXJkIHNlcmlhbGl6ZXJzXG4vLyBBIHNlcmlhbGl6ZXIgaXMgYSBmdW5jdGlvbiB0aGF0IHNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IG9iamVjdCB0byBhXG4vLyBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBsb2dnaW5nLiBUaGVyZSBpcyBhIHN0YW5kYXJkIHNldCBvZiBwcmVzdW1lZFxuLy8gaW50ZXJlc3Rpbmcgb2JqZWN0cyBpbiBub2RlLmpzLWxhbmQuXG5cbkxvZ2dlci5zdGRTZXJpYWxpemVycyA9IHt9O1xuXG4vKlxuICogVGhpcyBmdW5jdGlvbiBkdW1wcyBsb25nIHN0YWNrIHRyYWNlcyBmb3IgZXhjZXB0aW9ucyBoYXZpbmcgYSBjYXVzZSgpXG4gKiBtZXRob2QuIFRoZSBlcnJvciBjbGFzc2VzIGZyb21cbiAqIFt2ZXJyb3JdKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZlcGFjaGVjby9ub2RlLXZlcnJvcikgYW5kXG4gKiBbcmVzdGlmeSB2Mi4wXShodHRwczovL2dpdGh1Yi5jb20vbWNhdmFnZS9ub2RlLXJlc3RpZnkpIGFyZSBleGFtcGxlcy5cbiAqXG4gKiBCYXNlZCBvbiBgZHVtcEV4Y2VwdGlvbmAgaW5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZlcGFjaGVjby9ub2RlLWV4dHNwcmludGYvYmxvYi9tYXN0ZXIvbGliL2V4dHNwcmludGYuanNcbiAqL1xuZnVuY3Rpb24gZ2V0RnVsbEVycm9yU3RhY2soZXgpIHtcbiAgICB2YXIgcmV0ID0gZXguc3RhY2sgfHwgZXgudG9TdHJpbmcoKTtcbiAgICBpZiAoZXguY2F1c2UgJiYgdHlwZW9mIChleC5jYXVzZSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGNleCA9IGV4LmNhdXNlKCk7XG4gICAgICAgIGlmIChjZXgpIHtcbiAgICAgICAgICAgIHJldCArPSAnXFxuQ2F1c2VkIGJ5OiAnICsgZ2V0RnVsbEVycm9yU3RhY2soY2V4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHJldCk7XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBFcnJvciBvYmplY3Rcbi8vIChDb3JlIGVycm9yIHByb3BlcnRpZXMgYXJlIGVudW1lcmFibGUgaW4gbm9kZSAwLjQsIG5vdCBpbiAwLjYpLlxuTG9nZ2VyLnN0ZFNlcmlhbGl6ZXJzLmVyciA9IGZ1bmN0aW9uKGVycikge1xuICAgIGlmICghZXJyIHx8ICFlcnIuc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICB2YXIgb2JqID0ge1xuICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgICAgbmFtZTogZXJyLm5hbWUsXG4gICAgICAgIHN0YWNrOiBnZXRGdWxsRXJyb3JTdGFjayhlcnIpLFxuICAgICAgICBjb2RlOiBlcnIuY29kZSxcbiAgICAgICAgc2lnbmFsOiBlcnIuc2lnbmFsXG4gICAgfTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyBBIEpTT04gc3RyaW5naWZpZXIgdGhhdCBoYW5kbGVzIGN5Y2xlcyBzYWZlbHkuXG4vLyBVc2FnZTogSlNPTi5zdHJpbmdpZnkob2JqLCBzYWZlQ3ljbGVzKCkpXG5mdW5jdGlvbiBzYWZlQ3ljbGVzKCkge1xuICAgIHZhciBzZWVuID0gW107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICBpZiAoIXZhbCB8fCB0eXBlb2YgKHZhbCkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWVuLmluZGV4T2YodmFsKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5wdXNoKHZhbCk7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcbn1cblxuLy8tLS0tIEV4cG9ydHNcblxubW9kdWxlLmV4cG9ydHMgPSBMb2dnZXI7XG5cbm1vZHVsZS5leHBvcnRzLlRSQUNFID0gVFJBQ0U7XG5tb2R1bGUuZXhwb3J0cy5ERUJVRyA9IERFQlVHO1xubW9kdWxlLmV4cG9ydHMuSU5GTyA9IElORk87XG5tb2R1bGUuZXhwb3J0cy5XQVJOID0gV0FSTjtcbm1vZHVsZS5leHBvcnRzLkVSUk9SID0gRVJST1I7XG5tb2R1bGUuZXhwb3J0cy5GQVRBTCA9IEZBVEFMO1xubW9kdWxlLmV4cG9ydHMucmVzb2x2ZUxldmVsID0gcmVzb2x2ZUxldmVsO1xubW9kdWxlLmV4cG9ydHMubGV2ZWxGcm9tTmFtZSA9IGxldmVsRnJvbU5hbWU7XG5tb2R1bGUuZXhwb3J0cy5uYW1lRnJvbUxldmVsID0gbmFtZUZyb21MZXZlbDtcblxubW9kdWxlLmV4cG9ydHMuVkVSU0lPTiA9IFZFUlNJT047XG5tb2R1bGUuZXhwb3J0cy5MT0dfVkVSU0lPTiA9IExPR19WRVJTSU9OO1xuXG5tb2R1bGUuZXhwb3J0cy5jcmVhdGVMb2dnZXIgPSBmdW5jdGlvbiBjcmVhdGVMb2dnZXIob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTG9nZ2VyKG9wdGlvbnMpO1xufTtcblxuLy8gVXNlZnVsIGZvciBjdXN0b20gYHR5cGUgPT0gJ3JhdydgIHN0cmVhbXMgdGhhdCBtYXkgZG8gSlNPTiBzdHJpbmdpZmljYXRpb25cbi8vIG9mIGxvZyByZWNvcmRzIHRoZW1zZWx2ZXMuIFVzYWdlOlxuLy8gICAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KHJlYywgYnVueWFuLnNhZmVDeWNsZXMoKSk7XG5tb2R1bGUuZXhwb3J0cy5zYWZlQ3ljbGVzID0gc2FmZUN5Y2xlcztcblxuLy9zdHJlYW1zXG5tb2R1bGUuZXhwb3J0cy5Db25zb2xlRm9ybWF0dGVkU3RyZWFtID0gQ29uc29sZUZvcm1hdHRlZFN0cmVhbTtcbm1vZHVsZS5leHBvcnRzLkNvbnNvbGVSYXdTdHJlYW0gPSBDb25zb2xlUmF3U3RyZWFtO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Jyb3dzZXItYnVueWFuL2xpYi9idW55YW4uanNcbiAqKiBtb2R1bGUgaWQgPSAzMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBuYW1lRnJvbUxldmVsIH0gZnJvbSAnYnJvd3Nlci1idW55YW4nXG5cbmV4cG9ydCBjbGFzcyBSYXdTdHJlYW0ge1xuICB3cml0ZSAocmVjKSB7XG4gICAgY29uc29sZS5sb2coJ1slc10gJXM6ICVzJyxcbiAgICAgIC8vICAgICAgICAgICAgICAgIHJlYy50aW1lLnRvSVNPU3RyaW5nKCksXG4gICAgICByZWMubmFtZSxcbiAgICAgIG5hbWVGcm9tTGV2ZWxbcmVjLmxldmVsXSxcbiAgICAgIHJlYy5tc2dcbiAgICApXG4gIH1cbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvbG9nL2J1bnlhbi13cml0ZXIuanNcbiAqKi8iLCJleHBvcnQgY29uc3QgY29tbW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENPTk5FQ1RfU1VDQ0VTUzogJ0Nvbm5lY3QuU3VjY2VzcycsXG4gIENPTk5FQ1RfRkFJTFVSRTogJ0Nvbm5lY3QuRmFpbHVyZScsXG4gIFBVQkxJU0hfU1RBUlQ6ICdQdWJsaXNoLlN0YXJ0JyxcbiAgUFVCTElTSF9GQUlMOiAnUHVibGlzaC5GYWlsJyxcbiAgUFVCTElTSF9JTlZBTElEX05BTUU6ICdQdWJsaXNoLkludmFsaWROYW1lJyxcbiAgVU5QVUJMSVNIX1NVQ0NFU1M6ICdVbnB1Ymxpc2guU3VjY2VzcycsXG4gIFBVQkxJU0hfTUVUQURBVEE6ICdQdWJsaXNoLk1ldGFkYXRhJyxcbiAgQ09OTkVDVElPTl9DTE9TRUQ6ICdQdWJsaXNoZXIuQ29ubmVjdGlvbi5DbG9zZWQnXG59KVxuXG5leHBvcnQgY29uc3QgZmFpbG92ZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgUFVCTElTSEVSX1JFSkVDVDogJ1B1Ymxpc2hlci5SZWplY3QnLFxuICBQVUJMSVNIRVJfQUNDRVBUOiAnUHVibGlzaGVyLkFjY2VwdCdcbn0pXG5cbmV4cG9ydCBjb25zdCBydGMgPSBPYmplY3QuZnJlZXplKHtcbiAgTUVESUFfU1RSRUFNX0FWQUlMQUJMRTogJ1dlYlJUQy5NZWRpYVN0cmVhbS5BdmFpbGFibGUnLFxuICBQRUVSX0NPTk5FQ1RJT05fQVZBSUxBQkxFOiAnV2ViUlRDLlBlZXJDb25uZWN0aW9uLkF2YWlsYWJsZScsXG4gIE9GRkVSX1NUQVJUOiAnV2ViUlRDLk9mZmVyLlN0YXJ0JyxcbiAgT0ZGRVJfRU5EOiAnV2ViUlRDLk9mZmVyLkVuZCcsXG4gIElDRV9UUklDS0xFX0NPTVBMRVRFOiAnV2ViUlRDLkljZVRyaWNrbGUuQ29tcGxldGUnXG59KVxuXG5leHBvcnQgY29uc3QgcnRtcCA9IE9iamVjdC5mcmVlemUoe1xuICBFTUJFRF9TVUNDRVNTOiAnRmxhc2hQbGF5ZXIuRW1iZWQuU3VjY2VzcycsXG4gIEVNQkVEX0ZBSUxVUkU6ICdGbGFzaFBsYXllci5FbWJlZC5GYWlsdXJlJ1xufSlcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2V2ZW50L3B1Ymxpc2hlci1ldmVudC5qc1xuICoqLyIsImV4cG9ydCBjb25zdCBjb21tb24gPSBPYmplY3QuZnJlZXplKHtcbiAgQ09OTkVDVF9TVUNDRVNTOiAnQ29ubmVjdC5TdWNjZXNzJyxcbiAgQ09OTkVDVF9GQUlMVVJFOiAnQ29ubmVjdC5GYWlsdXJlJyxcbiAgU1VCU0NSSUJFX1NUQVJUOiAnU3Vic2NyaWJlLlN0YXJ0JyxcbiAgU1VCU0NSSUJFX1NUT1A6ICdTdWJzY3JpYmUuU3RvcCcsXG4gIFNVQlNDUklCRV9GQUlMOiAnU3Vic2NyaWJlLkZhaWwnLFxuICBTVUJTQ1JJQkVfSU5WQUxJRF9OQU1FOiAnU3Vic2NyaWJlLkludmFsaWROYW1lJyxcbiAgU1VCU0NSSUJFX01FVEFEQVRBOiAnU3Vic2NyaWJlLk1ldGFkYXRhJyxcbiAgU1VCU0NSSUJFX1NFTkRfSU5WT0tFOiAnU3Vic2NyaWJlci5TZW5kLkludm9rZScsXG4gIFBMQVlfVU5QVUJMSVNIOiAnU3Vic2NyaWJlci5QbGF5LlVucHVibGlzaCcsXG4gIENPTk5FQ1RJT05fQ0xPU0VEOiAnU3Vic2NyaWJlci5Db25uZWN0aW9uLkNsb3NlZCdcbn0pXG5cbmV4cG9ydCBjb25zdCBmYWlsb3ZlciA9IE9iamVjdC5mcmVlemUoe1xuICBTVUJTQ1JJQkVSX1JFSkVDVDogJ1N1YnNjcmliZXIuUmVqZWN0JyxcbiAgU1VCU0NSSUJFUl9BQ0NFUFQ6ICdTdWJzY3JpYmVyLkFjY2VwdCdcbn0pXG5cbmV4cG9ydCBjb25zdCBydGMgPSBPYmplY3QuZnJlZXplKHtcbiAgUEVFUl9DT05ORUNUSU9OX0FWQUlMQUJMRTogJ1dlYlJUQy5QZWVyQ29ubmVjdGlvbi5BdmFpbGFibGUnLFxuICBPRkZFUl9TVEFSVDogJ1dlYlJUQy5PZmZlci5TdGFydCcsXG4gIE9GRkVSX0VORDogJ1dlYlJUQy5PZmZlci5FbmQnLFxuICBBTlNXRVJfU1RBUlQ6ICdXZWJSVEMuQW5zd2VyLlN0YXJ0JyxcbiAgQU5TV0VSX0VORDogJ1dlYlJUQy5BbnN3ZXIuRW5kJyxcbiAgQ0FORElEQVRFX1NUQVJUOiAnV2ViUlRDLkNhbmRpZGF0ZS5TdGFydCcsXG4gIENBTkRJREFURV9FTkQ6ICdXZWJSVEMuQ2FuZGlkYXRlLkVuZCcsXG4gIElDRV9UUklDS0xFX0NPTVBMRVRFOiAnV2ViUlRDLkljZVRyaWNrbGUuQ29tcGxldGUnXG59KVxuXG5leHBvcnQgY29uc3QgcnRtcCA9IE9iamVjdC5mcmVlemUoe1xuICBFTUJFRF9TVUNDRVNTOiAnRmxhc2hQbGF5ZXIuRW1iZWQuU3VjY2VzcycsXG4gIEVNQkVEX0ZBSUxVUkU6ICdGbGFzaFBsYXllci5FbWJlZC5GYWlsdXJlJ1xufSlcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvZXZlbnQvc3Vic2NyaWJlci1ldmVudC5qc1xuICoqLyIsImV4cG9ydCBjb25zdCBjb21tb24gPSBPYmplY3QuZnJlZXplKHtcbiAgQ09OTkVDVF9TVUNDRVNTOiAnQ29ubmVjdC5TdWNjZXNzJyxcbiAgQ09OTkVDVF9GQUlMVVJFOiAnQ29ubmVjdC5GYWlsdXJlJyxcbiAgUFJPUEVSVFlfVVBEQVRFOiAnU2hhcmVkT2JqZWN0LlByb3BlcnR5VXBkYXRlJyxcbiAgTUVUSE9EX1VQREFURTogJ1NoYXJlZE9iamVjdC5NZXRob2RVcGRhdGUnXG59KVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9ldmVudC9zaGFyZWRvYmplY3QtZXZlbnQuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0IGNvbnN0IFBsYXliYWNrVHlwZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgUlRNUDogJ3J0bXAnLFxuICBSVEM6ICdydGMnLFxuICBITFM6ICdobHMnXG59KVxuXG5leHBvcnQgY29uc3QgUGxheWJhY2tBdWRpb0VuY29kZXIgPSBPYmplY3QuZnJlZXplKHtcbiAgT1BVUzogJ09wdXMnLFxuICBQQ01VOiAnUENNVScsXG4gIFBDTUE6ICdQQ01BJyxcbiAgU1BFRVg6ICdTcGVleCcsXG4gIE5PTkU6ICdOT05FJ1xufSlcblxuZXhwb3J0IGNvbnN0IFBsYXliYWNrVmlkZW9FbmNvZGVyID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFZQODogJ1ZQOCcsXG4gIEgyNjQ6ICdIMjY0JyxcbiAgTk9ORTogJ05PTkUnXG59KVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvZW51bS9wbGF5YmFjay5qc1xuICoqLyIsIi8qKlxuICogTWFpbiBlbnRyeSBmb3IgZmFpbG92ZXIgc3VwcG9ydCBvZiBhbGwgc3Vic2NyaWJlciBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCBSVENTdWJzY3JpYmVyIGZyb20gJy4vcmVkNXByby1ydGMnXG5pbXBvcnQgSExTU3Vic2NyaWJlciBmcm9tICcuL3JlZDVwcm8taGxzJ1xuaW1wb3J0IFJUTVBTdWJzY3JpYmVyUHJveHkgZnJvbSAnLi9yZWQ1cHJvLXJ0bXAnXG5pbXBvcnQgUjVMaXZlU3Vic2NyaWJlciBmcm9tICcuL3JlZDVwcm8tcnRtcC1saXZlJ1xuaW1wb3J0IFZpZGVvSlNTdWJzY3JpYmVyIGZyb20gJy4vcmVkNXByby1ydG1wLXZpZGVvanMnXG5cbmltcG9ydCBJbXBsRmFjdG9yeU9yZGVyIGZyb20gJy4uL3V0aWwvaW1wbC1mYWN0b3J5LW9yZGVyJ1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgUGxheWJhY2tUeXBlcyB9IGZyb20gJy4uL2VudW0vcGxheWJhY2snXG5pbXBvcnQgeyBkZWJ1Zywgd2FybiB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1N1YnNjcmliZXInXG5jb25zdCBwbGF5YmFja0ZhY3RvcnkgPSBuZXcgSW1wbEZhY3RvcnlPcmRlcigpXG5cbmNvbnN0IHBsYXliYWNrSW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gIGxldCBtYXAgPSBuZXcgTWFwKClcbiAgbWFwLnNldChQbGF5YmFja1R5cGVzLlJUQywgUlRDU3Vic2NyaWJlcilcbiAgbWFwLnNldChQbGF5YmFja1R5cGVzLlJUTVAsIFJUTVBTdWJzY3JpYmVyUHJveHkpXG4gIG1hcC5zZXQoUGxheWJhY2tUeXBlcy5ITFMsIEhMU1N1YnNjcmliZXIpXG4gIHJldHVybiBtYXBcbn0oKSlcblxuY2xhc3MgUmVkNVByb1N1YnNjcmliZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgLy8gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAgdGhpcy5fb3B0aW9ucyA9IHVuZGVmaW5lZFxuICAgIC8vIFRoZSBwbGF5YmFjayB2aWV3XG4gICAgdGhpcy5fdmlldyA9IHVuZGVmaW5lZFxuICAgIC8vIFNlbGVjdGVkIGZhaWxvdmVyIHN1YnNjcmliZXIuXG4gICAgdGhpcy5fY3VycmVudFN1YnNjcmliZXIgPSB1bmRlZmluZWRcbiAgICAvLyBEZWZhdWx0IG9yZGVyLlxuICAgIHRoaXMuX29yZGVyID0gW1xuICAgICAgUGxheWJhY2tUeXBlcy5SVEMsXG4gICAgICBQbGF5YmFja1R5cGVzLlJUTVAsXG4gICAgICBQbGF5YmFja1R5cGVzLkhMU1xuICAgIF1cbiAgICB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudCA9IHRoaXMuYnViYmxlU3Vic2NyaWJlckV2ZW50LmJpbmQodGhpcylcbiAgfVxuXG4gIGdldFBsYXliYWNrT3JkZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmRlclxuICB9XG5cbiAgc2V0UGxheWJhY2tPcmRlciAob3JkZXIpIHtcbiAgICAvLyBBbGxvdyBmb3Igc3RyaW5nIHZhbHVlIHRvIGRlZmluZSBzaW5nbGUgaXRlbSBpbiBvcmRlci5cbiAgICBvcmRlciA9IHR5cGVvZiBvcmRlciA9PT0gJ3N0cmluZycgPyBbb3JkZXJdIDogb3JkZXJcblxuICAgIC8vIEZpbHRlciBvdXQgdmFsdWVzIG5vdCBhdmFpbGFibGUgaW4gZW51bWVyYXRpb24gb2YgcGxheWJhY2sgdHlwZXMuXG4gICAgY29uc3QgdCA9IG9yZGVyLmZpbHRlcihlbnRyeSA9PiB7XG4gICAgICBsZXQga2V5XG4gICAgICBmb3IgKGtleSBpbiBQbGF5YmFja1R5cGVzKSB7XG4gICAgICAgIGlmIChQbGF5YmFja1R5cGVzW2tleV0udG9Mb3dlckNhc2UoKSA9PT0gZW50cnkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0pLm1hcChlbnRyeSA9PiBlbnRyeS50b0xvd2VyQ2FzZSgpKVxuXG4gICAgLy8gRGVmaW5lIG5ldyBvcmRlci5cbiAgICB0aGlzLl9vcmRlciA9IFsuLi5uZXcgU2V0KHQpXVxuICAgIGRlYnVnKE5BTUUsIGBbb3JkZXJ1cGRhdGVdOiAke3RoaXMuX29yZGVyfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHNldFZpZXcgKHBsYXliYWNrVmlldykge1xuICAgIHRoaXMuX3ZpZXcgPSBwbGF5YmFja1ZpZXdcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0UGxheWJhY2tGcm9tT3JkZXIgKG9yZGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHBsYXliYWNrRmFjdG9yeS5jcmVhdGUob3JkZXIsIHBsYXliYWNrSW1wbCwgb3B0aW9ucywgJ2luaXQnKVxuICB9XG5cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBkZWJ1ZyhOQU1FLCAnW3BsYXldJylcbiAgICB0aGlzLmdldFBsYXliYWNrRnJvbU9yZGVyKHRoaXMuX29yZGVyLCB0aGlzLl9vcHRpb25zKVxuICAgICAgLnRoZW4oc3Vic2NyaWJlciA9PiB7XG4gICAgICAgIGRlYnVnKE5BTUUsIGBbcGxheXN1Y2Nlc3NdOiBzdWJzY3JpYmVyIGZvdW5kICR7c3Vic2NyaWJlci5nZXRUeXBlKCl9YClcbiAgICAgICAgc3Vic2NyaWJlci5vbignKicsIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50KVxuICAgICAgICB0aGlzLl9jdXJyZW50U3Vic2NyaWJlciA9IHN1YnNjcmliZXJcbiAgICAgICAgaWYgKHRoaXMuX3ZpZXcpIHtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50U3Vic2NyaWJlci5zZXRWaWV3KHRoaXMuX3ZpZXcpXG4gICAgICAgIH1cbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0aGlzLl9jdXJyZW50U3Vic2NyaWJlcilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgd2FybihOQU1FLCBgW3BsYXllcnJvcl06IENvdWxkIG5vdCBpbXBsZW1lbnQgYSBzdWJzY3JpYmVyOiAke2Vycn1gKVxuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKVxuICAgICAgfSlcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyKSB7XG4gICAgICB3YXJuKE5BTUUsICdbc3RvcF06IENvdWxkIG5vdCBpbnZva2Ugc3RvcCgpIG9uIHVuZGVmaW5lZCBzdWJzY3JpYmVyLicpXG4gICAgICBkZWZlcnJlZC5yZWplY3QoJ0EgY3VycmVudCBzdWJzY3JpYmVyIGlzIG5vdCBhdmFpbGFibGUgdG8gaXNzdWUgYSA6c3RvcCgpIGNvbW1hbmQgdG8uJylcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoTkFNRSwgJ1tzdG9wXTogSW52b2tpbmcgc3RvcCBvbiBoZWxkIHN1YnNjcmliZXIuJylcbiAgICAgIHRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyLnN0b3AoKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgZGVidWcoTkFNRSwgJ1tzdG9wc3VjY2Vzc10nKVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyLm9mZignKicsIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50KVxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyID0gdW5kZWZpbmVkXG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGRlYnVnKE5BTUUsIGBbc3RvcGVycm9yXTogJHtlcnJ9YClcbiAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdWJzY3JpYmVyLm9mZignKicsIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jdXJyZW50U3Vic2NyaWJlciA9IHVuZGVmaW5lZFxuICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpXG4gICAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBidWJibGVTdWJzY3JpYmVyRXZlbnQgKHN1YnNjcmliZXJFdmVudCkge1xuICAgIHRoaXMudHJpZ2dlci5jYWxsKHRoaXMsIHN1YnNjcmliZXJFdmVudClcbiAgfVxuXG4gIGdldCBwbGF5YmFja1R5cGVzICgpIHtcbiAgICByZXR1cm4gUGxheWJhY2tUeXBlc1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRTdWJzY3JpYmVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFN1YnNjcmliZXJcbiAgfVxuXG59XG5cbmV4cG9ydCB7IFJlZDVQcm9TdWJzY3JpYmVyLCBSVENTdWJzY3JpYmVyLCBITFNTdWJzY3JpYmVyLCBWaWRlb0pTU3Vic2NyaWJlciwgUjVMaXZlU3Vic2NyaWJlciB9XG4vKipcbiAqIFVzaW5nIHRoZSBSVE1QU3Vic2NyaWJlciB3aWxsIGRldGVybWluZSB0aGUgUlRNUC1iYXNlZCBTdWJzY3JpYmVyXG4gKiB0byBiZSB1c2VkIGJhc2VkIG9uIGBvcHRpb25zLnVzZVZpZGVvSlNgIHByb3BlcnR5LlxuICpcbiAqIElmIGBvcHRpb25zLnVzZVZpZGVvSlNgIGlzIGxlZnQgdW5kZWZpbmVkLCBpdCB3aWxsIGRlZmF1bHQgdG8gYHRydWVgXG4gKiBJZiBgb3B0aW9ucy51c2VWaWRlb0pzYCBpcyBkZWZpbmVkLCBpdCBpcyByZXF1aXJlZCB0byBiZSBhIGJvb2xlYW4gdmFsdWVcbiAqXG4gKiB0cnVlOiBWaWRlb0pTU3Vic2NyaWJlciAtIHV0aWxpemVzIHRoZSB2aWRlb2pzIGxpYiBhbmQgY3VzdG9tIFNXRi5cbiAqIGZhbHNlOiBSNUxpdmVTdWJzY3JpYmVyIC0gdXRpbGl6ZWQgdGhlIGRlZmF1bHQgXCJsaXZlXCIgU1dGIHNoaXBwZWQgd2l0aCBSZWQ1IFBybyBleGFtcGxlcy5cbiovXG5leHBvcnQgY29uc3QgUlRNUFN1YnNjcmliZXIgPSBSVE1QU3Vic2NyaWJlclByb3h5XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9zdWJzY3JpYmVyL2luZGV4LmpzXG4gKiovIiwiY29uc3QgV0lMRENBUkQgPSAnKidcbmNvbnN0IFdJTERDQVJEX0tFWSA9ICdSRUQ1UFJPJ1xuXG5jbGFzcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fVxuICAgIHRoaXMuX2NhbGxiYWNrc1tXSUxEQ0FSRF9LRVldID0gW11cbiAgfVxuXG4gIF9ub3RpZnkgKGNhbGxiYWNrcywgZXZlbnQpIHtcbiAgICAgIGxldCBpLCBsZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoXG4gICAgICBmb3IoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0oZXZlbnQpXG4gICAgICB9XG4gIH1cblxuICBvbiAodHlwZSwgZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gV0lMRENBUkQpIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrc1tXSUxEQ0FSRF9LRVldLnB1c2goZm4pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzW3R5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrc1t0eXBlXSA9IFtdXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NhbGxiYWNrc1t0eXBlXS5pbmRleE9mKGZuKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrc1t0eXBlXS5wdXNoKGZuKVxuICAgIH1cbiAgfVxuXG4gIG9mZiAodHlwZSwgZm4pIHtcbiAgICBsZXQgbWFwID0gdGhpcy5fY2FsbGJhY2tzW3R5cGVdXG4gICAgaWYgKHR5cGUgPT09IFdJTERDQVJEKSB7XG4gICAgICBtYXAgPSB0aGlzLl9jYWxsYmFja3NbV0lMRENBUkRfS0VZXVxuICAgIH1cbiAgICBpZiAobWFwKSB7XG4gICAgICBjb25zdCBpbmRleCA9IG1hcC5pbmRleE9mKGZuKVxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBtYXAuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRyaWdnZXIgKGV2ZW50KSB7XG4gICAgY29uc3QgdHlwZSA9IGV2ZW50LnR5cGVcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzW3R5cGVdKSB7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5fY2FsbGJhY2tzW3R5cGVdLCBldmVudClcbiAgICB9XG4gICAgdGhpcy5fbm90aWZ5KHRoaXMuX2NhbGxiYWNrc1tXSUxEQ0FSRF9LRVldLCBldmVudClcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50RW1pdHRlclxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9jb3JlL2V2ZW50LWVtaXR0ZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnQgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCBTdWJzY3JpcHRpb25Tb2NrZXRIZWxwZXIgZnJvbSAnLi4vaGVscGVyL3NvY2tldC1oZWxwZXItc3ViJ1xuaW1wb3J0IFN1YnNjcmlwdGlvblBlZXJIZWxwZXIgZnJvbSAnLi4vaGVscGVyL3dlYnJ0Yy1oZWxwZXItc3ViJ1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0ICogYXMgd2VicnRjIGZyb20gJy4uL2FkYXB0ZXIvd2VicnRjJ1xuaW1wb3J0ICogYXMgd2Vic29ja2V0IGZyb20gJy4uL2FkYXB0ZXIvd2Vic29ja2V0J1xuaW1wb3J0IHsgU3Vic2NyaWJlckV2ZW50VHlwZXMsIFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQnXG5cbmltcG9ydCB7IGRlYnVnLCB3YXJuLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1JUQ1N1YnNjcmliZXInXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgc3RyZWFtVHlwZTogJ3dlYnJ0Yydcbn1cbmNvbnN0IGdlbmVyYXRlU3Vic2NyaXB0aW9uSWQgPSAoKSA9PiB7XG4gIGNvbnN0IGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHgxMDAwMCkudG9TdHJpbmcoMTYpXG4gIHJldHVybiBgc3Vic2NyaWJlci0ke2lkfWBcbn1cbmNvbnN0IGVuZHBvaW50RnJvbU9wdGlvbnMgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBwcm90b2NvbCA9IG9wdGlvbnMud3Nwcm90b2NvbCB8fCBvcHRpb25zLnByb3RvY29sXG4gIGNvbnN0IHBvcnQgPSBvcHRpb25zLndzcG9ydCB8fCBvcHRpb25zLnBvcnRcbiAgY29uc3QgYXBwRW5kcG9pbnQgPSBvcHRpb25zLmNvbnRleHQgPyBbb3B0aW9ucy5hcHAsIG9wdGlvbnMuY29udGV4dF0uam9pbignLycpIDogb3B0aW9ucy5hcHBcbiAgbGV0IGVuZHBvaW50ID0gYCR7cHJvdG9jb2x9Oi8vJHtvcHRpb25zLmhvc3R9OiR7cG9ydH0vJHthcHBFbmRwb2ludH0/aWQ9JHtvcHRpb25zLnN1YnNjcmlwdGlvbklkfWBcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbm5lY3Rpb25QYXJhbXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGV0IHBhcmFtcyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMuY29ubmVjdGlvblBhcmFtcykuZm9yRWFjaCggKGtleSwgaW5kZXgpID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcGFyYW1zLnB1c2goW2tleSwgb3B0aW9ucy5jb25uZWN0aW9uUGFyYW1zW2tleV1dLmpvaW4oJz0nKSlcbiAgICB9KVxuICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgZW5kcG9pbnQgKz0gJyYnICsgKHBhcmFtcy5qb2luKCcmJykpXG4gICAgfVxuICB9XG4gIHJldHVybiBlbmRwb2ludFxufVxuXG5jbGFzcyBSVENTdWJzY3JpYmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX3ZpZXcgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9vcHRpb25zID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcGVlckhlbHBlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NvY2tldEhlbHBlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX29yaWVudGF0aW9uID0gMFxuICB9XG5cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgaWYgKCF3ZWJydGMuaXNTdXBwb3J0ZWQoKSB8fCAhd2Vic29ja2V0LmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdCgnQ2Fubm90IGNyZWF0ZSBXZWJSVEMgcGxheWJhY2sgaW5zdGFuY2UuIFlvdXIgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBXZWJSVEMgYW5kL29yIFdlYlNvY2tldHMuJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKVxuICAgICAgdGhpcy5fb3B0aW9ucy5zdWJzY3JpcHRpb25JZCA9IHRoaXMuX29wdGlvbnMuc3Vic2NyaXB0aW9uSWQgfHwgZ2VuZXJhdGVTdWJzY3JpcHRpb25JZCgpXG4gICAgICB0aGlzLl9wZWVySGVscGVyID0gbmV3IFN1YnNjcmlwdGlvblBlZXJIZWxwZXIodGhpcylcbiAgICAgIHRoaXMuX3NvY2tldEhlbHBlciA9IG5ldyBTdWJzY3JpcHRpb25Tb2NrZXRIZWxwZXIodGhpcylcbiAgICAgIGRlZmVycmVkLnJlc29sdmUodGhpcylcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIHNldFZpZXcgKHZpZXcpIHtcbiAgICB0aGlzLl92aWV3ID0gdmlld1xuICAgIC8vICBUT0RPOiBOb3JtYWxpemUgcmV0dXJucyB0byBlaXRoZXIgYWxsIGJlIGNoYWluYWJsZSBvciBub3QgYmUgY2hhaW5hYmxlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJlcXVlc3RBdmFpbGFiaWxpdHkgKHN0cmVhbU5hbWUsIHR5cGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3JlcXVlc3RhdmFpbGFiaWxpdHldJylcbiAgICAvLyBtZXNzYWdlIG9uIHNvY2tldCByZXR1cm5zIC0+IG9uU3RyZWFtKFVuKUF2YWlsYWJsZVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIGlzQXZhaWxhYmxlOiBzdHJlYW1OYW1lLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH0pXG4gICAgLy8gIFRPRE86IE5vcm1hbGl6ZSByZXR1cm5zIHRvIGVpdGhlciBhbGwgYmUgY2hhaW5hYmxlIG9yIG5vdCBiZSBjaGFpbmFibGVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmVxdWVzdE9mZmVyIChzdHJlYW1OYW1lLCBzdWJzY3JpcHRpb25JZCwgdkVuY29kaW5nID0gdW5kZWZpbmVkLCBhRW5jb2RpbmcgPSB1bmRlZmluZWQpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3JlcXVlc3RvZmZlcl0nKVxuICAgIGxldCBvZmZlciA9IHtcbiAgICAgIHJlcXVlc3RPZmZlcjogc3RyZWFtTmFtZSxcbiAgICAgIHJlcXVlc3RJZDogc3Vic2NyaXB0aW9uSWRcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2RW5jb2RpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvZmZlci52aWRlb0VuY29kaW5nID0gdkVuY29kaW5nO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFFbmNvZGluZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9mZmVyLmF1ZGlvRW5jb2RpbmcgPSBhRW5jb2Rpbmc7XG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLk9GRkVSX1NUQVJULCB0aGlzKSlcbiAgICAvLyBtZXNzYWdlIG9uIHNvY2tldCByZXR1cm5zIC0+IG9uU0RQT2ZmZXJcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdChvZmZlcilcbiAgfVxuXG4gIHJlcXVlc3RBbnN3ZXIgKHNkcCkge1xuICAgIGRlYnVnKE5BTUUsICdbcmVxdWVzdGFuc3dlcl0nKVxuICAgIC8vIGludm9rZXMgLT4gc2VuZEFuc3dlclxuICAgIHRoaXMuX3BlZXJIZWxwZXIuY3JlYXRlQW5zd2VyKHNkcClcbiAgICAgICAgLnRoZW4oc2Vzc2lvbkRlc2NyaXB0aW9uID0+IHtcbiAgICAgICAgICBkZWJ1ZyhOQU1FLCAnW29uYW5zd2VyY3JlYXRlZF0nKVxuICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmJhbmR3aWR0aCkge1xuICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uLnNkcCA9IHdlYnJ0Yy51cGRhdGVCYW5kd2lkdGgodGhpcy5fb3B0aW9ucy5iYW5kd2lkdGgsIHNlc3Npb25EZXNjcmlwdGlvbi5zZHApXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlYnVnKE5BTUUsICdbPiBzZW5kYW5zd2VyXScpXG4gICAgICAgICAgdGhpcy5zZW5kQW5zd2VyKHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSwgdGhpcy5fb3B0aW9ucy5zdWJzY3JpcHRpb25JZCwgc2Vzc2lvbkRlc2NyaXB0aW9uKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIHRoaXMub25TRFBFcnJvcihlcnJvcilcbiAgICAgICAgfSlcbiAgfVxuXG4gIHNlbmRBbnN3ZXIgKHN0cmVhbU5hbWUsIHN1YnNjcmlwdGlvbklkLCBzZHApIHtcbiAgICBkZWJ1ZyhOQU1FLCBgW3NlbmRhbnN3ZXJdOiBzdHJlYW1uYW1lKCR7c3RyZWFtTmFtZX0pLCBzdWJzY3JpcHRpb25pZCgke3N1YnNjcmlwdGlvbklkfSlgKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLkFOU1dFUl9TVEFSVCwgdGhpcywgc2RwKSlcbiAgICAvLyBtZXNzYWdlIG9uIHNvY2tldCByZXNwb25zZSAtPiBvbkFkZEljZUNhbmRpZGF0ZVxuICAgIC8vIG1lc3NhZ2Ugb24gcGVlciByZXNwb25zZSAtPiBvbmFkZHN0cmVhbVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIGhhbmRsZUFuc3dlcjogc3RyZWFtTmFtZSxcbiAgICAgIHJlcXVlc3RJZDogc3Vic2NyaXB0aW9uSWQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNkcDogc2RwXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHNlbmRDYW5kaWRhdGUgKGNhbmRpZGF0ZSkge1xuICAgIGRlYnVnKE5BTUUsICdbc2VuZGNhbmRpZGF0ZV0nKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLkNBTkRJREFURV9TVEFSVCwgdGhpcywgY2FuZGlkYXRlKSlcbiAgICAvLyBtZXNzYWdlIG9uIHBlZXIgcmVzcG9uc2UgLT4gb25pY2VjYW5kaWRhdGVcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBoYW5kbGVDYW5kaWRhdGU6IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSxcbiAgICAgIHJlcXVlc3RJZDogdGhpcy5fb3B0aW9ucy5zdWJzY3JpcHRpb25JZCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY2FuZGlkYXRlOiBjYW5kaWRhdGVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc2VuZFN1YnNjcmliZSAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzZW5kc3Vic2NyaWJlXScpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgc3Vic2NyaWJlOiB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUsXG4gICAgICByZXF1ZXN0SWQ6IHRoaXMuX29wdGlvbnMuc3Vic2NyaXB0aW9uSWRcbiAgICB9KVxuICB9XG5cbiAgb25TdHJlYW1BdmFpbGFibGUgKHJlY2VpcHQpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29uc3RyZWFtYXZhaWxhYmxlXTogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICAgIHRoaXMuX2Nvbm5lY3QodGhpcy5fb3B0aW9ucy5pY2VTZXJ2ZXJzKVxuICB9XG5cbiAgb25TdHJlYW1VbmF2YWlsYWJsZSAocmVjZWlwdCkge1xuICAgIGRlYnVnKE5BTUUsIGBTdHJlYW0gJHt0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWV9IGRvZXMgbm90IGV4aXN0LmApXG4gICAgZGVidWcoTkFNRSwgJ1tvbnN0cmVhbXVuYXZhaWxhYmxlXTogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9JTlZBTElEX05BTUUsIHRoaXMpKVxuICAgIHRoaXMuX2Rpc2Nvbm5lY3QoKVxuICB9XG5cbiAgb25TRFBTdWNjZXNzIChyZWNlaXB0KSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbnNkcHN1Y2Nlc3NdOiAnICsgSlNPTi5zdHJpbmdpZnkocmVjZWlwdCwgbnVsbCwgMikpXG4gIH1cblxuICBvblNEUE9mZmVyIChyZWNlaXB0KSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbnNkcG9mZmVyXTogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICAgIGNvbnN0IHNkcCA9IG5ldyB3ZWJydGMuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHJlY2VpcHQuc2RwKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLk9GRkVSX0VORCwgdGhpcykpXG4gICAgdGhpcy5yZXF1ZXN0QW5zd2VyKHNkcClcbiAgfVxuXG4gIG9uU0RQRXJyb3IgKHJlY2VpcHQpIHtcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfRkFJTCwgdGhpcywgcmVjZWlwdCkpXG4gICAgZXJyb3IoTkFNRSwgJ1tvbnNkcGVycm9yXScpXG4gICAgZXJyb3IocmVjZWlwdClcbiAgfVxuXG4gIG9uQW5zd2VyTWVkaWFTdHJlYW0gKHN0cmVhbSA9IHVuZGVmaW5lZCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRDU3Vic2NyaWJlckV2ZW50VHlwZXMuQU5TV0VSX0VORCwgdGhpcykpXG4gIH1cblxuICBvbkljZUNhbmRpZGF0ZSAoY2FuZGlkYXRlKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbmljZWNhbmRpZGF0ZV0nKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzLkNBTkRJREFURV9FTkQsIHRoaXMpKVxuICAgIHRoaXMuc2VuZENhbmRpZGF0ZShjYW5kaWRhdGUpXG4gIH1cblxuICBvbkljZUNhbmRpZGF0ZVRyaWNrbGVFbmQgKHN0cmVhbSkge1xuICAgIGRlYnVnKE5BTUUsICdbb25pY2V0cmlja2xlZW5kXScpXG4gICAgdGhpcy5fdmlldy5hdHRhY2hTdHJlYW0oc3RyZWFtLCB0aGlzLl9vcHRpb25zLmF1dG9wbGF5IHx8IHRydWUpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX1NUQVJULCB0aGlzKSlcbiAgfVxuXG4gIG9uQWRkSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW29uYWRkaWNlY2FuZGlkYXRlXScpXG4gICAgdGhpcy5fcGVlckhlbHBlci5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKVxuICB9XG5cbiAgb25Tb2NrZXRJY2VDYW5kaWRhdGVFbmQgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbb25zb2NrZXRpY2VjYW5kaWRhdGVlbmRdJylcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChSVENTdWJzY3JpYmVyRXZlbnRUeXBlcy5JQ0VfVFJJQ0tMRV9DT01QTEVURSwgdGhpcykpXG4gICAgdGhpcy5zZW5kU3Vic2NyaWJlKClcbiAgfVxuXG4gIG9uU29ja2V0TWVzc2FnZUVycm9yIChtZXNzYWdlLCBkZXRhaWwgPSB1bmRlZmluZWQpIHtcbiAgICBlcnJvcihOQU1FLCBgRXJyb3IgaW4gc3RyZWFtIHN1YnNjcmlwdGlvbjogJHttZXNzYWdlfS5cXG5bT3B0aW9uYWwgZGV0YWlsXTogJHtkZXRhaWx9YClcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfRkFJTCwgdGhpcywgbWVzc2FnZSkpXG4gIH1cblxuICBvblVucHVibGlzaCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbnVucHVibGlzaF0nKVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlBMQVlfVU5QVUJMSVNILCB0aGlzKSlcbiAgfVxuXG4gIG9uQ29ubmVjdGlvbkNsb3NlZCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tvbmNvbm5lY3Rpb25jbG9zZWRdJylcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5DT05ORUNUSU9OX0NMT1NFRCwgdGhpcykpXG4gIH1cblxuICBvblNlbmRSZWNlaXZlZCAobWV0aG9kTmFtZSwgZGF0YSkge1xuICAgIGlmIChtZXRob2ROYW1lID09PSAnb25NZXRhRGF0YScpIHtcbiAgICAgIHRoaXMub25NZXRhRGF0YShkYXRhKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGVudmlyb25tZW50Lmludm9rZShtZXRob2ROYW1lLCBkYXRhKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX1NFTkRfSU5WT0tFLCB0aGlzLCB7XG4gICAgICAgIG1ldGhvZE5hbWU6IG1ldGhvZE5hbWUsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH0pKVxuICAgIH1cbiAgfVxuXG4gIG9uTWV0YURhdGEgKG1ldGFkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBtZXRhZGF0YS5vcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgJiYgbWV0YWRhdGEub3JpZW50YXRpb24gIT09IHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICBlbnZpcm9ubWVudC5hcHBseU9yaWVudGF0aW9uKHRoaXMuX3ZpZXcudmlldywgbWV0YWRhdGEub3JpZW50YXRpb24pXG4gICAgICB0aGlzLl9vcmllbnRhdGlvbiA9IG1ldGFkYXRhLm9yaWVudGF0aW9uXG4gICAgfVxuICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9NRVRBREFUQSwgdGhpcywgbWV0YWRhdGEpKVxuICB9XG5cbiAgX2Rpc2Nvbm5lY3QgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbZGlzY29ubmVjdF0nKVxuICAgIGlmICh0aGlzLl9zb2NrZXRIZWxwZXIpIHtcbiAgICAgIHRoaXMuX3NvY2tldEhlbHBlci50ZWFyRG93bigpXG4gICAgfVxuICAgIGlmICh0aGlzLl9wZWVySGVscGVyKSB7XG4gICAgICB0aGlzLl9wZWVySGVscGVyLnRlYXJEb3duKClcbiAgICB9XG4gIH1cblxuICBfY29ubmVjdCAoaWNlU2VydmVycykge1xuICAgIGRlYnVnKE5BTUUsICdbY29ubmVjdF0nKVxuICAgIHRoaXMuX29wdGlvbnMuaWNlU2VydmVycyA9IGljZVNlcnZlcnNcbiAgICBjb25zdCBwID0gdGhpcy5fcGVlckhlbHBlci5zZXRVcCh0aGlzLl9vcHRpb25zLmljZVNlcnZlcnMpXG4gICAgcC50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMucmVxdWVzdE9mZmVyKHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSwgdGhpcy5fb3B0aW9ucy5zdWJzY3JpcHRpb25JZCwgdGhpcy5fb3B0aW9ucy52aWRlb0VuY29kaW5nLCB0aGlzLl9vcHRpb25zLmF1ZGlvRW5jb2RpbmcpXG4gICAgfSlcbiAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgd2FybihOQU1FLCAnQ291bGQgbm90IGVzdGFibGlzaCBSVENQZWVyQ29ubmVjdGlvbi4nKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzKSlcbiAgICB9KVxuICAgIC8vICBUT0RPOiBOb3JtYWxpemUgcmV0dXJucyB0byBlaXRoZXIgYWxsIGJlIGNoYWluYWJsZSBvciBub3QgYmUgY2hhaW5hYmxlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHBsYXkgKHN0cmVhbU5hbWUgPSBudWxsLCBwcm9taXNlID0gbnVsbCkge1xuICAgIGRlYnVnKE5BTUUsICdbcGxheV0nKVxuICAgIHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSA9IHN0cmVhbU5hbWUgfHwgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgY29uc3QgcCA9IHByb21pc2UgfHwgbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgY29uc3Qgc29ja2V0UHJvbWlzZSA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGNvbnN0IHNvY2tldHVybCA9IGVuZHBvaW50RnJvbU9wdGlvbnModGhpcy5fb3B0aW9ucylcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIuc2V0VXAoc29ja2V0dXJsLCBzb2NrZXRQcm9taXNlKVxuICAgIHNvY2tldFByb21pc2UucHJvbWlzZVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBwLnJlc29sdmUodGhpcylcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9TVUNDRVNTLCB0aGlzKSlcbiAgICAgICAgdGhpcy5yZXF1ZXN0QXZhaWxhYmlsaXR5KHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSwgdGhpcy5fb3B0aW9ucy5zdHJlYW1UeXBlKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgcC5yZWplY3QoZXJyb3IpXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSwgdGhpcywgZXJyb3IpKVxuICAgICAgfSlcbiAgICByZXR1cm4gcC5oYXNPd25Qcm9wZXJ0eSgncHJvbWlzZScpID8gcC5wcm9taXNlIDogcFxuICB9XG5cbiAgc3RvcCAoKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzdG9wXScpXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0aGlzLl9kaXNjb25uZWN0KClcbiAgICB0aGlzLl92aWV3LnN0b3AoKVxuICAgIGRlZmVycmVkLnJlc29sdmUodGhpcylcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5VTlNVQlNDUklCRV9TVUNDRVNTLCB0aGlzKSlcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgZ2V0Q29ubmVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldEhlbHBlclxuICB9XG5cbiAgZ2V0UGVlckNvbm5lY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wZWVySGVscGVyID8gdGhpcy5fcGVlckhlbHBlci5jb25uZWN0aW9uIDogdW5kZWZpbmVkXG4gIH1cblxuICBnZXRPcHRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9uc1xuICB9XG5cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuICdSVEMnXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSVENTdWJzY3JpYmVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8tcnRjLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IE5vRWxlbWVudEZvdW5kRXJyb3IgfSBmcm9tICcuLi9leGNlcHRpb24vZXJyb3JzJ1xuaW1wb3J0IHsgb25PcmllbnRhdGlvbk1ldGFkYXRhIH0gZnJvbSAnLi9tZXRhZGF0YS11dGlsJ1xuXG5sZXQgY2xvc2VIYW5kbGVycyA9IFtdXG5mdW5jdGlvbiBvbndpbmRvd2Nsb3NlIChlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgLy8gIGNsb3NlSGFuZGxlcnMuZm9yRWFjaChoID0+IGgoKSlcbiAgbGV0IGksIGxlbmd0aCA9IGNsb3NlSGFuZGxlcnMubGVuZ3RoXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNsb3NlSGFuZGxlcnNbaV0oKVxuICB9XG4gIC8vIFJldHVybmluZyBhIHN0cmluZyB2YWx1ZSBmb3JjZXMgYSBsZWF2aW5nIGNvbmZpcm1hdGlvbiBwb3B1cCBvbiB0aGUgYnJvd3Nlci5cbiAgLy8gIGUucmV0dXJuVmFsdWUgPSAnZ29vZGJ5ZSdcbiAgLy8gIHJldHVybiAnZ29vZGJ5ZSdcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvYmxvYi9tYXN0ZXIvc3JjL2pzL3RlY2gvZmxhc2guanMjTDQ3NlxuY29uc3QgZmxhc2hWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xuICBsZXQgdmVyc2lvbiA9ICcwLDAsMCdcbiAgLy8gSUVcbiAgdHJ5IHtcbiAgICB2ZXJzaW9uID0gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KCdTaG9ja3dhdmVGbGFzaC5TaG9ja3dhdmVGbGFzaCcpLkdldFZhcmlhYmxlKCckdmVyc2lvbicpLnJlcGxhY2UoL1xcRCsvZywgJywnKS5tYXRjaCgvXiw/KC4rKSw/JC8pWzFdXG5cbiAgLy8gb3RoZXIgYnJvd3NlcnNcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAobmF2aWdhdG9yLm1pbWVUeXBlc1snYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnXS5lbmFibGVkUGx1Z2luKSB7XG4gICAgICAgIHZlcnNpb24gPSAobmF2aWdhdG9yLnBsdWdpbnNbJ1Nob2Nrd2F2ZSBGbGFzaCAyLjAnXSB8fCBuYXZpZ2F0b3IucGx1Z2luc1snU2hvY2t3YXZlIEZsYXNoJ10pLmRlc2NyaXB0aW9uLnJlcGxhY2UoL1xcRCsvZywgJywnKS5tYXRjaCgvXiw/KC4rKSw/JC8pWzFdXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBuYWRhXG4gICAgfVxuICB9XG4gIHJldHVybiB2ZXJzaW9uLnNwbGl0KCcsJylcbn1cblxuY29uc3QgaXNNb3ogPSAhIW5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWFcbm5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWFcblxuY29uc3QgZGVmYXVsdFVzZXJNZWRpYUF1ZGlvID0gaXNNb3ogPyB0cnVlIDoge1xuICBtYW5kaXRvcnk6IHtcbiAgICBnb29nQXV0b0dhaW5Db250cm9sOiB0cnVlLFxuICAgIGdvb2dIaWdocGFzc0ZpbHRlcjogdHJ1ZSxcbiAgICBnb29nRWNob0NhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgICBnb29nTm9pc2VTdXBwcmVzc2lvbjogdHJ1ZVxuICB9LFxuICBvcHRpb25hbDogW1xuICAgIHtcbiAgICAgIGJhbmR3aWR0aDogNTBcbiAgICB9LFxuICAgIHtcbiAgICAgIGVjaG9DYW5jZWxsYXRpb246IHRydWVcbiAgICB9XG4gIF1cbn1cbmNvbnN0IGRlZmF1bHRVc2VyTWVkaWFWaWRlbyA9IGlzTW96ID8gdHJ1ZSA6IHtcbiAgbWFuZGF0b3J5OiB7XG4gICAgbWluV2lkdGg6IDMyMCxcbiAgICBtaW5IZWlnaHQ6IDI0MCxcbiAgICBtaW5GcmFtZVJhdGU6IDQsXG4gICAgbWF4V2lkdGg6IDY0MCxcbiAgICBtYXhIZWlnaHQ6IDQ4MCxcbiAgICBtYXhGcmFtZVJhdGU6IDI0XG4gIH0sXG4gIG9wdGlvbmFsOiBbXG4gICAge1xuICAgICAgYmFuZHdpZHRoOiAyNTZcbiAgICB9XG4gIF1cbn1cblxuY29uc3Qgb3JpZ2luID0gW1xuICAnd2Via2l0VHJhbnNmb3JtT3JpZ2luJyxcbiAgJ21velRyYW5zZm9ybU9yaWdpbicsXG4gICdtc1RyYW5zZm9ybU9yaWdpbicsXG4gICdvVHJhbnNmb3JtT3JpZ2luJyxcbiAgJ3RyYW5zZm9ybU9yaWdpbidcbl1cbmNvbnN0IHN0eWxlcyA9IFtcbiAgJ3dlYmtpdFRyYW5zZm9ybScsXG4gICdtb3pUcmFuc2Zvcm0nLFxuICAnbXNUcmFuc2Zvcm0nLFxuICAnb1RyYW5zZm9ybScsXG4gICd0cmFuc2Zvcm0nXG5dXG5jb25zdCB0cmFuc2l0aW9uID0gW1xuICAnd2Via2l0VHJhbnNpdGlvbicsXG4gICdtb3pUcmFuc2l0aW9uJyxcbiAgJ21zVHJhbnNpdGlvbicsXG4gICdvVHJhbnNpdGlvbicsXG4gICd0cmFuc2l0aW9uJ1xuXVxuY29uc3Qgcm90YXRpb25UcmFuc2xhdGlvbnMgPSB7XG4gICcwJzoge1xuICAgIG9yaWdpbjogJ2NlbnRlciBjZW50ZXInLFxuICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgwZGVnKSdcbiAgfSxcbiAgJzkwJzoge1xuICAgIG9yaWdpbjogJ2xlZnQgdG9wJyxcbiAgICB0cmFuc2Zvcm06ICdyb3RhdGUoOTBkZWcpIHRyYW5zbGF0ZVkoLTEwMCUpJ1xuICB9LFxuICAnMTgwJzoge1xuICAgIG9yaWdpbjogJ2NlbnRlciBjZW50ZXInLFxuICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgxODBkZWcpJ1xuICB9LFxuICAnMjcwJzoge1xuICAgIG9yaWdpbjogJ3RvcCBsZWZ0JyxcbiAgICB0cmFuc2Zvcm06ICdyb3RhdGUoMjcwZGVnKSB0cmFuc2xhdGVYKC0xMDAlKSB0cmFuc2xhdGVZKDAlKSdcbiAgfSxcbiAgJy05MCc6IHtcbiAgICBvcmlnaW46ICdsZWZ0IHRvcCcsXG4gICAgdHJhbnNmb3JtOiAncm90YXRlKC05MGRlZykgdHJhbnNsYXRlWCgtMTAwJSknXG4gIH0sXG4gICctMTgwJzoge1xuICAgIG9yaWdpbjogJ2NlbnRlciBjZW50ZXInLFxuICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgtMTgwZGVnKSdcbiAgfSxcbiAgJy0yNzAnOiB7XG4gICAgb3JpZ2luOiAndG9wIGxlZnQnLFxuICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgtMjcwZGVnKSB0cmFuc2xhdGVZKC0xMDAlKSdcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHN1cHBvcnRzV2ViU29ja2V0OiAoKSA9PiB7XG4gICAgcmV0dXJuICEhd2luZG93LldlYlNvY2tldFxuICB9LFxuXG4gIHN1cHBvcnRzRmxhc2hWZXJzaW9uOiAodmVyc2lvbiwgZGVsaW1pdGVyID0gJy4nKSA9PiB7XG4gICAgcmV0dXJuIGZsYXNoVmVyc2lvbigpWzBdID49IHZlcnNpb24uc3BsaXQoZGVsaW1pdGVyKVswXVxuICB9LFxuXG4gIHJlc29sdmVFbGVtZW50OiAoaWQpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZClcbiAgICAgIGlmICghZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vRWxlbWVudEZvdW5kRXJyb3IoYEVsZW1lbnQgd2l0aCBpZCgke2lkfSkgY291bGQgbm90IGJlIGZvdW5kLmApXG4gICAgICB9XG4gICAgICByZXR1cm4gZWxcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgTm9FbGVtZW50Rm91bmRFcnJvcihgRXJyb3IgaW4gYWNjZXNzaW5nIGVsZW1lbnQgd2l0aCBpZCgke2lkfSkuICR7ZS5tZXNzYWdlfWApXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZVdlYlNvY2tldDogKHVybCkgPT4ge1xuICAgIHJldHVybiBuZXcgd2luZG93LldlYlNvY2tldCh1cmwpXG4gIH0sXG5cbiAgc2V0VmlkZW9Tb3VyY2U6ICh2aWRlb0VsZW1lbnQsIG1lZGlhU3RyZWFtLCBhdXRvcGxheSA9IGZhbHNlKSA9PiB7XG4gICAgaWYgKGlzTW96KSB7XG4gICAgICB2aWRlb0VsZW1lbnRbJ21velNyY09iamVjdCddID0gbWVkaWFTdHJlYW1cbiAgICB9IGVsc2Uge1xuICAgICAgdmlkZW9FbGVtZW50LnNyYyA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG1lZGlhU3RyZWFtKVxuICAgIH1cbiAgICBpZiAoYXV0b3BsYXkpIHtcbiAgICAgIHZpZGVvRWxlbWVudC5wbGF5KClcbiAgICB9XG4gIH0sXG5cbiAgaW5qZWN0U2NyaXB0OiAodXJsKSA9PiB7XG4gICAgbGV0IGRmZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGxldCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICBzY3JpcHQub25sb2FkID0gKCkgPT4ge1xuICAgICAgZGZkLnJlc29sdmUoKVxuICAgIH1cbiAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNjcmlwdC5yZWFkeVN0YXRlID09PSAnbG9hZGVkJyB8fCBzY3JpcHQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICBkZmQucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgfVxuICAgIHNjcmlwdC5zcmMgPSB1cmxcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHNjcmlwdClcbiAgICByZXR1cm4gZGZkLnByb21pc2VcbiAgfSxcblxuICBzZXRHbG9iYWw6IChwcm9wLCB2YWx1ZSkgPT4ge1xuICAgIHdpbmRvd1twcm9wXSA9IHZhbHVlXG4gIH0sXG5cbiAgZ2V0U3dmT2JqZWN0OiAoKSA9PiB7XG4gICAgcmV0dXJuIHdpbmRvdy5zd2ZvYmplY3RcbiAgfSxcblxuICBnZXRFbWJlZE9iamVjdDogKGlkKSA9PiB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKVxuICB9LFxuXG4gIGdldEVsZW1lbnRJZDogKGVsKSA9PiB7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgfSxcblxuICBnZXRWaWRlb0pzOiAoKSA9PiB7XG4gICAgcmV0dXJuIHdpbmRvdy52aWRlb2pzXG4gIH0sXG5cbiAgZ2V0VXNlck1lZGlhOiAoYXVkaW8gPSBudWxsLCB2aWRlbyA9IG51bGwpID0+IHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEoe1xuICAgICAgYXVkaW86IGF1ZGlvIHx8IGRlZmF1bHRVc2VyTWVkaWFBdWRpbyxcbiAgICAgIHZpZGVvOiB2aWRlbyB8fCBkZWZhdWx0VXNlck1lZGlhVmlkZW9cbiAgICB9LCBkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QpXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfSxcblxuICBnZXREZWZhdWx0UHVibGlzaENvbnN0cmFpbnRzOiAoYXVkaW8gPSBmYWxzZSwgdmlkZW8gPSBmYWxzZSkgPT4ge1xuICAgIGlmIChpc01veikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2ZmZXJUb1JlY2VpdmVWaWRlbzogdmlkZW8sXG4gICAgICAgIG9mZmVyVG9SZWNlaXZlQXVkaW86IGF1ZGlvXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtYW5kYXRvcnk6IHtcbiAgICAgICAgb2ZmZXJUb1JlY2VpdmVWaWRlbzogdmlkZW8sXG4gICAgICAgIG9mZmVyVG9SZWNlaXZlQXVkaW86IGF1ZGlvXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldElzTW96OiAoKSA9PiB7XG4gICAgcmV0dXJuIGlzTW96XG4gIH0sXG5cbiAgYWRkQ2xvc2VIYW5kbGVyOiAoaGFuZGxlciwgaW5zZXJ0VmFsdWUgPSAtMSkgPT4ge1xuICAgIGNsb3NlSGFuZGxlcnMuc2xpY2UoaW5zZXJ0VmFsdWUgPT09IC0xID8gY2xvc2VIYW5kbGVycy5sZW5ndGggOiBpbnNlcnRWYWx1ZSwgMCwgaGFuZGxlcilcbiAgICBpZiAod2luZG93Lm9uYmVmb3JldW5sb2FkICE9PSBvbndpbmRvd2Nsb3NlKSB7XG4gICAgICB3aW5kb3cub25iZWZvcmV1bmxvYWQgPSBvbndpbmRvd2Nsb3NlXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgb253aW5kb3djbG9zZSlcbiAgICB9XG4gIH0sXG5cbiAgcmVtb3ZlQ2xvc2VIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgIGxldCBpID0gY2xvc2VIYW5kbGVycy5sZW5ndGhcbiAgICB3aGlsZSggLS1pID4gLTEpIHtcbiAgICAgIGlmIChjbG9zZUhhbmRsZXJzW2ldID09PSBoYW5kbGVyKSB7XG4gICAgICAgIGNsb3NlSGFuZGxlcnMuc2xpY2UoaSwgMSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgaW52b2tlOiAobWV0aG9kTmFtZSwgZGF0YSkgPT4ge1xuICAgIGlmICh3aW5kb3cuaGFzT3duUHJvcGVydHkobWV0aG9kTmFtZSkpIHtcbiAgICAgIHdpbmRvd1ttZXRob2ROYW1lXS5jYWxsKHdpbmRvdywgZGF0YSlcbiAgICB9XG4gIH0sXG5cbiAgb25PcmllbnRhdGlvbk1ldGFkYXRhOiBvbk9yaWVudGF0aW9uTWV0YWRhdGEsXG5cbiAgYXBwbHlPcmllbnRhdGlvbjogKGVsZW1lbnQsIHZhbHVlKSA9PiB7XG4gICAgbGV0IGksIGxlbmd0aCA9IHN0eWxlcy5sZW5ndGhcbiAgICB2YWx1ZSA9IHZhbHVlICUgMzYwXG4gICAgY29uc3QgdHJhbnNsYXRpb25zID0gcm90YXRpb25UcmFuc2xhdGlvbnNbdmFsdWUudG9TdHJpbmcoKV1cbiAgICBmb3IoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgZWxlbWVudC5zdHlsZVtvcmlnaW5baV1dID0gdHJhbnNsYXRpb25zLm9yaWdpblxuICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZXNbaV1dID0gdHJhbnNsYXRpb25zLnRyYW5zZm9ybVxuICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uW2ldXSA9ICd0cmFuc2Zvcm0gMC4wcyBsaW5lYXInXG4gICAgfVxuICB9XG5cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2Vudi9icm93c2VyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIF9EZWZlcnJlZFByb21pc2Uge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5yZXNvbHZlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5yZWplY3QgPSB1bmRlZmluZWRcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlXG4gICAgICB0aGlzLnJlamVjdCA9IHJlamVjdFxuICAgIH0pXG4gIH1cbn1cblxuY29uc3QgX0Z1dHVyZSA9IHtcbiAgY3JlYXRlSWZOb3RFeGlzdDogKGRlZmVycmVkSWZFeGlzdCkgPT4ge1xuICAgIGxldCBmID0gZGVmZXJyZWRJZkV4aXN0XG4gICAgaWYgKCFmKSB7XG4gICAgICBmID0gbmV3IF9EZWZlcnJlZFByb21pc2UoKVxuICAgIH1cbiAgICByZXR1cm4gZlxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBEZWZlcnJlZFByb21pc2UgPSBfRGVmZXJyZWRQcm9taXNlXG5leHBvcnQgY29uc3QgRnV0dXJlID0gX0Z1dHVyZVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvdXRpbC9wcm9taXNlLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydCBjbGFzcyBOb0VsZW1lbnRGb3VuZEVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm5hbWUgPSAnTm9FbGVtZW50Rm91bmQnXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9leGNlcHRpb24vZXJyb3JzLmpzXG4gKiovIiwiY29uc3QganNvbkF0dHIgPSAvWydcIl0oLio/KVsnXCJdOi9naVxuY29uc3QganNvblZhbCA9IC86WydcIl0oLio/KVsnXCJdL2dpXG5cbmZ1bmN0aW9uIHJlYWRVVEYgKGRhdGEsc3RhcnQsbGVuKSB7XG4gIGxldCByZXN1bHQgPSAnJywgb2Zmc2V0ID0gc3RhcnQsIGVuZCA9IHN0YXJ0ICsgbGVuXG4gIGRvIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW29mZnNldCsrXSlcbiAgfVxuICB3aGlsZShvZmZzZXQgPCBlbmQpXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gcGFyc2VKU09ORm9yT3JpZW50YXRpb24gKHRleHQpIHtcbiAgdHJ5IHtcbiAgICBsZXQgdmFsdWUgPSBKU09OLnBhcnNlKHRleHQpXG4gICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCdvcmllbnRhdGlvbicpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcmllbnRhdGlvbjogcGFyc2VJbnQodmFsdWUub3JpZW50YXRpb24pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICBjYXRjaCAoZSkge1xuICAgIGxldCBtYXRjaCA9IGpzb25BdHRyLmV4ZWModGV4dClcbiAgICBsZXQgbWF0Y2gyXG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIG1hdGNoMiA9IGpzb25WYWwuZXhlYyh0ZXh0KVxuICAgICAgaWYgKG1hdGNoWzFdID09PSAnb3JpZW50YXRpb24nICYmIG1hdGNoMiAmJiBtYXRjaDIubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9yaWVudGF0aW9uOiBwYXJzZUludChtYXRjaDJbMV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBvbk9yaWVudGF0aW9uTWV0YWRhdGEgPSAocGxheWVyLCBjYWxsYmFjaykgPT4ge1xuXG4gIGNvbnN0IHRleHRUcmFja3MgPSB0eXBlb2YgcGxheWVyLnRleHRUcmFja3MgPT09ICdmdW5jdGlvbicgPyBwbGF5ZXIudGV4dFRyYWNrcygpIDogcGxheWVyLnRleHRUcmFja3NcblxuICBpZiAodGV4dFRyYWNrcykge1xuXG4gICAgcGxheWVyLmFkZFRleHRUcmFjaygnbWV0YWRhdGEnKVxuXG4gICAgdGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIGFkZFRyYWNrRXZlbnQgPT4ge1xuXG4gICAgICBsZXQgdHJhY2sgPSBhZGRUcmFja0V2ZW50LnRyYWNrXG4gICAgICB0cmFjay5tb2RlID0gJ2hpZGRlbidcbiAgICAgIC8qKlxuICAgICAgdmFyIGN1ZSA9IG5ldyBWVFRDdWUoMS4wLCAwLCAnVGVzdGluZycpXG4gICAgICBjdWUuaWQgPSAxXG4gICAgICBjdWUucGF1c2VPbkV4aXQgPSBmYWxzZVxuICAgICAgdHJhY2suYWRkQ3VlKGN1ZSlcbiAgICAgICovXG5cbiAgICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIGN1ZUNoYW5nZUV2ZW50ID0+IHtcbiAgICAgICAgbGV0IGN1ZXNcbiAgICAgICAgbGV0IGlcbiAgICAgICAgLy8gTW9zdGx5IENocm9tZS5cbiAgICAgICAgaWYgKGN1ZUNoYW5nZUV2ZW50ICYmIGN1ZUNoYW5nZUV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICBjdWVzID0gY3VlQ2hhbmdlRXZlbnQuY3VycmVudFRhcmdldC5jdWVzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5kZWZpbmVkID09PSB0aGlzKSB7XG4gICAgICAgICAgY3VlcyA9IHRyYWNrLmN1ZXNcbiAgICAgICAgICBjdWVzID0gY3VlcyAmJiBjdWVzLmxlbmd0aCA+IDAgPyBjdWVzIDogdHJhY2suYWN0aXZlQ3Vlc1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuZGVmaW5lZCAhPT0gdGhpcykge1xuICAgICAgICAgIC8vIE1vc3RseSBGaXJlZm94ICYgU2FmYXJpLlxuICAgICAgICAgIGN1ZXMgPSBjdWVzICYmIGN1ZXMubGVuZ3RoID4gMCA/IGN1ZXMgOiB0aGlzLmFjdGl2ZUN1ZXNcbiAgICAgICAgfVxuICAgICAgICAvLyBNb3N0bHkgZmFpbHVyZS5cbiAgICAgICAgY3VlcyA9IGN1ZXMgfHwgW11cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgZGF0YSA9IGN1ZXNbaV1cbiAgICAgICAgICBpZiAoZGF0YS52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSB0eXBlb2YgZGF0YS52YWx1ZS5kYXRhID09PSAnc3RyaW5nJyA/IGRhdGEudmFsdWUuZGF0YSA6IHJlYWRVVEYoIGRhdGEudmFsdWUuZGF0YSAsIDAgLCBkYXRhLnNpemUpXG4gICAgICAgICAgICBsZXQgb3JpZW50YXRpb24gPSBwYXJzZUpTT05Gb3JPcmllbnRhdGlvbih0ZXh0KVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sob3JpZW50YXRpb24pXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgfSlcblxuICB9XG59XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2Vudi9tZXRhZGF0YS11dGlsLmpzXG4gKiovIiwiY2xhc3MgRXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBkYXRhID0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fdHlwZSA9IHR5cGVcbiAgICB0aGlzLl9kYXRhID0gZGF0YVxuICB9XG5cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlXG4gIH1cblxuICBnZXQgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFcbiAgfVxuXG59XG5cbmNsYXNzIFB1Ymxpc2hlckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBwdWJsaXNoZXIsIGRhdGEpIHtcbiAgICBzdXBlcih0eXBlLCBkYXRhKVxuICAgIHRoaXMuX3B1Ymxpc2hlciA9IHB1Ymxpc2hlclxuICB9XG5cbiAgZ2V0IHB1Ymxpc2hlciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1Ymxpc2hlclxuICB9XG5cbn1cblxuY2xhc3MgU3Vic2NyaWJlckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBzdWJzY3JpYmVyLCBkYXRhKSB7XG4gICAgc3VwZXIodHlwZSwgZGF0YSlcbiAgICB0aGlzLl9zdWJzY3JpYmVyID0gc3Vic2NyaWJlclxuICB9XG5cbiAgZ2V0IHN1YnNjcmliZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmVyXG4gIH1cblxufVxuXG5jbGFzcyBTaGFyZWRPYmplY3RFdmVudCBleHRlbmRzIEV2ZW50IHtcblxuICBjb25zdHJ1Y3RvciAodHlwZSwgc2hhcmVkT2JqZWN0TmFtZSwgZGF0YSkge1xuICAgIHN1cGVyKHR5cGUsIGRhdGEpXG4gICAgdGhpcy5fbmFtZSA9IHNoYXJlZE9iamVjdE5hbWVcbiAgfVxuXG4gIGdldCBuYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZVxuICB9XG5cbn1cblxuZXhwb3J0IHsgUHVibGlzaGVyRXZlbnQgYXMgUHVibGlzaGVyRXZlbnQgfVxuZXhwb3J0IHsgU3Vic2NyaWJlckV2ZW50IGFzIFN1YnNjcmliZXJFdmVudCB9XG5leHBvcnQgeyBTaGFyZWRPYmplY3RFdmVudCBhcyBTaGFyZWRPYmplY3RFdmVudCB9XG5leHBvcnQgeyBjb21tb24gYXMgUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vcHVibGlzaGVyLWV2ZW50J1xuZXhwb3J0IHsgcnRjIGFzIFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMgfSBmcm9tICcuL3B1Ymxpc2hlci1ldmVudCdcbmV4cG9ydCB7IHJ0bXAgYXMgUlRNUFB1Ymxpc2hlckV2ZW50VHlwZXMgfSBmcm9tICcuL3B1Ymxpc2hlci1ldmVudCdcbmV4cG9ydCB7IGZhaWxvdmVyIGFzIEZhaWxvdmVyUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4vcHVibGlzaGVyLWV2ZW50J1xuZXhwb3J0IHsgY29tbW9uIGFzIFN1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9zdWJzY3JpYmVyLWV2ZW50J1xuZXhwb3J0IHsgcnRjIGFzIFJUQ1N1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9zdWJzY3JpYmVyLWV2ZW50J1xuZXhwb3J0IHsgcnRtcCBhcyBSVE1QU3Vic2NyaWJlckV2ZW50VHlwZXMgfSBmcm9tICcuL3N1YnNjcmliZXItZXZlbnQnXG5leHBvcnQgeyBmYWlsb3ZlciBhcyBGYWlsb3ZlclN1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi9zdWJzY3JpYmVyLWV2ZW50J1xuZXhwb3J0IHsgY29tbW9uIGFzIFNoYXJlZE9iamVjdEV2ZW50VHlwZXMgfSBmcm9tICcuL3NoYXJlZG9iamVjdC1ldmVudCdcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvZXZlbnQvaW5kZXguanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IFNvY2tldEhlbHBlciBmcm9tICcuL3NvY2tldC1oZWxwZXInXG5pbXBvcnQgeyB3YXJuLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1N1YnNjcmlwdGlvblNvY2tldCdcblxuY2xhc3MgU3Vic2NyaXB0aW9uU29ja2V0SGVscGVyIGV4dGVuZHMgU29ja2V0SGVscGVyIHtcblxuICBjb25zdHJ1Y3RvciAocmVzcG9uZGVyKSB7XG4gICAgc3VwZXIocmVzcG9uZGVyLCBOQU1FKVxuICB9XG5cbiAgcmVzcG9uZCAobWVzc2FnZSkge1xuICAgIC8vICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpXG4gICAgaWYgKG1lc3NhZ2UuZGF0YSkge1xuICAgICAgbGV0IGpzb24gPSB0aGlzLmdldEpzb25Gcm9tU29ja2V0TWVzc2FnZShtZXNzYWdlKVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFzdXBlci5yZXNwb25kKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgaWYgKGpzb24uZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoanNvbi5kYXRhLnNkcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmIChqc29uLmRhdGEuc2RwLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TRFBPZmZlcihqc29uLmRhdGEpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uLmRhdGEuY2FuZGlkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uQWRkSWNlQ2FuZGlkYXRlKGpzb24uZGF0YS5jYW5kaWRhdGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNvbi5kYXRhLnR5cGUgPT09ICdzdGF0dXMnKSB7XG4gICAgICAgICAgICAgIGlmIChqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uSUNFLlRyaWNsZUNvbXBsZXRlZCcgfHxcbiAgICAgICAgICAgICAgICAganNvbi5kYXRhLmNvZGUgPT09ICdOZXRDb25uZWN0aW9uLklDRS5Ucmlja2xlQ29tcGxldGVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldEljZUNhbmRpZGF0ZUVuZCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoanNvbi5kYXRhLmNvZGUgPT09ICdOZXRTdHJlYW0uUGxheS5VbnB1Ymxpc2hOb3RpZnknKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uVW5wdWJsaXNoKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uQ29ubmVjdC5DbG9zZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uQ29ubmVjdGlvbkNsb3NlZCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uLmRhdGEuaGFzT3duUHJvcGVydHkoJ3N0YXR1cycpKSB7XG4gICAgICAgICAgICAgIGlmIChqc29uLmRhdGEuc3RhdHVzID09PSAnTmV0U3RyZWFtLlBsYXkuVW5wdWJsaXNoTm90aWZ5Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblVucHVibGlzaCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoanNvbi50eXBlID09PSAnbWV0YWRhdGEnKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgYSBgc2VuZGAgQVBJIGludm9jYXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGpzb24ubWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNlbmRSZWNlaXZlZChqc29uLm1ldGhvZCwganNvbi5kYXRhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbHNlIGl0IGlzIG5vcm1hbCBtZXRhZGF0YS5cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbk1ldGFEYXRhKGpzb24uZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGpzb24udHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoanNvbi50eXBlID09PSAnbWV0YWRhdGEnKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbk1ldGFEYXRhKGpzb24ubWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcihOQU1FLCBgW3dzLm9ubWVzc2FnZV0gLSBFcnJvciBpbiBhY2Nlc3NpbmcgbWVzc2FnZSBkYXRhIGFzIEpTT04uICR7ZS5tZXNzYWdlfWApXG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldE1lc3NhZ2VFcnJvcihgW3dzLm9ubWVzc2FnZV0gLSBFcnJvciBpbiBhY2Nlc3NpbmcgbWVzc2FnZSBkYXRhIGFzIEpTT04uICR7ZS5tZXNzYWdlfWApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oTkFNRSwgJ1t3cy5vbm1lc3NhZ2VdIC0gTm8gTWVzc2FnZSBEYXRhLicpXG4gICAgfVxuICB9XG5cbn1cbmV4cG9ydCBkZWZhdWx0IFN1YnNjcmlwdGlvblNvY2tldEhlbHBlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvaGVscGVyL3NvY2tldC1oZWxwZXItc3ViLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5pbXBvcnQgKiBhcyB3ZWJzb2NrZXQgZnJvbSAnLi4vYWRhcHRlci93ZWJzb2NrZXQnXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBpbmZvLCBkZWJ1Zywgd2FybiB9IGZyb20gJy4uL2xvZydcblxuY2xhc3MgU29ja2V0SGVscGVyIHtcblxuICBjb25zdHJ1Y3RvciAocmVzcG9uZGVyLCBuYW1lKSB7XG4gICAgdGhpcy5fcmVzcG9uZGVyID0gcmVzcG9uZGVyXG4gICAgdGhpcy5fcGVuZGluZ1Bvc3RSZXF1ZXN0cyA9IFtdXG4gICAgdGhpcy5fd2Vic29ja2V0ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9uYW1lID0gbmFtZVxuICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMgPSBbXVxuICAgIHRoaXMuX29uY2xvc2UgPSB0aGlzLnRlYXJEb3duLmJpbmQodGhpcylcbiAgfVxuXG4gIF9yZW1vdmVTb2NrZXRIYW5kbGVycyAod3MpIHtcbiAgICB3cy5vbm9wZW4gPSB1bmRlZmluZWRcbiAgICB3cy5vbm1lc3NhZ2UgPSB1bmRlZmluZWRcbiAgICB3cy5vbmVycm9yID0gdW5kZWZpbmVkXG4gIH1cblxuICBfYWRkU29ja2V0SGFuZGxlcnMgKHdzLCBwcm9taXNlKSB7XG5cbiAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICBpbmZvKHRoaXMuX25hbWUsICdbd2Vic29ja2V0b3Blbl0nKVxuICAgICAgd2hpbGUgKHRoaXMuX3BlbmRpbmdQb3N0UmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnBvc3QodGhpcy5fcGVuZGluZ1Bvc3RSZXF1ZXN0cy5zaGlmdCgpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHdzLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMudGVhckRvd24oKVxuICAgICAgd2Fybih0aGlzLl9uYW1lLCBgW3dlYnNvY2tldGVycm9yXTogRXJyb3IgZnJvbSBXZWJTb2NrZXQuICR7ZXJyb3IudHlwZX1gKVxuICAgICAgcHJvbWlzZS5yZWplY3QoZXJyb3IpXG4gICAgfVxuXG4gICAgd3Mub25tZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgIHRoaXMucmVzcG9uZChtZXNzYWdlKVxuICAgIH1cblxuICB9XG5cbiAgc2V0VXAgKHVybCwgc2V0dXBQcm9taXNlKSB7XG4gICAgdGhpcy50ZWFyRG93bigpXG4gICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UgPSBzZXR1cFByb21pc2VcbiAgICBlbnZpcm9ubWVudC5hZGRDbG9zZUhhbmRsZXIodGhpcy5fb25jbG9zZSlcbiAgICB0aGlzLl93ZWJzb2NrZXQgPSB3ZWJzb2NrZXQuY3JlYXRlKHVybClcbiAgICB0aGlzLl9hZGRTb2NrZXRIYW5kbGVycyh0aGlzLl93ZWJzb2NrZXQsIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlKVxuICB9XG5cbiAgdGVhckRvd24gKCkge1xuICAgIHRoaXMuX3BlbmRpbmdQb3N0UmVxdWVzdHMubGVuZ3RoID0gMFxuICAgIGlmICh0eXBlb2YgdGhpcy5fd2Vic29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5fcmVtb3ZlU29ja2V0SGFuZGxlcnModGhpcy5fd2Vic29ja2V0KVxuICAgICAgdGhpcy5fd2Vic29ja2V0LmNsb3NlKClcbiAgICB9XG4gICAgdGhpcy5fd2Vic29ja2V0ID0gdW5kZWZpbmVkXG4gICAgd2hpbGUodGhpcy5fcmVzcG9uc2VIYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLnNoaWZ0KClcbiAgICB9XG4gICAgZW52aXJvbm1lbnQucmVtb3ZlQ2xvc2VIYW5kbGVyKHRoaXMuX29uY2xvc2UpXG4gIH1cblxuICBnZXRKc29uRnJvbVNvY2tldE1lc3NhZ2UgKG1lc3NhZ2UpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlLmRhdGEgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpIDogbWVzc2FnZS5kYXRhXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB3YXJuKHRoaXMuX25hbWUsICdDb3VsZCBub3QgcGFyc2UgbWVzc2FnZSBhcyBKU09OLiBNZXNzYWdlPSAnICsgbWVzc2FnZS5kYXRhICsgJy4gRXJyb3I9ICcgKyBlLm1lc3NhZ2UpXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBhZGRTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLnB1c2goaGFuZGxlcilcbiAgfVxuXG4gIHJlbW92ZVNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIGxldCBpID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5sZW5ndGhcbiAgICBsZXQgckhhbmRsZXJcbiAgICB3aGlsZSgtLWkgPiAtMSkge1xuICAgICAgckhhbmRsZXIgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzW2ldXG4gICAgICBpZiAockhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5zcGxpY2UoaSwgMSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlTWVzc2FnZVJlc3BvbnNlIChtZXNzYWdlKSB7XG4gICAgbGV0IGksIGhhbmRsZXJcbiAgICBsZXQgbGVuZ3RoID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhbmRsZXIgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzW2ldXG4gICAgICBpZiAoaGFuZGxlci5yZXNwb25kKG1lc3NhZ2UpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcG9zdCAoc2VuZFJlcXVlc3QpIHtcbiAgICBpZiAodGhpcy5fd2Vic29ja2V0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fd2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IDEgLyogV2ViU29ja2V0Lk9QRU4gKi8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRlYnVnKHRoaXMuX25hbWUsICdbd2Vic29ja2V0LXBvc3RdOiAnICsgSlNPTi5zdHJpbmdpZnkoc2VuZFJlcXVlc3QsIG51bGwsIDIpKVxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShzZW5kUmVxdWVzdCkpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRlYnVnKHRoaXMuX25hbWUsIGBDb3VsZCBub3Qgc2VuZCByZXF1ZXN0OiAke3NlbmRSZXF1ZXN0fS4gJHtlfWApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdQb3N0UmVxdWVzdHMucHVzaChzZW5kUmVxdWVzdClcbiAgICB9XG4gIH1cblxuICByZXNwb25kIChtZXNzYWdlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBsZXQgaGFuZGxlZCA9IHRoaXMuaGFuZGxlTWVzc2FnZVJlc3BvbnNlKG1lc3NhZ2UpXG4gICAgaWYgKCFoYW5kbGVkICYmIG1lc3NhZ2UuZGF0YSkge1xuICAgICAgbGV0IGpzb24gPSB0aGlzLmdldEpzb25Gcm9tU29ja2V0TWVzc2FnZShtZXNzYWdlKVxuICAgICAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICAgICAgd2Fybih0aGlzLl9uYW1lLCAnRGV0ZXJtaW5lZCB3ZWJzb2NrZXQgcmVzcG9uc2Ugbm90IGluIGNvcnJlY3QgZm9ybWF0LiBBYm9ydGluZyBtZXNzYWdlIGhhbmRsZS4nKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGRlYnVnKHRoaXMuX25hbWUsICdbd2Vic29ja2V0LXJlc3BvbnNlXTogJyArIEpTT04uc3RyaW5naWZ5KGpzb24sIG51bGwsIDIpKVxuICAgICAgaWYgKGpzb24uaXNBdmFpbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uaXNBdmFpbGFibGUgPT09ICdib29sZWFuJyAmJiBqc29uLmlzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU3RyZWFtQXZhaWxhYmxlKGpzb24pXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25TdHJlYW1VbmF2YWlsYWJsZShqc29uKVxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoanNvbi5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGpzb24uZGF0YS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoanNvbi5kYXRhLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNvY2tldE1lc3NhZ2VFcnJvcihqc29uLmRhdGEubWVzc2FnZSwganNvbi5kYXRhLmRldGFpbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24uZGF0YS50eXBlID09PSAnc3RhdHVzJykge1xuICAgICAgICAgIGlmIChqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uQ29ubmVjdC5TdWNjZXNzJykge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uQ29ubmVjdC5SZWplY3RlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25Qcm9taXNlLnJlamVjdCgnTmV0Q29ubmVjdGlvbi5Db25uZWN0LlJlamVjdGVkJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGpzb24uZGF0YS50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgaWYgKGpzb24uZGF0YS5jb2RlID09PSAnTmV0Q29ubmVjdGlvbi5Db25uZWN0LlJlamVjdGVkJykge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvblByb21pc2UucmVqZWN0KCdOZXRDb25uZWN0aW9uLkNvbm5lY3QuUmVqZWN0ZWQnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZWRcbiAgfVxuXG4gIGdldFJlbW90ZVNoYXJlZE9iamVjdCAobmFtZSkge1xuICAgIHRoaXMucG9zdCh7XG4gICAgICBzaGFyZWRPYmplY3RHZXRSZW1vdGU6IHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjb25uZWN0VG9TaGFyZWRPYmplY3QgKG5hbWUpIHtcbiAgICB0aGlzLnBvc3Qoe1xuICAgICAgc2hhcmVkT2JqZWN0Q29ubmVjdDoge1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHNlbmRUb1NoYXJlZE9iamVjdCAobmFtZSwgY2FsbE5hbWUsIGRhdGEpIHtcbiAgICB0aGlzLnBvc3Qoe1xuICAgICAgc2hhcmVkT2JqZWN0U2VuZDoge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBjYWxsOiBjYWxsTmFtZSxcbiAgICAgICAgcGFyYW1zOiBbZGF0YV1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QgKG5hbWUsIGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnBvc3Qoe1xuICAgICAgc2hhcmVkT2JqZWN0U2V0UHJvcGVydHk6IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBjbG9zZVNoYXJlZE9iamVjdCAobmFtZSkge1xuICAgIHRoaXMucG9zdCh7XG4gICAgICBzaGFyZWRPYmplY3RDbG9zZToge1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNvY2tldEhlbHBlclxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9oZWxwZXIvc29ja2V0LWhlbHBlci5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5cbmV4cG9ydCBjb25zdCBpc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGVudmlyb25tZW50LnN1cHBvcnRzV2ViU29ja2V0KClcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgcmV0dXJuIGVudmlyb25tZW50LmNyZWF0ZVdlYlNvY2tldCh1cmwpXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9hZGFwdGVyL3dlYnNvY2tldC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgKiBhcyB3ZWJydGMgZnJvbSAnLi4vYWRhcHRlci93ZWJydGMnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBkZWJ1Zywgd2FybiwgZXJyb3IgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9TdWJzY3JpcHRpb25QZWVyJ1xuXG5jbGFzcyBTdWJzY3JpcHRpb25QZWVySGVscGVyIHtcblxuICBjb25zdHJ1Y3RvciAocmVzcG9uZGVyKSB7XG4gICAgdGhpcy5fcmVzcG9uZGVyID0gcmVzcG9uZGVyXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24gPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZW5kaW5nTWVkaWFTdHJlYW0gPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9yZW1vdmVDb25uZWN0aW9uSGFuZGxlcnMgKGNvbm5lY3Rpb24pIHtcbiAgICBjb25uZWN0aW9uLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gdW5kZWZpbmVkXG4gICAgY29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IHVuZGVmaW5lZFxuICAgIGNvbm5lY3Rpb24ub25hZGRzdHJlYW0gPSB1bmRlZmluZWRcbiAgICBjb25uZWN0aW9uLm9udHJhY2sgPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9hZGRDb25uZWN0aW9uSGFuZGxlcnMgKGNvbm5lY3Rpb24sIHByb21pc2UpIHtcblxuICAgIGNvbm5lY3Rpb24ub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAoY29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgIGRlYnVnKE5BTUUsICdbcGVlcmNvbm5lY3Rpb246b3Blbl0nKVxuICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgIHByb21pc2UucmVzb2x2ZSh0aGlzKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlID09PSAnZmFpbGVkJyB8fFxuICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgd2FybihOQU1FLCAnW3BlZXJjb25uZWN0aW9uOmVycm9yXScpXG4gICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZWplY3QoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgZGVidWcoTkFNRSwgYFtwZWVyLm9uaWNlY2FuZGlkYXRlXSAtIFBlZXIgQ2FuZGlkYXRlOiAke2V2ZW50LmNhbmRpZGF0ZX1gKVxuICAgICAgaWYgKGV2ZW50LmNhbmRpZGF0ZSkge1xuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25JY2VDYW5kaWRhdGUoZXZlbnQuY2FuZGlkYXRlKVxuICAgICAgfSBlbHNlIGlmIChldmVudC5jYW5kaWRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gbnVsbCBtZWFucyB0aGV5IGhhdmUgZmluaXNoZWQgc2VuZGluZyBjYW5kaWRhdGVzIGJhY2sgYW5kIGZvcnRoP1xuICAgICAgICB0aGlzLl9yZXNwb25kZXIub25JY2VDYW5kaWRhdGVUcmlja2xlRW5kKHRoaXMuX3BlbmRpbmdNZWRpYVN0cmVhbSlcbiAgICAgICAgdGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi5vbmFkZHN0cmVhbSA9IChldmVudCkgPT4ge1xuICAgICAgZGVidWcoTkFNRSwgYFBlZXIgQWRkIFN0cmVhbTogJHtldmVudC5zdHJlYW19YClcbiAgICAgIGlmIChldmVudC5zdHJlYW0pIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtID0gZXZlbnQuc3RyZWFtXG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vbkFuc3dlck1lZGlhU3RyZWFtKGV2ZW50LnN0cmVhbSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25uZWN0aW9uLm9udHJhY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgIGRlYnVnKE5BTUUsIGBQZWVyIEFkZCBTdHJlYW06ICR7ZXZlbnQuc3RyZWFtc31gKVxuICAgICAgaWYgKGV2ZW50LnN0cmVhbXMgJiYgZXZlbnQuc3RyZWFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdNZWRpYVN0cmVhbSA9IGV2ZW50LnN0cmVhbXNbMF1cbiAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHNldFVwIChpY2VTZXJ2ZXJzLCBzZXRVcFByb21pc2UpIHtcbiAgICB0aGlzLnRlYXJEb3duKClcbiAgICBkZWJ1ZyhOQU1FLCAnW3NldHVwXScpXG4gICAgY29uc3QgcCA9IHNldFVwUHJvbWlzZSB8fCBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0cnkge1xuICAgICAgbGV0IHBlZXIgPSBuZXcgd2VicnRjLlJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyxcbiAgICAgICAgcnRjcE11eFBvbGljeTogJ25lZ290aWF0ZSdcbiAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBvcHRpb25hbDogW1xuICAgICAgICAgICAge0R0bHNTcnRwS2V5QWdyZWVtZW50OiB0cnVlfSxcbiAgICAgICAgICAgIHtSdHBEYXRhQ2hhbm5lbHM6IGZhbHNlfSxcbiAgICAgICAgICAgIHtnb29nQ3B1T3ZlcnVzZURldGVjdGlvbjogdHJ1ZX1cbiAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbiA9IHBlZXJcbiAgICAgIHRoaXMuX2FkZENvbm5lY3Rpb25IYW5kbGVycyhwZWVyKVxuICAgICAgcC5yZXNvbHZlKClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKE5BTUUsIGBDb3VsZCBub3QgY3JlYXRlIGEgUlRDUGVlckNvbm5lY3Rpb24uIEVycm9yOiAke2UubWVzc2FnZX1gKVxuICAgICAgcC5yZWplY3QoZS5tZXNzYWdlKVxuICAgIH1cbiAgICByZXR1cm4gcC5oYXNPd25Qcm9wZXJ0eSgncHJvbWlzZScpID8gcC5wcm9taXNlIDogcFxuICB9XG5cbiAgdGVhckRvd24gKCkge1xuICAgIGRlYnVnKE5BTUUsICdbdGVhcmRvd25dJylcbiAgICBpZiAodGhpcy5fcGVlckNvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMuX3JlbW92ZUNvbm5lY3Rpb25IYW5kbGVycyh0aGlzLl9wZWVyQ29ubmVjdGlvbilcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLmNsb3NlKClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd2FybihOQU1FLCBgW3BlZXJjb25uZWN0aW9uLmNsb3NlXSBlcnJvcjogJHtlLm1lc3NhZ2V9YClcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcGVuZGluZ01lZGlhU3RyZWFtID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24gPSB1bmRlZmluZWRcbiAgfVxuXG4gIGNyZWF0ZUFuc3dlciAoc2RwKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tjcmVhdGVhbnN3ZXJdJylcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24oc2RwKVxuICAgICAgLnRoZW4odGhpcy5fcmVzcG9uZGVyLm9uU0RQU3VjY2VzcylcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNEUEVycm9yKGVycilcbiAgICAgIH0pXG5cbiAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKVxuICAgICAgLnRoZW4oc2Vzc2lvbkRlc2NyaXB0aW9uID0+IHtcbiAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihzZXNzaW9uRGVzY3JpcHRpb24pXG4gICAgICAgICAgLnRoZW4odGhpcy5fcmVzcG9uZGVyLm9uU0RQU3VjY2VzcylcbiAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU0RQRXJyb3IoZXJyKVxuICAgICAgICAgIH0pXG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUoc2Vzc2lvbkRlc2NyaXB0aW9uKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChkZWZlcnJlZC5yZWplY3QpXG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgYWRkSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2FkZGljZWNhbmRpZGF0ZV0nKVxuICAgIGxldCBpY2VDYW5kaWRhdGUgPSBuZXcgd2VicnRjLlJUQ0ljZUNhbmRpZGF0ZSh7XG4gICAgICBzZHBNTGluZUluZGV4OiBjYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgIGNhbmRpZGF0ZTogY2FuZGlkYXRlLmNhbmRpZGF0ZVxuICAgIH0pXG4gICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKGljZUNhbmRpZGF0ZSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgLy8gbmFkYVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBlcnJvcihOQU1FLCBgRXJyb3IgaW4gYWRkIG9mIElDRSBDYW5kaWRpYXRlICsgJHtlcnJ9YClcbiAgICAgIH0pXG4gIH1cblxuICBnZXQgY29ubmVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlZXJDb25uZWN0aW9uXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBTdWJzY3JpcHRpb25QZWVySGVscGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9oZWxwZXIvd2VicnRjLWhlbHBlci1zdWIuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuXG4vKiogLS0gaGFuZGxlZCBieSBhZGFwdGVyLmpzIC0tICovXG5jb25zdCBfUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgKHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbiB8fCB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pXG5jb25zdCBfUlRDSWNlQ2FuZGlkYXRlID0gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCAod2luZG93Lm1velJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cud2Via2l0UlRDSWNlQ2FuZGlkYXRlKVxuY29uc3QgX1JUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24gfHwgKHdpbmRvdy5tb3pSVENTZXNzaW9uRGVzY3JpcHRpb24gfHwgd2luZG93LndlYmtpdFJUQ1Nlc3Npb25EZXNjcmlwdGlvbilcblxuZXhwb3J0IGNvbnN0IGlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX1JUQ1BlZXJDb25uZWN0aW9uICYmIF9SVENJY2VDYW5kaWRhdGUgJiYgX1JUQ1Nlc3Npb25EZXNjcmlwdGlvblxufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbXVhei1raGFuL1dlYlJUQy1FeHBlcmltZW50L2Jsb2IvbWFzdGVyL1JUQ1BlZXJDb25uZWN0aW9uL1JUQ1BlZXJDb25uZWN0aW9uLXYxLjYuanMjTDE1OFxuLy8gTXVheiBLaGFuICAgICAtIGdpdGh1Yi5jb20vbXVhei1raGFuXG4vLyBNSVQgTGljZW5zZSAgIC0gd3d3LldlYlJUQy1FeHBlcmltZW50LmNvbS9saWNlbmNlXG4vLyBEb2N1bWVudGF0aW9uIC0gZ2l0aHViLmNvbS9tdWF6LWtoYW4vV2ViUlRDLUV4cGVyaW1lbnQvdHJlZS9tYXN0ZXIvUlRDUGVlckNvbm5lY3Rpb25cbmV4cG9ydCBjb25zdCB1cGRhdGVCYW5kd2lkdGggPSBmdW5jdGlvbiAob3B0aW9ucywgc2RwKSB7XG4gIGlmIChlbnZpcm9ubWVudC5nZXRJc01veigpKSB7XG4gICAgcmV0dXJuIHNkcFxuICB9XG4gIHNkcCA9IHNkcC5yZXBsYWNlKC9iPUFTKFteXFxyXFxuXStcXHJcXG4pL2csICcnKVxuICBpZiAob3B0aW9ucy5hdWRpbykge1xuICAgIHNkcCA9IHNkcC5yZXBsYWNlKC9hPW1pZDphdWRpb1xcclxcbi9nLCAnYT1taWQ6YXVkaW9cXHJcXG5iPUFTOicgKyBvcHRpb25zLmF1ZGlvICsgJ1xcclxcbicpXG4gIH1cbiAgaWYgKG9wdGlvbnMudmlkZW8pIHtcbiAgICBzZHAgPSBzZHAucmVwbGFjZSgvYT1taWQ6dmlkZW9cXHJcXG4vZywgJ2E9bWlkOnZpZGVvXFxyXFxuYj1BUzonICsgb3B0aW9ucy52aWRlbyArICdcXHJcXG4nKVxuICB9XG4gIHJldHVybiBzZHBcbn1cblxuZXhwb3J0IGNvbnN0IFJUQ1BlZXJDb25uZWN0aW9uID0gX1JUQ1BlZXJDb25uZWN0aW9uXG5leHBvcnQgY29uc3QgUlRDSWNlQ2FuZGlkYXRlID0gX1JUQ0ljZUNhbmRpZGF0ZVxuZXhwb3J0IGNvbnN0IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbiA9IF9SVENTZXNzaW9uRGVzY3JpcHRpb25cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvYWRhcHRlci93ZWJydGMuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnQgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IFN1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgVmlkZW9KU0hhbmRsZXIgZnJvbSAnLi92aWRlb2pzLXNvdXJjZS1oYW5kbGVyJ1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9ITFNTdWJzY3JpYmVyJ1xuY29uc3QgdmlkZW9qcyA9IGVudmlyb25tZW50LmdldFZpZGVvSnMoKVxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHByb3RvY29sOiAnaHR0cHMnLFxuICBwb3J0OiA4MCxcbiAgbWltZVR5cGU6ICdhcHBsaWNhdGlvbi94LW1wZWdVUkwnLFxuICBzd2Y6ICdsaWIvcmVkNXByby9yZWQ1cHJvLXZpZGVvLWpzLnN3Zidcbn1cbmNvbnN0IG9wdGlvbnNUb0hsc1VSTCA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHByb3RvY29sID0gb3B0aW9ucy5obHNwcm90b2NvbCA/IG9wdGlvbnMuaGxzcHJvdG9jb2wgOiBvcHRpb25zLnByb3RvY29sXG4gIGNvbnN0IHBvcnQgPSBvcHRpb25zLmhsc3BvcnQgPyBvcHRpb25zLmhsc3BvcnQgOiBvcHRpb25zLnBvcnRcbiAgY29uc3QgYXBwRW5kcG9pbnQgPSBvcHRpb25zLmNvbnRleHQgPyBbb3B0aW9ucy5hcHAsIG9wdGlvbnMuY29udGV4dF0uam9pbignLycpIDogb3B0aW9ucy5hcHBcbiAgcmV0dXJuIGAke3Byb3RvY29sfTovLyR7b3B0aW9ucy5ob3N0fToke3BvcnR9LyR7YXBwRW5kcG9pbnR9LyR7b3B0aW9ucy5zdHJlYW1OYW1lfS5tM3U4YFxufVxuXG5jbGFzcyBITFNTdWJzY3JpYmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudHMgPSB0aGlzLmJ1YmJsZVN1YnNjcmliZXJFdmVudHMuYmluZCh0aGlzKVxuICB9XG5cbiAgYnViYmxlU3Vic2NyaWJlckV2ZW50cyAoZXZlbnQpIHtcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChldmVudC50eXBlLCB0aGlzLCBldmVudC5kYXRhKSlcbiAgfVxuXG4gIGluaXQgKG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGlmICghZW52aXJvbm1lbnQuZ2V0VmlkZW9KcygpKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoJ0NvdWxkIG5vdCByZXNvbHZlIEhMU1N1YnNjcmliZXIuIFJlcXVpcmVzIHZpZGVvanMgbGlicmFyeS4nKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpXG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHRoaXMpXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBzZXRWaWV3ICh2aWV3KSB7XG4gICAgdGhpcy5fdmlldyA9IHZpZXdcbiAgICBpZiAodGhpcy5fdmlkZW9qc0hhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIub2ZmKCcqJywgdGhpcy5fYm91bmRCdWJibGVTdWJzY3JpYmVyRXZlbnRzKVxuICAgICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIuZGlzY29ubmVjdCgpXG4gICAgICB0aGlzLl92aWRlb2pzSGFuZGxlciA9IHVuZGVmaW5lZFxuICAgIH1cbiAgICB0aGlzLl92aWRlb2pzSGFuZGxlciA9IG5ldyBWaWRlb0pTSGFuZGxlcih0aGlzLl92aWV3LnZpZXcsIHRoaXMuZ2V0VHlwZSgpKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwbGF5IChzdHJlYW1OYW1lID0gbnVsbCwgcHJvbWlzZSA9IG51bGwpIHtcbiAgICBjb25zdCBwID0gcHJvbWlzZSB8fCBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCB1cmxSZWdleCA9IC9eaHR0cCh8cykuKlxcLm0zdTgvZ1xuICAgIHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSA9IHN0cmVhbU5hbWUgfHwgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgbGV0IHVybCA9IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZS5tYXRjaCh1cmxSZWdleCkgPyB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUgOiBvcHRpb25zVG9IbHNVUkwodGhpcy5fb3B0aW9ucylcbiAgICBsZXQgdHlwZSA9IHRoaXMuX29wdGlvbnMubWltZVR5cGVcbiAgICBsZXQgc3dmVVJMID0gdGhpcy5fb3B0aW9ucy5zd2ZcbiAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICB0eXBlID0gdGhpcy5fb3B0aW9ucy5ydG1wTWltZVR5cGUgfHwgdGhpcy5fb3B0aW9ucy5taW1lVHlwZVxuICAgIH1cbiAgICBkZWJ1ZyhOQU1FLCBgW3BsYXldOiBVUkwoJHt1cmx9KS5gKVxuICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyLm9uKCcqJywgdGhpcy5fYm91bmRCdWJibGVTdWJzY3JpYmVyRXZlbnRzKVxuICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyLmFkZFNvdXJjZSh1cmwsIHR5cGUsIHZpZGVvanMsIHN3ZlVSTClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcC5yZXNvbHZlKHRoaXMpXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkNPTk5FQ1RfU1VDQ0VTUykpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgcC5yZWplY3QoZXJyb3IpXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSkpXG4gICAgICB9KVxuICAgIHJldHVybiBwLmhhc093blByb3BlcnR5KCdwcm9taXNlJykgPyBwLnByb21pc2UgOiBwXG4gIH1cblxuICBzdG9wICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3N0b3BdJylcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl92aWRlb2pzSGFuZGxlci5vZmYoJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudHMpXG4gICAgICB0aGlzLl92aWRlb2pzSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdChlLm1lc3NhZ2UpXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBnZXRDb25uZWN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlkZW9qc0hhbmRsZXJcbiAgfVxuXG4gIGdldE9wdGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zXG4gIH1cblxuICBnZXRQbGF5ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl92aWRlb2pzSGFuZGxlci5nZXRQbGF5ZXIoKVxuICB9XG5cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuICdITFMnXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBITFNTdWJzY3JpYmVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9zdWJzY3JpYmVyL3JlZDVwcm8taGxzLmpzXG4gKiovIiwiLyoqXG4gKiBCYXNlIGhhbmRsZXIgZm9yIHV0aWxpemluZyB0aGUgdmlkZW9qc1xuICogbGlicmFyeSB0byBpbnRlcmdhdGUgcGxheWJhY2sgb2YgbGl2ZSB2aWRlby5cbiAqXG4gKiBAc2VlIHJlZDVwcm8taGxzXG4gKiBAc2VlIHJlZDVwcm8tcnRtcFxuICovXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnQgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCB7IFN1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgYnJvd3NlciBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IGRlZXBEZWZpbmUgfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IGRlYnVnLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb0Jhc2VWaWRlb0pTSGFuZGxlcidcblxuY29uc3QgdmlkZW9qcyA9IGJyb3dzZXIuZ2V0VmlkZW9KcygpXG5jb25zdCBtaW1lVHlwZSA9ICd2aWRlby93ZWJtJ1xuY29uc3Qgb3B0aW9uc1RvVVJMID0gKG9wdGlvbnMpID0+IHtcbiAgdmFyIGFwcEVuZHBvaW50ID0gb3B0aW9ucy5jb250ZXh0ID8gW29wdGlvbnMuYXBwLCBvcHRpb25zLmNvbnRleHRdLmpvaW4oJy8nKSA6IG9wdGlvbnMuYXBwXG4gIHJldHVybiBgJHtvcHRpb25zLnByb3RvY29sfTovLyR7b3B0aW9ucy5ob3N0fToke29wdGlvbnMucG9ydH0vJHthcHBFbmRwb2ludH0vJHtvcHRpb25zLnN0cmVhbU5hbWV9YFxufVxuXG5jbGFzcyBCYXNlSGFuZGxlciBleHRlbmRzIEV2ZW50RW1pdHRlcntcblxuICBjb25zdHJ1Y3RvciAodmlkZW8sIHBsYXllclR5cGUgPSBudWxsKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMudmlkZW8gPSB2aWRlb1xuICAgIHRoaXMuY2xvbmUgPSB0aGlzLnZpZGVvLmNsb25lTm9kZSh0cnVlKVxuICAgIHRoaXMuaG9sZGVyID0gdGhpcy52aWRlby5wYXJlbnROb2RlXG4gICAgdGhpcy52aWRlb2pzID0gbnVsbFxuICAgIHRoaXMuc291cmNlID0gbnVsbFxuICAgIHRoaXMucGxheWVyVHlwZSA9IHBsYXllclR5cGVcbiAgICB0aGlzLmhhc0Fzc2lnbmVkRXZlbnRMaXN0ZW5lcnMgPSBmYWxzZVxuXG4gICAgLy8gIFRPRE86IFRlbXBvcmFyeSBhZGp1c3RtZW50LiBCZXR0ZXIgdG8gcGFzcyB2aWRlb2pzIHVwIHRoZSBjaGFpbiBzbyBlbmQgdXNlcnMgY2FuIHNldCB0aGVpciBvd24gaGFuZGxlcnMuXG4gICAgdGhpcy5vblZpZGVvSlNFcnJvciA9IHRoaXMub25WaWRlb0pTRXJyb3IuYmluZCh0aGlzKVxuICAgIHRoaXMub25WaWRlb0pTTG9hZGVkRGF0YSA9IHRoaXMub25WaWRlb0pTTG9hZGVkRGF0YS5iaW5kKHRoaXMpXG4gICAgdGhpcy5vblZpZGVvSlNMb2FkZWRNZXRhZGF0YSA9IHRoaXMub25WaWRlb0pTTG9hZGVkTWV0YWRhdGEuYmluZCh0aGlzKVxuICAgIHRoaXMub25WaWRlb0pTVGltZVVwZGF0ZSA9IHRoaXMub25WaWRlb0pTVGltZVVwZGF0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5vblZpZGVvSlNVc2VyQWN0aXZlID0gdGhpcy5vblZpZGVvSlNVc2VyQWN0aXZlLmJpbmQodGhpcylcbiAgICB0aGlzLm9uVmlkZW9KU1VzZXJJbmFjdGl2ZSA9IHRoaXMub25WaWRlb0pTVXNlckluYWN0aXZlLmJpbmQodGhpcylcbiAgICB0aGlzLm9uVmlkZW9KU1ZvbHVtZUNoYW5nZSA9IHRoaXMub25WaWRlb0pTVm9sdW1lQ2hhbmdlLmJpbmQodGhpcylcbiAgICB0aGlzLm9uVmlkZW9KU0VuZGVkID0gdGhpcy5vblZpZGVvSlNFbmRlZC5iaW5kKHRoaXMpXG4gIH1cblxuICAvLyAgQXNzaWduIGFsbCB2aWRlby5qcyBsaXN0ZW5lcnMgKHRob3NlIHdoaWNoIGFyZSBsaXN0ZWQgb24gaHR0cDovL2RvY3MudmlkZW9qcy5jb20vZG9jcy9hcGkvcGxheWVyLmh0bWwjZXZlbnRzKVxuICBhZGRWaWRlb0pTRXZlbnRMaXN0ZW5lcnMgKCkge1xuICAgIGlmICh0aGlzLmhhc0Fzc2lnbmVkRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLnZpZGVvanMub24oJ2Vycm9yJywgdGhpcy5vblZpZGVvSlNFcnJvcilcbiAgICB0aGlzLnZpZGVvanMub24oJ2xvYWRlZGRhdGEnLCB0aGlzLm9uVmlkZW9KU0xvYWRlZERhdGEpXG4gICAgdGhpcy52aWRlb2pzLm9uKCdsb2FkZWRtZXRhZGF0YScsIHRoaXMub25WaWRlb0pTTG9hZGVkTWV0YWRhdGEpXG4gICAgdGhpcy52aWRlb2pzLm9uKCd0aW1ldXBkYXRlJywgdGhpcy5vblZpZGVvSlNUaW1lVXBkYXRlKVxuICAgIHRoaXMudmlkZW9qcy5vbigndXNlcmFjdGl2ZScsIHRoaXMub25WaWRlb0pTVXNlckFjdGl2ZSlcbiAgICB0aGlzLnZpZGVvanMub24oJ3VzZXJpbmFjdGl2ZScsIHRoaXMub25WaWRlb0pTVXNlckluYWN0aXZlKVxuICAgIHRoaXMudmlkZW9qcy5vbigndm9sdW1lY2hhbmdlJywgdGhpcy5vblZpZGVvSlNWb2x1bWVDaGFuZ2UpXG4gICAgdGhpcy52aWRlb2pzLm9uKCdlbmRlZCcsIHRoaXMub25WaWRlb0pTRW5kZWQpXG4gICAgdGhpcy5oYXNBc3NpZ25lZEV2ZW50TGlzdGVuZXJzID0gdHJ1ZVxuICB9XG5cbiAgLy8gIFJlbW92ZSBhbGwgdmlkZW8uanMgbGlzdGVuZXJzICh0aG9zZSB3aGljaCBhcmUgbGlzdGVkIG9uIGh0dHA6Ly9kb2NzLnZpZGVvanMuY29tL2RvY3MvYXBpL3BsYXllci5odG1sI2V2ZW50cylcbiAgcmVtb3ZlVmlkZW9KU0V2ZW50TGlzdGVuZXJzICgpIHtcbiAgICBpZiAoIXRoaXMuaGFzQXNzaWduZWRFdmVudExpc3RlbmVycykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMudmlkZW9qcy5vZmYoJ2Vycm9yJywgdGhpcy5vblZpZGVvSlNFcnJvcilcbiAgICB0aGlzLnZpZGVvanMub2ZmKCdsb2FkZWRkYXRhJywgdGhpcy5vblZpZGVvSlNMb2FkZWREYXRhKVxuICAgIHRoaXMudmlkZW9qcy5vZmYoJ2xvYWRlZG1ldGFkYXRhJywgdGhpcy5vblZpZGVvSlNMb2FkZWRNZXRhZGF0YSlcbiAgICB0aGlzLnZpZGVvanMub2ZmKCd0aW1ldXBkYXRlJywgdGhpcy5vblZpZGVvSlNUaW1lVXBkYXRlKVxuICAgIHRoaXMudmlkZW9qcy5vZmYoJ3VzZXJhY3RpdmUnLCB0aGlzLm9uVmlkZW9KU1VzZXJBY3RpdmUpXG4gICAgdGhpcy52aWRlb2pzLm9mZigndXNlcmluYWN0aXZlJywgdGhpcy5vblZpZGVvSlNVc2VySW5hY3RpdmUpXG4gICAgdGhpcy52aWRlb2pzLm9mZigndm9sdW1lY2hhbmdlJywgdGhpcy5vblZpZGVvSlNWb2x1bWVDaGFuZ2UpXG4gICAgdGhpcy52aWRlb2pzLm9mZignZW5kZWQnLCB0aGlzLm9uVmlkZW9KU0VuZGVkKVxuICAgIHRoaXMuaGFzQXNzaWduZWRFdmVudExpc3RlbmVycyA9IGZhbHNlXG4gIH1cblxuICAvLyAgQ2xlYW51cCBvdXIgPHNvdXJjZT4gaWYgaXQgZXhpc3RzXG4gIGNsZWFudXAgKCkge1xuICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgdGhpcy5zb3VyY2UucmVtb3ZlKClcbiAgICB9XG4gICAgdGhpcy5zb3VyY2UgPSBudWxsXG4gIH1cblxuICAvLyAgQ2xlYW51cCBvdXIgdmlkZW8uanMgaW1wbGVtZW50YXRpb25cbiAgY2xlYW51cFZpZGVvSlMgKCkge1xuICAgIGlmICh0aGlzLnZpZGVvanMpIHtcbiAgICAgIHRoaXMudmlkZW8ucmVtb3ZlKClcbiAgICAgIHRoaXMucmVtb3ZlVmlkZW9KU0V2ZW50TGlzdGVuZXJzKClcbiAgICAgIHRoaXMudmlkZW9qcy5kaXNwb3NlKClcbiAgICAgIC8vICBUaGlzIHJlY3JlYXRlcyBvdXIgb3JpZ2luYWwgPHZpZGVvPiBlbGVtZW50IGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBvcmlnaW5hbCBjb250YWluaW5nIGVsZW1lbnRcbiAgICAgIHRoaXMudmlkZW8gPSB0aGlzLmNsb25lLmNsb25lTm9kZSh0cnVlKVxuICAgICAgdGhpcy5ob2xkZXIuYXBwZW5kQ2hpbGQodGhpcy52aWRlbylcbiAgICB9XG4gICAgdGhpcy52aWRlb2pzID0gbnVsbFxuICB9XG5cbiAgLy8gIEFkZCBhIG5ldyA8c291cmNlPiBmb3Igb3VyIDx2aWRlbz4gYW5kIHN0YXJ0dXAgdmlkZW8uanNcbiAgYWRkU291cmNlIChzcmMsIHR5cGUgPSBtaW1lVHlwZSwgdmlkZW9JbXBsID0gdmlkZW9qcywgc3dmVVJMID0gbnVsbCkge1xuICAgIGxldCBzZWxmID0gdGhpc1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlU291cmNlIChfc3JjLCBfdHlwZSkge1xuICAgICAgbGV0IHNvdXJjZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJylcbiAgICAgIHNvdXJjZUVsLnNyYyA9IF9zcmNcbiAgICAgIHNvdXJjZUVsLnR5cGUgPSBfdHlwZVxuICAgICAgcmV0dXJuIHNvdXJjZUVsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zZXJ0U291cmNlSW50byAoX3NyYywgX3R5cGUsIF9wYXJlbnQpIHtcbiAgICAgIGxldCBzb3VyY2VFbCA9IGNyZWF0ZVNvdXJjZShfc3JjLCBfdHlwZSlcbiAgICAgIGlmIChfcGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgX3BhcmVudC5pbnNlcnRCZWZvcmUoc291cmNlRWwsIF9wYXJlbnQuZmlyc3RDaGlsZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9wYXJlbnQuYXBwZW5kQ2hpbGQoc291cmNlRWwpXG4gICAgICB9XG4gICAgICByZXR1cm4gc291cmNlRWxcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gIElmIHdlIGhhdmUgYSBjdXJyZW50IDxzb3VyY2U+IGVsZW1lbnQsIHJlbW92ZSBpdFxuICAgICAgICBzZWxmLmNsZWFudXAoKVxuICAgICAgICAvLyAgSWYgdmlkZW8uanMgaGFzIGFscmVhZHkgYmVlbiBpbnN0YW50aWF0ZWQsIGRpc3Bvc2Ugb2YgaXRcbiAgICAgICAgc2VsZi5jbGVhbnVwVmlkZW9KUygpXG5cbiAgICAgICAgLy8gIENyZWF0ZSB0aGUgbmV3IDxzb3VyY2U+IGVsZW1lbnRcbiAgICAgICAgY29uc3Qgc3JjVVJMID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyBzcmMgOiBvcHRpb25zVG9VUkwoc3JjKVxuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gdHlwZSA6ICgoc3JjLm1pbWVUeXBlKSA/IHNyYy5taW1lVHlwZSA6IHR5cGUpXG4gICAgICAgIGRlYnVnKE5BTUUsIGBcIiR7c2VsZi5wbGF5ZXJUeXBlfVwiIGxvYWRpbmcgJHtzcmNVUkx9YClcbiAgICAgICAgc2VsZi5zb3VyY2UgPSBpbnNlcnRTb3VyY2VJbnRvKHNyY1VSTCwgbWltZVR5cGUsIHNlbGYudmlkZW8pXG5cbiAgICAgICAgLy8gIEluc3RhbnRpYXRlIHZpZGVvLmpzXG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgdGVjaE9yZGVyOiBbJ2h0bWw1JywgJ2ZsYXNoJ11cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3dmVVJMKSB7XG4gICAgICAgICAgZGVlcERlZmluZSh2aWRlb0ltcGwsIFsnb3B0aW9ucycsICdmbGFzaCcsICdzd2YnXSwgc3dmVVJMKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9yaWVudGF0aW9uID0gMFxuICAgICAgICBzZWxmLnZpZGVvanMgPSB2aWRlb0ltcGwoc2VsZi52aWRlbywgb3B0cywgKCkgPT4ge1xuICAgICAgICAgIGRlYnVnKE5BTUUsICd2aWRlb0pTIGVtYmVkIGNvbXBsZXRlLicpXG4gICAgICAgICAgbGV0IHBsYXllciA9IHNlbGYuZ2V0UGxheWVyKClcbiAgICAgICAgICBpZiAocGxheWVyKSB7XG4gICAgICAgICAgICBicm93c2VyLm9uT3JpZW50YXRpb25NZXRhZGF0YShwbGF5ZXIsIChtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBkZWJ1ZyhOQU1FLCAnTWV0YWRhdGEgcmVjZWl2ZWQ6ICcgKyBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSwgbnVsbCwgMikpXG4gICAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiAhPT0gbWV0YWRhdGEub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICBicm93c2VyLmFwcGx5T3JpZW50YXRpb24oc2VsZi52aWRlbywgbWV0YWRhdGEub3JpZW50YXRpb24pXG4gICAgICAgICAgICAgICAgc2VsZi50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX01FVEFEQVRBLCB1bmRlZmluZWQsIG1ldGFkYXRhKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcmllbnRhdGlvbiA9IG1ldGFkYXRhLm9yaWVudGF0aW9uXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHNlbGYpXG4gICAgICAgIH0pXG4gICAgICAgIHNlbGYuYWRkVmlkZW9KU0V2ZW50TGlzdGVuZXJzKClcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yKE5BTUUsIGBDb3VsZCBub3QgaW5zdGFudGlhdGUgbmV3IFZpZGVvSlMtYmFzZWQgXCIke3NlbGYucGxheWVyVHlwZX1cIiBQbGF5ZXIuXFxuUmVhc29uOiAke2UubWVzc2FnZX1gKVxuICAgICAgICByZWplY3QoYENvdWxkIG5vdCBpbnN0YW50aWF0ZSBuZXcgVmlkZW9KUy1iYXNlZCBcIiR7c2VsZi5wbGF5ZXJUeXBlfVwiIFBsYXllci5cXG5SZWFzb246ICR7ZS5tZXNzYWdlfWApXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIG9uVmlkZW9KU0Vycm9yIChlKSB7XG4gICAgZXJyb3IoTkFNRSwgJ29uVmlkZW9KU0Vycm9yOiAnICsgSlNPTi5zdHJpbmdpZnkoZSwgbnVsbCwgMikpXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX0ZBSUwsIG51bGwsIGUpKVxuICB9XG5cbiAgb25WaWRlb0pTTG9hZGVkRGF0YSAoKSB7XG4gICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX1NUQVJUKSlcbiAgfVxuXG4gIG9uVmlkZW9KU0VuZGVkICgpIHtcbiAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU1RPUCkpXG4gIH1cblxuICBvblZpZGVvSlNMb2FkZWRNZXRhZGF0YSAoKSB7fVxuXG4gIG9uVmlkZW9KU1RpbWVVcGRhdGUgKCkge31cblxuICBvblZpZGVvSlNVc2VyQWN0aXZlICgpIHt9XG5cbiAgb25WaWRlb0pTVXNlckluYWN0aXZlICgpIHt9XG5cbiAgb25WaWRlb0pTVm9sdW1lQ2hhbmdlICgpIHt9XG5cbiAgYWRkU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyIChoYW5kbGVyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAvLyB1bnN1cHBvcnRlZCBhdCB0aGUgbW9tZW50LlxuICB9XG5cbiAgcmVtb3ZlU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyIChoYW5kbGVyKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAvLyB1bnN1cHBvcnRlZCBhdCB0aGUgbW9tZW50LlxuICB9XG5cbiAgc2VuZFRvU2hhcmVkT2JqZWN0IChuYW1lLCBjYWxsTmFtZSwgbWVzc2FnZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgLy8gdW5zdXBwb3J0ZWQgYXQgdGhlIG1vbWVudC5cbiAgfVxuXG4gIHNlbmRQcm9wZXJ0eVRvU2hhcmVkT2JqZWN0IChuYW1lLCBrZXksIHZhbHVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAvLyB1bnN1cHBvcnRlZCBhdCB0aGUgbW9tZW50LlxuICB9XG5cbiAgZ2V0UmVtb3RlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAvLyB1bnN1cHBvcnRlZCBhdCB0aGUgbW9tZW50LlxuICB9XG5cbiAgY29ubmVjdFRvU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAvLyB1bnN1cHBvcnRlZCBhdCB0aGUgbW9tZW50LlxuICB9XG5cbiAgZGlzY29ubmVjdEZyb21TaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIC8vIHVuc3VwcG9ydGVkIGF0IHRoZSBtb21lbnQuXG4gIH1cblxuICBnZXRQbGF5ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLnZpZGVvanNcbiAgfVxuXG4gIGdldFR5cGUgKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXllclR5cGVcbiAgfVxuXG4gIGRpc2Nvbm5lY3QgKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnZpZGVvLnBhdXNlKClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBuYWRhLlxuICAgIH1cbiAgICB0aGlzLmNsZWFudXAoKVxuICAgIHRoaXMuY2xlYW51cFZpZGVvSlMoKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VIYW5kbGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9zdWJzY3JpYmVyL3ZpZGVvanMtc291cmNlLWhhbmRsZXIuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2RpZmllcyB0YXJnZXQgYG9iamVjdGAgaW4gcGxhY2Ugd2l0aCBhIG5hbWVzcGFjZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBjb25zdCBkZWVwRGVmaW5lID0gKG9iamVjdCwgcGF0aHMsIHZhbHVlKSA9PiB7XG4gIGxldCBpID0gMFxuICBsZXQgdGFpbCA9IG9iamVjdFxuICBjb25zdCBwcm9wID0gcGF0aHMucG9wKClcbiAgY29uc3QgbGVuZ3RoID0gcGF0aHMubGVuZ3RoXG4gIGZvciAoaTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHBhdGggPSBwYXRoc1tpXVxuICAgIHRhaWxbcGF0aF0gPSB0YWlsW3BhdGhdIHx8IHt9XG4gICAgdGFpbCA9IHRhaWxbcGF0aF1cbiAgfVxuICB0YWlsW3Byb3BdID0gdmFsdWVcbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3V0aWwvb2JqZWN0LmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IFZpZGVvSlNTdWJzY3JpYmVyIGZyb20gJy4vcmVkNXByby1ydG1wLXZpZGVvanMnXG5pbXBvcnQgUjVMaXZlU3Vic2NyaWJlciBmcm9tICcuL3JlZDVwcm8tcnRtcC1saXZlJ1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9SVE1QU3Vic2NyaWJlclByb3h5J1xuXG5jbGFzcyBSVE1QU3Vic2NyaWJlclByb3h5IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX3ZpZXcgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9ib3VuZEJ1YmJsZVN1YkltcGxFdmVudCA9IHRoaXMuYnViYmxlU3Vic2NyaWJlckV2ZW50LmJpbmQodGhpcylcbiAgfVxuXG4gIGluaXQgKG9wdGlvbnMpIHtcbiAgICBsZXQgaW1wbFxuICAgIGRlYnVnKE5BTUUsIGBPcHRpb25zIHByb3BlcnR5IGZvciB1c2VWaWRlb0pTOiAke29wdGlvbnMudXNlVmlkZW9KU30uYClcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgndXNlVmlkZW9KUycpICYmIHR5cGVvZiBvcHRpb25zLnVzZVZpZGVvSlMgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnVzZVZpZGVvSlMpIHtcbiAgICAgIGRlYnVnKE5BTUUsICdEZWZhdWx0IHRvIFJUTVBTdWJzY3JpYmVyIHVzaW5nIHZpZGVvanMgc3VwcG9ydC4nKVxuICAgICAgaW1wbCA9IG5ldyBWaWRlb0pTU3Vic2NyaWJlcigpXG4gICAgICBpbXBsLm9uKCcqJywgdGhpcy5fYm91bmRCdWJibGVTdWJJbXBsRXZlbnQpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZGVidWcoTkFNRSwgJ0RlZmF1bHRpbmcgdG8gUlRNUFN1YnNjcmliZXIgdXNpbmcgY3VzdG9tIGxpdmUgU1dGLicpXG4gICAgICBpbXBsID0gbmV3IFI1TGl2ZVN1YnNjcmliZXIoKVxuICAgICAgaW1wbC5vbignKicsIHRoaXMuX2JvdW5kQnViYmxlU3ViSW1wbEV2ZW50KVxuICAgIH1cbiAgICBpZiAodGhpcy5fdmlldykge1xuICAgICAgaW1wbC5zZXRWaWV3KHRoaXMuX3ZpZXcpXG4gICAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIHJldHVybiBpbXBsLmluaXQob3B0aW9ucylcbiAgfVxuXG4gIHNldFZpZXcgKHZpZXcpIHtcbiAgICB0aGlzLl92aWV3ID0gdmlld1xuICB9XG5cbiAgYnViYmxlU3Vic2NyaWJlckV2ZW50IChzdWJzY3JpYmVyRXZlbnQpIHtcbiAgICB0aGlzLnRyaWdnZXIuY2FsbCh0aGlzLCBzdWJzY3JpYmVyRXZlbnQpXG4gIH1cblxuICBnZXRPcHRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9uc1xuICB9XG5cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuICdSVE1QU3Vic2NyaWJlclByb3h5J1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUlRNUFN1YnNjcmliZXJQcm94eVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvc3Vic2NyaWJlci9yZWQ1cHJvLXJ0bXAuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgVmlkZW9KU0hhbmRsZXIgZnJvbSAnLi92aWRlb2pzLXNvdXJjZS1oYW5kbGVyJ1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9SVE1QU3Vic2NyaWJlcidcbmNvbnN0IHZpZGVvanMgPSBlbnZpcm9ubWVudC5nZXRWaWRlb0pzKClcbmNvbnN0IGRlZmF1bHRNaW1lVHlwZSA9ICdydG1wL2ZsdidcbmNvbnN0IGRlZmF1bHRGbGFzaFZlcnNpb24gPSAnMTAuMC4wJ1xuY29uc3QgZGVmYXVsdFNXRiA9ICdsaWIvcmVkNXByby9yZWQ1cHJvLXZpZGVvLWpzLnN3ZidcbmNvbnN0IG9wdGlvbnNUb1J0bXBVUkwgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBwcm90b2NvbCA9IG9wdGlvbnMucnRtcHByb3RvY29sID8gb3B0aW9ucy5ydG1wcHJvdG9jb2wgOiBvcHRpb25zLnByb3RvY29sXG4gIGNvbnN0IHBvcnQgPSBvcHRpb25zLnJ0bXBwb3J0ID8gb3B0aW9ucy5ydG1wcG9ydCA6IG9wdGlvbnMucG9ydFxuICBjb25zdCBhcHBFbmRwb2ludCA9IG9wdGlvbnMuY29udGV4dCA/IFtvcHRpb25zLmFwcCwgb3B0aW9ucy5jb250ZXh0XS5qb2luKCcvJykgOiBvcHRpb25zLmFwcFxuICByZXR1cm4gYCR7cHJvdG9jb2x9Oi8vJHtvcHRpb25zLmhvc3R9OiR7cG9ydH0vJHthcHBFbmRwb2ludH0vJHtvcHRpb25zLnN0cmVhbU5hbWV9YFxufVxuXG5jbGFzcyBWaWRlb0pTU3Vic2NyaWJlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9vcHRpb25zID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdmlldyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fYm91bmRCdWJibGVTdWJzY3JpYmVyRXZlbnRzID0gdGhpcy5idWJibGVTdWJzY3JpYmVyRXZlbnRzLmJpbmQodGhpcylcbiAgfVxuXG4gIGJ1YmJsZVN1YnNjcmliZXJFdmVudHMgKGV2ZW50KSB7XG4gICAgdGhpcy50cmlnZ2VyLmNhbGwodGhpcywgZXZlbnQpXG4gIH1cblxuICBpbml0IChvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBpZiAoIWVudmlyb25tZW50LnN1cHBvcnRzRmxhc2hWZXJzaW9uKGRlZmF1bHRGbGFzaFZlcnNpb24pKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoYENvdWxkIG5vdCByZXNvbHZlIFJUTVBTdWJzY3JpYmVyIGluc3RhbmNlLiBSZXF1aXJlcyBtaW5pbXVtIEZsYXNoIFBsYXllciBpbnN0YWxsIG9mICR7ZGVmYXVsdEZsYXNoVmVyc2lvbn0uYClcbiAgICB9IGVsc2UgaWYgKCFlbnZpcm9ubWVudC5nZXRWaWRlb0pzKCkpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdCgnQ291bGQgbm90IHJlc29sdmUgUlRNUFN1YnNjcmliZXIgaW5zdGFuY2UuIFJlcXVpcmVzIHZpZGVvanMgbGlicmFyeS4nKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0aGlzKVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgc2V0VmlldyAodmlldykge1xuICAgIHRoaXMuX3ZpZXcgPSB2aWV3XG4gICAgaWYgKHRoaXMuX3ZpZGVvanNIYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyLm9mZignKicsIHRoaXMuX2JvdW5kQnViYmxlU3Vic2NyaWJlckV2ZW50cylcbiAgICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyLmRpc2Nvbm5lY3QoKVxuICAgICAgdGhpcy5fdmlkZW9qc0hhbmRsZXIgPSB1bmRlZmluZWRcbiAgICB9XG4gICAgaWYgKHZpZXcpIHtcbiAgICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyID0gbmV3IFZpZGVvSlNIYW5kbGVyKHRoaXMuX3ZpZXcudmlldywgdGhpcy5nZXRUeXBlKCkpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwbGF5IChzdHJlYW1OYW1lID0gbnVsbCwgcHJvbWlzZSA9IG51bGwpIHtcbiAgICBjb25zdCBwID0gcHJvbWlzZSB8fCBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUgPSBzdHJlYW1OYW1lIHx8IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZVxuICAgIGxldCB1cmwgPSBvcHRpb25zVG9SdG1wVVJMKHRoaXMuX29wdGlvbnMpXG4gICAgbGV0IHR5cGUgPSBkZWZhdWx0TWltZVR5cGVcbiAgICBsZXQgc3dmVVJMID0gZGVmYXVsdFNXRlxuICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHR5cGUgPSB0aGlzLl9vcHRpb25zLnJ0bXBNaW1lVHlwZSB8fCB0aGlzLl9vcHRpb25zLm1pbWVUeXBlIHx8IHR5cGVcbiAgICAgIHN3ZlVSTCA9IHRoaXMuX29wdGlvbnMuc3dmIHx8IHN3ZlVSTFxuICAgIH1cbiAgICBkZWJ1ZyhOQU1FLCBgW3BsYXldOiBVUkwoJHt1cmx9KS5gKVxuICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyLm9uKCcqJywgdGhpcy5fYm91bmRCdWJibGVTdWJzY3JpYmVyRXZlbnRzKVxuICAgIHRoaXMuX3ZpZGVvanNIYW5kbGVyLmFkZFNvdXJjZSh1cmwsIHR5cGUsIHZpZGVvanMsIHN3ZlVSTClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcC5yZXNvbHZlKHRoaXMpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKHAucmVqZWN0KVxuICAgIHJldHVybiBwLmhhc093blByb3BlcnR5KCdwcm9taXNlJykgPyBwLnByb21pc2UgOiBwXG4gIH1cblxuICBzdG9wICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3N0b3BdJylcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl92aWRlb2pzSGFuZGxlci5vZmYoJyonLCB0aGlzLl9ib3VuZEJ1YmJsZVN1YnNjcmliZXJFdmVudHMpXG4gICAgICB0aGlzLl92aWRlb2pzSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlZmVycmVkLnJlamVjdChlLm1lc3NhZ2UpXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBnZXRDb25uZWN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlkZW9qc0hhbmRsZXJcbiAgfVxuXG4gIGdldE9wdGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zXG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gJ1JUTVAgLSBWaWRlb0pTJ1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmlkZW9KU1N1YnNjcmliZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3N1YnNjcmliZXIvcmVkNXByby1ydG1wLXZpZGVvanMuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuLi9jb3JlL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnQgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCBMaXZlU291cmNlSGFuZGxlciBmcm9tICcuL2xpdmUtc291cmNlLWhhbmRsZXInXG5pbXBvcnQgeyBTdWJzY3JpYmVyRXZlbnRUeXBlcywgUlRNUFN1YnNjcmliZXJFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgeyBkZWJ1ZywgZXJyb3IgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9MaXZlUlRNUFN1YmNyaWJlcidcbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBwcm90b2NvbDogJ3J0bXAnLFxuICBwb3J0OiAxOTM1LFxuICB3aWR0aDogMzIwLCAvLyB2aWRlbyBwbGF5YmFja1xuICBoZWlnaHQ6IDI0MCwgLy8gdmlkZW8gcGxheWJhY2tcbiAgZW1iZWRXaWR0aDogJzEwMCUnLCAvLyBET00gZGlzcGxheSBzdHlsZVxuICBlbWJlZEhlaWdodDogJzEwMCUnLCAvLyBET00gZGlzcGxheSBzdHlsZVxuICBtaW5GbGFzaFZlcnNpb246ICcxMC4wLjAnLFxuICBzd2Y6ICdsaWIvcmVkNXByby9yZWQ1cHJvLXN1YnNjcmliZXIuc3dmJyxcbiAgc3dmb2JqZWN0VVJMOiAnbGliL3JlZDVwcm8vcmVkNXByby1zdWJzY3JpYmVyLnN3ZicsXG4gIHByb2R1Y3RJbnN0YWxsVXJsOiAnbGliL3N3Zm9iamVjdC9wbGF5ZXJQcm9kdWN0SW5zdGFsbC5zd2YnXG59XG5cbmNsYXNzIFI1TGl2ZVN1YnNjcmliZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fb3B0aW9ucyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3ZpZXcgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zb3VyY2VIYW5kbGVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fZWxlbWVudElkID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcGxheWJhY2tQcm9taXNlID0gdW5kZWZpbmVkXG4gIH1cblxuICBpbml0IChvcHRpb25zKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGNvbnN0IHZlcnNpb24gPSBvcHRpb25zLm1pbkZsYXNoVmVyc2lvbiB8fCBkZWZhdWx0T3B0aW9ucy5taW5GbGFzaFZlcnNpb25cbiAgICBpZiAoIWVudmlyb25tZW50LnN1cHBvcnRzRmxhc2hWZXJzaW9uKHZlcnNpb24pKSB7XG4gICAgICBkZWZlcnJlZC5yZWplY3QoYENvdWxkIG5vdCByZXNvbHZlIExpdmVSVE1QU3Vic2NyaWJlciBpbnN0YW5jZS4gUmVxdWlyZXMgbWluaW11bSBGbGFzaCBQbGF5ZXIgaW5zdGFsbCBvZiAke3ZlcnNpb259LmApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcbiAgICAgIHRyeSB7XG4gICAgICAgIGVudmlyb25tZW50LmluamVjdFNjcmlwdCh0aGlzLl9vcHRpb25zLnN3Zm9iamVjdFVSTClcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhOQU1FLCAnU1dGT2JqZWN0IGVtYmVkZGVkLicpXG4gICAgICAgICAgICBpZiAoc2VsZi5fc291cmNlSGFuZGxlcikge1xuICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fc291cmNlSGFuZGxlci5hZGRTb3VyY2Uoc2VsZi5fZWxlbWVudElkLCBzZWxmLl9vcHRpb25zKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoc2VsZilcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcy5FTUJFRF9TVUNDRVNTLCBzZWxmKSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgZXJyb3IoTkFNRSwgYENvdWxkIG5vdCBlbWJlZCBGbGFzaC1iYXNlZCBSVE1QIFBsYXllci4gUmVhc29uOiAke2Vycn1gKVxuICAgICAgICAgICAgaWYgKHNlbGYuX3NvdXJjZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgc2VsZi5fc291cmNlSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycilcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFJUTVBTdWJzY3JpYmVyRXZlbnRUeXBlcy5FTUJFRF9GQUlMVVJFLCBzZWxmKSlcbiAgICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoYENvdWxkIG5vdCBpbmplY3QgRmxhc2gtYmFzZWQgUGxheWVyIGludG8gdGhlIHBhZ2UuIFJlYXNvbjogJHtlLm1lc3NhZ2V9YClcbiAgICAgICAgc2VsZi50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRNUFN1YnNjcmliZXJFdmVudFR5cGVzLkVNQkVEX0ZBSUxVUkUsIHNlbGYpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgc2V0VmlldyAodmlldywgZWxlbWVudElkKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICB0aGlzLl92aWV3ID0gdmlld1xuICAgIHRoaXMuX2VsZW1lbnRJZCA9IGVsZW1lbnRJZFxuICAgIGlmICh0aGlzLl9zb3VyY2VIYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuZGlzY29ubmVjdCgpXG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyID0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgaWYgKHZpZXcpIHtcbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSBuZXcgTGl2ZVNvdXJjZUhhbmRsZXIodGhpcy5fdmlldy52aWV3LCB0aGlzLmdldFR5cGUoKSlcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuYWRkU291cmNlKHRoaXMuX2VsZW1lbnRJZCwgdGhpcy5fb3B0aW9ucylcbiAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoUlRNUFN1YnNjcmliZXJFdmVudFR5cGVzLkVNQkVEX0ZBSUxVUkUsIHNlbGYpKVxuXG4gICAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIF9lc3RhYmxpc2hFeHRJbnRIYW5kbGVycyAoKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWVcbiAgICBjb25zdCBpbnZva2VGbiA9IChsYWJlbCkgPT4ge1xuICAgICAgcmV0dXJuIFsnc3Vic2NyaWJlcicsIGxhYmVsLCBpZF0uam9pbignXycpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9Db25uZWN0Q2xvc2VkJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVElPTl9DTE9TRUQsIHRoaXMpKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9Db25uZWN0U3VjY2VzcycpXSA9ICgpID0+IHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLkNPTk5FQ1RfU1VDQ0VTUywgdGhpcykpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZVN0b3AnKV0gPSAoKSA9PiB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU1RPUCwgdGhpcykpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZU1ldGFkYXRhJyldID0gKG1ldGFkYXRhKSA9PiB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfTUVUQURBVEEsIHRoaXMsIG1ldGFkYXRhKSlcbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvU3Vic2NyaWJlU2VuZEludm9rZScpXSA9IChwYXlsb2FkKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfU0VORF9JTlZPS0UsIHRoaXMsIHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UocGF5bG9hZCkgOiBwYXlsb2FkKSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZVN0YXJ0JyldID0gKCkgPT4ge1xuICAgICAgdGhpcy5fcGxheWJhY2tQcm9taXNlLnJlc29sdmUodGhpcylcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgU3Vic2NyaWJlckV2ZW50KFN1YnNjcmliZXJFdmVudFR5cGVzLlNVQlNDUklCRV9TVEFSVCwgdGhpcykpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9Db25uZWN0RmFpbHVyZScpXSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3BsYXliYWNrUHJvbWlzZS5yZWplY3QoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzKSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1N1YnNjcmliZUludmFsaWROYW1lJyldID0gKCkgPT4ge1xuICAgICAgdGhpcy5fcGxheWJhY2tQcm9taXNlLnJlamVjdChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfSU5WQUxJRF9OQU1FKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTdWJzY3JpYmVyRXZlbnQoU3Vic2NyaWJlckV2ZW50VHlwZXMuU1VCU0NSSUJFX0lOVkFMSURfTkFNRSwgdGhpcykpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9TdWJzY3JpYmVGYWlsJyldID0gKCkgPT4ge1xuICAgICAgdGhpcy5fcGxheWJhY2tQcm9taXNlLnJlamVjdChcIkZhaWxlZCB0byBzdGFydCBwbGF5YmFjayBzdHJlYW0uXCIpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFN1YnNjcmliZXJFdmVudChTdWJzY3JpYmVyRXZlbnRUeXBlcy5TVUJTQ1JJQkVfRkFJTCwgdGhpcykpXG4gICAgfVxuXG4gIH1cblxuICBwbGF5IChzdHJlYW1OYW1lID0gbnVsbCwgcHJvbWlzZSA9IG51bGwpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHRoaXMuX3BsYXliYWNrUHJvbWlzZSA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRoaXMuX2VzdGFibGlzaEV4dEludEhhbmRsZXJzKClcbiAgICByZXR1cm4gdGhpcy5fcGxheWJhY2tQcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIHN0b3AgKCkge1xuICAgIGNvbnN0IGNiID0gKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlLm1lc3NhZ2UpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3BsYXliYWNrUHJvbWlzZSA9IHVuZGVmaW5lZFxuICAgIHJldHVybiBuZXcgUHJvbWlzZShjYilcbiAgfVxuXG4gIGdldENvbm5lY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VIYW5kbGVyXG4gIH1cblxuICBnZXRPcHRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9uc1xuICB9XG5cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuICdSVE1QJ1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUjVMaXZlU3Vic2NyaWJlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvc3Vic2NyaWJlci9yZWQ1cHJvLXJ0bXAtbGl2ZS5qc1xuICoqLyIsIid1c2Ugc2NyaXB0J1xuXG5pbXBvcnQgKiBhcyBlbWJlZCBmcm9tICcuLi9lbnYvZW1iZWQnXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uL2xvZydcbmltcG9ydCBSVE1QU2hhcmVkT2JqZWN0SGFuZGxlciBmcm9tICcuLi9oZWxwZXIvc2hhcmVkb2JqZWN0LWhlbHBlci1ydG1wJ1xuXG5jb25zdCBOQU1FID0gJ1JUTVBMaXZlU291cmNlSGFuZGxlcidcbmNvbnN0IHRvSW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlLnBhcnNlSW50KDEwKVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKVxuICB9XG59XG5cbmNsYXNzIExpdmVTb3VyY2VIYW5kbGVyIHtcblxuICBjb25zdHJ1Y3RvciAodmlkZW8sIHR5cGUsIHNvUmVzcG9uZGVyID0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy52aWRlbyA9IHZpZGVvXG4gICAgdGhpcy5jbG9uZSA9IHRoaXMudmlkZW8uY2xvbmVOb2RlKHRydWUpXG4gICAgdGhpcy5ob2xkZXIgPSB0aGlzLnZpZGVvLnBhcmVudE5vZGVcbiAgICB0aGlzLnBsYXllclR5cGUgPSB0eXBlXG4gICAgdGhpcy5fc3dmSWQgPSBudWxsXG4gICAgdGhpcy5fc29SZXNwb25kZXIgPSBzb1Jlc3BvbmRlciB8fCBuZXcgUlRNUFNoYXJlZE9iamVjdEhhbmRsZXIoKVxuICB9XG5cbiAgY2xlYW5VcCAoKSB7XG4gICAgLy8gUmV0dXJuIHRvIHByaW9yIERPTSBtYW5pcHVsYXRpb24uXG4gICAgdGhpcy52aWRlby5yZW1vdmUoKVxuICAgIHRoaXMudmlkZW8gPSB0aGlzLmNsb25lLmNsb25lTm9kZSh0cnVlKVxuICAgIHRoaXMuaG9sZGVyLmFwcGVuZENoaWxkKHRoaXMudmlkZW8pXG4gIH1cblxuICBfc2V0VXBJbml0Q2FsbGJhY2sgKHByb21pc2UpIHtcbiAgICB3aW5kb3cuc2V0U3Vic2NyaWJlcklkID0gKHN1Y2Nlc3NJZCkgPT4ge1xuICAgICAgLy8gc3VjY2Vzc0lkID09PSBfb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgICBkZWJ1ZyhOQU1FLCBgRW1iZWQgYW5kIGluaXQoKSBjb21wbGV0ZSBmb3Igc3Vic2NyaWJlciBzd2YuIHN1Y2Nlc3NJZCgke3N1Y2Nlc3NJZH0pLmApXG4gICAgICBwcm9taXNlLnJlc29sdmUoc3VjY2Vzc0lkKVxuICAgICAgdGhpcy5fdGVhckRvd25Jbml0Q2FsbGJhY2soKVxuICAgIH1cbiAgICAvLyBUT0RPOiBTZXR1cCB0aW1lb3V0IHRvIHJlamVjdD9cbiAgfVxuXG4gIF90ZWFyRG93bkluaXRDYWxsYmFjayAoKSB7XG4gICAgd2luZG93LnNldEFjdGl2ZUlkID0gdW5kZWZpbmVkXG4gIH1cblxuICBhZGRTb3VyY2UgKHN3ZklkLCBvcHRpb25zLCBzd2ZVcmwgPSBudWxsLCBtaW5GbGFzaFZlcnNpb24gPSBudWxsKSB7XG4gICAgZGVidWcoTkFNRSwgJ1thZGRzb3VyY2VdJylcbiAgICB0aGlzLl9zd2ZJZCA9IHN3ZklkO1xuICAgIGNvbnN0IHNvUmVzcG9uZGVyID0gdGhpcy5fc29SZXNwb25kZXJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIG9wdGlvbnMuc3dmID0gc3dmVXJsIHx8IG9wdGlvbnMuc3dmXG4gICAgb3B0aW9ucy5taW5GbGFzaFZlcnNpb24gPSBtaW5GbGFzaFZlcnNpb24gfHwgb3B0aW9ucy5taW5GbGFzaFZlcnNpb25cbiAgICB0aGlzLl9zZXRVcEluaXRDYWxsYmFjayhkZWZlcnJlZClcbiAgICBlbWJlZC5kZWZpbmVFbWJlZEVsZW1lbnQodGhpcy52aWRlbywgdGhpcy5ob2xkZXIpXG4gICAgICAudGhlbihlbGVtZW50SWQgPT4ge1xuICAgICAgICBsZXQgZmxhc2h2YXJzID0ge1xuICAgICAgICAgIHN0cmVhbTogb3B0aW9ucy5zdHJlYW1OYW1lLFxuICAgICAgICAgIGFwcDogb3B0aW9ucy5jb250ZXh0ID8gYCR7b3B0aW9ucy5hcHB9LyR7b3B0aW9ucy5jb250ZXh0fWAgOiBvcHRpb25zLmFwcCxcbiAgICAgICAgICBob3N0OiBvcHRpb25zLmhvc3RcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5idWZmZXIgJiYgIWlzTmFOKE51bWJlcihvcHRpb25zLmJ1ZmZlcikpKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLmJ1ZmZlciA9IG9wdGlvbnMuYnVmZmVyXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggJiYgIWlzTmFOKG9wdGlvbnMud2lkdGgpKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLndpZHRoID0gdG9JbnQob3B0aW9ucy53aWR0aClcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5oZWlnaHQgJiYgIWlzTmFOKG9wdGlvbnMuaGVpZ2h0KSkge1xuICAgICAgICAgIGZsYXNodmFycy5oZWlnaHQgPSB0b0ludChvcHRpb25zLmhlaWdodClcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbWJlZFdpZHRoID09PSAnMTAwJScgfHwgb3B0aW9ucy5lbWJlZEhlaWdodCA9PT0gJzEwMCUnKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLmF1dG9zaXplID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb25uZWN0aW9uUGFyYW1zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGZsYXNodmFycy5jb25uZWN0aW9uUGFyYW1zID0gZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuY29ubmVjdGlvblBhcmFtcykpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtYmVkLmVtYmVkU3dmT2JqZWN0KHN3ZklkLCBvcHRpb25zLCBmbGFzaHZhcnMsIGVudmlyb25tZW50LmdldFN3Zk9iamVjdCgpLCBlbGVtZW50SWQpXG4gICAgICB9KVxuICAgICAgLnRoZW4oICgpID0+IHtcbiAgICAgICAgc29SZXNwb25kZXIuY29ubmVjdChzd2ZJZClcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZSA9PiBkZWZlcnJlZC5yZWplY3QoZSkpXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIGNvbm5lY3QgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbY29ubmVjdF0nKVxuICAgIHRyeSB7XG4gICAgICBlbnZpcm9ubWVudC5nZXRFbWJlZE9iamVjdCh0aGlzLl9zd2ZJZCkuY29ubmVjdCgpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAvLyBuYWRhLlxuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QgKCkge1xuICAgIGRlYnVnKE5BTUUsICdbZGlzY29ubmVjdF0nKVxuICAgIHRyeSB7XG4gICAgICBlbnZpcm9ubWVudC5nZXRFbWJlZE9iamVjdCgpLmRpc2Nvbm5lY3QoKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIG5hZGEuXG4gICAgfVxuICAgIHRoaXMuY2xlYW5VcCgpXG4gICAgdGhpcy5fc29SZXNwb25kZXIuZGlzY29ubmVjdCgpXG4gIH1cblxuICBhZGRTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5hZGRSZXNwb25zZUhhbmRsZXIoaGFuZGxlcilcbiAgfVxuXG4gIHJlbW92ZVNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLnJlbW92ZVJlc3BvbnNlSGFuZGxlcihoYW5kbGVyKVxuICB9XG5cbiAgc2VuZFRvU2hhcmVkT2JqZWN0IChuYW1lLCBjYWxsTmFtZSwgbWVzc2FnZSkge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLnNlbmRUb1NoYXJlZE9iamVjdChuYW1lLCBjYWxsTmFtZSwgbWVzc2FnZSlcbiAgfVxuXG4gIHNlbmRQcm9wZXJ0eVRvU2hhcmVkT2JqZWN0IChuYW1lLCBrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuc2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QobmFtZSwga2V5LCB2YWx1ZSlcbiAgfVxuXG4gIGdldFJlbW90ZVNoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmdldFJlbW90ZVNoYXJlZE9iamVjdChzaGFyZWRPYmplY3ROYW1lKVxuICB9XG5cbiAgY29ubmVjdFRvU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuY29ubmVjdFRvU2hhcmVkT2JqZWN0KHNoYXJlZE9iamVjdE5hbWUpXG4gIH1cblxuICBjbG9zZVNoYXJlZE9iamVjdCAoc2hhcmVkT2JqZWN0TmFtZSkge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmNsb3NlU2hhcmVkT2JqZWN0KHNoYXJlZE9iamVjdE5hbWUpXG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJUeXBlXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBMaXZlU291cmNlSGFuZGxlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvc3Vic2NyaWJlci9saXZlLXNvdXJjZS1oYW5kbGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcblxuZXhwb3J0IGNvbnN0IGRlZmluZUVtYmVkRWxlbWVudCA9ICh0YXJnZXRFbGVtZW50LCB0YXJnZXRQYXJlbnQpID0+IHtcbiAgbGV0IGRmZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICBjb25zdCBlbGVtZW50SWQgPSB0YXJnZXRFbGVtZW50LmlkXG4gIGlmICh0YXJnZXRFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlbycpIHtcbiAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBkaXYuaWQgPSBlbGVtZW50SWQgKyAnX3J0bXAnXG4gICAgdGFyZ2V0UGFyZW50LmFwcGVuZENoaWxkKGRpdilcbiAgICB0YXJnZXRFbGVtZW50LnJlbW92ZSgpXG4gICAgZGZkLnJlc29sdmUoZGl2LmlkKVxuICB9IGVsc2Uge1xuICAgIGRmZC5yZXNvbHZlKGVsZW1lbnRJZClcbiAgfVxuICByZXR1cm4gZGZkLnByb21pc2Vcbn1cblxuZXhwb3J0IGNvbnN0IGVtYmVkU3dmT2JqZWN0ID0gKGlkTmFtZSwgb3B0aW9ucywgZmxhc2h2YXJzLCBzd2ZvYmplY3QsIGVsZW1lbnRJZCkgPT4ge1xuICBsZXQgZGZkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gIGxldCBwYXJhbXMgPSB7XG4gICAgcXVhbGl0eTogJ2hpZ2gnLFxuICAgIGJnY29sb3I6ICcjMDAwJyxcbiAgICBhbGxvd3NjcmlwdGFjY2VzczogJ2Fsd2F5cycsXG4gICAgYWxsb3dmdWxsc2NyZWVuOiAndHJ1ZSdcbiAgfVxuICBsZXQgYXR0cmlidXRlcyA9IHtcbiAgICBpZDogaWROYW1lLFxuICAgIG5hbWU6IGlkTmFtZSxcbiAgICBhbGlnbjogJ21pZGRsZSdcbiAgfVxuICBpZiAoc3dmb2JqZWN0Lmhhc0ZsYXNoUGxheWVyVmVyc2lvbihvcHRpb25zLm1pbkZsYXNoVmVyc2lvbikpIHtcbiAgICBzd2ZvYmplY3QuZW1iZWRTV0YoXG4gICAgICBvcHRpb25zLnN3ZixcbiAgICAgIGVsZW1lbnRJZCxcbiAgICAgIG9wdGlvbnMuZW1iZWRXaWR0aCB8fCBvcHRpb25zLndpZHRoLFxuICAgICAgb3B0aW9ucy5lbWJlZEhlaWdodCB8fCBvcHRpb25zLmhlaWdodCxcbiAgICAgIG9wdGlvbnMubWluRmxhc2hWZXJzaW9uLFxuICAgICAgb3B0aW9ucy5wcm9kdWN0SW5zdGFsbFVSTCxcbiAgICAgIGZsYXNodmFycyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBkZmQucmVzb2x2ZSlcbiAgfSBlbHNlIHtcbiAgICBkZmQucmVqZWN0KCdGbGFzaCBQbGF5ZXIgVmVyc2lvbiBpcyBub3Qgc3VwcG9ydGVkLicpXG4gIH1cbiAgcmV0dXJuIGRmZC5wcm9taXNlXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9lbnYvZW1iZWQuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IHsgZGVidWcsIHdhcm4gfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9SVE1QU2hhcmVkT2JqZWN0SGFuZGxlcidcblxuY2xhc3MgUlRNUFNoYXJlZE9iamVjdEhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycyA9IFtdXG4gIH1cblxuICBhZGRSZXNwb25zZUhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLnB1c2goaGFuZGxlcilcbiAgfVxuXG4gIHJlbW92ZVJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIGxldCBpID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5sZW5ndGhcbiAgICBsZXQgckhhbmRsZXJcbiAgICB3aGlsZSgtLWkgPiAtMSkge1xuICAgICAgckhhbmRsZXIgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzW2ldXG4gICAgICBpZiAockhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5zcGxpY2UoaSwgMSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU2hhcmVkT2JqZWN0RXZlbnQgKGV2ZW50KSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzaGFyZWRvYmplY3Q6ZXZlbnRdJylcbiAgICBsZXQgaVxuICAgIGxldCBsZW5ndGggPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmxlbmd0aFxuICAgIGxldCBoYW5kbGVyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBoYW5kbGVyID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVyc1tpXVxuICAgICAgaWYgKGhhbmRsZXIucmVzcG9uZChKU09OLnBhcnNlKGV2ZW50KSkpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3NpZ25TaGFyZWRPYmplY3RSZXNwb25kZXIgKG5hbWUsIGVsKSB7XG4gICAgY29uc3QgX2hhbmRsZVNoYXJlZE9iamVjdEV2ZW50ID0gdGhpcy5oYW5kbGVTaGFyZWRPYmplY3RFdmVudC5iaW5kKHRoaXMpXG4gICAgY29uc3QgZWxJZCA9IGVsLmlkLnNwbGl0KCctJykuam9pbignXycpXG4gICAgY29uc3QgaGFuZGxlck5hbWUgPSBbJ2hhbmRsZVNoYXJlZE9iamVjdEV2ZW50JywgZWxJZF0uam9pbignXycpXG4gICAgZGVidWcoTkFNRSwgYFthc3NpZ246c2hhcmVkb2JqZWN0OnJlc3BvbmRlcl0gOjogJHtlbElkfWApXG4gICAgZGVidWcoTkFNRSwgYFtzaGFyZWRvamVjdDpyZXNwb25kZXJdIDo6ICR7aGFuZGxlck5hbWV9YClcbiAgICBlbC5zZXRTaGFyZWRPYmplY3RSZXNwb25kZXIobmFtZSwgaGFuZGxlck5hbWUpXG4gICAgZW52aXJvbm1lbnQuc2V0R2xvYmFsKGhhbmRsZXJOYW1lLCBfaGFuZGxlU2hhcmVkT2JqZWN0RXZlbnQpXG4gIH1cblxuICBjb25uZWN0IChzd2ZJZCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbnZpcm9ubWVudC5nZXRFbWJlZE9iamVjdChzd2ZJZClcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIHdhcm4oYENvdWxkIG5vdCBsb2NhdGUgZW1iZWRkZWQgRmxhc2ggb2JqZWN0IGZvciBpZDogJHtzd2ZJZH1gKVxuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QgKCkge1xuICAgIHdoaWxlICh0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMuc2hpZnQoKVxuICAgIH1cbiAgfVxuXG4gIHNlbmRUb1NoYXJlZE9iamVjdCAobmFtZSwgY2FsbE5hbWUsIG1lc3NhZ2UpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3NlbmRUb1NoYXJlZE9iamVjdF0nKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnNoYXJlZE9iamVjdFNlbmQobmFtZSwgY2FsbE5hbWUsIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IG1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSlcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oJ0NvdWxkIG5vdCBzZW5kIHRvIHNoYXJlZCBvYmplY3QgKCcgKyBuYW1lICsgJykuIEVycm9yOiAnICsgZS5tZXNzYWdlKVxuICAgIH1cbiAgfVxuXG4gIHNlbmRQcm9wZXJ0eVRvU2hhcmVkT2JqZWN0IChuYW1lLCBrZXksIHZhbHVlKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tzZW5kUHJvcGVydHlUb1NoYXJlZE9iamVjdF0nKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnNoYXJlZE9iamVjdFNlbmRQcm9wZXJ0eShuYW1lLCBrZXksIHZhbHVlKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgd2FybignQ291bGQgbm90IHNlbmQgdG8gc2hhcmVkIG9iamVjdCAoJyArIG5hbWUgKyAnKS4gRXJyb3I6ICcgKyBlLm1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgZ2V0UmVtb3RlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7XG4gICAgZGVidWcoTkFNRSwgJ1tnZXRSZW1vdGVTaGFyZWRPYmplY3RdJylcbiAgICB0cnkge1xuICAgICAgdGhpcy5hc3NpZ25TaGFyZWRPYmplY3RSZXNwb25kZXIoc2hhcmVkT2JqZWN0TmFtZSwgdGhpcy5fZWxlbWVudClcbiAgICAgIHRoaXMuX2VsZW1lbnQuZ2V0UmVtb3RlU2hhcmVkT2JqZWN0KHNoYXJlZE9iamVjdE5hbWUpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB3YXJuKCdDb3VsZCBub3QgZ2V0IHJlbW90ZSBzaGFyZWQgb2JqZWN0ICgnICsgbmFtZSArICcpLiBFcnJvcjogJyArIGUubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICBjb25uZWN0VG9TaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2Nvbm5lY3RUb1NoYXJlZE9iamVjdF0nKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNvbm5lY3RUb1NoYXJlZE9iamVjdChzaGFyZWRPYmplY3ROYW1lKVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgd2FybignQ291bGQgbm90IGNvbm5lY3QgdG8gc2hhcmVkIG9iamVjdCAoJyArIG5hbWUgKyAnKS4gRXJyb3I6ICcgKyBlLm1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgY2xvc2VTaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2Rpc2Nvbm5lY3RUb1NoYXJlZE9iamVjdF0nKVxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9lbGVtZW50LmRpc2Nvbm5lY3RGcm9tU2hhcmVkT2JqZWN0KHNoYXJlZE9iamVjdE5hbWUpXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB3YXJuKCdDb3VsZCBub3QgZGlzY29ubmVjdCB0byBzaGFyZWQgb2JqZWN0ICgnICsgbmFtZSArICcpLiBFcnJvcjogJyArIGUubWVzc2FnZSlcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBSVE1QU2hhcmVkT2JqZWN0SGFuZGxlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvaGVscGVyL3NoYXJlZG9iamVjdC1oZWxwZXItcnRtcC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuL3Byb21pc2UnXG5cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKClcblxuY29uc3QgcHZ0ID0gKGN0eCkgPT4ge1xuICBpZiAoIW1hcC5oYXMoY3R4KSkge1xuICAgIG1hcC5zZXQoY3R4LCB7fSlcbiAgfVxuXG4gIHJldHVybiBtYXAuZ2V0KGN0eClcbn1cblxuZXhwb3J0IGNsYXNzIEltcGxGYWN0b3J5T3JkZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmxpc3RvcmRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKiBsaXN0b3JkZXIgKGxpc3QpIHtcbiAgICAgICAgd2hpbGUgKGxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHlpZWxkIGxpc3Quc2hpZnQoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSgpKVxuXG4gICAgcHZ0KHRoaXMpLmZpbmQgPSAoaXRlcmF0b3IsIG1hcCwgb3B0aW9ucywgcHJvbWlzZSwgaW5pdEZuID0gbnVsbCkgPT4ge1xuICAgICAgY29uc3QgW3R5cGUsIEltcGxdID0gcHZ0KHRoaXMpLm5leHQoaXRlcmF0b3IsIG1hcClcbiAgICAgIGlmICghSW1wbCkge1xuICAgICAgICBwcm9taXNlLnJlamVjdCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcFxuICAgICAgICBsZXQgc3JjID0gb3B0aW9uc1t0eXBlXVxuICAgICAgICBzcmMgPSBzcmMgfHwgb3B0aW9uc1xuICAgICAgICBpZiAoaW5pdEZuKSB7XG4gICAgICAgICAgcCA9IG5ldyBJbXBsKClbaW5pdEZuXShzcmMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcCA9IG5ldyBJbXBsKHNyYylcbiAgICAgICAgfVxuICAgICAgICBwLnRoZW4oKGNvbmNyZXRlKSA9PiB7XG4gICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGNvbmNyZXRlKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgcHZ0KHRoaXMpLmZpbmQoaXRlcmF0b3IsIG1hcCwgb3B0aW9ucywgcHJvbWlzZSwgaW5pdEZuKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHB2dCh0aGlzKS5uZXh0ID0gKG9yZGVyLCBtYXApID0+IHtcbiAgICAgIGxldCBJbXBsXG4gICAgICBsZXQga2V5XG4gICAgICBjb25zdCBuZXh0ID0gb3JkZXIubmV4dCgpXG4gICAgICBpZiAoIW5leHQuZG9uZSkge1xuICAgICAgICBrZXkgPSBuZXh0LnZhbHVlXG4gICAgICAgIEltcGwgPSBtYXAuZ2V0KGtleSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBba2V5LCBJbXBsXVxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZSAob3JkZXIsIG1hcCwgb3B0aW9ucywgaW5pdEZuID0gbnVsbCkge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBwdnQodGhpcykuZmluZCh0aGlzLmxpc3RvcmRlcihvcmRlci5zbGljZSgpKSwgbWFwLCBvcHRpb25zLCBwcm9taXNlLCBpbml0Rm4pXG4gICAgcmV0dXJuIHByb21pc2UucHJvbWlzZVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1wbEZhY3RvcnlPcmRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvdXRpbC9pbXBsLWZhY3Rvcnktb3JkZXIuanNcbiAqKi8iLCIvKipcbiAqIE1haW4gZW50cnkgZm9yIGZhaWxvdmVyIHN1cHBvcnQgb2YgYWxsIHB1Ymxpc2hlciBpbXBsZW1lbnRhdGlvbnMuXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgSW1wbEZhY3RvcnlPcmRlciBmcm9tICcuLi91dGlsL2ltcGwtZmFjdG9yeS1vcmRlcidcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IFJUTVBQdWJsaXNoZXIgZnJvbSAnLi9yZWQ1cHJvLXJ0bXAnXG5pbXBvcnQgUlRDUHVibGlzaGVyIGZyb20gJy4vcmVkNXByby1ydGMnXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBQdWJsaXNoVHlwZXMgfSBmcm9tICcuLi9lbnVtL3B1Ymxpc2gnXG5pbXBvcnQgeyBkZWJ1Zywgd2FybiB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1B1Ymxpc2hlcidcbmNvbnN0IHB1Ymxpc2hGYWN0b3J5ID0gbmV3IEltcGxGYWN0b3J5T3JkZXIoKVxuY29uc3QgcHVibGlzaGVySW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gIGxldCBtYXAgPSBuZXcgTWFwKClcbiAgbWFwLnNldChQdWJsaXNoVHlwZXMuUlRDLCBSVENQdWJsaXNoZXIpXG4gIG1hcC5zZXQoUHVibGlzaFR5cGVzLlJUTVAsIFJUTVBQdWJsaXNoZXIpXG4gIHJldHVybiBtYXBcbn0oKSlcblxuY2xhc3MgUmVkNVByb1B1Ymxpc2hlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9vcHRpb25zID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdmlldyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9ib3VuZEJ1YmJsZVB1Ymxpc2hlckV2ZW50ID0gdGhpcy5idWJibGVQdWJsaXNoZXJFdmVudC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fb3JkZXIgPSBbXG4gICAgICBQdWJsaXNoVHlwZXMuUlRDLFxuICAgICAgUHVibGlzaFR5cGVzLlJUTVBcbiAgICBdXG4gIH1cblxuICBnZXRQdWJsaXNoT3JkZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmRlclxuICB9XG5cbiAgc2V0UHVibGlzaE9yZGVyIChvcmRlcikge1xuICAgIC8vIEFsbG93IGZvciBzdHJpbmcgdmFsdWUgdG8gZGVmaW5lIHNpbmdsZSBpdGVtIGluIG9yZGVyLlxuICAgIG9yZGVyID0gdHlwZW9mIG9yZGVyID09PSAnc3RyaW5nJyA/IFtvcmRlcl0gOiBvcmRlclxuXG4gICAgLy8gRmlsdGVyIG91dCB2YWx1ZXMgbm90IGF2YWlsYWJsZSBpbiBlbnVtZXJhdGlvbiBvZiBwbGF5YmFjayB0eXBlcy5cbiAgICBjb25zdCB0ID0gb3JkZXIuZmlsdGVyKGVudHJ5ID0+IHtcbiAgICAgIGxldCBrZXlcbiAgICAgIGZvciAoa2V5IGluIFB1Ymxpc2hUeXBlcykge1xuICAgICAgICBpZiAoUHVibGlzaFR5cGVzW2tleV0udG9Mb3dlckNhc2UoKSA9PT0gZW50cnkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0pLm1hcChlbnRyeSA9PiBlbnRyeS50b0xvd2VyQ2FzZSgpKVxuXG4gICAgLy8gRGVmaW5lIG5ldyBvcmRlci5cbiAgICB0aGlzLl9vcmRlciA9IFsuLi5uZXcgU2V0KHQpXVxuICAgIGRlYnVnKE5BTUUsIGBbb3JkZXJ1cGRhdGVdOiAke3RoaXMuX29yZGVyfWApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHNldFZpZXcgKHB1Ymxpc2hWaWV3KSB7XG4gICAgdGhpcy5fdmlldyA9IHB1Ymxpc2hWaWV3XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldFB1Ymxpc2hlckZyb21PcmRlciAob3JkZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHVibGlzaEZhY3RvcnkuY3JlYXRlKG9yZGVyLCBwdWJsaXNoZXJJbXBsLCBvcHRpb25zLCAnaW5pdCcpXG4gIH1cblxuICBpbml0IChvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBkZWJ1ZyhOQU1FLCAnW3B1Ymxpc2hdJylcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuZ2V0UHVibGlzaGVyRnJvbU9yZGVyKHRoaXMuX29yZGVyLCB0aGlzLl9vcHRpb25zKVxuICAgICAgLnRoZW4ocHVibGlzaGVyID0+IHtcbiAgICAgICAgdGhpcy5fY3VycmVudFB1Ymxpc2hlciA9IHB1Ymxpc2hlclxuICAgICAgICB0aGlzLl9jdXJyZW50UHVibGlzaGVyLnNldFZpZXcodGhpcy5fdmlldylcbiAgICAgICAgdGhpcy5fY3VycmVudFB1Ymxpc2hlci5vbignKicsIHRoaXMuX2JvdW5kQnViYmxlUHVibGlzaGVyRXZlbnQpXG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodGhpcy5fY3VycmVudFB1Ymxpc2hlcilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgd2FybihOQU1FLCBgW3B1Ymxpc2hlcnJvcl06IENvdWxkIG5vdCBpbXBsZW1lbnQgYSBwdWJsaXNoZXI6ICR7ZXJyfWApXG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpXG4gICAgICB9KVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBzdG9wICgpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGlmICghdGhpcy5fY3VycmVudFB1Ymxpc2hlcikge1xuICAgICAgd2FybihOQU1FLCAnW3N0b3BdOiBDb3VsZCBub3QgaW52b2tlIHN0b3AoKSBvbiB1bmRlZmluZWQgcHVibGlzaGVyLicpXG4gICAgICBkZWZlcnJlZC5yZWplY3QoJ0EgY3VycmVudCBwdWJsaXNoZXIgaXMgbm90IGF2YWlsYWJsZSB0byBpc3N1ZSBhIDpzdG9wKCkgY29tbWFuZCB0by4nKVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZyhOQU1FLCAnW3N0b3BdOiBJbnZva2luZyBzdG9wIG9uIGhlbGQgcHVibGlzaGVyJylcbiAgICAgIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIudW5wdWJsaXNoKClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGRlYnVnKE5BTUUsICdbc3RvcHN1Y2Nlc3NdJylcbiAgICAgICAgICB0aGlzLl9jdXJyZW50UHVibGlzaGVyLm9mZignKicsIHRoaXMuX2JvdW5kQnViYmxlUHVibGlzaGVyRXZlbnQpXG4gICAgICAgICAgdGhpcy5fY3VycmVudFB1Ymxpc2hlciA9IHVuZGVmaW5lZFxuICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICBkZWJ1ZyhOQU1FLCBgW3N0b3BlcnJvcl06ICR7ZXJyfWApXG4gICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQdWJsaXNoZXIub2ZmKCcqJywgdGhpcy5fYm91bmRCdWJibGVQdWJsaXNoZXJFdmVudClcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY3VycmVudFB1Ymxpc2hlciA9IHVuZGVmaW5lZFxuICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnIpXG4gICAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBidWJibGVQdWJsaXNoZXJFdmVudCAocHVibGlzaGVyRXZlbnQpIHtcbiAgICB0aGlzLnRyaWdnZXIuY2FsbCh0aGlzLCBwdWJsaXNoZXJFdmVudClcbiAgfVxuXG4gIGdldCBwdWJsaXNoVHlwZXMgKCkge1xuICAgIHJldHVybiBQdWJsaXNoVHlwZXNcbiAgfVxuXG4gIGdldCBjdXJyZW50UHVibGlzaGVyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFB1Ymxpc2hlclxuICB9XG5cbn1cblxuZXhwb3J0IHsgUmVkNVByb1B1Ymxpc2hlciwgUlRNUFB1Ymxpc2hlciwgUlRDUHVibGlzaGVyIH1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3B1Ymxpc2hlci9pbmRleC5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2NvcmUvZXZlbnQtZW1pdHRlcidcbmltcG9ydCB7IFB1Ymxpc2hlckV2ZW50IH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5pbXBvcnQgeyBEZWZlcnJlZFByb21pc2UgfSBmcm9tICcuLi91dGlsL3Byb21pc2UnXG5pbXBvcnQgeyBQdWJsaXNoVHlwZXMgfSBmcm9tICcuLi9lbnVtL3B1Ymxpc2gnXG5pbXBvcnQgUHVibGlzaGVyU291cmNlSGFuZGxlciBmcm9tICcuL3B1Yi1zb3VyY2UtaGFuZGxlcidcbmltcG9ydCB7IFB1Ymxpc2hlckV2ZW50VHlwZXMsIFJUTVBQdWJsaXNoZXJFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQnXG5pbXBvcnQgeyBkZWJ1ZywgZXJyb3IgfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9SVE1QUHVibGlzaGVyJ1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHByb3RvY29sOiAncnRtcCcsXG4gIHBvcnQ6IDE5MzUsXG4gIHN0cmVhbU1vZGU6ICdsaXZlJyxcbiAgd2lkdGg6IDMyMCwgLy8gY2FtZXJhL3ZpZGVvXG4gIGhlaWdodDogMjQwLCAvLyBjYW1lcmEvdmlkZW9cbiAgZW1iZWRXaWR0aDogJzEwMCUnLCAvLyBET00gZGlzcGxheSBzdHlsZVxuICBlbWJlZEhlaWdodDogJzEwMCUnLCAvLyBET00gZGlzcGxheSBzdHlsZVxuICBtaW5GbGFzaFZlcnNpb246ICcxMC4wLjAnLFxuICBzd2Y6ICdsaWIvcmVkNXByby9yZWQ1cHJvLXB1Ymxpc2hlci5zd2YnLFxuICBzd2ZvYmplY3RVUkw6ICdsaWIvc3dmb2JqZWN0L3N3Zm9iamVjdC5qcycsXG4gIHByb2R1Y3RJbnN0YWxsVVJMOiAnbGliL3N3Zm9iamVjdC9wbGF5ZXJQcm9kdWN0SW5zdGFsbC5zd2YnXG59XG5cbmNsYXNzIFJUTVBQdWJsaXNoZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fb3B0aW9ucyA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3ZpZXcgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zb3VyY2VIYW5kbGVyID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fZWxlbWVudElkID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fY29ubmVjdEZ1dHVyZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgaW5pdCAob3B0aW9ucykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCB2ZXJzaW9uID0gb3B0aW9ucy5taW5GbGFzaFZlcnNpb24gfHwgZGVmYXVsdE9wdGlvbnMubWluRmxhc2hWZXJzaW9uXG4gICAgaWYgKCFlbnZpcm9ubWVudC5zdXBwb3J0c0ZsYXNoVmVyc2lvbih2ZXJzaW9uKSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KGBDb3VsZCBub3QgcmVzb2x2ZSBSVE1QUHVibGlzaGVyIGluc3RhbmNlLiBSZXF1aXJlcyBtaW5pbXVtIEZsYXNoIFBsYXllciBpbnN0YWxsIG9mICR7dmVyc2lvbn1gKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcbiAgICAgIHRyeSB7XG4gICAgICAgIGVudmlyb25tZW50LmluamVjdFNjcmlwdCh0aGlzLl9vcHRpb25zLnN3Zm9iamVjdFVSTClcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhOQU1FLCAnU1dGT2JqZWN0IGVtYmVkZGVkLicpXG4gICAgICAgICAgICBpZiAoc2VsZi5fc291cmNlSGFuZGxlcikge1xuICAgICAgICAgICAgICBkZWJ1ZyhOQU1FLCAnUHVibGlzaCBoYW5kbGVyIGVzdGFibGlzaGVkLicpXG4gICAgICAgICAgICAgIHJldHVybiBzZWxmLl9zb3VyY2VIYW5kbGVyLmFkZFNvdXJjZShzZWxmLl9lbGVtZW50SWQsIHNlbGYuX29wdGlvbnMpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWJ1ZyhOQU1FLCAnUHVibGlzaCBoYW5kbGVyIG5vdCBlc3RhYmxpc2hlZC4nKVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oKCkgPT4gZGVmZXJyZWQucmVzb2x2ZShzZWxmKSlcbiAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGVycm9yKE5BTUUsIGBDb3VsZCBub3QgZW1iZWQgRmxhc2gtYmFzZWQgUlRNUCBQdWJsaXNoZXIuIFJlYXNvbjogJHtlcnJ9YClcbiAgICAgICAgICAgIGlmIChzZWxmLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgIHNlbGYuX3NvdXJjZUhhbmRsZXIuZGlzY29ubmVjdCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKVxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChSVE1QUHVibGlzaGVyRXZlbnRUeXBlcy5FTUJFRF9GQUlMVVJFLCBzZWxmKSlcbiAgICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoYENvdWxkIG5vdCBpbmplY3QgRmxhc2gtYmFzZWQgUHVibGlzaGVyIGludG8gdGhlIHBhZ2UuIFJlYXNvbjogJHtlLm1lc3NhZ2V9YClcbiAgICAgICAgc2VsZi50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChSVE1QUHVibGlzaGVyRXZlbnRUeXBlcy5FTUJFRF9GQUlMVVJFLCBzZWxmKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2VcbiAgfVxuXG4gIF9zZXRVcENvbm5lY3RDYWxsYmFjayAocHJvbWlzZSkge1xuICAgIHdpbmRvdy5zZXRBY3RpdmVJZCA9IChzdWNjZXNzSWQpID0+IHtcbiAgICAgIC8vIHN1Y2Nlc3NJZCA9PT0gX29wdGlvbnMuc3RyZWFtTmFtZVxuICAgICAgZGVidWcoTkFNRSwgYEVtYmVkIGFuZCBjb25uZWN0KCkgY29tcGxldGUgZm9yIHB1Ymxpc2hlciBzd2YuIHN1Y2Nlc3NJZCgke3N1Y2Nlc3NJZH0pLmApXG4gICAgICBwcm9taXNlLnJlc29sdmUoc3VjY2Vzc0lkKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChSVE1QUHVibGlzaGVyRXZlbnRUeXBlcy5FTUJFRF9TVUNDRVNTLCB0aGlzKSlcbiAgICAgIHRoaXMuX3RlYXJEb3duQ29ubmVjdENhbGxiYWNrKClcbiAgICB9XG4gICAgLy8gVE9ETzogU2V0dXAgdGltZW91dCB0byByZWplY3Q/XG4gIH1cblxuICBfdGVhckRvd25Db25uZWN0Q2FsbGJhY2sgKCkge1xuICAgIHdpbmRvdy5zZXRBY3RpdmVJZCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgX2VzdGFibGlzaEV4dEludEhhbmRsZXJzICgpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZVxuICAgIGNvbnN0IGludm9rZUZuID0gKGxhYmVsKSA9PiB7XG4gICAgICByZXR1cm4gWydwdWJsaXNoZXInLCBsYWJlbCwgaWRdLmpvaW4oJ18nKVxuICAgIH1cbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvQ29ubmVjdENsb3NlZCcpXSA9ICgpID0+IHtcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUSU9OX0NMT1NFRCwgdGhpcykpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9Db25uZWN0U3VjY2VzcycpXSA9ICgpID0+IHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX1NVQ0NFU1MsIHRoaXMpKVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9VbnB1Ymxpc2hTdWNjZXNzJyldID0gKCkgPT4gdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlVOUFVCTElTSF9TVUNDRVNTLCB0aGlzKSlcbiAgICB3aW5kb3dbaW52b2tlRm4oJ3I1cHJvUHVibGlzaFN0YXJ0JyldID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdEZ1dHVyZS5yZXNvbHZlKHRoaXMpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9TVEFSVCwgdGhpcykpXG4gICAgfVxuICAgIHdpbmRvd1tpbnZva2VGbigncjVwcm9QdWJsaXNoTWV0YWRhdGEnKV0gPSAobWV0YWRhdGEpID0+IHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX01FVEFEQVRBLCB0aGlzLCBtZXRhZGF0YSkpXG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb0Nvbm5lY3RGYWlsdXJlJyldID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdEZ1dHVyZS5yZWplY3QoUHVibGlzaGVyRXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzKSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1B1Ymxpc2hGYWlsJyldID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdEZ1dHVyZS5yZWplY3QoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX0ZBSUwpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuUFVCTElTSF9GQUlMLCB0aGlzKSlcbiAgICB9XG4gICAgd2luZG93W2ludm9rZUZuKCdyNXByb1B1Ymxpc2hJbnZhbGlkTmFtZScpXSA9KCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdEZ1dHVyZS5yZWplY3QoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX0lOVkFMSURfTkFNRSlcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX0lOVkFMSURfTkFNRSwgdGhpcykpXG4gICAgfVxuICB9XG5cbiAgcHVibGlzaCAoc3RyZWFtTmFtZSA9IHVuZGVmaW5lZCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgY29uc3QgZGZkID0gbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdGhpcy5fc2V0VXBDb25uZWN0Q2FsbGJhY2soZGZkKVxuICAgIHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSA9IHN0cmVhbU5hbWUgfHwgdGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lXG4gICAgY29uc3QgcHVibGlzaE9wdGlvbnMgPSB0aGlzLl9vcHRpb25zXG4gICAgdHJ5IHtcbiAgICAgIGxldCBzcmNIYW5kbGVyID0gdGhpcy5fc291cmNlSGFuZGxlclxuICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5nZXRFbWJlZE9wZXJhdGlvbigpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBkZWJ1ZyhOQU1FLCAnW2hhbmRsZXI6ZW1iZWQ6Y29tcGxldGVdJylcbiAgICAgICAgICBjb25zdCBlbCA9IGVudmlyb25tZW50LmdldEVtYmVkT2JqZWN0KHRoaXMuX2VsZW1lbnRJZClcbiAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2VzdGFibGlzaEV4dEludEhhbmRsZXJzKClcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGNvdW50ID0gMFxuICAgICAgICAgIGNvbnN0IGxpbWl0ID0gMTAwXG4gICAgICAgICAgbGV0IHRyeUNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgdGltZW91dFxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgICAgICAgICAgIHNyY0hhbmRsZXIuY29ubmVjdChKU09OLnN0cmluZ2lmeShwdWJsaXNoT3B0aW9ucykpXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQrKyA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyeUNvbm5lY3QoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMzAwKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0cnlDb25uZWN0KClcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgZGZkLnJlamVjdChlcnIpXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSwgdGhpcykpXG4gICAgICAgIH0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoTkFNRSwgJ1toYW5kbGVyOmVtYmVkOmVycm9yXScpXG4gICAgICBkZmQucmVqZWN0KGBDb3VsZCBub3QgaW5pdGlhdGUgY29ubmVjdGlvbiBzZXF1ZW5jZS4gUmVhc29uOiAke2UubWVzc2FnZX1gKVxuICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLkNPTk5FQ1RfRkFJTFVSRSwgdGhpcykpXG4gICAgICB0aGlzLl90ZWFyRG93bkNvbm5lY3RDYWxsYmFjaygpXG4gICAgfVxuICAgIHRoaXMuX2Nvbm5lY3RGdXR1cmUgPSBkZmRcbiAgICByZXR1cm4gZGZkLnByb21pc2VcbiAgfVxuXG4gIHVucHVibGlzaCAoKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICB0cnkge1xuICAgICAgZW52aXJvbm1lbnQuZ2V0RW1iZWRPYmplY3QodGhpcy5fZWxlbWVudElkKS5kaXNjb25uZWN0KClcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yKE5BTUUsIGBDb3VsZCBub3QgaW5pdGlhdGUgZGlzY29ubmVjdGlvbiBzZXF1ZW5jZS4gUmVhc29uOiAke2UubWVzc2FnZX1gKVxuICAgICAgZGVmZXJyZWQucmVqZWN0KGUubWVzc2FnZSlcbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBzZW5kIChtZXRob2ROYW1lLCBkYXRhKSB7XG4gICAgdGhpcy5fc291cmNlSGFuZGxlci5zZW5kKG1ldGhvZE5hbWUsIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBKU09OLnN0cmluZ2lmeShkYXRhKSlcbiAgfVxuXG4gIHNldFZpZXcgKHZpZXcsIGVsZW1lbnRJZCkge1xuICAgIHRoaXMuX3ZpZXcgPSB2aWV3XG4gICAgdGhpcy5fZWxlbWVudElkID0gZWxlbWVudElkXG4gICAgaWYgKHRoaXMuX3NvdXJjZUhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc291cmNlSGFuZGxlci5kaXNjb25uZWN0KClcbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSB1bmRlZmluZWRcbiAgICB9XG4gICAgaWYgKHRoaXMuX3ZpZXcpIHtcbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIgPSBuZXcgUHVibGlzaGVyU291cmNlSGFuZGxlcih0aGlzLl92aWV3LnZpZXcsIHRoaXMuZ2V0VHlwZSgpKVxuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9zb3VyY2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLl9zb3VyY2VIYW5kbGVyLmFkZFNvdXJjZSh0aGlzLl9lbGVtZW50SWQsIHRoaXMuX29wdGlvbnMpXG4gICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGVycm9yKE5BTUUsIGBDb3VsZCBub3QgZXN0YWJsaXNoIHByb3BlciBSVE1QIHB1Ymxpc2hlcjogJHtlcnJ9YClcbiAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUTVBQdWJsaXNoZXJFdmVudFR5cGVzLkVNQkVEX0ZBSUxVUkUsIHRoaXMpKVxuICAgICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc2V0TWVkaWFRdWFsaXR5IChxdWFsaXR5KSB7XG4gICAgaWYgKHRoaXMuX3NvdXJjZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX3NvdXJjZUhhbmRsZXIuc2V0TWVkaWFRdWFsaXR5KHF1YWxpdHkpXG4gICAgfVxuICB9XG5cbiAgb3ZlcmxheU9wdGlvbnMgKG5ld09wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih0aGlzLl9vcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgfVxuXG4gIGdldENvbm5lY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VIYW5kbGVyXG4gIH1cblxuICBnZXRPcHRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9uc1xuICB9XG5cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIFB1Ymxpc2hUeXBlcy5SVE1QLnRvVXBwZXJDYXNlKClcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJUTVBQdWJsaXNoZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3B1Ymxpc2hlci9yZWQ1cHJvLXJ0bXAuanNcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0IGNvbnN0IFB1Ymxpc2hUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICBSVE1QOiAncnRtcCcsXG4gIFJUQzogJ3J0Yydcbn0pXG5cbmV4cG9ydCBjb25zdCBQdWJsaXNoTW9kZVR5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIExJVkU6ICdsaXZlJyxcbiAgUkVDT1JEOiAncmVjb3JkJyxcbiAgQVBQRU5EOiAnYXBwZW5kJ1xufSlcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvZW51bS9wdWJsaXNoLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCAqIGFzIGVtYmVkIGZyb20gJy4uL2Vudi9lbWJlZCdcbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IEZ1dHVyZSB9IGZyb20gJy4uL3V0aWwvcHJvbWlzZSdcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nJ1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4uL2xvZydcbmltcG9ydCBSVE1QU2hhcmVkT2JqZWN0SGFuZGxlciBmcm9tICcuLi9oZWxwZXIvc2hhcmVkb2JqZWN0LWhlbHBlci1ydG1wJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvUHVibGlzaGVyU291cmNlSGFuZGxlcidcbmNvbnN0IHRvSW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlLnBhcnNlSW50KDEwKVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKVxuICB9XG59XG5cbmNsYXNzIFB1Ymxpc2hlclNvdXJjZUhhbmRsZXIge1xuXG4gIGNvbnN0cnVjdG9yICh2aWRlbywgdHlwZSwgc29SZXNwb25kZXIgPSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnZpZGVvID0gdmlkZW9cbiAgICB0aGlzLmNsb25lID0gdGhpcy52aWRlby5jbG9uZU5vZGUodHJ1ZSlcbiAgICB0aGlzLmhvbGRlciA9IHRoaXMudmlkZW8ucGFyZW50Tm9kZVxuICAgIHRoaXMucHVibGlzaGVyVHlwZSA9IHR5cGVcbiAgICB0aGlzLl9zd2ZJZCA9IG51bGxcbiAgICB0aGlzLl9lbWJlZEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NvUmVzcG9uZGVyID0gc29SZXNwb25kZXIgfHwgbmV3IFJUTVBTaGFyZWRPYmplY3RIYW5kbGVyKClcbiAgfVxuXG4gIGdldEVtYmVkT3BlcmF0aW9uICgpIHtcbiAgICB0aGlzLl9lbWJlZEZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX2VtYmVkRnV0dXJlKVxuICAgIHJldHVybiB0aGlzLl9lbWJlZEZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICBjbGVhblVwICgpIHtcbiAgICAvLyBSZXR1cm4gdG8gcHJpb3IgRE9NIG1hbmlwdWxhdGlvbi5cbiAgICB0aGlzLnZpZGVvLnJlbW92ZSgpXG4gICAgdGhpcy52aWRlbyA9IHRoaXMuY2xvbmUuY2xvbmVOb2RlKHRydWUpXG4gICAgdGhpcy5ob2xkZXIuYXBwZW5kQ2hpbGQodGhpcy52aWRlbylcbiAgICB0aGlzLl9lbWJlZEZ1dHVyZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgYWRkU291cmNlIChzd2ZJZCwgb3B0aW9ucywgc3dmVXJsID0gbnVsbCwgbWluRmxhc2hWZXJzaW9uID0gbnVsbCkge1xuICAgIGRlYnVnKE5BTUUsICdbYWRkc291cmNlXScpXG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICB0aGlzLl9zd2ZJZCA9IHN3ZklkO1xuICAgIHRoaXMuX2VtYmVkRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fZW1iZWRGdXR1cmUpXG4gICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLl9lbWJlZEZ1dHVyZVxuICAgIG9wdGlvbnMuc3dmID0gc3dmVXJsIHx8IG9wdGlvbnMuc3dmXG4gICAgb3B0aW9ucy5taW5GbGFzaFZlcnNpb24gPSBtaW5GbGFzaFZlcnNpb24gfHwgb3B0aW9ucy5taW5GbGFzaFZlcnNpb25cbiAgICBlbWJlZC5kZWZpbmVFbWJlZEVsZW1lbnQodGhpcy52aWRlbywgdGhpcy5ob2xkZXIpXG4gICAgICAudGhlbihlbGVtZW50SWQgPT4ge1xuICAgICAgICBkZWJ1ZyhOQU1FLCAnW2VsZW1lbnQ6Y29tcGxldGVdJylcbiAgICAgICAgbGV0IGZsYXNodmFycyA9IHtcbiAgICAgICAgICBidWZmZXI6IG9wdGlvbnMuYnVmZmVyICE9IG51bGwgPyBvcHRpb25zLmJ1ZmZlciA6IDIsXG4gICAgICAgICAgc3RyZWFtTW9kZTogb3B0aW9ucy5zdHJlYW1Nb2RlLFxuICAgICAgICAgIHN0cmVhbU5hbWU6IG9wdGlvbnMuc3RyZWFtTmFtZSxcbiAgICAgICAgICBhcHBOYW1lOiBvcHRpb25zLmFwcCxcbiAgICAgICAgICBob3N0OiBvcHRpb25zLmhvc3RcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jb250ZXh0KSB7XG4gICAgICAgICAgZmxhc2h2YXJzLnJvb21OYW1lID0gb3B0aW9ucy5jb250ZXh0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggJiYgIWlzTmFOKG9wdGlvbnMud2lkdGgpKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLndpZHRoID0gdG9JbnQob3B0aW9ucy53aWR0aClcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5oZWlnaHQgJiYgIWlzTmFOKG9wdGlvbnMuaGVpZ2h0KSkge1xuICAgICAgICAgIGZsYXNodmFycy5oZWlnaHQgPSB0b0ludChvcHRpb25zLmhlaWdodClcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbWJlZFdpZHRoID09PSAnMTAwJScgfHwgb3B0aW9ucy5lbWJlZEhlaWdodCA9PT0gJzEwMCUnKSB7XG4gICAgICAgICAgZmxhc2h2YXJzLmF1dG9zaXplID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb25uZWN0aW9uUGFyYW1zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGZsYXNodmFycy5jb25uZWN0aW9uUGFyYW1zID0gZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuY29ubmVjdGlvblBhcmFtcykpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtYmVkLmVtYmVkU3dmT2JqZWN0KHN3ZklkLCBvcHRpb25zLCBmbGFzaHZhcnMsIGVudmlyb25tZW50LmdldFN3Zk9iamVjdCgpLCBlbGVtZW50SWQpXG4gICAgICB9KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBkZWJ1ZyhOQU1FLCAnW2VtYmVkOmNvbXBsZXRlXScpXG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUoc2VsZilcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IGRlZmVycmVkLnJlamVjdChlcnIpKVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlXG4gIH1cblxuICBjb25uZWN0IChwdWJsaXNoT3B0aW9ucykge1xuICAgIGRlYnVnKE5BTUUsICdbY29ubmVjdF0nKVxuICAgIGNvbnN0IGVsID0gZW52aXJvbm1lbnQuZ2V0RW1iZWRPYmplY3QodGhpcy5fc3dmSWQpXG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5jb25uZWN0KHB1Ymxpc2hPcHRpb25zKVxuICAgICAgdGhpcy5fc29SZXNwb25kZXIuY29ubmVjdCh0aGlzLl9zd2ZJZClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB3YXJuKE5BTUUsICdDb3VsZCBub3QgZGV0ZXJtaW5lIGVtYmVkZGVkIGVsZW1lbnQgd2l0aCBzd2YgaWQ6ICcgKyB0aGlzLl9zd2ZJZCArICcuJylcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2Rpc2Nvbm5lY3RdJylcbiAgICB0cnkge1xuICAgICAgLy8gTm8gaW52b2NhYmxlIEFQSSBmb3IgY3VzdG9tIGxpdmUgZmxhc2ggcHVibGlzaGVyIGZyb20gUmVkNSBQcm8gYXQgdGhlIHRpbWUuXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gbmFkYS5cbiAgICB9XG4gICAgdGhpcy5jbGVhblVwKClcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5kaXNjb25uZWN0KClcbiAgfVxuXG4gIHNlbmQgKG1ldGhvZE5hbWUsIGRhdGEpIHtcbiAgICBjb25zdCBlbCA9IGVudmlyb25tZW50LmdldEVtYmVkT2JqZWN0KHRoaXMuX3N3ZklkKVxuICAgIGlmIChlbCkge1xuICAgICAgZWwuc2VuZChtZXRob2ROYW1lLCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIGFkZFNoYXJlZE9iamVjdFJlc3BvbnNlSGFuZGxlciAoaGFuZGxlcikge1xuICAgIHRoaXMuX3NvUmVzcG9uZGVyLmFkZFJlc3BvbnNlSGFuZGxlcihoYW5kbGVyKVxuICB9XG5cbiAgcmVtb3ZlU2hhcmVkT2JqZWN0UmVzcG9uc2VIYW5kbGVyIChoYW5kbGVyKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIucmVtb3ZlUmVzcG9uc2VIYW5kbGVyKGhhbmRsZXIpXG4gIH1cblxuICBzZW5kVG9TaGFyZWRPYmplY3QgKG5hbWUsIGNhbGxOYW1lLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuc2VuZFRvU2hhcmVkT2JqZWN0KG5hbWUsIGNhbGxOYW1lLCBtZXNzYWdlKVxuICB9XG5cbiAgc2VuZFByb3BlcnR5VG9TaGFyZWRPYmplY3QgKG5hbWUsIGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5zZW5kUHJvcGVydHlUb1NoYXJlZE9iamVjdChuYW1lLCBrZXksIHZhbHVlKVxuICB9XG5cbiAgZ2V0UmVtb3RlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuZ2V0UmVtb3RlU2hhcmVkT2JqZWN0KHNoYXJlZE9iamVjdE5hbWUpXG4gIH1cblxuICBjb25uZWN0VG9TaGFyZWRPYmplY3QgKHNoYXJlZE9iamVjdE5hbWUpIHtcbiAgICB0aGlzLl9zb1Jlc3BvbmRlci5jb25uZWN0VG9TaGFyZWRPYmplY3Qoc2hhcmVkT2JqZWN0TmFtZSlcbiAgfVxuXG4gIGNsb3NlU2hhcmVkT2JqZWN0IChzaGFyZWRPYmplY3ROYW1lKSB7XG4gICAgdGhpcy5fc29SZXNwb25kZXIuY2xvc2VTaGFyZWRPYmplY3Qoc2hhcmVkT2JqZWN0TmFtZSlcbiAgfVxuXG4gIHNldE1lZGlhUXVhbGl0eSAocXVhbGl0eSkge1xuICAgIGNvbnN0IGVsID0gZW52aXJvbm1lbnQuZ2V0RW1iZWRPYmplY3QodGhpcy5fc3dmSWQpXG4gICAgaWYgKGVsKSB7XG4gICAgICBpZiAocXVhbGl0eS52aWRlbyAmJiB0eXBlb2YgcXVhbGl0eS52aWRlbyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGNvbnN0IHcgPSAhaXNOYU4ocXVhbGl0eS52aWRlby53aWR0aCkgPyB0b0ludChxdWFsaXR5LnZpZGVvLndpZHRoKSA6IE51bWJlci5pc05hTjtcbiAgICAgICAgY29uc3QgaCA9ICFpc05hTihxdWFsaXR5LnZpZGVvLmhlaWdodCkgPyB0b0ludChxdWFsaXR5LnZpZGVvLmhlaWdodCkgOiBOdW1iZXIuaXNOYU47XG4gICAgICAgIGVsLnVwZGF0ZVJlc29sdXRpb24odywgaClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRUeXBlICgpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXJUeXBlXG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQdWJsaXNoZXJTb3VyY2VIYW5kbGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9qcy9wdWJsaXNoZXIvcHViLXNvdXJjZS1oYW5kbGVyLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IHsgUHVibGlzaGVyRXZlbnQgfSBmcm9tICcuLi9ldmVudCdcbmltcG9ydCBQdWJsaXNoZXJTb2NrZXRIZWxwZXIgZnJvbSAnLi4vaGVscGVyL3NvY2tldC1oZWxwZXItcHViJ1xuaW1wb3J0IFB1Ymxpc2hlclBlZXJIZWxwZXIgZnJvbSAnLi4vaGVscGVyL3dlYnJ0Yy1oZWxwZXItcHViJ1xuaW1wb3J0IHsgUHVibGlzaE1vZGVUeXBlcyB9IGZyb20gJy4uL2VudW0vcHVibGlzaCdcbmltcG9ydCB7IERlZmVycmVkUHJvbWlzZSwgRnV0dXJlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0ICogYXMgd2VicnRjIGZyb20gJy4uL2FkYXB0ZXIvd2VicnRjJ1xuaW1wb3J0ICogYXMgd2Vic29ja2V0IGZyb20gJy4uL2FkYXB0ZXIvd2Vic29ja2V0J1xuaW1wb3J0IHsgUHVibGlzaFR5cGVzIH0gZnJvbSAnLi4vZW51bS9wdWJsaXNoJ1xuaW1wb3J0IHsgUHVibGlzaGVyRXZlbnRUeXBlcywgUlRDUHVibGlzaGVyRXZlbnRUeXBlcyB9IGZyb20gJy4uL2V2ZW50J1xuXG5pbXBvcnQgeyBkZWJ1ZyBhcyBkZWJ1Z0xvZyB9IGZyb20gJy4uL2xvZydcbmltcG9ydCB7IGVycm9yIGFzIGVycm9yTG9nIH0gZnJvbSAnLi4vbG9nJ1xuaW1wb3J0IHsgd2FybiBhcyB3YXJuTG9nIH0gZnJvbSAnLi4vbG9nJ1xuXG4vLyBEZWZhdWx0IHRvIHNlY3VyZSBzZXR0aW5ncy5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBwcm90b2NvbDogJ3dzcycsXG4gIHBvcnQ6IDgwODMsXG4gIHN0cmVhbVR5cGU6ICd3ZWJydGMnLFxuICBzdHJlYW1Nb2RlOiBQdWJsaXNoTW9kZVR5cGVzLkxJVkUsXG4gIGJhbmR3aWR0aDoge1xuICAgIGF1ZGlvOiA1NixcbiAgICB2aWRlbzogNTEyXG4gIH1cbn1cbmNvbnN0IGVuZHBvaW50RnJvbU9wdGlvbnMgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBwcm90b2NvbCA9IG9wdGlvbnMud3Nwcm90b2NvbCB8fCBvcHRpb25zLnByb3RvY29sXG4gIGNvbnN0IHBvcnQgPSBvcHRpb25zLndzcG9ydCB8fCBvcHRpb25zLnBvcnRcbiAgY29uc3QgYXBwRW5kcG9pbnQgPSBvcHRpb25zLmNvbnRleHQgPyBbb3B0aW9ucy5hcHAsIG9wdGlvbnMuY29udGV4dF0uam9pbignLycpIDogb3B0aW9ucy5hcHBcbiAgbGV0IGVuZHBvaW50ID0gYCR7cHJvdG9jb2x9Oi8vJHtvcHRpb25zLmhvc3R9OiR7cG9ydH0vJHthcHBFbmRwb2ludH0/aWQ9JHtvcHRpb25zLnN0cmVhbU5hbWV9YFxuICBpZiAodHlwZW9mIG9wdGlvbnMuY29ubmVjdGlvblBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQgcGFyYW1zID0gW107XG4gICAgT2JqZWN0LmtleXMob3B0aW9ucy5jb25uZWN0aW9uUGFyYW1zKS5mb3JFYWNoKCAoa2V5LCBpbmRleCkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBwYXJhbXMucHVzaChba2V5LCBvcHRpb25zLmNvbm5lY3Rpb25QYXJhbXNba2V5XV0uam9pbignPScpKVxuICAgIH0pXG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICBlbmRwb2ludCArPSAnJicgKyAocGFyYW1zLmpvaW4oJyYnKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuZHBvaW50XG59XG5cbmNvbnN0IHB1YlN0YXJ0UmVnZXggPSAvKC4qKSBzdGFydGluZy9naVxuY29uc3QgcHViU3RvcFJlZ2V4ID0gLyguKikgc3RvcHBpbmcvZ2lcbmNvbnN0IE5BTUUgPSAnUlRDUHVibGlzaGVyJ1xuY29uc3QgZGVidWcgPSAobWVzc2FnZSkgPT4ge1xuICBkZWJ1Z0xvZyhOQU1FLCBtZXNzYWdlKVxufVxuY29uc3Qgd2FybiA9IChtZXNzYWdlKSA9PiB7XG4gIHdhcm5Mb2coTkFNRSwgbWVzc2FnZSlcbn1cbmNvbnN0IGVycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgZXJyb3JMb2coTkFNRSwgbWVzc2FnZSlcbn1cblxuY2xhc3MgUlRDUHVibGlzaGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX29wdGlvbnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLl92aWV3ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcGVlckhlbHBlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NvY2tldEhlbHBlciA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX21lZGlhU3RyZWFtID0gdW5kZWZpbmVkXG5cbiAgICB0aGlzLl9zdHJlYW1GdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZWVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fb2ZmZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zZW5kT2ZmZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl90cmlja2xlRW5kRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcHVibGlzaEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3VucHVibGlzaEZ1dHVyZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgX2dldE1lZGlhU3RyZWFtICgpIHtcbiAgICB0aGlzLl9zdHJlYW1GdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9zdHJlYW1GdXR1cmUpXG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbUZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICBfZ2V0VHJpY2tsZUVuZCAoKSB7XG4gICAgcmV0dXJuIEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3RyaWNrbGVFbmRGdXR1cmUpXG4gIH1cblxuICBpbml0IChvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBpZiAoIXdlYnJ0Yy5pc1N1cHBvcnRlZCgpIHx8ICF3ZWJzb2NrZXQuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KCdDYW5ub3QgY3JlYXRlIFdlYlJUQyBwbGF5YmFjayBpbnN0YW5jZS4gWW91ciBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IFdlYlJUQyBhbmQvb3IgV2ViU29ja2V0cy4nKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcbiAgICAgIHRoaXMuX3BlZXJIZWxwZXIgPSBuZXcgUHVibGlzaGVyUGVlckhlbHBlcih0aGlzKVxuICAgICAgdGhpcy5fc29ja2V0SGVscGVyID0gbmV3IFB1Ymxpc2hlclNvY2tldEhlbHBlcih0aGlzKVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZSh0aGlzKVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZVxuICB9XG5cbiAgc2V0VmlldyAodmlldykge1xuICAgIHRoaXMuX3ZpZXcgPSB2aWV3XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGF0dGFjaFN0cmVhbSAobWVkaWEpIHtcbiAgICB0aGlzLl9zdHJlYW1GdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9zdHJlYW1GdXR1cmUpXG4gICAgdGhpcy5fc3RyZWFtRnV0dXJlLnJlc29sdmUobWVkaWEpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGRldGFjaFN0cmVhbSAoKSB7XG4gICAgaWYgKHRoaXMuX21lZGlhU3RyZWFtICYmIHRoaXMuX21lZGlhU3RyZWFtLnN0b3ApIHtcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtLnN0b3AoKVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl9tZWRpYVN0cmVhbSAmJiB0aGlzLl9tZWRpYVN0cmVhbS5nZXRUcmFja3MpIHtcbiAgICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMuX21lZGlhU3RyZWFtLmdldFRyYWNrcygpXG4gICAgICBsZXQgdHJhY2tMZW5ndGggPSB0cmFja3MubGVuZ3RoO1xuICAgICAgd2hpbGUgKC0tdHJhY2tMZW5ndGggPiAtMSkge1xuICAgICAgICBpZiAodHJhY2tzW3RyYWNrTGVuZ3RoXS5zdG9wKSB7XG4gICAgICAgICAgdHJhY2tzW3RyYWNrTGVuZ3RoXS5zdG9wKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zdHJlYW1GdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9tZWRpYVN0cmVhbSA9IHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByZXF1ZXN0QXZhaWxhYmlsaXR5IChzdHJlYW1OYW1lLCB0eXBlKSB7XG4gICAgZGVidWcoJ1tyZXF1ZXN0YXZhaWxhYmlsaXR5XScpXG4gICAgdGhpcy5fYXZhaWxhYmxlRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fYXZhaWxhYmxlRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fYXZhaWxhYmxlRnV0dXJlKVxuICAgIC8vIG1lc3NhZ2Ugb24gc29ja2V0IHJldHVybnMgLT4gb25TdHJlYW0oVW4pQXZhaWxhYmxlXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgaXNBdmFpbGFibGU6IHN0cmVhbU5hbWUsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgYnVuZGxlOiBmYWxzZVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuX2F2YWlsYWJsZUZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICBjcmVhdGVQZWVyQ29ubmVjdGlvbiAoaWNlU2VydmVycykge1xuICAgIGRlYnVnKCdbY3JlYXRlcGVlZXJdJylcbiAgICB0aGlzLl9wZWVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcGVlckZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3BlZXJGdXR1cmUpXG4gICAgdGhpcy5fcGVlckhlbHBlci5zZXRVcChpY2VTZXJ2ZXJzLCB0aGlzLl9wZWVyRnV0dXJlKVxuICAgIHJldHVybiB0aGlzLl9wZWVyRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIGNyZWF0ZU9mZmVyIChiYW5kd2lkdGggPSBudWxsKSB7XG4gICAgZGVidWcoJ1tjcmVhdGVvZmZlcl0nKVxuICAgIHRoaXMuX29mZmVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fb2ZmZXJGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9vZmZlckZ1dHVyZSlcbiAgICB0aGlzLl9wZWVySGVscGVyLmNyZWF0ZU9mZmVyKGJhbmR3aWR0aCwgdGhpcy5fb2ZmZXJGdXR1cmUpXG4gICAgcmV0dXJuIHRoaXMuX29mZmVyRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIHNldFJlbW90ZURlc2NyaXB0aW9uIChzZHApIHtcbiAgICBkZWJ1ZygnW3NldHJlbW90ZWRlc2NyaXB0aW9uXScpXG4gICAgcmV0dXJuIHRoaXMuX3BlZXJIZWxwZXIuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2RwKVxuICB9XG5cbiAgc2VuZE9mZmVyIChzZHAsIHN0cmVhbU5hbWUpIHtcbiAgICBkZWJ1ZygnW3NlbmRvZmZlcl0nKVxuICAgIHRoaXMuX3NlbmRPZmZlckZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3NlbmRPZmZlckZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX3NlbmRPZmZGdXR1cmUpXG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgaGFuZGxlT2ZmZXI6IHN0cmVhbU5hbWUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNkcDogc2RwXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy5fc2VuZE9mZmVyRnV0dXJlLnByb21pc2VcbiAgfVxuXG4gIHNlbmRDYW5kaWRhdGUgKGNhbmRpZGF0ZSwgc3RyZWFtTmFtZSkge1xuICAgIGRlYnVnKCdbc2VuZGNhbmRpZGF0ZV0nKVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIGhhbmRsZUNhbmRpZGF0ZTogc3RyZWFtTmFtZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY2FuZGlkYXRlOiBjYW5kaWRhdGVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcmVxdWVzdFB1Ymxpc2ggKHN0cmVhbU5hbWUsIHN0cmVhbU1vZGUpIHtcbiAgICBkZWJ1ZygnW3JlcXVlc3RwdWJsaXNoXScpXG4gICAgdGhpcy5fcHVibGlzaEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIHRoaXMuX3B1Ymxpc2hGdXR1cmUgPSBGdXR1cmUuY3JlYXRlSWZOb3RFeGlzdCh0aGlzLl9wdWJsaXNoRnV0dXJlKVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIHB1Ymxpc2g6IHN0cmVhbU5hbWUsXG4gICAgICBtb2RlOiBzdHJlYW1Nb2RlXG4gICAgfSlcbiAgICByZXR1cm4gdGhpcy5fcHVibGlzaEZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICByZXF1ZXN0VW5wdWJsaXNoIChzdHJlYW1OYW1lKSB7XG4gICAgdGhpcy5fdW5wdWJsaXNoRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fdW5wdWJsaXNoRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fdW5wdWJsaXNoRnV0dXJlKVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIHVucHVibGlzaDogc3RyZWFtTmFtZVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuX3VucHVibGlzaEZ1dHVyZS5wcm9taXNlXG4gIH1cblxuICBwdWJsaXNoIChzdHJlYW1OYW1lID0gbnVsbCwgcHJvbWlzZSA9IG51bGwpIHtcbiAgICBkZWJ1ZygnW3B1Ymxpc2hdJylcbiAgICB0aGlzLl9vcHRpb25zLnN0cmVhbU5hbWUgPSBzdHJlYW1OYW1lIHx8IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZVxuICAgIGNvbnN0IHAgPSBwcm9taXNlIHx8IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIGNvbnN0IHNvY2tldFByb21pc2UgPSBuZXcgRGVmZXJyZWRQcm9taXNlKClcbiAgICBjb25zdCBzb2NrZXR1cmwgPSBlbmRwb2ludEZyb21PcHRpb25zKHRoaXMuX29wdGlvbnMpXG4gICAgdGhpcy5fdHJpY2tsZUVuZEZ1dHVyZSA9IHRoaXMuX2dldFRyaWNrbGVFbmQoKVxuICAgIHRoaXMuX3NvY2tldEhlbHBlci5zZXRVcChzb2NrZXR1cmwsIHNvY2tldFByb21pc2UpXG4vLyAwLiBFc3RhYmxpc2ggc29ja2V0IGNvbm5lY3Rpb24uXG4gICAgc29ja2V0UHJvbWlzZS5wcm9taXNlXG4vLyAxLiBXYWl0IGZvciBzdHJlYW0gYXR0YWNoXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuQ09OTkVDVF9TVUNDRVNTLCB0aGlzKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1lZGlhU3RyZWFtKClcbiAgICAgIH0pXG4vLyAyLiBSZXF1ZXN0IGF2YWlsYWJsZSBzdHJlYW0gdG8gcHVibGlzaCBvblxuICAgICAgLnRoZW4obWVkaWFTdHJlYW0gPT4ge1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbSA9IG1lZGlhU3RyZWFtXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRDUHVibGlzaGVyRXZlbnRUeXBlcy5NRURJQV9TVFJFQU1fQVZBSUxBQkxFLCB0aGlzLCBtZWRpYVN0cmVhbSkpXG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBdmFpbGFiaWxpdHkodGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lLCB0aGlzLl9vcHRpb25zLnN0cmVhbVR5cGUpXG4gICAgICB9KVxuLy8gMy4gQ3JlYXRlIFBlZXIgQ29ubmVjdGlvblxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVQZWVyQ29ubmVjdGlvbih0aGlzLl9vcHRpb25zLmljZVNlcnZlcnMpXG4gICAgICB9KVxuLy8gNC4gTWFrZSBPZmZlciBvbiBQZWVyIENvbm5lY3Rpb25cbiAgICAgIC50aGVuKGNvbm5lY3Rpb24gPT4ge1xuICAgICAgICBjb25uZWN0aW9uLmFkZFN0cmVhbSh0aGlzLl9tZWRpYVN0cmVhbSlcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChSVENQdWJsaXNoZXJFdmVudFR5cGVzLlBFRVJfQ09OTkVDVElPTl9BVkFJTEFCTEUsIHRoaXMsIGNvbm5lY3Rpb24pKVxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVPZmZlcih0aGlzLl9vcHRpb25zLmJhbmR3aWR0aClcbiAgICAgIH0pXG4vLyA1LiBTZW5kIE9mZmVyXG4gICAgICAudGhlbihzZXNzaW9uRGVzY3JpcHRpb24gPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFJUQ1B1Ymxpc2hlckV2ZW50VHlwZXMuT0ZGRVJfU1RBUlQsIHRoaXMsIHNlc3Npb25EZXNjcmlwdGlvbikpXG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRPZmZlcihzZXNzaW9uRGVzY3JpcHRpb24sIHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSlcbiAgICAgIH0pXG4vLyA2LiBTZXQgdGhlIHNlc3Npb24gZGVzY3JpcHRpb24gcmVtb3RlbHlcbiAgICAgIC50aGVuKHNkcCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkcC5zZHApXG4gICAgICB9KVxuLy8gNy4gV2FpdCB1bnRpbCBpY2UgdHJpY2tsZSBlbmRcbiAgICAgIC50aGVuKHNkcCA9PiB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUlRDUHVibGlzaGVyRXZlbnRUeXBlcy5PRkZFUl9FTkQsIHRoaXMsIHNkcCkpXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUcmlja2xlRW5kKCkucHJvbWlzZVxuICAgICAgfSlcbi8vIDguIFJlcXVlc3QgdG8gcHVibGlzaCBzdHJlYW1cbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChSVENQdWJsaXNoZXJFdmVudFR5cGVzLklDRV9UUklDS0xFX0NPTVBMRVRFLCB0aGlzKSlcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdFB1Ymxpc2godGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lLCB0aGlzLl9vcHRpb25zLnN0cmVhbU1vZGUpXG4gICAgICB9KVxuLy8gOS4gUmVzdWx0cyBpbiBzb2NrZXQgbWVzc2FnZSBvZiBwdWJsaXNoIChzZWUgOm9uUHVibGlzaFN0YXR1cylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcC5yZXNvbHZlKHRoaXMpXG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX1NUQVJULCB0aGlzKSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIHAucmVqZWN0KGVycm9yKVxuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzLCBlcnJvcikpXG4gICAgICB9KVxuICAgIHJldHVybiBwLmhhc093blByb3BlcnR5KCdwcm9taXNlJykgPyBwLnByb21pc2UgOiBwXG4gIH1cblxuICB1bnB1Ymxpc2ggKCkge1xuICAgIGRlYnVnKCdbdW5wdWJsaXNoXScpXG4gICAgY29uc3QgY2xlYXJIZWxwZXJzID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9zb2NrZXRIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5fc29ja2V0SGVscGVyLnRlYXJEb3duKClcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wZWVySGVscGVyKSB7XG4gICAgICAgIHRoaXMuX3BlZXJIZWxwZXIudGVhckRvd24oKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9wZWVyRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fb2ZmZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl9zZW5kT2ZmZXJGdXR1cmUgPSB1bmRlZmluZWRcbiAgICB0aGlzLl90cmlja2xlRW5kRnV0dXJlID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fcHVibGlzaEZ1dHVyZSA9IHVuZGVmaW5lZFxuICAgIGNvbnN0IGYgPSB0aGlzLnJlcXVlc3RVbnB1Ymxpc2godGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lKVxuICAgIGYudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLl91bnB1Ymxpc2hGdXR1cmUgPSB1bmRlZmluZWRcbiAgICAgIGNsZWFySGVscGVycygpXG4gICAgICB0aGlzLnRyaWdnZXIobmV3IFB1Ymxpc2hlckV2ZW50KFB1Ymxpc2hlckV2ZW50VHlwZXMuVU5QVUJMSVNIX1NVQ0NFU1MsIHRoaXMpKVxuICAgIH0pXG4gICAgcmV0dXJuIGZcbiAgfVxuXG4gIG11dGUgKCkge1xuICAgIHRoaXMuX3NvY2tldEhlbHBlci5wb3N0KHtcbiAgICAgIG11dGU6IHRydWVcbiAgICB9KVxuICB9XG5cbiAgdW5tdXRlICgpIHtcbiAgICB0aGlzLl9zb2NrZXRIZWxwZXIucG9zdCh7XG4gICAgICBtdXRlOiBmYWxzZVxuICAgIH0pXG4gIH1cblxuICBzZW5kIChtZXRob2ROYW1lLCBkYXRhKSB7XG4gICAgdGhpcy5fc29ja2V0SGVscGVyLnBvc3Qoe1xuICAgICAgc2VuZDoge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICAgIGRhdGE6ICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpID8gSlNPTi5wYXJzZShkYXRhKSA6IGRhdGFcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgb25TdHJlYW1BdmFpbGFibGUgKHJlY2VpcHQpIHtcbiAgICBkZWJ1ZygnW29uc3RyZWFtYXZhaWxhYmxlXTogJyArIEpTT04uc3RyaW5naWZ5KHJlY2VpcHQsIG51bGwsIDIpKVxuICAgIHRoaXMuX2F2YWlsYWJsZUZ1dHVyZSA9IEZ1dHVyZS5jcmVhdGVJZk5vdEV4aXN0KHRoaXMuX2F2YWlsYWJsZUZ1dHVyZSlcbiAgICB0aGlzLl9hdmFpbGFibGVGdXR1cmUucmVqZWN0KGBTdHJlYW0gd2l0aCBuYW1lICR7dGhpcy5fb3B0aW9ucy5zdHJlYW1OYW1lfSBhbHJlYWR5IGhhcyBhIGJyb2FkY2FzdCBzZXNzaW9uLmApXG4gICAgdGhpcy50cmlnZ2VyKG5ldyBQdWJsaXNoZXJFdmVudChQdWJsaXNoZXJFdmVudFR5cGVzLlBVQkxJU0hfSU5WQUxJRF9OQU1FLCB0aGlzKSlcbiAgfVxuXG4gIG9uU3RyZWFtVW5hdmFpbGFibGUgKHJlY2VpcHQpIHtcbiAgICAvLyBCZWluZyB1bmF2YWlsYWJsZSwgaXMgYSBnb29kIHRoaW5nIGZvciBhbGxvd2luZyB0byBwdWJsaXNoIHVzaW5nIGBvcHRpb25zLnN0cmVhbU5hbWVgXG4gICAgZGVidWcoYFN0cmVhbSAke3RoaXMuX29wdGlvbnMuc3RyZWFtTmFtZX0gZG9lcyBub3QgZXhpc3QuYClcbiAgICBkZWJ1ZygnW29uc3RyZWFtdW5hdmFpbGFibGVdOiAnICsgSlNPTi5zdHJpbmdpZnkocmVjZWlwdCwgbnVsbCwgMikpXG4gICAgdGhpcy5fYXZhaWxhYmxlRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fYXZhaWxhYmxlRnV0dXJlKVxuICAgIHRoaXMuX2F2YWlsYWJsZUZ1dHVyZS5yZXNvbHZlKHRydWUpXG4gIH1cblxuICBvblNvY2tldE1lc3NhZ2VFcnJvciAobWVzc2FnZSwgZGV0YWlsID0gbnVsbCkge1xuICAgIGVycm9yKGBFcnJvciBpbiBzdHJlYW0gcGxheWJhY2s6ICR7bWVzc2FnZX0uXFxuW09wdGlvbmFsIGRldGFpbF06ICR7ZGV0YWlsfWApXG4gICAgaWYgKHRoaXMuX3B1Ymxpc2hGdXR1cmUpIHtcbiAgICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX0ZBSUwsIHRoaXMpKVxuICAgICAgdGhpcy5fcHVibGlzaEZ1dHVyZS5yZWplY3QobWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICBvblNEUFN1Y2Nlc3MgKHJlY2VpcHQpIHtcbiAgICBsZXQgaW5mbyA9IHJlY2VpcHQgPyAnOiAnICsgSlNPTi5zdHJpbmdpZnkocmVjZWlwdCwgbnVsbCwgMikgOiAnJ1xuICAgIGRlYnVnKGBbb25zZHBzdWNjZXNzXSR7aW5mb31gKVxuICB9XG5cbiAgb25TRFBFcnJvciAocmVjZWlwdCkge1xuICAgIHRoaXMudHJpZ2dlcihuZXcgUHVibGlzaGVyRXZlbnQoUHVibGlzaGVyRXZlbnRUeXBlcy5QVUJMSVNIX0ZBSUwsIHRoaXMpKVxuICAgIGxldCBlcnJvciA9IHJlY2VpcHQgPyAnOiAnICsgSlNPTi5zdHJpbmdpZnkocmVjZWlwdCwgbnVsbCwgMikgOiAnJ1xuICAgIGVycm9yKGBbb25zZHBlcnJvcl0ke2Vycm9yfWApXG4gIH1cblxuICBvblNEUEFuc3dlciAoc2RwKSB7XG4gICAgZGVidWcoJ1tzZHBhbnN3ZXJdOjogJyArIEpTT04uc3RyaW5naWZ5KHNkcCwgbnVsbCwgMikpXG4gICAgdGhpcy5fc2VuZE9mZmVyRnV0dXJlID0gRnV0dXJlLmNyZWF0ZUlmTm90RXhpc3QodGhpcy5fc2VuZE9mZmVyRnV0dXJlKVxuICAgIHRoaXMuX3NlbmRPZmZlckZ1dHVyZS5yZXNvbHZlKHNkcClcbiAgfVxuXG4gIG9uQWRkSWNlQ2FuZGlkYXRlIChjYW5kaWRhdGUpIHtcbiAgICBkZWJ1ZygnW2FkZGljZWNhbmRpZGF0ZV0nKVxuICAgIHRoaXMuX3BlZXJIZWxwZXIuYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgZGVidWcoJ1thZGRpY2VjYW5kaWRhdGU6c3VjY2Vzc10nKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICB3YXJuKGBbYWRkaWNlY2FuZGlkYXRlOmVycm9yXSAtICR7ZXJyfWApXG4gICAgICB9KVxuICB9XG5cbiAgb25JY2VDYW5kaWRhdGUgKGNhbmRpZGF0ZSkge1xuICAgIGRlYnVnKCdbaWNlY2FuZGlkYXRldHJpY2tsZV0nKVxuICAgIHRoaXMuc2VuZENhbmRpZGF0ZShjYW5kaWRhdGUsIHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSlcbiAgfVxuXG4gIG9uSWNlQ2FuZGlkYXRlVHJpY2tsZUVuZCAoKSB7XG4gICAgZGVidWcoJ1tpY2VjYW5kaWRhdGV0cmlja2xlOmVuZF0nKVxuICB9XG5cbiAgb25Tb2NrZXRJY2VDYW5kaWRhdGVFbmQgKCkge1xuICAgIGRlYnVnKCdbc29ja2V0aWNlY2FuZGlkYXRlOmVuZF0nKVxuICAgIHRoaXMuX2dldFRyaWNrbGVFbmQoKS5yZXNvbHZlKClcbiAgICAvLyB0aGlzLl90cmlja2xlRW5kRnV0dXJlID0gdW5kZWZpbmVkXG4gIH1cblxuICBvblB1Ymxpc2hlclN0YXR1cyAoc3RhdHVzKSB7XG4gICAgZGVidWcoJ1twdWJsaXNoZXJzdGF0dXNdIC0gJyArIEpTT04uc3RyaW5naWZ5KHN0YXR1cywgbnVsbCwgMikpXG4gICAgY29uc3Qgc3RvcFJlc3VsdCA9IHB1YlN0b3BSZWdleC5leGVjKHN0YXR1cy5tZXNzYWdlKVxuICAgIGNvbnN0IHN0YXJ0UmVzdWx0ID0gcHViU3RhcnRSZWdleC5leGVjKHN0YXR1cy5tZXNzYWdlKVxuICAgIGlmIChzdG9wUmVzdWx0ICYmIHN0b3BSZXN1bHRbMV0gPT09IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSkge1xuICAgICAgdGhpcy5fdW5wdWJsaXNoRnV0dXJlLnJlc29sdmUoKVxuICAgIH0gZWxzZSBpZiAoc3RhcnRSZXN1bHQgJiYgc3RhcnRSZXN1bHRbMV0gPT09IHRoaXMuX29wdGlvbnMuc3RyZWFtTmFtZSkge1xuICAgICAgdGhpcy5fcHVibGlzaEZ1dHVyZS5yZXNvbHZlKClcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybignUHVibGlzaGVyIHN0YXR1cyByZWNlaXZlZCwgYnV0IGNvdWxkIG5vdCBoYW5kbGUuJylcbiAgICB9XG4gIH1cblxuICBvdmVybGF5T3B0aW9ucyAobmV3T3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHRoaXMuX29wdGlvbnMsIG5ld09wdGlvbnMpO1xuICB9XG5cbiAgZ2V0Q29ubmVjdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldEhlbHBlclxuICB9XG5cbiAgZ2V0UGVlckNvbm5lY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wZWVySGVscGVyID8gdGhpcy5fcGVlckhlbHBlci5jb25uZWN0aW9uIDogdW5kZWZpbmVkXG4gIH1cblxuICBnZXRNZWRpYVN0cmVhbSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtXG4gIH1cblxuICBnZXRPcHRpb25zICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9uc1xuICB9XG5cbiAgZ2V0VHlwZSAoKSB7XG4gICAgcmV0dXJuIFB1Ymxpc2hUeXBlcy5SVEMudG9VcHBlckNhc2UoKVxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUlRDUHVibGlzaGVyXG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3B1Ymxpc2hlci9yZWQ1cHJvLXJ0Yy5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgU29ja2V0SGVscGVyIGZyb20gJy4vc29ja2V0LWhlbHBlcidcbmltcG9ydCB7IHdhcm4sIGVycm9yIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1I1UHJvUHVibGlzaGVyU29ja2V0J1xuXG5jbGFzcyBQdWJsaXNoZXJTb2NrZXRIZWxwZXIgZXh0ZW5kcyBTb2NrZXRIZWxwZXIge1xuXG4gIGNvbnN0cnVjdG9yIChyZXNwb25kZXIpIHtcbiAgICBzdXBlcihyZXNwb25kZXIsIE5BTUUpXG4gIH1cblxuICByZXNwb25kIChtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UuZGF0YSkge1xuICAgICAgbGV0IGpzb24gPSB0aGlzLmdldEpzb25Gcm9tU29ja2V0TWVzc2FnZShtZXNzYWdlKVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFzdXBlci5yZXNwb25kKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgaWYgKGpzb24uZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoanNvbi5kYXRhLnNkcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmIChqc29uLmRhdGEuc2RwLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU0RQQW5zd2VyKGpzb24uZGF0YSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5jYW5kaWRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25BZGRJY2VDYW5kaWRhdGUoanNvbi5kYXRhLmNhbmRpZGF0ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uLmRhdGEudHlwZSA9PT0gJ3N0YXR1cycpIHtcbiAgICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5jb2RlID09PSAnTmV0Q29ubmVjdGlvbi5JQ0UuVHJpY2xlQ29tcGxldGVkJyB8fFxuICAgICAgICAgICAgICAgICBqc29uLmRhdGEuY29kZSA9PT0gJ05ldENvbm5lY3Rpb24uSUNFLlRyaWNrbGVDb21wbGV0ZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU29ja2V0SWNlQ2FuZGlkYXRlRW5kKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25kZXIub25QdWJsaXNoZXJTdGF0dXMoanNvbi5kYXRhKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yKE5BTUUsIGBbd3Mub25tZXNzYWdlXSAtIEVycm9yIGluIGFjY2Vzc2luZyBtZXNzYWdlIGRhdGEgYXMgSlNPTi4gJHtlLm1lc3NhZ2V9YClcbiAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU29ja2V0TWVzc2FnZUVycm9yKGBbd3Mub25tZXNzYWdlXSAtIEVycm9yIGluIGFjY2Vzc2luZyBtZXNzYWdlIGRhdGEgYXMgSlNPTi4gJHtlLm1lc3NhZ2V9YClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihOQU1FLCAnW3dzLm9ubWVzc2FnZV0gLSBObyBNZXNzYWdlIERhdGEuJylcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgZGVmYXVsdCBQdWJsaXNoZXJTb2NrZXRIZWxwZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL2hlbHBlci9zb2NrZXQtaGVscGVyLXB1Yi5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuaW1wb3J0ICogYXMgd2VicnRjIGZyb20gJy4uL2FkYXB0ZXIvd2VicnRjJ1xuaW1wb3J0IHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgZGVidWcsIHdhcm4gfSBmcm9tICcuLi9sb2cnXG5cbmNvbnN0IE5BTUUgPSAnUjVQcm9QdWJsaXNoUGVlcidcblxuY2xhc3MgUHVibGlzaGVyUGVlckhlbHBlciB7XG5cbiAgY29uc3RydWN0b3IgKHJlc3BvbmRlcikge1xuICAgIHRoaXMuX3Jlc3BvbmRlciA9IHJlc3BvbmRlclxuICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uID0gdW5kZWZpbmVkXG4gIH1cblxuICBfcmVtb3ZlQ29ubmVjdGlvbkhhbmRsZXJzIChjb25uZWN0aW9uKSB7XG4gICAgY29ubmVjdGlvbi5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IHVuZGVmaW5lZFxuICAgIGNvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIF9hZGRDb25uZWN0aW9uSGFuZGxlcnMgKGNvbm5lY3Rpb24sIHByb21pc2UpIHtcbiAgICBjb25uZWN0aW9uLm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYgKGNvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICBkZWJ1ZyhOQU1FLCAnW3BlZXJjb25uZWN0aW9uOm9wZW5dJylcbiAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICBwcm9taXNlLnJlc29sdmUodGhpcylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uLmNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcgfHxcbiAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgIHdhcm4oTkFNRSwgJ1twZWVyY29ubmVjdGlvbjplcnJvcl0nKVxuICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgIHByb21pc2UucmVqZWN0KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGRlYnVnKE5BTUUsIGBbcGVlci5vbmljZWNhbmRpZGF0ZV0gLSBQZWVyIENhbmRpZGF0ZTogJHtldmVudC5jYW5kaWRhdGV9YClcbiAgICAgIGlmIChldmVudC5jYW5kaWRhdGUpIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uSWNlQ2FuZGlkYXRlKGV2ZW50LmNhbmRpZGF0ZSlcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuY2FuZGlkYXRlID09PSBudWxsKSB7XG4gICAgICAgIC8vIG51bGwgbWVhbnMgdGhleSBoYXZlIGZpbmlzaGVkIHNlbmRpbmcgY2FuZGlkYXRlcyBiYWNrIGFuZCBmb3J0aD9cbiAgICAgICAgLy8gTW92ZWQgdG8gbm90aWZpY2F0aW9uIGZyb20gc2VydmVyIG9uIHRyaWNrbGUgZW5kIGV2ZW50LlxuICAgICAgICAvLyB0aGlzLl9yZXNwb25kZXIub25JY2VDYW5kaWRhdGVUcmlja2xlRW5kKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjcmVhdGVPZmZlciAoYmFuZHdpZHRoID0gbnVsbCwgb2ZmZXJQcm9taXNlID0gbnVsbCkge1xuICAgIGRlYnVnKE5BTUUsICdbY3JlYXRlb2ZmZXJdJylcbiAgICBjb25zdCBwID0gb2ZmZXJQcm9taXNlIHx8IG5ldyBEZWZlcnJlZFByb21pc2UoKVxuICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLmNyZWF0ZU9mZmVyKClcbiAgICAgIC50aGVuKChzZXNzaW9uRGVzY3JpcHRpb24pID0+IHtcbiAgICAgICAgdGhpcy5zZXRMb2NhbERlc2NyaXB0aW9uKHNlc3Npb25EZXNjcmlwdGlvbiwgYmFuZHdpZHRoKVxuICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChiYW5kd2lkdGgpIHtcbiAgICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uLnNkcCA9IHdlYnJ0Yy51cGRhdGVCYW5kd2lkdGgoYmFuZHdpZHRoLCBzZXNzaW9uRGVzY3JpcHRpb24uc2RwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVzcG9uZGVyLm9uU0RQU3VjY2VzcygpXG4gICAgICAgICAgICBwLnJlc29sdmUoc2Vzc2lvbkRlc2NyaXB0aW9uKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRlci5vblNEUEVycm9yKGVycilcbiAgICAgICAgICAgIHAucmVqZWN0KGVycilcbiAgICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBkZWJ1ZyhOQU1FLCAnW2NyZWF0ZW9mZmVyOmVycm9yXScpXG4gICAgICAgIHAucmVqZWN0KGVycilcbiAgICAgIH0pXG4gICAgcmV0dXJuIHAuaGFzT3duUHJvcGVydHkoJ3Byb21pc2UnKSA/IHAucHJvbWlzZSA6IHBcbiAgfVxuXG4gIHNldExvY2FsRGVzY3JpcHRpb24gKHNlc3Npb25EZXNjcmlwdGlvbiwgYmFuZHdpZHRoID0gbnVsbCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZGVidWcoTkFNRSwgJ1tzZXRsb2NhbGRlc2NyaXB0aW9uXScpXG4gICAgcmV0dXJuIHRoaXMuX3BlZXJDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oc2Vzc2lvbkRlc2NyaXB0aW9uKVxuICB9XG5cbiAgc2V0UmVtb3RlRGVzY3JpcHRpb24gKHNkcCkge1xuICAgIGRlYnVnKE5BTUUsICdbc2V0cmVtb3RlZGVzY3JpcHRpb25dJylcbiAgICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24obmV3IHdlYnJ0Yy5SVENTZXNzaW9uRGVzY3JpcHRpb24oc2RwKSlcbiAgfVxuXG4gIGFkZEljZUNhbmRpZGF0ZSAoY2FuZGlkYXRlKSB7XG4gICAgZGVidWcoTkFNRSwgJ1thZGRjYW5kaWRhdGVdJylcbiAgICByZXR1cm4gdGhpcy5fcGVlckNvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSlcbiAgfVxuXG4gIHNldFVwIChpY2VTZXJ2ZXJzLCBzZXRVcFByb21pc2UgPSBudWxsKSB7XG4gICAgdGhpcy50ZWFyRG93bigpXG4gICAgZGVidWcoTkFNRSwgJ1tzZXR1cF0nKVxuICAgIGNvbnN0IHAgPSBzZXRVcFByb21pc2UgfHwgbmV3IERlZmVycmVkUHJvbWlzZSgpXG4gICAgdHJ5IHtcbiAgICAgIGxldCBwZWVyID0gbmV3IHdlYnJ0Yy5SVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMsXG4gICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICduZWdvdGlhdGUnXG4gICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgb3B0aW9uYWw6IFtcbiAgICAgICAgICAgIHtEdGxzU3J0cEtleUFncmVlbWVudDogdHJ1ZX0sXG4gICAgICAgICAgICB7UnRwRGF0YUNoYW5uZWxzOiBmYWxzZX0sXG4gICAgICAgICAgICB7Z29vZ0NwdU92ZXJ1c2VEZXRlY3Rpb246IHRydWV9XG4gICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgdGhpcy5fYWRkQ29ubmVjdGlvbkhhbmRsZXJzKHBlZXIpXG4gICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbiA9IHBlZXJcbiAgICAgIHAucmVzb2x2ZShwZWVyKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oTkFNRSwgYENvdWxkIG5vdCBlc3RhYmxpc2ggYSBQZWVyQ29ubmVjdGlvbi4gJHtlLm1lc3NhZ2V9YClcbiAgICAgIHAucmVqZWN0KGUubWVzc2FnZSlcbiAgICB9XG4gICAgcmV0dXJuIHAuaGFzT3duUHJvcGVydHkoJ3Byb21pc2UnKSA/IHAucHJvbWlzZSA6IHBcbiAgfVxuXG4gIHRlYXJEb3duICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3RlYXJkb3duXScpXG4gICAgaWYgKHRoaXMuX3BlZXJDb25uZWN0aW9uKSB7XG4gICAgICB0aGlzLl9yZW1vdmVDb25uZWN0aW9uSGFuZGxlcnModGhpcy5fcGVlckNvbm5lY3Rpb24pXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jbG9zZSgpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdhcm4oTkFNRSwgYFtwZWVyY29ubmVjdGlvbi5jbG9zZV0gZXJyb3I6ICR7ZS5tZXNzYWdlfWApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvbm5lY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wZWVyQ29ubmVjdGlvblxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHVibGlzaGVyUGVlckhlbHBlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvaGVscGVyL3dlYnJ0Yy1oZWxwZXItcHViLmpzXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vY29yZS9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IGVudmlyb25tZW50IGZyb20gJy4uL2Vudi9icm93c2VyJ1xuaW1wb3J0IHsgU2hhcmVkT2JqZWN0RXZlbnQgfSBmcm9tICcuLi9ldmVudC9pbmRleCdcbmltcG9ydCB7IGNvbW1vbiBhcyBTaGFyZWRPYmplY3RFdmVudFR5cGVzIH0gZnJvbSAnLi4vZXZlbnQvc2hhcmVkb2JqZWN0LWV2ZW50J1xuXG5pbXBvcnQgeyBkZWJ1ZyBhcyBkZWJ1Z0xvZyB9IGZyb20gJy4uL2xvZydcbmltcG9ydCB7IHdhcm4gYXMgd2FybkxvZyB9IGZyb20gJy4uL2xvZydcbmltcG9ydCB7IGVycm9yIGFzIGVycm9yTG9nIH0gZnJvbSAnLi4vbG9nJ1xuXG5jb25zdCBOQU1FID0gJ1JlZDVQcm9TaGFyZWRPYmplY3QnXG5jb25zdCBkZWJ1ZyA9IChzb05hbWUsIG1lc3NhZ2UpID0+IHtcbiAgZGVidWdMb2coW05BTUUsIHNvTmFtZV0uam9pbignOicpLCBtZXNzYWdlKVxufVxuY29uc3Qgd2FybiA9IChzb05hbWUsIG1lc3NhZ2UpID0+IHtcbiAgd2FybkxvZyhbTkFNRSwgc29OYW1lXS5qb2luKCc6JyksIG1lc3NhZ2UpXG59XG5jb25zdCBlcnJvciA9IChzb05hbWUsIG1lc3NhZ2UpID0+IHtcbiAgZXJyb3JMb2coW05BTUUsIHNvTmFtZV0uam9pbignOicpLCBtZXNzYWdlKVxufVxuXG5jb25zdCBTT19TVUJUWVBFX1BST1BFUlRZID0gNFxuY29uc3QgU09fU1VCVFlQRV9NRVRIT0QgPSA2XG5cbmNvbnN0IGRlY29kZU1lc3NhZ2VJZkpTT05TdHJpbmcgPSAobWVzc2FnZSkgPT4ge1xuICByZXR1cm4gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShtZXNzYWdlKSA6IG1lc3NhZ2Vcbn1cblxuY2xhc3MgUHJvcGVydHlEYXRhIHtcblxuICBjb25zdHJ1Y3RvciAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMua2V5ID0ga2V5XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIH1cblxuICB0b09iamVjdCAoKSB7XG4gICAgbGV0IG9iaiA9ICB7fVxuICAgIG9ialt0aGlzLmtleV0gPSB0aGlzLnZhbHVlXG4gICAgcmV0dXJuIG9ialxuICB9XG5cbn1cblxuY2xhc3MgTWV0aG9kRGF0YSB7XG5cbiAgY29uc3RydWN0b3IgKG1ldGhvZE5hbWUsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lXG4gICAgbGV0IG1lc3NhZ2VMaXN0XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgbGV0IGlcbiAgICAgIGxldCBtc2dcbiAgICAgIGxldCBsZW5ndGggPSBtZXNzYWdlLmxlbmd0aFxuICAgICAgbWVzc2FnZUxpc3QgPSBbXVxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1zZyA9IGRlY29kZU1lc3NhZ2VJZkpTT05TdHJpbmcobWVzc2FnZVtpXSlcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgIG1lc3NhZ2VMaXN0ID0gbWVzc2FnZUxpc3QuY29uY2F0KG1zZylcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBtZXNzYWdlTGlzdC5wdXNoKG1zZylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG1lc3NhZ2VMaXN0ID0gW2RlY29kZU1lc3NhZ2VJZkpTT05TdHJpbmcobWVzc2FnZSldXG4gICAgfVxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VMaXN0Lmxlbmd0aCA9PT0gMSA/IG1lc3NhZ2VMaXN0WzBdIDogbWVzc2FnZUxpc3RcbiAgfVxuXG4gIHRvT2JqZWN0ICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0aG9kTmFtZTogdGhpcy5tZXRob2ROYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlXG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgUmVkNVByb1NoYXJlZE9iamVjdCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG5cbiAgY29uc3RydWN0b3IgKG5hbWUsIGNvbm5lY3Rpb24pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fbmFtZSA9IG5hbWVcbiAgICB0aGlzLl9zb2NrZXQgPSBjb25uZWN0aW9uLmdldENvbm5lY3Rpb24oKVxuICAgIHRoaXMuX3NvY2tldC5hZGRTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIodGhpcylcbiAgICB0aGlzLl9vbmNsb3NlID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG4gICAgdHJ5IHtcbiAgICAgIGRlYnVnKHRoaXMuX25hbWUsICdbc2hhcmVkb2JqZWN0OmNvbm5lY3Q6YXR0ZW1wdF0nKVxuICAgICAgdGhpcy5fc29ja2V0LmdldFJlbW90ZVNoYXJlZE9iamVjdCh0aGlzLl9uYW1lKVxuICAgICAgZW52aXJvbm1lbnQuYWRkQ2xvc2VIYW5kbGVyKHRoaXMuX29uY2xvc2UsIDApXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBlcnJvcih0aGlzLl9uYW1lLCAnW3NoYXJlZG9iamVjdDpjb25uZWN0OmVycm9yXTogJyArIGUubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICBnZXRKc29uRnJvbVNvY2tldE1lc3NhZ2UgKG1lc3NhZ2UpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlLmRhdGEgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShtZXNzYWdlLmRhdGEpIDogbWVzc2FnZS5kYXRhXG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICB3YXJuKHRoaXMuX25hbWUsICdDb3VsZCBub3QgcGFyc2UgbWVzc2FnZSBhcyBKU09OLiBNZXNzYWdlPSAnICsgbWVzc2FnZS5kYXRhICsgJy4gRXJyb3I9ICcgKyBlLm1lc3NhZ2UpXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBub3RpZnlPZlByb3BlcnR5VmFsdWVzICh2YWx1ZU9iamVjdCkge1xuICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZU9iamVjdCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU2hhcmVkT2JqZWN0RXZlbnQoU2hhcmVkT2JqZWN0RXZlbnRUeXBlcy5QUk9QRVJUWV9VUERBVEUsIHRoaXMuX25hbWUsIHt9KSlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsZXQga2V5XG4gICAgICBmb3IgKGtleSBpbiB2YWx1ZU9iamVjdCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFNoYXJlZE9iamVjdEV2ZW50KFNoYXJlZE9iamVjdEV2ZW50VHlwZXMuUFJPUEVSVFlfVVBEQVRFLCB0aGlzLl9uYW1lLCBuZXcgUHJvcGVydHlEYXRhKGtleSwgdmFsdWVPYmplY3Rba2V5XSkudG9PYmplY3QoKSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbm90aWZ5T2ZFdmVudHMgKGV2ZW50cykge1xuICAgIGxldCBpLCBldmVudFxuICAgIGNvbnN0IGxlbmd0aCA9IGV2ZW50cy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGV2ZW50ID0gZXZlbnRzW2ldXG4gICAgICBzd2l0Y2ggKGV2ZW50LnN1YnR5cGUpIHtcbiAgICAgICAgY2FzZSBTT19TVUJUWVBFX1BST1BFUlRZOlxuICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU2hhcmVkT2JqZWN0RXZlbnQoU2hhcmVkT2JqZWN0RXZlbnRUeXBlcy5QUk9QRVJUWV9VUERBVEUsIHRoaXMuX25hbWUsIG5ldyBQcm9wZXJ0eURhdGEoZXZlbnQuYXR0cmlidXRlLCBldmVudC52YWx1ZSkudG9PYmplY3QoKSkpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgY2FzZSBTT19TVUJUWVBFX01FVEhPRDpcbiAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFNoYXJlZE9iamVjdEV2ZW50KFNoYXJlZE9iamVjdEV2ZW50VHlwZXMuTUVUSE9EX1VQREFURSwgdGhpcy5fbmFtZSwgbmV3IE1ldGhvZERhdGEoZXZlbnQubWV0aG9kLCBldmVudC52YWx1ZSkudG9PYmplY3QoKSkpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXNwb25kIChtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UuZGF0YSkge1xuICAgICAgbGV0IGpzb24gPSB0aGlzLmdldEpzb25Gcm9tU29ja2V0TWVzc2FnZShtZXNzYWdlKVxuICAgICAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICAgICAgd2Fybih0aGlzLl9uYW1lLCAnRGV0ZXJtaW5lZCB3ZWJzb2NrZXQgcmVzcG9uc2Ugbm90IGluIGNvcnJlY3QgZm9ybWF0LiBBYm9ydGluZyBtZXNzYWdlIGhhbmRsZS4nKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChqc29uLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoanNvbi5kYXRhLm5hbWUgPT09IHRoaXMuX25hbWUpIHtcbiAgICAgICAgICBkZWJ1Zyh0aGlzLl9uYW1lLCAnW3NoYXJlZG9iamVjdC1yZXNwb25zZV06ICcgKyBKU09OLnN0cmluZ2lmeShqc29uLCBudWxsLCAyKSlcbiAgICAgICAgICBpZiAoanNvbi5kYXRhLnN0YXR1cyA9PT0gJ1NoYXJlZE9iamVjdC5TdGF0dXMuR2V0UmVtb3RlJyAmJlxuICAgICAgICAgICAgICBqc29uLmRhdGEubWVzc2FnZSA9PT0gJ1N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICB0aGlzLl9zb2NrZXQuY29ubmVjdFRvU2hhcmVkT2JqZWN0KHRoaXMuX25hbWUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChqc29uLmRhdGEuc3RhdHVzID09PSAnU2hhcmVkT2JqZWN0LlN0YXR1cy5HZXRSZW1vdGUnICYmXG4gICAgICAgICAgICAgIGpzb24uZGF0YS5tZXNzYWdlID09PSAnRmFpbCcpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcihuZXcgU2hhcmVkT2JqZWN0RXZlbnQoU2hhcmVkT2JqZWN0RXZlbnRUeXBlcy5DT05ORUNUX0ZBSUxVUkUsIHRoaXMuX25hbWUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoanNvbi5kYXRhLnN0YXR1cyA9PT0gJ1NoYXJlZE9iamVjdC5TdGF0dXMuQ29ubmVjdCcgJiZcbiAgICAgICAgICAgICAganNvbi5kYXRhLm1lc3NhZ2UgPT09ICdTdWNjZXNzJykge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG5ldyBTaGFyZWRPYmplY3RFdmVudChTaGFyZWRPYmplY3RFdmVudFR5cGVzLkNPTk5FQ1RfU1VDQ0VTUywgdGhpcy5fbmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChqc29uLmRhdGEuc3RhdHVzID09PSAnU2hhcmVkT2JqZWN0LlN0YXR1cy5Db25uZWN0JyAmJlxuICAgICAgICAgICAgICBqc29uLmRhdGEubWVzc2FnZSA9PT0gJ0ZhaWwnKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIobmV3IFNoYXJlZE9iamVjdEV2ZW50KFNoYXJlZE9iamVjdEV2ZW50VHlwZXMuQ09OTkVDVF9GQUlMVVJFLCB0aGlzLl9uYW1lKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGpzb24uZGF0YS50eXBlID09PSAnc2hhcmVkb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKGpzb24uZGF0YS5oYXNPd25Qcm9wZXJ0eSgnZXZlbnRzJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubm90aWZ5T2ZFdmVudHMoanNvbi5kYXRhLmV2ZW50cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGpzb24uZGF0YS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub3RpZnlPZlByb3BlcnR5VmFsdWVzKGpzb24uZGF0YS52YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ1VuaGFuZGxlZCBTb2NrZXQgZXhjaGFuZ2U6ICcgKyBKU09OLnN0cmluZ2lmeShqc29uLCBudWxsLCAyKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBzZW5kIChtZXNzYWdlTmFtZSwgZGF0YSkge1xuICAgIHRoaXMuX3NvY2tldC5zZW5kVG9TaGFyZWRPYmplY3QodGhpcy5fbmFtZSwgbWVzc2FnZU5hbWUsIGRhdGEpXG4gIH1cblxuICBzZXRQcm9wZXJ0eSAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuX3NvY2tldC5zZW5kUHJvcGVydHlUb1NoYXJlZE9iamVjdCh0aGlzLl9uYW1lLCBrZXksIHZhbHVlKVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIGlmICh0aGlzLl9zb2NrZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgd2FybignU29ja2V0IG5vIGxvbmdlciBleGlzdCB0byBjbG9zZSBzaGFyZWQgb2JqZWN0IHByb3Blcmx5LicpXG4gICAgfVxuICAgIHRoaXMuX3NvY2tldC5jbG9zZVNoYXJlZE9iamVjdCh0aGlzLl9uYW1lKVxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3NvY2tldC5yZW1vdmVTaGFyZWRPYmplY3RSZXNwb25zZUhhbmRsZXIodGhpcylcbiAgICB9XG4gICAgdGhpcy5fc29ja2V0ID0gdW5kZWZpbmVkXG4gICAgdGhpcy5fbmFtZSA9IHVuZGVmaW5lZFxuICAgIGVudmlyb25tZW50LnJlbW92ZUNsb3NlSGFuZGxlcih0aGlzLl9vbmNsb3NlKVxuICB9XG5cbiAgZ2V0TmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVcbiAgfVxuXG59XG5cbmV4cG9ydCB7IFJlZDVQcm9TaGFyZWRPYmplY3QgfVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvc2hhcmVkb2JqZWN0L2luZGV4LmpzXG4gKiovIiwiJ3VzZSBzY3JpcHQnXG5cbmltcG9ydCBlbnZpcm9ubWVudCBmcm9tICcuLi9lbnYvYnJvd3NlcidcbmltcG9ydCB7IGRlYnVnLCB3YXJuLCBlcnJvciB9IGZyb20gJy4uL2xvZydcblxuY29uc3QgTkFNRSA9ICdSNVByb1BsYXliYWNrVmlldydcbmNvbnN0IHBsYXliYWNrSWQgPSAncmVkNXByby1zdWJzY3JpYmVyJ1xuXG5leHBvcnQgY2xhc3MgUGxheWJhY2tWaWV3IHtcblxuICBjb25zdHJ1Y3RvciAoZWxlbWVudElkID0gcGxheWJhY2tJZCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBUYXJnZXQgdmlkZW8gZWxlbWVudC5cbiAgICAgIHRoaXMuX3RhcmdldEVsZW1lbnQgPSBlbnZpcm9ubWVudC5yZXNvbHZlRWxlbWVudChlbGVtZW50SWQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoTkFNRSwgYENvdWxkIG5vdCBpbnN0YW50aWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBSZWQ1UHJvU3Vic2NyaWJlci4gUmVhc29uOiAke2UubWVzc2FnZX1gKVxuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIGF0dGFjaFN1YnNjcmliZXIgKHN1YnNjcmliZXIpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW2F0dGFjaHN1YnNjcmliZXJdJylcbiAgICBzdWJzY3JpYmVyLnNldFZpZXcodGhpcywgZW52aXJvbm1lbnQuZ2V0RWxlbWVudElkKHRoaXMuX3RhcmdldEVsZW1lbnQpKVxuICB9XG5cbiAgYXR0YWNoU3RyZWFtIChtZWRpYVN0cmVhbSwgYXV0b3BsYXkgPSBmYWxzZSkge1xuICAgIGRlYnVnKE5BTUUsIGBbYXR0YWNoc3RyZWFtXTogYXV0b3BsYXkoJHthdXRvcGxheX0pYClcbiAgICBlbnZpcm9ubWVudC5zZXRWaWRlb1NvdXJjZSh0aGlzLl90YXJnZXRFbGVtZW50LCBtZWRpYVN0cmVhbSwgYXV0b3BsYXkpXG4gIH1cblxuICBzdG9wICgpIHtcbiAgICBkZWJ1ZyhOQU1FLCAnW3N0b3BdJylcbiAgICB0cnkge1xuICAgICAgdGhpcy5fdGFyZ2V0RWxlbWVudC5wYXVzZSgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybihOQU1FLCBgQ291bGQgbm90IHN0b3AgdmlkZW8gZWxlbWVudDogJHtlLm1lc3NhZ2V9YClcbiAgICB9XG4gIH1cblxuICBnZXQgdmlldyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldEVsZW1lbnRcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFBsYXliYWNrVmlld1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvanMvdmlldy9wbGF5YmFjay5qc1xuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgZW52aXJvbm1lbnQgZnJvbSAnLi4vZW52L2Jyb3dzZXInXG5cbmltcG9ydCB7IGRlYnVnLCBlcnJvciB9IGZyb20gJy4uL2xvZydcbmNvbnN0IE5BTUUgPSAnUjVQcm9QdWJsaXNoVmlldydcblxuY29uc3QgcHVibGlzaGVySWQgPSAncmVkNXByby1wdWJsaXNoZXInXG5cbmNsYXNzIFB1Ymxpc2hWaWV3IHtcblxuICBjb25zdHJ1Y3RvciAoZWxlbWVudElkID0gcHVibGlzaGVySWQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fdGFyZ2V0RWxlbWVudCA9IGVudmlyb25tZW50LnJlc29sdmVFbGVtZW50KGVsZW1lbnRJZClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihOQU1FLCBgQ291bGQgbm90IGluc3RhbnRpYXRlIGEgbmV3IGluc3RhbmNlIG9mIFJlZDVQcm9QdWJsaXNoZXIuIFJlYXNvbjogJHtlLm1lc3NhZ2V9YClcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cblxuICBhdHRhY2hQdWJsaXNoZXIgKHB1Ymxpc2hlcikge1xuICAgIGRlYnVnKE5BTUUsICdbYXR0YWNocHVibGlzaGVyXScpXG4gICAgcHVibGlzaGVyLnNldFZpZXcodGhpcywgZW52aXJvbm1lbnQuZ2V0RWxlbWVudElkKHRoaXMuX3RhcmdldEVsZW1lbnQpKVxuICB9XG5cbiAgcHJldmlldyAobWVkaWFTdHJlYW0sIGF1dG9wbGF5ID0gZmFsc2UpIHtcbiAgICBkZWJ1ZyhOQU1FLCBgW3ByZXZpZXddOiBhdXRvcGxheSgke2F1dG9wbGF5fSlgKVxuICAgIGVudmlyb25tZW50LnNldFZpZGVvU291cmNlKHRoaXMuX3RhcmdldEVsZW1lbnQsIG1lZGlhU3RyZWFtLCBhdXRvcGxheSlcbiAgfVxuXG4gIGdldCB2aWV3ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0RWxlbWVudFxuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgUHVibGlzaFZpZXdcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2pzL3ZpZXcvcHVibGlzaC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=